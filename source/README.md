# Проект Status Monitor (v4.x - В разработке)

**Status Monitor** - это система централизованного мониторинга состояния распределенной IT-инфраструктуры. Она позволяет собирать данные о доступности (PING) и состоянии различных узлов (серверы, АРМы, сетевое оборудование), служб и приложений, агрегировать их в единой базе данных и визуализировать через веб-интерфейс.

**Ключевые особенности:**

*   **Централизация:** Единая точка сбора и просмотра данных.
*   **Гибкость:** Поддержка мониторинга узлов как с прямым доступом к серверу (Online), так и в изолированных сетях (Offline).
*   **Модульные проверки:** Логика каждой проверки вынесена в отдельный PowerShell скрипт (`Checks/Check-*.ps1`), что упрощает добавление и изменение методов.
*   **Система Заданий (Assignments):** Конфигурация проверок через базу данных, а не жестко закодированная логика.
*   **Детализация:** Возможность хранения подробных результатов проверок (списки процессов, использование дисков и т.д.).
*   **Веб-интерфейс:** Отображение текущего статуса, истории событий, управление сущностями (подразделения, узлы, типы, задания, API-ключи).
*   **Аутентификация:** Защита веб-интерфейса (Flask-Login) и API (API-ключи с ролями).
*   **Развертывание:** Использование Docker и Docker Compose для упрощения установки и запуска.

## Содержание

*   [Архитектура](#архитектура)
*   [Ключевые Концепты](#ключевые-концепты)
*   [Компоненты Системы](#компоненты-системы)
    *   [База Данных (PostgreSQL)](#база-данных-postgresql)
    *   [Бэкенд (Flask API + Web UI)](#бэкенд-flask-api--web-ui)
    *   [Агенты и Утилиты (PowerShell)](#агенты-и-утилиты-powershell)
*   [Workflows (Сценарии работы)](#workflows-сценарии-работы)
    *   [Online Агент](#online-агент)
    *   [Offline Агент](#offline-агент)
*   [Установка и Запуск](#установка-и-запуск)
    *   [Требования](#требования)
    *   [Настройка Сети Docker](#настройка-сети-docker)
    *   [Запуск Базы Данных](#запуск-базы-данных)
    *   [Запуск Бэкенда](#запуск-бэкенда)
    *   [Настройка Агентов и Скриптов](#настройка-агентов-и-скриптов)
*   [Использование](#использование)
    *   [Веб-интерфейс](#веб-интерфейс)
    *   [API](#api)
*   [Конфигурация](#конфигурация)
*   [Дальнейшие Планы](#дальнейшие-планы)
*   [Лицензия](#лицензия)

## Архитектура

Система состоит из следующих основных частей:

1.  **Центральный Сервер (Docker Stack):**
    *   **База данных PostgreSQL:** Хранит всю конфигурацию (сущности, задания, ключи, пользователи) и историю проверок/событий.
    *   **Бэкенд Приложение (Flask):** Предоставляет RESTful API и рендерит динамический веб-интерфейс. Обрабатывает логику, аутентификацию.
    *   **Веб-сервер (Nginx):** Обратный прокси для Flask, раздает статические файлы (CSS, JS, иконки).
2.  **Агенты Мониторинга (PowerShell):**
    *   **Online-агент:** Работает на узлах с доступом к API. Получает задания с API, выполняет проверки *локально* (используя модуль `StatusMonitorAgentUtils`), отправляет результаты напрямую в API.
    *   **Offline-агент:** Работает в изолированных сетях. Читает задания из локального JSON файла, выполняет проверки *локально* (используя модуль `StatusMonitorAgentUtils`), пишет результаты в файл `.zrpu`.
3.  **Вспомогательные Скрипты (PowerShell):**
    *   **Конфигуратор:** Запрашивает у API конфигурацию для Offline-агентов и сохраняет/доставляет ее в виде JSON файлов.
    *   **Загрузчик Результатов:** Сканирует папку с файлами `.zrpu` от Offline-агентов, читает их и отправляет каждый результат проверки в API.
4.  **Общий Модуль PowerShell (`StatusMonitorAgentUtils`):**
    *   Содержит **диспетчер** проверок (`Invoke-StatusMonitorCheck`), который запускает **локально** нужный скрипт проверки из папки `Checks/`.
    *   Содержит скрипты для **каждого метода проверки** (`Checks/Check-*.ps1`).
    *   Содержит вспомогательные функции (стандартизация результата `New-CheckResultObject`).

*(Диаграмму архитектуры можно добавить сюда, например, используя Mermaid или вставив изображение)*

## Ключевые Концепты

*   **Подразделения (`Subdivisions`):** Иерархическая структура для организации узлов. Имеют `object_id` для связи с агентами и опциональный `transport_system_code` для оффлайн-сценариев.
*   **Узлы (`Nodes`):** Конкретные объекты мониторинга (серверы, АРМы), привязанные к подразделениям.
*   **Типы Узлов (`Node Types`):** Иерархическая классификация узлов для группировки и задания свойств по умолчанию (иконка, таймаут).
*   **Методы Проверки (`Check Methods`):** Справочник типов проверок (PING, SERVICE_STATUS, DISK_USAGE и т.д.). Имя метода (`method_name`) используется для вызова соответствующего скрипта `Checks/Check-{method_name}.ps1`.
*   **Задания (`Assignments`):** Определяют, *какой* узел (`node_id`) проверяется *каким* методом (`method_id`) с *какими* параметрами (`parameters`) и как часто (`check_interval_seconds`). Также могут содержать `success_criteria`.
*   **Результаты Проверок (`Checks`):** История выполнения заданий. Сохраняет статус доступности (`is_available`), результат проверки критериев (`check_success`), время, исполнителя, версии и ссылку на детали.
*   **Детали Проверок (`Check Details`):** Подробные данные специфичных проверок (списки процессов, диски, ошибки и т.д.) в формате JSONB.
*   **События Системы (`System Events`):** Лог работы самой системы мониторинга.
*   **Пользователи (`Users`):** Учетные записи для доступа к веб-интерфейсу.
*   **API Ключи (`API Keys`):** Используются для аутентификации агентов и скриптов при взаимодействии с API. Имеют роли (`agent`, `loader`, `configurator`, `admin`).

## Компоненты Системы

### База Данных (PostgreSQL)

*   **Расположение:** `postgres/`
*   **Назначение:** Хранение конфигурации, истории проверок, событий.
*   **Особенности:** Использует хранимые процедуры, детально структурированную схему. **ВНИМАНИЕ:** Для сохранения данных между перезапусками Docker раскомментируйте `volume` для `postgres_data` в `postgres/docker-compose.yaml`.
*   **Подробнее:** См. [`postgres/README.md`](postgres/README.md).

### Бэкенд (Flask API + Web UI)

*   **Расположение:** `status/`
*   **Назначение:** Предоставление API (`/api/v1/...`), рендеринг веб-интерфейса, аутентификация (Flask-Login для UI, API-ключи для API).
*   **Технологии:** Python 3.11, Flask, Gunicorn, Psycopg2, Flask-Login.
*   **Структура:** Модульная (routes, repositories, services, models).
*   **Подробнее:** См. [`status/README.md`](status/README.md).

### Агенты и Утилиты (PowerShell)

*   **Расположение:** `powershell/`
*   **Назначение:** Выполнение проверок и вспомогательные задачи.
*   **Общий модуль:** `StatusMonitorAgentUtils` содержит диспетчер и скрипты проверок `Checks/Check-*.ps1`.
*   **Компоненты:** Online-агент, Offline-агент, Загрузчик результатов, Конфигуратор.
*   **Подробнее:** См. [`powershell/README.md`](powershell/README.md) и README в подпапках.

## Workflows (Сценарии работы)

### Online Агент

1.  Агент запускается, читает свой `config.json` (`object_id`, `apiBaseUrl`, `api_key`).
2.  Периодически запрашивает `GET /api/v1/assignments?object_id={id}` у API.
3.  API возвращает список активных заданий для узлов в подразделении агента.
4.  Агент планирует выполнение заданий с учетом `check_interval_seconds`.
5.  При наступлении времени выполнения для Задания X:
    *   Вызывает **локально** `Invoke-StatusMonitorCheck -Assignment {Задание X}`.
    *   `Invoke-StatusMonitorCheck` определяет `method_name` (например, 'SERVICE_STATUS').
    *   `Invoke-StatusMonitorCheck` запускает **локально** скрипт `Checks/Check-SERVICE_STATUS.ps1`, передавая ему нужные параметры (`TargetIP`, `Parameters`, `SuccessCriteria`).
    *   Скрипт `Check-SERVICE_STATUS.ps1` выполняет проверку (например, `Get-Service` к `TargetIP`).
    *   Скрипт `Check-SERVICE_STATUS.ps1` возвращает стандартизированный результат (хэш-таблицу с `IsAvailable`, `CheckSuccess`, `Details` и т.д.).
    *   Агент получает этот результат от `Invoke-StatusMonitorCheck`.
    *   Агент формирует тело для `POST /api/v1/checks`, используя данные из результата (включая `Details`) и метаданные (версию скрипта).
    *   Агент отправляет `POST /api/v1/checks` с результатом и API-ключом.
6.  API (через процедуру `record_check_result`) записывает результат в БД.
7.  *(Будущее)* API может отправить уведомление в веб-интерфейс через Socket.IO.

### Offline Агент

1.  **Администратор:** Запускает **Конфигуратор** для нужного `ObjectId`.
2.  **Конфигуратор:** Запрашивает `GET /api/v1/objects/{ObjectId}/offline_config`, получает JSON с заданиями и `assignment_config_version`, сохраняет в файл `...json.status.КОД_ТС`, доставляет на целевой объект.
3.  **Offline-Агент:**
    *   Запускается, читает `config.json`, проверяет наличие/обновление файла конфигурации заданий.
    *   Читает файл, извлекает список `assignments` и `assignment_config_version`.
    *   Для **каждого** Задания X из списка:
        *   Вызывает **локально** `Invoke-StatusMonitorCheck -Assignment {Задание X}`.
        *   `Invoke-StatusMonitorCheck` запускает **локально** нужный скрипт `Checks/Check-*.ps1`.
        *   Скрипт `Check-*.ps1` выполняет проверку.
        *   Скрипт `Check-*.ps1` возвращает стандартизированный результат.
        *   Агент получает результат.
        *   **Агент добавляет `assignment_id`** из Задания X к полученному результату.
    *   Собирает все дополненные результаты в один массив (`results`).
    *   Формирует итоговый JSON, содержащий метаданные (`agent_script_version`, `assignment_config_version`) и массив `results`.
    *   Сохраняет итоговый JSON в файл `*.zrpu` в папку `output_path`.
4.  **Транспортная Система:** Забирает файл `*.zrpu`, доставляет в центральное хранилище.
5.  **Загрузчик Результатов:**
    *   Сканирует папку с файлами `*.zrpu`.
    *   Для каждого файла:
        *   Читает JSON, извлекает `agent_script_version`, `assignment_config_version` и массив `results`.
        *   Для **каждой** записи результата из `results`:
            *   Извлекает `assignment_id` и остальные данные (статус, детали и т.д.).
            *   Формирует тело для `POST /api/v1/checks`, добавляя версии (`agent_script_version`, `assignment_config_version`) из метаданных файла.
            *   Отправляет запрос в API с ключом `loader`.
        *   После обработки всех записей отправляет `POST /api/v1/events` с типом `FILE_PROCESSED`.
        *   Перемещает обработанный файл (`Processed` или `Error`).
6.  **API:** Обрабатывает каждый результат через `record_check_result`, записывает событие `FILE_PROCESSED`.

## Установка и Запуск

### Требования

*   Docker
*   Docker Compose
*   PowerShell 5.1+ (для агентов и скриптов на машинах Windows)
*   Git (для клонирования репозитория)
*   Установленный модуль PowerShell `SqlServer` (на машинах, где будут выполняться SQL-проверки)

### Настройка Сети Docker

Бэкенд и База Данных используют общую внешнюю сеть Docker `pu_share`. Создайте ее перед первым запуском:
```bash
docker network create pu_share

Запуск Базы Данных

    Перейдите в папку postgres: cd postgres

    (Для Production/Сохранения данных) Отредактируйте postgres/docker-compose.yaml и раскомментируйте/добавьте volume для postgres_data (см. postgres/README.md).

    Запустите контейнеры: docker-compose up -d

    При первом запуске БД будет инициализирована скриптами.

    Доступ:

        PostgreSQL: localhost:48036 (или IP Docker хоста)

        pgAdmin: http://localhost:48035 (Login: admin@admin.com, Pass: admin)

Запуск Бэкенда

    Перейдите в папку status: cd ../status (или cd status, если вы в корне)

    Создайте файл .env (скопируйте из .env.example или репозитория). Обязательно установите надежный SECRET_KEY! Убедитесь, что DATABASE_URL указывает на правильный хост и порт PostgreSQL (см. status/README.md).

    Соберите образ (при первом запуске или изменении зависимостей requirements.txt):

          
    docker-compose build web

        

    IGNORE_WHEN_COPYING_START

Use code with caution. Bash
IGNORE_WHEN_COPYING_END

Запустите контейнеры: docker-compose up -d

При первом запуске автоматически создается пользователь adm с паролем 123 (см. entrypoint.sh).

Для создания других пользователей или API ключей используйте Flask CLI команды внутри контейнера web (выполнять из папки status):

      
# Создать пользователя UI
docker-compose exec web flask create-user <username> <password>

# Создать API ключ (пример для агента)
docker-compose exec web flask create-api-key --description "Online Agent - OTRPK" --role agent --object-id 1060

    

IGNORE_WHEN_COPYING_START

    Use code with caution. Bash
    IGNORE_WHEN_COPYING_END

    ВАЖНО: Сразу скопируйте сгенерированный API ключ! Он больше не будет показан.

    Доступ к веб-интерфейсу: http://localhost:48030

Настройка Агентов и Скриптов

    Модуль StatusMonitorAgentUtils: Скопируйте всю папку powershell/StatusMonitorAgentUtils на каждую машину, где будет запускаться любой агент (online или offline). Убедитесь, что путь к модулю (.psd1 файлу) доступен для Import-Module из скриптов агентов. Обычно достаточно разместить папку StatusMonitorAgentUtils рядом с папками online-agent и offline-agent.

    Online-агент:

        Скопируйте папку powershell/online-agent на целевую машину.

        Отредактируйте online-agent/config.json, указав правильные object_id, apiBaseUrl, api_key (с ролью agent).

        Настройте запуск online-agent.ps1 (Планировщик Задач, Служба Windows).

    Offline-агент:

        Скопируйте папку powershell/offline-agent на целевую машину в изолированной сети.

        Отредактируйте offline-agent/config.json, указав правильные object_id, assignments_file_path (куда будет доставлен конфиг), output_path (куда сохранять .zrpu), check_interval_seconds.

        Настройте запуск offline-agent.ps1.

    Конфигуратор:

        Разместите powershell/configurator на машине с доступом к API.

        Отредактируйте configurator/config.json, указав API URL, API ключ (с ролью configurator), пути, ID объектов для обработки.

        Запускайте generate_and_deliver_config.ps1 по необходимости или расписанию.

    Загрузчик Результатов:

        Разместите powershell/result_loader на машине с доступом к API и папке с .zrpu файлами.

        Отредактируйте result_loader/config.json, указав API URL, API ключ (с ролью loader), путь к папке (check_folder).

        Настройте регулярный запуск result_loader.ps1.

Подробные инструкции см. в README.md внутри каждой папки.
Использование
Веб-интерфейс

Доступен по адресу, на котором запущен Nginx (по умолчанию http://localhost:48030).

    Сводка: Обзор состояния узлов по подразделениям.

    Детальный статус: Иерархическая таблица со всеми узлами, их статусом PING, возможностью просмотра назначенных заданий и истории проверок.

    События: Журнал системных событий с фильтрами.

    Управление: (Требуется вход) Разделы для управления Подразделениями, Узлами, Типами Узлов, Заданиями и API Ключами.

API

API доступно по префиксу /api/v1/ от базового URL. Основные эндпоинты:

    /health: Проверка доступности сервиса и БД.

    /api/v1/dashboard: Данные для сводки (GET).

    /api/v1/status_detailed: Данные для детальной таблицы (GET).

    /api/v1/events: Получение (GET) и добавление (POST, ключ loader) системных событий.

    /api/v1/assignments?object_id={id}: Получение заданий для Online-агента (GET, ключ agent).

    /api/v1/objects/{id}/offline_config: Генерация конфига для Offline-агента (GET, ключ configurator).

    /api/v1/checks: Прием результатов проверок (POST, ключ agent или loader).

    /api/v1/node_checks/{id}/details: Получение деталей конкретной проверки (GET).

    /api/v1/nodes, /api/v1/subdivisions, /api/v1/node_types, /api/v1/assignments, /api/v1/api_keys: CRUD эндпоинты для управления сущностями (требуют аутентификации UI или соответствующего API-ключа).

    /api/v1/check_methods: Получение списка методов проверки (GET).

    /api/v1/node_property_types: Получение списка типов свойств (GET).

    /api/v1/node_types/{id}/properties: Получение/изменение свойств для типа узла (GET/PUT).

(Подробная документация API (Swagger/OpenAPI) планируется).
Конфигурация

Основные файлы конфигурации:

    Бэкенд: status/.env (URL БД, SECRET_KEY, FLASK_ENV, TZ).

    Nginx: status/nginx/nginx.conf.

    База данных: Параметры в postgres/docker-compose.yaml, инициализация в postgres/db_*.sql.

    Online-агент: powershell/online-agent/config.json.

    Offline-агент: powershell/offline-agent/config.json.

    Конфигуратор: powershell/configurator/config.json.

    Загрузчик: powershell/result_loader/config.json.

Дальнейшие Планы

    Документация: Завершить README для всех компонентов, добавить документацию API (Swagger/OpenAPI), добавить диаграмму архитектуры.

    Тестирование: Написать юнит-тесты для Python и PowerShell, интеграционные тесты.

    UI/UX: Реализовать пагинацию, фильтры, поиск во всех разделах управления. Улучшить визуализацию на дашборде. Добавить управление пользователями UI.

    PowerShell Проверки: Реализовать оставшиеся методы в Checks/ (например, KASPERSKY_STATUS, HTTP_CHECK, CERT_EXPIRY, требующие внешнего подключения). Добавить обработку SuccessCriteria в скрипты проверок.

    Оптимизация БД: Реализовать очистку/архивацию старых данных (node_checks, node_check_details, system_events). Рассмотреть партиционирование для больших таблиц.

    Оптимизация Загрузчика: Реализовать Bulk API эндпоинт (POST /api/v1/checks/bulk) для пакетной загрузки результатов и обновить result_loader.ps1.

    Безопасность: Усилить защиту API (проверка ролей для CRUD), добавить CSRF-защиту для UI. Рассмотреть безопасные способы передачи учетных данных для SQL проверок (если Windows Auth не подходит).

    Надежность Агентов: Упаковка агентов для запуска как служб Windows/демонов Linux, улучшенная обработка ошибок сети и API.

    Real-time: Задействовать Flask-SocketIO для мгновенного обновления статусов в веб-интерфейсе без перезагрузки страницы.