{% extends "base.html" %}
{% block title %}Управление Заданиями (Pipeline) - Мониторинг ПТК{% endblock %}

{% block head_extra %}
<style>
    /* ... (общие стили остаются) ... */

    .pipeline-builder-container {
        display: grid;
        grid-template-columns: 250px 1fr 350px; /* Панель шагов | Рабочая область | Панель свойств */
        gap: 1rem;
        min-height: 500px; /* Чтобы было место для перетаскивания */
    }

    .available-steps-panel {
        border: 1px solid #ccc;
        padding: 1rem;
        background-color: #f9f9f9;
        border-radius: 4px;
        height: fit-content; /* Чтобы панель не растягивалась на всю высоту */
    }
    .available-steps-panel h4 { margin-top: 0; }
    .step-item {
        padding: 8px;
        margin-bottom: 5px;
        background-color: #e9ecef;
        border: 1px solid #ced4da;
        border-radius: 3px;
        cursor: grab; /* Для drag-and-drop */
        text-align: center;
    }
    .step-item:hover { background-color: #dde2e6; }

    .pipeline-workspace {
        border: 1px solid #ccc;
        padding: 1rem;
        background-color: #fff;
        border-radius: 4px;
        min-height: 480px; /* Для области перетаскивания */
        display: flex;
        flex-direction: column; /* Шаги располагаются вертикально */
        gap: 0.5rem;
    }
    .pipeline-workspace .placeholder { /* Сообщение, если нет шагов */
        color: #aaa;
        text-align: center;
        padding: 2rem;
        border: 2px dashed #eee;
        border-radius: 4px;
        margin: auto; /* Центрируем */
    }

    .pipeline-step-block { /* Блок одного шага в рабочей области */
        background-color: #f0f8ff; /* AliceBlue */
        border: 1px solid #add8e6; /* LightBlue */
        padding: 10px;
        border-radius: 4px;
        cursor: pointer; /* Для выбора */
        position: relative; /* Для кнопки удаления */
    }
    .pipeline-step-block.selected {
        border-color: var(--primary-color);
        box-shadow: 0 0 5px var(--primary-color);
    }
    .pipeline-step-block .step-header {
        font-weight: bold;
        margin-bottom: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .pipeline-step-block .step-description {
        font-size: 0.9em;
        color: #555;
        margin-bottom: 5px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .pipeline-step-block .step-params-preview {
        font-size: 0.8em;
        color: #777;
        font-family: monospace;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 90%; /* Чтобы не вылезало за кнопку удаления */
    }
    .pipeline-step-block .delete-step-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        background: var(--danger-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 18px; /* Центрируем крестик */
        text-align: center;
        cursor: pointer;
        font-size: 12px;
    }

    .step-properties-panel {
        border: 1px solid #ccc;
        padding: 1rem;
        background-color: #fdfdfd;
        border-radius: 4px;
        height: fit-content; /* Чтобы панель не растягивалась */
    }
    .step-properties-panel h4 { margin-top: 0; }
    .step-properties-panel .form-group textarea {
        min-height: 120px; /* Больше места для JSON */
        font-size: 0.9em;
    }
    .step-properties-panel #save-step-properties-btn {
        background-color: var(--success-color);
    }
    .step-properties-panel #save-step-properties-btn:hover {
        background-color: #1e7e34;
    }
    .step-properties-panel .validation-message {
        font-size: 0.85em;
        margin-top: 5px;
    }
    .step-properties-panel .validation-message.valid { color: green; }
    .step-properties-panel .validation-message.invalid { color: red; }

</style>
{% endblock %}

{% block content %}
<h2>Управление Заданиями (Pipeline Конструктор)</h2>

<div class="manage-container"> <!-- Используем общий класс для отступов -->

    <!-- Секция 1: Форма общих параметров задания и выбора целей -->
    <section class="section-card" id="assignment-form-section">
        <h3>
             <span id="form-title">Параметры и Цели Задания</span>
             <button type="button" id="reset-form-btn" title="Сбросить всю форму (включая pipeline)">Сбросить всё</button>
        </h3>
        <div id="form-feedback" class="feedback-area"></div>
        <form id="assignment-main-form">
            <input type="hidden" id="assignment-id"> <!-- Для ID редактируемого задания -->

            <!-- Общие параметры задания -->
            <h4>Общие параметры:</h4>
            <div class="form-grid">
                 <div class="form-group">
                     <label for="method-id">Основной тип задания (для группировки)</label>
                     <select id="method-id"><option value="">-- Выберите тип --</option></select>
                     <div class="error-feedback" id="method-id-error"></div>
                 </div>
                 <div class="form-group">
                     <label for="check-interval">Интервал (сек)</label>
                     <input type="number" id="check-interval" placeholder="Например, 300" min="10">
                     <div class="error-feedback" id="check-interval-error"></div>
                 </div>
                 <div class="form-group" style="grid-column: 1 / -1;"> <!-- Описание на всю ширину -->
                     <label for="description">Описание всего задания</label>
                     <input type="text" id="description" placeholder="Например, 'Полная проверка сервера приложений X'">
                 </div>
                 <div class="form-group">
                     <label for="is-enabled" class="checkbox-label">
                         <input type="checkbox" id="is-enabled" checked> Включено
                     </label>
                 </div>
            </div>
            <hr style="margin: 1.5rem 0;">
            <!-- Выбор целей (как было раньше) -->
            <h4>Целевые узлы:</h4>
            <div class="target-selection-mode">
                 <label><input type="radio" name="target-mode" value="criteria" checked> Выбрать по критериям</label>
                 <label><input type="radio" name="target-mode" value="specific"> Выбрать конкретные узлы</label>
            </div>
            <div id="criteria-section" class="target-section active">
                <!-- ... (содержимое выбора по критериям как раньше) ... -->
                 <div class="form-grid">
                     <div class="form-group">
                         <label class="multi-select-label">Подразделения:</label>
                         <div class="multi-select-container" id="target-subdivision-select"><small>Загрузка...</small></div>
                         <div class="error-feedback" id="target-subdivision_ids-error"></div>
                    </div>
                    <div class="form-group">
                         <label class="multi-select-label">Типы узлов:</label>
                         <div class="multi-select-container" id="target-nodetype-select"><small>Загрузка...</small></div>
                         <div class="error-feedback" id="target-node_type_ids-error"></div>
                    </div>
                    <div class="form-group">
                         <label for="target-name-mask">Маска имени узла (SQL LIKE):</label>
                         <input type="text" id="target-name-mask" placeholder="Например: SRV-%">
                         <div class="error-feedback" id="target-name_mask-error"></div>
                    </div>
                </div>
                 <div class="error-feedback" id="criteria-error"></div>
            </div>
            <div id="specific-nodes-section" class="target-section">
                <!-- ... (содержимое выбора конкретных узлов как раньше) ... -->
                <div class="node-search-container">
                    <input type="search" id="node-search" placeholder="Поиск узла по имени или IP...">
                    <button type="button" id="clear-node-selection-btn">Очистить выбор</button>
                 </div>
                <div class="nodes-list" id="nodes-checkbox-list"><small>Начните поиск...</small></div>
                <div class="selected-nodes-info" id="selected-nodes-info">Выбрано узлов: 0</div>
                <div class="error-feedback" id="target-specific_nodes-error"></div>
            </div>
        </form>
    </section>

    <!-- Секция 2: Конструктор Pipeline -->
    <section class="section-card">
        <h3>Конструктор Pipeline <button type="button" id="clear-pipeline-btn" title="Очистить все шаги" style="font-size: 0.8em; padding: 3px 8px; background-color: var(--secondary-color);">Очистить Pipeline</button></h3>
        <div class="pipeline-builder-container">
            <!-- Панель доступных шагов -->
            <aside class="available-steps-panel">
                <h4>Доступные шаги</h4>
                <div id="available-steps-list">
                    <p class="loading-message">Загрузка методов...</p>
                    <!-- Шаги будут добавлены JS из check_methods -->
                </div>
            </aside>

            <!-- Рабочая область для сборки pipeline -->
            <main class="pipeline-workspace" id="pipeline-workspace-area">
                <div class="placeholder">Перетащите шаги сюда или кликните для добавления</div>
                <!-- Блоки шагов будут добавляться сюда JS -->
            </main>

            <!-- Панель свойств выбранного шага -->
            <aside class="step-properties-panel" id="step-properties-panel-id" style="display: none;">
                <h4>Свойства шага "<span id="selected-step-type-name"></span>"</h4>
                <input type="hidden" id="selected-step-ui-id">
                <div class="form-group">
                    <label for="step-description">Описание шага (опционально)</label>
                    <input type="text" id="step-description" placeholder="Например, Пинг основного шлюза">
                </div>
                <div class="form-group">
                    <label for="step-parameters">Параметры шага (JSON)</label>
                    <textarea id="step-parameters" placeholder='Пример: {"target": "192.168.1.1", "count": 3}'></textarea>
                    <div class="validation-message" id="step-parameters-validation"></div>
                </div>
                <div class="form-group">
                    <label for="step-success-criteria">Критерий успеха шага (JSON, опционально)</label>
                    <textarea id="step-success-criteria" placeholder='Пример: {"rtt_ms": {"<=": 100}}'></textarea>
                    <div class="validation-message" id="step-success-criteria-validation"></div>
                </div>
                <button type="button" id="save-step-properties-btn">Применить свойства к шагу</button>
            </aside>
        </div>
        <!-- Кнопка сохранения всего задания (pipeline + цели) -->
        <div class="form-actions" style="margin-top: 1.5rem;">
            <button type="button" id="save-assignment-pipeline-btn" style="padding: 10px 20px; font-size: 1.1em;">Сохранить Задание</button>
        </div>
    </section>

    <!-- Секция 3: Список существующих заданий (остается как есть для просмотра) -->
    <section class="section-card">
         <h3>Список Существующих Заданий</h3>
         <div id="list-feedback-assignments" class="feedback-area"></div>
         <div class="list-controls">
             <!-- ... (фильтры как раньше) ... -->
         </div>
        <table class="assignments-table">
             <thead>
                 <tr>
                     <th>Узел</th>
                     <th>Тип (Метод)</th>
                     <th>Pipeline (шагов)</th> <!-- ИЗМЕНЕНО -->
                     <th>Интервал</th>
                     <th>Вкл.</th>
                     <th>Описание</th>
                     <th>Действия</th>
                 </tr>
             </thead>
            <tbody id="assignment-list">
                <tr><td colspan="7" class="loading-message">Загрузка...</td></tr> <!-- colspan изменен -->
            </tbody>
        </table>
         <div class="pagination-controls" id="pagination-controls" style="display: none;">
             <!-- ... (пагинация как раньше) ... -->
         </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
    // --- DOM Elements ---
    // Main assignment form (targets, general params)
    const mainForm = document.getElementById('assignment-main-form');
    const formTitle = document.getElementById('form-title'); // For title of general + pipeline section
    const assignmentIdInput = document.getElementById('assignment-id'); // Hidden input for edit mode
    const methodIdSelect = document.getElementById('method-id'); // Main method for grouping
    const checkIntervalInput = document.getElementById('check-interval');
    const isEnabledCheckbox = document.getElementById('is-enabled');
    const descriptionInput = document.getElementById('description'); // Overall assignment description
    const formFeedback = document.getElementById('form-feedback'); // General form feedback
    const resetFormBtn = document.getElementById('reset-form-btn');

    // Target selection
    const targetModeRadios = document.querySelectorAll('input[name="target-mode"]');
    const criteriaSection = document.getElementById('criteria-section');
    const specificNodesSection = document.getElementById('specific-nodes-section');
    const targetSubdivisionContainer = document.getElementById('target-subdivision-select');
    const targetNodeTypeContainer = document.getElementById('target-nodetype-select');
    const targetNameMaskInput = document.getElementById('target-name-mask');
    const nodeSearchInput = document.getElementById('node-search');
    const nodesCheckboxList = document.getElementById('nodes-checkbox-list');
    const selectedNodesInfo = document.getElementById('selected-nodes-info');
    const clearNodeSelectionBtn = document.getElementById('clear-node-selection-btn');

    // Pipeline Builder
    const availableStepsList = document.getElementById('available-steps-list');
    const pipelineWorkspace = document.getElementById('pipeline-workspace-area');
    const stepPropertiesPanel = document.getElementById('step-properties-panel-id');
    const selectedStepTypeNameEl = document.getElementById('selected-step-type-name');
    const selectedStepUiIdInput = document.getElementById('selected-step-ui-id');
    const stepDescriptionInput = document.getElementById('step-description');
    const stepParametersTextarea = document.getElementById('step-parameters');
    const stepSuccessCriteriaTextarea = document.getElementById('step-success-criteria');
    const stepParamsValidationMsg = document.getElementById('step-parameters-validation');
    const stepCriteriaValidationMsg = document.getElementById('step-success-criteria-validation');
    const saveStepPropsBtn = document.getElementById('save-step-properties-btn');
    const clearPipelineBtn = document.getElementById('clear-pipeline-btn');
    const saveAssignmentPipelineBtn = document.getElementById('save-assignment-pipeline-btn'); // Main save button

    // Assignment List (for viewing existing)
    const assignmentTableBody = document.getElementById('assignment-list');
    const listFeedbackAssignments = document.getElementById('list-feedback-assignments');
    const paginationControls = document.getElementById('pagination-controls');
    // ... (Filter elements for the list - copy from previous if needed)

    // --- API URLs (same as your previous manage_assignments.html) ---
    const API_URL_ASSIGNMENTS_ALL = "{{ url_for('assignments.api_get_all_assignments_paginated') }}";
    const API_URL_ASSIGNMENT_DETAIL_TPL = "{{ url_for('assignments.api_get_assignment', assignment_id=0) }}"; // For GET/PUT/DELETE single
    const API_URL_ASSIGNMENT_BULK_CREATE = "{{ url_for('assignments.api_create_or_assign_assignments') }}"; // For POST new
    const API_URL_NODES = "{{ url_for('nodes.api_get_nodes') }}";
    const API_URL_METHODS = "{{ url_for('data.api_get_check_methods') }}"; // Check methods for step types
    const API_URL_SUBDIVISIONS = "{{ url_for('subdivisions.api_get_subdivisions') }}";
    const API_URL_NODE_TYPES = "{{ url_for('node_types.api_get_node_types') }}";

    // --- State Variables ---
    let currentPipelineSteps = []; // Array of step objects: { uiId: '...', type: 'PING', description: '...', parameters: {}, success_criteria: {} }
    let selectedStepUiId = null; // UI ID of the currently selected step in the workspace
    let allNodesDataCache = [];
    let checkMethodsCache = []; // Will hold {id, method_name, description}
    let subdivisionsDataCache = [];
    let nodeTypesDataCache = [];
    let currentEditAssignmentId = null; // ID of assignment being edited
    // Pagination for list view
    let listCurrentPage = 1;
    let listItemsPerPage = 15;
    let listTotalAssignments = 0;
    // ... (other state vars like selectedNodeIds Set for specific node targeting)
    let selectedNodeIds = new Set();


    // --- Helper Functions (fetchData, populateSelect, displayValidationErrors, etc. - can be copied and adapted) ---

    async function fetchData(url, options = {}) {
        // Показываем индикатор загрузки где-нибудь, если это GET запрос
        const method = options.method ? options.method.toUpperCase() : 'GET';
        if (method === 'GET' && (url.includes('/assignments/all') || url.includes('/check_methods'))) {
            showFeedback(listFeedbackAssignments, 'Загрузка данных...');
        }
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                let errorText = `Ошибка: ${response.status} ${response.statusText}`;
                let errorDetails = null;
                let errorCode = 'NETWORK_ERROR';
                try {
                    const errorData = await response.json();
                    if (errorData && errorData.error) {
                        errorCode = errorData.error.code || 'API_ERROR';
                        errorText = errorData.error.message || errorText;
                        errorDetails = errorData.error.details || errorData.error.message || errorData.error;
                    }
                } catch (e) { /* ignore json parsing error if not json */ }
                const error = new Error(errorText);
                error.details = errorDetails; error.code = errorCode; error.status = response.status;
                throw error;
            }
            if (method === 'GET') showFeedback(listFeedbackAssignments, ''); // Clear loading
            return response.status === 204 ? null : response.json();
        } catch (error) {
            console.error(`Ошибка fetchData для URL: ${url}`, error);
            showFeedback(formFeedback, `Ошибка: ${error.message}`, true); // Показываем ошибку в форме
            showFeedback(listFeedbackAssignments, `Ошибка загрузки: ${error.message}`, true); // И над списком
            throw error;
        }
    }

    function displayValidationErrors(errors, feedbackElementId = 'form-feedback', fieldPrefix = '') {
        const feedbackEl = document.getElementById(feedbackElementId);
        if (!feedbackEl) return;
        feedbackEl.innerHTML = ''; // Clear previous
        feedbackEl.className = 'feedback-area';

        if (typeof errors === 'string') {
            feedbackEl.textContent = errors;
            feedbackEl.classList.add('error-feedback');
        } else if (errors && typeof errors === 'object') {
            let html = '<ul>';
            for (const field in errors) {
                html += `<li>${field}: ${errors[field]}</li>`;
                const inputEl = document.getElementById(`${fieldPrefix}${field.replace(/_([a-z])/g, (m, p1) => p1.toUpperCase())}`);
                if (inputEl) inputEl.classList.add('invalid'); // Simple invalid class for now
            }
            html += '</ul>';
            feedbackEl.innerHTML = html;
            feedbackEl.classList.add('error-feedback');
        }
    }

    function clearValidationErrors(feedbackElementId = 'form-feedback', formId = 'assignment-main-form') {
        const feedbackEl = document.getElementById(feedbackElementId);
        if (feedbackEl) {
            feedbackEl.innerHTML = '';
            feedbackEl.className = 'feedback-area';
        }
        document.querySelectorAll(`#${formId} .invalid`).forEach(el => el.classList.remove('invalid'));
        document.querySelectorAll(`#${formId} .error-feedback`).forEach(el => el.textContent = '');
    }

    function showFeedback(element, message, isError = false) {
        if(!element) return;
        element.textContent = message;
        element.className = 'feedback-area';
        if (message) {
            element.classList.add(isError ? 'error-feedback' : 'success-feedback');
        }
    }

    // --- Pipeline Builder Logic ---

    /** Загружает доступные типы шагов (check_methods) и отображает их в панели. */
    async function loadAvailableSteps() {
        availableStepsList.innerHTML = '<p class="loading-message">Загрузка методов...</p>';
        try {
            checkMethodsCache = await fetchData(API_URL_METHODS) || [];
            if (checkMethodsCache.length === 0) {
                availableStepsList.innerHTML = '<p>Методы проверки не найдены.</p>';
                return;
            }
            availableStepsList.innerHTML = checkMethodsCache.map(method => `
                <div class="step-item" draggable="true" data-method-id="${method.id}" data-method-name="${method.method_name}" title="${method.description || method.method_name}">
                    ${method.method_name}
                </div>
            `).join('');
        } catch (error) {
            availableStepsList.innerHTML = '<p class="error-message">Ошибка загрузки методов.</p>';
        }
    }

    /** Добавляет шаг в рабочую область pipeline. */
    function addStepToPipeline(methodName, methodId, existingStepData = null) {
        const uiId = existingStepData?.uiId || `step-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
        const newStep = existingStepData ? { ...existingStepData, uiId } : {
            uiId: uiId,
            type: methodName, // Это 'method_name' из check_methods
            description: '',
            parameters: {},   // Пустой объект по умолчанию
            success_criteria: {} // Пустой объект по умолчанию
        };
        currentPipelineSteps.push(newStep);
        renderPipelineWorkspace();
        selectPipelineStep(uiId); // Автоматически выбираем добавленный шаг для редактирования
    }

    /** Рендерит шаги pipeline в рабочей области. */
    function renderPipelineWorkspace() {
        if (currentPipelineSteps.length === 0) {
            pipelineWorkspace.innerHTML = '<div class="placeholder">Перетащите шаги сюда или кликните для добавления</div>';
            stepPropertiesPanel.style.display = 'none'; // Скрываем панель свойств, если нет шагов
            selectedStepUiId = null;
            return;
        }
        pipelineWorkspace.innerHTML = currentPipelineSteps.map(step => `
            <div class="pipeline-step-block ${selectedStepUiId === step.uiId ? 'selected' : ''}" data-ui-id="${step.uiId}">
                <div class="step-header">
                    <span>${step.type}</span>
                    <button class="delete-step-btn" data-ui-id="${step.uiId}" title="Удалить шаг">×</button>
                </div>
                <div class="step-description" title="${step.description || 'Нет описания'}">${step.description || 'Нет описания'}</div>
                <div class="step-params-preview" title='${JSON.stringify(step.parameters)}'>
                    Параметры: ${Object.keys(step.parameters || {}).length > 0 ? JSON.stringify(step.parameters).substring(0, 50) + '...' : 'нет'}
                </div>
            </div>
        `).join('');
    }

    /** Выбирает шаг в pipeline для редактирования его свойств. */
    function selectPipelineStep(uiId) {
        selectedStepUiId = uiId;
        const stepData = currentPipelineSteps.find(s => s.uiId === uiId);
        if (stepData) {
            selectedStepTypeNameEl.textContent = stepData.type;
            selectedStepUiIdInput.value = uiId;
            stepDescriptionInput.value = stepData.description || '';
            // Аккуратно форматируем JSON для textarea
            stepParametersTextarea.value = stepData.parameters && Object.keys(stepData.parameters).length > 0 ? JSON.stringify(stepData.parameters, null, 2) : '';
            stepSuccessCriteriaTextarea.value = stepData.success_criteria && Object.keys(stepData.success_criteria).length > 0 ? JSON.stringify(stepData.success_criteria, null, 2) : '';
            stepPropertiesPanel.style.display = 'block';
            validateJsonInTextarea(stepParametersTextarea, stepParamsValidationMsg);
            validateJsonInTextarea(stepSuccessCriteriaTextarea, stepCriteriaValidationMsg);
        } else {
            stepPropertiesPanel.style.display = 'none';
        }
        renderPipelineWorkspace(); // Перерисовываем для подсветки выбранного
    }

    /** Сохраняет измененные свойства выбранного шага. */
    function saveSelectedStepProperties() {
        if (!selectedStepUiId) return;
        const stepIndex = currentPipelineSteps.findIndex(s => s.uiId === selectedStepUiId);
        if (stepIndex === -1) return;

        const paramsValid = validateJsonInTextarea(stepParametersTextarea, stepParamsValidationMsg, true);
        const criteriaValid = validateJsonInTextarea(stepSuccessCriteriaTextarea, stepCriteriaValidationMsg, true);

        if (!paramsValid.isValid || !criteriaValid.isValid) {
            showFeedback(formFeedback, "Исправьте ошибки в JSON параметрах/критериях шага.", true);
            return;
        }

        currentPipelineSteps[stepIndex].description = stepDescriptionInput.value.trim();
        currentPipelineSteps[stepIndex].parameters = paramsValid.data || {}; // Пустой объект, если textarea пуста
        currentPipelineSteps[stepIndex].success_criteria = criteriaValid.data || {};

        renderPipelineWorkspace(); // Обновляем отображение шага
        showFeedback(formFeedback, `Свойства шага '${currentPipelineSteps[stepIndex].type}' обновлены. Не забудьте сохранить всё задание.`, false);
    }

    /** Удаляет шаг из pipeline. */
    function deletePipelineStep(uiId) {
        currentPipelineSteps = currentPipelineSteps.filter(s => s.uiId !== uiId);
        if (selectedStepUiId === uiId) { // Если удалили выбранный шаг
            selectedStepUiId = null;
            stepPropertiesPanel.style.display = 'none';
        }
        renderPipelineWorkspace();
    }

    /** Очищает все шаги из pipeline. */
    function clearPipeline() {
        if (confirm("Вы уверены, что хотите очистить все шаги из текущего pipeline?")) {
            currentPipelineSteps = [];
            selectedStepUiId = null;
            stepPropertiesPanel.style.display = 'none';
            renderPipelineWorkspace();
        }
    }

    /** Валидирует JSON в textarea и показывает сообщение.
     * @param {boolean} returnData - Если true, возвращает объект {isValid, data, message}
     */
    function validateJsonInTextarea(textareaElement, messageElement, returnData = false) {
        const jsonString = textareaElement.value.trim();
        messageElement.textContent = '';
        textareaElement.classList.remove('invalid', 'valid');
        let result = { isValid: true, data: null, message: '' };

        if (jsonString === '' || jsonString === '{}') { // Пустой или {} - валидно, нет параметров/критериев
            result.data = {}; // или null, в зависимости от того, как сервер ожидает
            textareaElement.classList.add('valid');
            result.message = 'JSON корректен (пусто).';
        } else {
            try {
                const parsed = JSON.parse(jsonString);
                if (typeof parsed !== 'object' || Array.isArray(parsed) || parsed === null) {
                    throw new Error("Ожидается JSON объект { ключ: значение, ... }.");
                }
                result.data = parsed;
                textareaElement.classList.add('valid');
                result.message = 'JSON корректен.';
            } catch (e) {
                result.isValid = false;
                result.message = `Некорректный JSON: ${e.message}`;
                textareaElement.classList.add('invalid');
            }
        }
        messageElement.textContent = result.message;
        messageElement.className = `validation-message ${result.isValid ? 'valid' : 'invalid'}`;
        return returnData ? result : result.isValid;
    }


    // --- Drag-and-Drop для Pipeline ---
    let draggedStep = null; // Элемент, который перетаскивается

    function handleDragStart(e) {
        if (e.target.classList.contains('step-item')) { // Перетаскивание из панели доступных шагов
            draggedStep = {
                type: 'new',
                methodName: e.target.dataset.methodName,
                methodId: e.target.dataset.methodId,
                description: e.target.title || e.target.dataset.methodName // Используем title если есть
            };
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', e.target.dataset.methodName); // Для совместимости
            e.target.style.opacity = '0.5';
        } else if (e.target.closest('.pipeline-step-block')) { // Перетаскивание существующего шага в рабочей области
            draggedStep = {
                type: 'existing',
                uiId: e.target.closest('.pipeline-step-block').dataset.uiId,
                element: e.target.closest('.pipeline-step-block')
            };
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedStep.uiId);
            draggedStep.element.style.opacity = '0.5';
        }
    }

    function handleDragEnd(e) {
        if (e.target.classList.contains('step-item') || e.target.closest('.pipeline-step-block')) {
            e.target.style.opacity = '1';
            draggedStep = null;
            // Убираем подсветку зон drop
            pipelineWorkspace.classList.remove('drag-over');
        }
    }

    pipelineWorkspace.addEventListener('dragover', (e) => {
        e.preventDefault(); // Необходимо, чтобы событие drop сработало
        e.dataTransfer.dropEffect = draggedStep?.type === 'new' ? 'copy' : 'move';
        pipelineWorkspace.classList.add('drag-over'); // Визуальная обратная связь
    });

    pipelineWorkspace.addEventListener('dragleave', (e) => {
        pipelineWorkspace.classList.remove('drag-over');
    });

    pipelineWorkspace.addEventListener('drop', (e) => {
        e.preventDefault();
        pipelineWorkspace.classList.remove('drag-over');
        if (!draggedStep) return;

        if (draggedStep.type === 'new') { // Добавление нового шага
            addStepToPipeline(draggedStep.methodName, draggedStep.methodId, {description: draggedStep.description});
        } else if (draggedStep.type === 'existing') { // Изменение порядка существующих
            const targetElement = e.target.closest('.pipeline-step-block');
            const draggedUiId = draggedStep.uiId;
            const targetUiId = targetElement ? targetElement.dataset.uiId : null;

            const draggedIndex = currentPipelineSteps.findIndex(s => s.uiId === draggedUiId);
            if (draggedIndex === -1) return;

            const stepToMove = currentPipelineSteps.splice(draggedIndex, 1)[0];

            if (targetUiId && targetUiId !== draggedUiId) {
                const targetIndex = currentPipelineSteps.findIndex(s => s.uiId === targetUiId);
                // Вставляем перед или после целевого элемента в зависимости от положения мыши
                const rect = targetElement.getBoundingClientRect();
                const mouseY = e.clientY;
                if (mouseY < rect.top + rect.height / 2) {
                    currentPipelineSteps.splice(targetIndex, 0, stepToMove); // Вставить перед
                } else {
                    currentPipelineSteps.splice(targetIndex + 1, 0, stepToMove); // Вставить после
                }
            } else { // Если бросили на пустое место или на самого себя - добавляем в конец
                currentPipelineSteps.push(stepToMove);
            }
            renderPipelineWorkspace();
        }
        draggedStep = null;
    });

    // Навешиваем слушатели на панель доступных шагов (делегирование)
    availableStepsList.addEventListener('dragstart', handleDragStart);
    availableStepsList.addEventListener('dragend', handleDragEnd);
    availableStepsList.addEventListener('click', (e) => { // Добавление по клику
        const stepItem = e.target.closest('.step-item');
        if (stepItem) {
            addStepToPipeline(stepItem.dataset.methodName, stepItem.dataset.methodId, {description: stepItem.title || stepItem.dataset.methodName});
        }
    });

    // Навешиваем слушатели на рабочую область pipeline (делегирование)
    pipelineWorkspace.addEventListener('dragstart', handleDragStart);
    pipelineWorkspace.addEventListener('dragend', handleDragEnd);
    pipelineWorkspace.addEventListener('click', (e) => {
        const stepBlock = e.target.closest('.pipeline-step-block');
        const deleteBtn = e.target.closest('.delete-step-btn');
        if (deleteBtn) {
            e.stopPropagation(); // Предотвращаем выбор шага при клике на удаление
            deletePipelineStep(deleteBtn.dataset.uiId);
        } else if (stepBlock) {
            selectPipelineStep(stepBlock.dataset.uiId);
        }
    });

    // --- Сохранение всего Задания (pipeline + цели) ---
    async function handleSaveAssignmentPipeline() {
        showFeedback(formFeedback, 'Сохранение задания...');
        saveAssignmentPipelineBtn.disabled = true;
        saveAssignmentPipelineBtn.textContent = 'Сохранение...';
        clearValidationErrors('form-feedback'); // Очищаем общие ошибки формы

        // 1. Валидация JSON в свойствах текущего выбранного шага (если он есть)
        // Это нужно, чтобы пользователь не забыл нажать "Применить свойства к шагу"
        if (selectedStepUiId) {
            const paramsValid = validateJsonInTextarea(stepParametersTextarea, stepParamsValidationMsg, true);
            const criteriaValid = validateJsonInTextarea(stepSuccessCriteriaTextarea, stepCriteriaValidationMsg, true);
            if (!paramsValid.isValid || !criteriaValid.isValid) {
                showFeedback(formFeedback, "Пожалуйста, исправьте JSON в свойствах выбранного шага и нажмите 'Применить свойства', затем сохраните всё задание.", true);
                saveAssignmentPipelineBtn.disabled = false;
                saveAssignmentPipelineBtn.textContent = 'Сохранить Задание';
                stepPropertiesPanel.scrollIntoView({behavior: 'smooth'});
                return;
            }
            // Если JSON валиден, применяем свойства перед сохранением всего задания
            saveSelectedStepProperties(); // Это обновит currentPipelineSteps
        }


        // 2. Сборка данных для основного задания (цели и общие параметры)
        const selectedTargetMode = document.querySelector('input[name="target-mode"]:checked').value;
        const isEdit = !!currentEditAssignmentId;

        const assignmentPayload = {
            method_id: methodIdSelect.value ? parseInt(methodIdSelect.value, 10) : null,
            check_interval_seconds: checkIntervalInput.value ? parseInt(checkIntervalInput.value, 10) : null,
            is_enabled: isEnabledCheckbox.checked,
            description: descriptionInput.value.trim() || null,
            // Преобразуем currentPipelineSteps для отправки (убираем uiId)
            pipeline: currentPipelineSteps.map(step => ({
                type: step.type,
                description: step.description,
                parameters: step.parameters,
                success_criteria: step.success_criteria
            }))
        };

        // 3. Валидация общих параметров задания
        let mainFormErrors = {};
        if (!assignmentPayload.method_id) { mainFormErrors['method-id'] = "Основной тип задания обязателен."; }
        // ... (добавить другие валидации для interval, description, если нужно) ...

        // 4. Определение URL, метода и тела запроса в зависимости от режима (создание/редактирование)
        let apiUrl, apiMethod, finalPayload;
        if (isEdit) { // Редактирование существующего задания
            apiUrl = API_URL_ASSIGNMENT_DETAIL_TPL.replace('/0', `/${currentEditAssignmentId}`);
            apiMethod = 'PUT';
            finalPayload = assignmentPayload; // Отправляем только данные самого задания
        } else { // Создание нового задания (возможно, для нескольких целей)
            apiUrl = API_URL_ASSIGNMENT_BULK_CREATE; // Используем bulk_create эндпоинт
            apiMethod = 'POST';
            if (selectedTargetMode === 'criteria') {
                const selectedSubdivisionIds = Array.from(targetSubdivisionContainer.querySelectorAll('input:checked')).map(cb => parseInt(cb.value, 10));
                const selectedNodeTypeIds = Array.from(targetNodeTypeContainer.querySelectorAll('input:checked')).map(cb => parseInt(cb.value, 10));
                const nameMask = targetNameMaskInput.value.trim() || null;
                const criteria = {};
                if (selectedSubdivisionIds.length > 0) criteria.subdivision_ids = selectedSubdivisionIds;
                if (selectedNodeTypeIds.length > 0) criteria.node_type_ids = selectedNodeTypeIds;
                if (nameMask) criteria.node_name_mask = nameMask;

                if (Object.keys(criteria).length === 0) {
                    mainFormErrors['criteria'] = "Выберите хотя бы один критерий таргетинга (подразделение, тип или маску имени).";
                }
                finalPayload = { criteria: criteria, assignment_data: assignmentPayload };
            } else { // specific nodes
                if (selectedNodeIds.size === 0) {
                    mainFormErrors['specific_nodes'] = "Выберите хотя бы один конкретный узел.";
                }
                finalPayload = { node_ids: Array.from(selectedNodeIds), assignment_data: assignmentPayload };
            }
        }

        // Если есть ошибки валидации - показываем и выходим
        if (Object.keys(mainFormErrors).length > 0) {
            displayValidationErrors(mainFormErrors, 'form-feedback'); // Показываем ошибки в общем фидбеке формы
            saveAssignmentPipelineBtn.disabled = false;
            saveAssignmentPipelineBtn.textContent = 'Сохранить Задание';
            mainForm.scrollIntoView({ behavior: 'smooth' });
            return;
        }

        // 5. Отправка запроса
        try {
            const result = await fetchData(apiUrl, {
                method: apiMethod,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(finalPayload)
            });

            let successMsg = isEdit ? `Задание ID ${currentEditAssignmentId} успешно обновлено.` :
                             `Задания успешно созданы/назначены. (Создано новых: ${result?.assignments_created ?? '?'})`;
            showFeedback(listFeedbackAssignments, successMsg, false); // Сообщение над списком
            resetFullFormAndPipeline(); // Полный сброс формы
            await loadAssignments(isEdit ? listCurrentPage : 1); // Обновляем список заданий

        } catch (error) {
            console.error("Ошибка сохранения задания:", error);
            displayValidationErrors(error.details || error.message, 'form-feedback'); // Ошибки в форме
            showFeedback(formFeedback, `Ошибка сохранения: ${error.message}`, true);
        } finally {
            saveAssignmentPipelineBtn.disabled = false;
            saveAssignmentPipelineBtn.textContent = 'Сохранить Задание';
        }
    }

    /** Полный сброс формы, включая pipeline и состояние редактирования. */
    function resetFullFormAndPipeline() {
        resetFormBtn.click(); // Вызываем логику сброса основной формы (целей и общих параметров)
        clearPipeline();      // Очищаем pipeline
        currentEditAssignmentId = null; // Сбрасываем ID редактируемого задания
        // Меняем заголовок и текст кнопки обратно на "Создать"
        const mainFormTitleEl = document.getElementById('form-title'); // Заголовок для секции с основной формой
        if (mainFormTitleEl) mainFormTitleEl.textContent = 'Параметры и Цели Задания';
        // submitBtn (если бы он был один на всю страницу) тоже нужно было бы сбросить,
        // но у нас отдельная кнопка для pipeline.
    }


    // --- Инициализация и Обработчики ---
    // ... (Скопировать loadInitialData, renderAssignmentTable, renderPagination, обработчики фильтров, пагинации, edit/delete для списка заданий из предыдущего manage_assignments.html) ...
    // Важно: populateSelect для методов и других справочников также нужно перенести/адаптировать.

    // Заполнение селектов для фильтров списка заданий (адаптировать из старого manage_assignments)
    async function populateListFilters() {
        // methodsData, allNodesDataCache, subdivisionsDataCache, nodeTypesDataCache должны быть уже загружены
        populateSelect(filterMethodSelect, checkMethodsCache, 'id', 'method_name', 'Все методы');
        populateSelect(filterNodeSelect, allNodesDataCache, 'id', 'name', 'Все узлы', false, 'subdivision_id'); // Группировка по подразделению
        populateSelect(filterSubdivisionSelect, subdivisionsDataCache, 'id', 'short_name', 'Все подразделения', true);
        populateSelect(filterTypeSelect, nodeTypesDataCache, 'id', 'name', 'Все типы', true);
    }


    // Инициализация страницы
    async function initializePage() {
        showFeedback(formFeedback, 'Инициализация страницы...');
        try {
            // Загружаем все справочники параллельно
            const [nodesResp, methodsResp, subdivisionsResp, nodeTypesResp] = await Promise.all([
                fetchData(API_URL_NODES + "?limit=10000"), // Загружаем все узлы для селектов
                loadAvailableSteps(), // Загружает checkMethodsCache и рендерит панель шагов
                fetchData(API_URL_SUBDIVISIONS + "?limit=10000"), // Все подразделения
                fetchData(API_URL_NODE_TYPES + "?limit=10000")     // Все типы узлов
            ]);

            allNodesDataCache = nodesResp?.items || [];
            subdivisionsDataCache = subdivisionsResp?.items || [];
            nodeTypesDataCache = nodeTypesResp?.items || [];

            // Заполняем селекты в основной форме и фильтрах
            populateSelect(methodIdSelect, checkMethodsCache, 'id', 'method_name', '-- Выберите тип --');
            populateCheckboxList(targetSubdivisionContainer, subdivisionsDataCache, 'id', 'short_name', 'target_subdivision_ids', true);
            populateCheckboxList(targetNodeTypeContainer, nodeTypesDataCache, 'id', 'name', 'target_node_type_ids', true);
            renderSpecificNodesList(); // Для поиска узлов
            await populateListFilters(); // Заполняем фильтры списка заданий

            await loadAssignments(); // Загружаем первую страницу списка существующих заданий

            showFeedback(formFeedback, ''); // Убираем "Инициализация"
        } catch (error) {
            console.error("Критическая ошибка инициализации страницы:", error);
            showFeedback(formFeedback, `Ошибка инициализации: ${error.message}`, true);
        }
    }


    // --- Назначение обработчиков ---
    // Кнопка сброса основной формы и pipeline
    resetFormBtn.addEventListener('click', resetFullFormAndPipeline);
    // Выбор режима таргетинга
    targetModeRadios.forEach(radio => radio.addEventListener('change', handleTargetModeChange));
    // Поиск и выбор узлов
    nodeSearchInput.addEventListener('input', renderSpecificNodesList);
    nodesCheckboxList.addEventListener('change', handleNodeCheckboxChange);
    clearNodeSelectionBtn.addEventListener('click', clearNodeSelection);
    // Валидация JSON в панели свойств шага
    stepParametersTextarea.addEventListener('input', () => validateJsonInTextarea(stepParametersTextarea, stepParamsValidationMsg));
    stepSuccessCriteriaTextarea.addEventListener('input', () => validateJsonInTextarea(stepSuccessCriteriaTextarea, stepCriteriaValidationMsg));
    // Кнопка "Применить свойства к шагу"
    saveStepPropsBtn.addEventListener('click', saveSelectedStepProperties);
    // Кнопка "Очистить Pipeline"
    clearPipelineBtn.addEventListener('click', clearPipeline);
    // Главная кнопка "Сохранить Задание" (которая сохраняет и цели, и pipeline)
    saveAssignmentPipelineBtn.addEventListener('click', handleSaveAssignmentPipeline);

    // Обработчики для списка существующих заданий (фильтры, пагинация, edit/delete)
    // ... (Скопировать/адаптировать из старого manage_assignments.html) ...
    // Пример для одного фильтра:
    document.getElementById('filter-method').addEventListener('change', () => loadAssignments(1));
    // и т.д. для других фильтров и пагинации.

    // TODO: Добавить обработчики для кнопок Edit/Delete в таблице заданий,
    // которые будут загружать существующее задание в конструктор pipeline.
    assignmentTableBody.addEventListener('click', (event) => {
        const editBtn = event.target.closest('.edit-btn');
        const deleteBtn = event.target.closest('.delete-btn');
        if (editBtn) {
            const assignmentId = parseInt(editBtn.dataset.id, 10);
            loadAssignmentForEditing(assignmentId); // Новая функция
        } else if (deleteBtn) {
            // handleDeleteClick(parseInt(deleteBtn.dataset.id, 10), deleteBtn.dataset.nodeName, deleteBtn.dataset.methodName);
            console.warn("Функция удаления из списка еще не реализована полностью для pipeline");
        }
    });

    /** Загружает существующее задание в конструктор pipeline для редактирования. */
    async function loadAssignmentForEditing(assignmentId) {
        showFeedback(formFeedback, `Загрузка задания ID ${assignmentId} для редактирования...`);
        try {
            const assignment = await fetchData(API_URL_ASSIGNMENT_DETAIL_TPL.replace('/0', `/${assignmentId}`));
            if (!assignment) {
                showFeedback(formFeedback, `Ошибка: Задание ID ${assignmentId} не найдено.`, true);
                return;
            }

            // Сбрасываем все перед заполнением
            resetFullFormAndPipeline();
            currentEditAssignmentId = assignment.id;
            formTitle.textContent = `Редактировать Задание (Pipeline) ID: ${assignment.id}`;
            // Заполняем общие поля
            methodIdSelect.value = assignment.method_id || '';
            checkIntervalInput.value = assignment.check_interval_seconds || '';
            isEnabledCheckbox.checked = assignment.is_enabled !== false;
            descriptionInput.value = assignment.description || '';

            // Заполняем таргеты (только для specific, т.к. bulk_create не возвращает criteria)
            // Для упрощения, при редактировании всегда будем показывать только конкретный узел.
            // Логику редактирования "по критериям" можно добавить позже, если очень нужно.
            document.querySelector('input[name="target-mode"][value="specific"]').checked = true;
            handleTargetModeChange(); // Обновить видимость секций
            selectedNodeIds.clear();
            if (assignment.node_id) { // Предполагаем, что GET /assignment_id возвращает node_id
                selectedNodeIds.add(assignment.node_id);
            }
            renderSpecificNodesList(); // Обновит чекбоксы (если узел есть в кеше)
            updateSelectedNodesInfo();
            // Блокируем изменение таргетинга при редактировании одного задания
            document.querySelectorAll('input[name="target-mode"]').forEach(r => r.disabled = true);
            document.querySelectorAll('#criteria-section input, #criteria-section select, #criteria-section textarea').forEach(el => el.disabled = true);
            document.querySelectorAll('#specific-nodes-section input, #specific-nodes-section button').forEach(el => el.disabled = true);


            // Заполняем pipeline
            if (Array.isArray(assignment.pipeline)) {
                currentPipelineSteps = assignment.pipeline.map(step => ({
                    ...step, // type, description, parameters, success_criteria
                    uiId: `step-${Date.now()}-${Math.random().toString(36).substr(2, 5)}` // Генерируем новый uiId
                }));
            } else {
                currentPipelineSteps = [];
            }
            renderPipelineWorkspace();
            if (currentPipelineSteps.length > 0) {
                selectPipelineStep(currentPipelineSteps[0].uiId); // Выбираем первый шаг
            }

            showFeedback(formFeedback, `Задание ID ${assignmentId} загружено для редактирования.`);
            mainForm.scrollIntoView({ behavior: 'smooth' }); // Прокрутка к форме

        } catch (error) {
            console.error(`Ошибка загрузки задания ID ${assignmentId} для редактирования:`, error);
            showFeedback(formFeedback, `Ошибка загрузки задания: ${error.message}`, true);
        }
    }


    // Начальная загрузка
    document.addEventListener('DOMContentLoaded', initializePage);

</script>
{% endblock %}