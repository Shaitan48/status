<!-- status/app/templates/manage_assignments.html -->
{% extends "base.html" %} <!-- Наследуем базовый шаблон -->
{% block title %}Управление Заданиями - Мониторинг ПТК{% endblock %} <!-- Устанавливаем заголовок страницы -->

{% block head_extra %}
<!-- Дополнительные стили для этой страницы -->
<style>
    /* --- Общие стили --- */
    .manage-container { display: flex; flex-direction: column; gap: 1.5rem; }
    .section-card { background-color: var(--card-bg); padding: 1.5rem; border-radius: 5px; box-shadow: var(--card-shadow); border: 1px solid var(--border-color); margin-bottom: 1.5rem; }
    .section-card h3, .section-card h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 0.8rem; margin-bottom: 1rem; }
    .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem 1.5rem; } /* Адаптивная сетка для полей формы */
    .form-group { margin-bottom: 1rem; } /* Отступ для групп полей */
    .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 500; } /* Стили для лейблов */
    .form-group select, .form-group input, .form-group textarea { width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1em; } /* Общие стили полей ввода */
    .form-group input[type="checkbox"] { width: auto; margin-right: 0.5em; vertical-align: middle;} /* Стиль чекбокса */
    .form-group label.checkbox-label { display: inline-block; margin-bottom: 0; font-weight: normal; cursor: pointer; } /* Стиль лейбла для чекбокса */
    .form-group textarea { min-height: 100px; font-family: monospace; resize: vertical; background-color: #fff; } /* Стили для textarea */
    .form-group textarea.invalid { border-color: var(--danger-color); background-color: #fffafa; } /* Стиль для невалидного JSON */
    .form-actions { margin-top: 1.5rem; text-align: right; } /* Выравнивание кнопок формы */
    .feedback-area { min-height: 1.5em; margin-top: 1rem; font-weight: 500; text-align: center; padding: 5px; border-radius: 3px; } /* Область для сообщений */
    .feedback-area.error-feedback { color: var(--danger-color); background-color: #f8d7da; border: 1px solid #f5c6cb; } /* Стиль для сообщений об ошибках */
    .feedback-area.success-feedback { color: var(--success-color); background-color: #d4edda; border: 1px solid #c3e6cb;} /* Стиль для сообщений об успехе */
    .error-feedback { color: var(--danger-color); font-size: 0.9em; margin-top: 5px; } /* Стиль для ошибок валидации полей */

    /* --- Форма создания/назначения --- */
    #assignment-form-section h3 { display: flex; justify-content: space-between; align-items: center; } /* Заголовок формы с кнопкой сброса */
    #assignment-form-section h3 button { font-size: 0.8em; padding: 3px 8px; } /* Кнопка сброса */
    .target-selection-mode { margin-bottom: 1rem; border-bottom: 1px dashed #ccc; padding-bottom: 1rem;} /* Выбор режима таргетинга */
    .target-selection-mode label { margin-right: 15px; cursor: pointer; } /* Радио-кнопки выбора режима */
    .target-section { display: none; /* Скрываем секции таргетинга по умолчанию */ border: 1px solid #eee; padding: 1rem; border-radius: 4px; margin-top: 1rem; background-color: #fdfdfd; }
    .target-section.active { display: block; } /* Показываем активную секцию */

    /* --- Выбор конкретных узлов --- */
    #specific-nodes-section .node-search-container { display: flex; gap: 10px; margin-bottom: 10px; } /* Поиск и кнопка */
    #specific-nodes-section #node-search { flex-grow: 1; } /* Поле поиска растягивается */
    #specific-nodes-section .nodes-list { max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; margin-bottom: 10px; background-color: #fff; } /* Список узлов с прокруткой */
    #specific-nodes-section .nodes-list label { display: block; padding: 3px 5px; cursor: pointer; } /* Строка с узлом */
    #specific-nodes-section .nodes-list label:hover { background-color: #f0f0f0; } /* Подсветка при наведении */
    #specific-nodes-section .nodes-list input[type="checkbox"] { margin-right: 8px; vertical-align: middle; } /* Чекбокс узла */
    #specific-nodes-section .selected-nodes-info { font-size: 0.9em; color: #555; min-height: 1.2em;} /* Информация о выбранных узлах */

    /* --- Выбор по критериям --- */
    #criteria-section .form-grid { gap: 1rem 1.5rem; } /* Сетка для критериев */
    .multi-select-label { display: block; margin-bottom: 0.5rem; font-weight: 500; } /* Заголовок для мультиселекта */
    .multi-select-container { border: 1px solid #ccc; border-radius: 4px; padding: 10px; max-height: 150px; overflow-y: auto; background-color: white; } /* Контейнер для чекбоксов */
    .multi-select-container label { display: block; margin-bottom: 5px; font-weight: normal; cursor: pointer; } /* Строка с чекбоксом */
    .multi-select-container label:hover { background-color: #f0f0f0; } /* Подсветка */
    .multi-select-container input[type="checkbox"] { margin-right: 8px; vertical-align: middle; } /* Чекбокс */
    /* Иерархия в мультиселекте */
    .multi-select-container .level-0 { font-weight: bold; margin-left: 0px;}
    .multi-select-container .level-1 { margin-left: 15px; }
    .multi-select-container .level-2 { margin-left: 30px; }

    /* --- Список заданий и пагинация --- */
    .list-controls { /* Контейнер фильтров над таблицей */
        margin-bottom: 1rem; display: flex; flex-wrap: wrap; gap: 5px 15px;
        align-items: center; padding: 10px; background-color: #f8f9fa; border-radius: 4px;
        border: 1px solid var(--border-color);
    }
    .filter-group { display: flex; align-items: center; gap: 5px; } /* Группа: лейбл + инпут */
    .list-controls label { font-weight: 500; font-size: 0.9em; margin-right: 5px; margin-bottom: 0; } /* Лейблы фильтров */
    .list-controls select, .list-controls input[type="search"], .list-controls input[type="checkbox"] {
         padding: 4px 6px; font-size: 0.9em; border-radius: 3px; border: 1px solid #ccc;
    }
    .list-controls input[type="search"] { min-width: 150px; } /* Поле поиска */
    .list-controls input[type="checkbox"] { margin-right: 3px; vertical-align: middle; } /* Чекбоксы */
    .filter-group label[for^="filter-"] { white-space: nowrap; } /* Предотвращение переноса лейблов селектов */
    .filter-group label.checkbox-label { font-weight: normal; cursor: pointer; } /* Лейблы чекбоксов */

    .assignments-table { width: 100%; border-collapse: collapse; margin-top: 1rem; table-layout: fixed; } /* Таблица заданий */
    .assignments-table th, .assignments-table td { border: 1px solid var(--border-color); padding: 8px 10px; text-align: left; vertical-align: middle; word-wrap: break-word; } /* Ячейки таблицы */
    .assignments-table th { background-color: var(--light-grey); font-weight: 600; white-space: nowrap; } /* Заголовки таблицы */
    .assignments-table .params-cell { font-family: monospace; font-size: 0.85em; max-width: 250px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: help; } /* Ячейка с параметрами JSON */
    .assignments-table .criteria-cell { font-family: monospace; font-size: 0.8em; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: help; } /* Ячейка с критериями JSON */
    .assignments-table .actions { width: 90px; text-align: center; } /* Колонка действий */
    .assignments-table .actions button { padding: 4px 8px; font-size: 0.9em; margin: 2px 3px; cursor: pointer; border: none; border-radius: 3px; color: white; } /* Кнопки действий */
    .assignments-table .edit-btn { background-color: var(--warning-color); color: #333; } /* Кнопка Редактировать */
    .assignments-table .delete-btn { background-color: var(--danger-color); color: white;} /* Кнопка Удалить */
    .pagination-controls { margin-top: 1.5rem; text-align: center; } /* Контейнер пагинации */
    .pagination-controls button, .pagination-controls span { display: inline-block; padding: 5px 10px; margin: 0 3px; border: 1px solid #ccc; border-radius: 3px; background-color: #fff; cursor: pointer; font-size: 0.9em;} /* Элементы пагинации */
    .pagination-controls button:disabled { background-color: #eee; color: #aaa; cursor: not-allowed; } /* Неактивные кнопки */
    .pagination-controls span.current-page { background-color: var(--primary-color); color: white; border-color: var(--primary-color); cursor: default; } /* Текущая страница */

     /* Стили для поля Критерий успеха */
     .form-group textarea#success-criteria {
        min-height: 60px;
        font-family: monospace;
        background-color: #f8f9fa;
    }

</style>
{% endblock %}

{% block content %}
<h2>Управление Заданиями Проверки</h2>

<div class="manage-container">

    <!-- Секция 1: Форма создания/назначения/редактирования задания -->
    <section class="section-card" id="assignment-form-section">
        <h3>
             <span id="form-title">Создать и назначить задание</span>
             <button type="button" id="reset-form-btn" title="Сбросить форму и выбор узлов">Сбросить</button>
        </h3>
        <!-- Область для общих сообщений формы (ошибки API, успех) -->
        <div id="form-feedback" class="feedback-area"></div>
        <form id="assignment-form">
            <!-- Скрытое поле для хранения ID редактируемого задания -->
            <input type="hidden" id="assignment-id">

            <!-- Шаг 1: Общие параметры задания -->
            <h4>Шаг 1: Параметры Задания</h4>
            <div class="form-grid">
                 <!-- Метод проверки (выпадающий список) -->
                 <div class="form-group">
                     <label for="method-id">Метод проверки *</label>
                     <select id="method-id" required><option value="">-- Выберите метод --</option></select>
                     <!-- Область для ошибки валидации этого поля -->
                     <div class="error-feedback" id="method-id-error"></div>
                 </div>
                 <!-- Интервал проверки (числовое поле) -->
                 <div class="form-group">
                     <label for="check-interval">Интервал (сек)</label>
                     <input type="number" id="check-interval" placeholder="По умолчанию" min="0">
                     <div class="error-feedback" id="check-interval-error"></div>
                 </div>
                 <!-- Описание задания (текстовое поле) -->
                 <div class="form-group">
                     <label for="description">Описание</label>
                     <input type="text" id="description">
                     <div class="error-feedback" id="description-error"></div> <!-- Добавлено на всякий случай -->
                 </div>
                 <!-- Чекбокс "Включено" -->
                 <div class="form-group">
                     <label for="is-enabled" class="checkbox-label">
                         <input type="checkbox" id="is-enabled" checked> Включено
                     </label>
                 </div>
            </div>
             <!-- Параметры задания в формате JSON (текстовое поле) -->
             <div class="form-group">
                 <label for="parameters">Параметры (JSON)</label>
                 <textarea id="parameters" placeholder='Пример: {"service_name": "Spooler", "timeout": 10}'></textarea>
                 <div class="error-feedback" id="parameters-error"></div>
            </div>
            <!-- Критерий успеха задания в формате JSON (текстовое поле) -->
            <div class="form-group">
                 <label for="success-criteria">Критерий успеха (JSON)</label>
                 <textarea id="success-criteria" placeholder='Пример: {"status": "Running"} или {"value": {">": 100}}'></textarea>
                 <div class="error-feedback" id="success-criteria-error"></div>
            </div>

            <hr style="margin: 1.5rem 0;">

            <!-- Шаг 2: Выбор целевых узлов -->
            <h4>Шаг 2: Выбор Целевых Узлов</h4>
            <!-- Переключатель режима выбора -->
             <div class="target-selection-mode">
                 <label><input type="radio" name="target-mode" value="criteria" checked> Выбрать по критериям</label>
                 <label><input type="radio" name="target-mode" value="specific"> Выбрать конкретные узлы</label>
             </div>

            <!-- Секция выбора по критериям (показывается, если выбран режим 'criteria') -->
            <div id="criteria-section" class="target-section active">
                <p style="font-size: 0.9em; color: #555;">Задание будет создано для всех узлов, удовлетворяющих **всем** указанным ниже критериям.</p>
                <div class="form-grid">
                     <!-- Выбор подразделений (мультиселект с чекбоксами) -->
                     <div class="form-group">
                         <label class="multi-select-label">Подразделения:</label>
                         <div class="multi-select-container" id="target-subdivision-select"><small>Загрузка...</small></div>
                         <!-- Область для ошибок валидации, связанных с критериями -->
                         <div class="error-feedback" id="criteria-error"></div> <!-- Общая ошибка критериев -->
                         <div class="error-feedback" id="target-subdivision_ids-error"></div>
                    </div>
                    <!-- Выбор типов узлов (мультиселект с чекбоксами) -->
                    <div class="form-group">
                         <label class="multi-select-label">Типы узлов:</label>
                         <div class="multi-select-container" id="target-nodetype-select"><small>Загрузка...</small></div>
                         <div class="error-feedback" id="target-node_type_ids-error"></div>
                    </div>
                    <!-- Маска имени узла (текстовое поле) -->
                    <div class="form-group">
                         <label for="target-name-mask">Маска имени узла (SQL LIKE, % - любое кол-во, _ - один символ):</label>
                         <input type="text" id="target-name-mask" placeholder="Например: SRV-% или %-DC-%">
                         <div class="error-feedback" id="target-name_mask-error"></div>
                    </div>
                </div>
            </div>

            <!-- Секция выбора конкретных узлов (показывается, если выбран режим 'specific') -->
            <div id="specific-nodes-section" class="target-section">
                 <!-- Поиск узлов -->
                 <div class="node-search-container">
                    <input type="search" id="node-search" placeholder="Поиск узла по имени или IP...">
                    <button type="button" id="clear-node-selection-btn">Очистить выбор</button>
                 </div>
                 <!-- Список узлов для выбора (чекбоксы) -->
                <div class="nodes-list" id="nodes-checkbox-list">
                    <small>Начните вводить имя для поиска...</small>
                </div>
                <!-- Информация о количестве выбранных узлов -->
                <div class="selected-nodes-info" id="selected-nodes-info">Выбрано узлов: 0</div>
                 <!-- Область для ошибок валидации, связанных с выбором узлов -->
                <div class="error-feedback" id="target-specific_nodes-error"></div>
            </div>

            <!-- Кнопка отправки формы -->
            <div class="form-actions">
                <button type="submit" id="submit-assignment-btn">Создать / Назначить Задание(я)</button>
            </div>
        </form>
    </section>

    <!-- Секция 2: Список существующих заданий -->
    <section class="section-card">
         <h3>Список Существующих Заданий</h3>
         <!-- Область для сообщений над списком (успех/ошибка удаления и т.п.) -->
         <div id="list-feedback" class="feedback-area"></div>
          <!-- Панель фильтров -->
          <div class="list-controls">
             <!-- Фильтр по подразделению -->
             <div class="filter-group">
                 <label for="filter-subdivision">Подр:</label>
                 <select id="filter-subdivision"> <option value="">Все</option> </select>
                 <input type="checkbox" id="filter-subdivision-include-children" title="Включить дочерние подразделения">
                 <label for="filter-subdivision-include-children" class="checkbox-label">Вкл. дочерние</label>
             </div>
             <!-- Фильтр по типу узла -->
             <div class="filter-group">
                 <label for="filter-type">Тип:</label>
                 <select id="filter-type"> <option value="">Все</option> </select>
                  <input type="checkbox" id="filter-type-include-nested" title="Включить вложенные типы">
                  <label for="filter-type-include-nested" class="checkbox-label">Вкл. вложенные</label>
             </div>
             <!-- Фильтр по конкретному узлу -->
             <div class="filter-group">
                 <label for="filter-node">Узел:</label>
                 <select id="filter-node"> <option value="">Все</option> </select>
             </div>
             <!-- Фильтр по методу проверки -->
             <div class="filter-group">
                 <label for="filter-method">Метод:</label>
                 <select id="filter-method"> <option value="">Все</option> </select>
             </div>
             <!-- Текстовый поиск -->
             <div class="filter-group">
                 <label for="filter-text">Поиск:</label>
                 <input type="search" id="filter-text" placeholder="Имя узла, описание...">
             </div>
        </div>
        <!-- Таблица с заданиями -->
        <table class="assignments-table">
             <thead>
                 <tr>
                     <th>Узел</th>
                     <th>Метод</th>
                     <th>Параметры</th>
                     <th>Критерий</th> <!-- Новая колонка -->
                     <th>Интервал</th>
                     <th>Вкл.</th>
                     <th>Описание</th>
                     <th>Действия</th>
                 </tr>
             </thead>
            <tbody id="assignment-list">
                <!-- Строки таблицы будут загружены динамически -->
                <tr><td colspan="8" class="loading-message">Загрузка списка заданий...</td></tr> <!-- Увеличен colspan -->
            </tbody>
        </table>
         <!-- Элементы управления пагинацией -->
         <div class="pagination-controls" id="pagination-controls" style="display: none;"> <!-- Скрыто по умолчанию -->
             <button id="prev-page" disabled>« Назад</button>
             <span id="page-info">Страница - из -</span>
             <button id="next-page" disabled>Вперед »</button>
         </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
    // --- Получение ссылок на элементы DOM ---
    // Форма
    const form = document.getElementById('assignment-form');
    const formTitle = document.getElementById('form-title');
    const submitBtn = document.getElementById('submit-assignment-btn');
    const resetBtn = document.getElementById('reset-form-btn');
    const formFeedback = document.getElementById('form-feedback');
    const assignmentList = document.getElementById('assignment-list'); // tbody таблицы
    const listFeedback = document.getElementById('list-feedback'); // Фидбек над таблицей
    // Поля формы
    const idInput = document.getElementById('assignment-id');
    const methodIdSelect = document.getElementById('method-id');
    const intervalInput = document.getElementById('check-interval');
    const isEnabledCheckbox = document.getElementById('is-enabled');
    const descriptionInput = document.getElementById('description');
    const parametersTextarea = document.getElementById('parameters');
    const successCriteriaTextarea = document.getElementById('success-criteria'); // Новое поле
    // Выбор таргетинга
    const targetModeRadios = document.querySelectorAll('input[name="target-mode"]');
    const criteriaSection = document.getElementById('criteria-section');
    const specificNodesSection = document.getElementById('specific-nodes-section');
    // Критерии
    const targetSubdivisionContainer = document.getElementById('target-subdivision-select');
    const targetNodeTypeContainer = document.getElementById('target-nodetype-select');
    const targetNameMaskInput = document.getElementById('target-name-mask');
    // Выбор узлов
    const nodeSearchInput = document.getElementById('node-search');
    const nodesCheckboxList = document.getElementById('nodes-checkbox-list');
    const selectedNodesInfo = document.getElementById('selected-nodes-info');
    const clearNodeSelectionBtn = document.getElementById('clear-node-selection-btn');
    // Фильтры списка
    const filterSubdivisionSelect = document.getElementById('filter-subdivision');
    const filterTypeSelect = document.getElementById('filter-type');
    const filterNodeSelect = document.getElementById('filter-node');
    const filterMethodSelect = document.getElementById('filter-method');
    const filterTextInput = document.getElementById('filter-text');
    const filterSubdivisionIncludeChildren = document.getElementById('filter-subdivision-include-children');
    const filterTypeIncludeNested = document.getElementById('filter-type-include-nested');
    // Пагинация
    const paginationControls = document.getElementById('pagination-controls');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const pageInfoSpan = document.getElementById('page-info');

    // --- URL API эндпоинтов ---
    const API_URL_ASSIGNMENTS_ALL = "{{ url_for('assignments.api_get_all_assignments_paginated') }}";
    const API_URL_ASSIGNMENT_DETAIL_TPL = "{{ url_for('assignments.api_get_assignment', assignment_id=0) }}";
    const API_URL_ASSIGNMENT_BULK_CREATE = "{{ url_for('assignments.api_create_or_assign_assignments') }}";
    const API_URL_NODES = "{{ url_for('nodes.api_get_nodes') }}"; // Для выбора узлов и фильтра
    const API_URL_METHODS = "{{ url_for('data.api_get_check_methods') }}"; // Для выбора метода
    const API_URL_SUBDIVISIONS = "{{ url_for('subdivisions.api_get_subdivisions') }}"; // Для выбора подразделений
    const API_URL_NODE_TYPES = "{{ url_for('node_types.api_get_node_types') }}"; // Для выбора типов

    // --- Переменные состояния приложения ---
    let allAssignmentsData = []; // Кэш заданий текущей страницы
    let allNodesData = [];       // Кэш ВСЕХ узлов (для поиска/выбора и фильтра)
    let methodsData = [];        // Кэш методов проверки
    let subdivisionsData = [];   // Кэш ВСЕХ подразделений
    let nodeTypesData = [];      // Кэш ВСЕХ типов узлов
    let currentEditId = null;    // ID редактируемого задания (если есть)
    let selectedNodeIds = new Set(); // Множество ID узлов, выбранных в режиме 'specific'
    // Пагинация
    let currentPage = 1;         // Текущая страница списка заданий
    let itemsPerPage = 25;       // Количество заданий на странице
    let totalAssignments = 0;    // Общее количество заданий по текущим фильтрам

    // --- Вспомогательные функции ---

    /**
     * Универсальная функция для заполнения выпадающих списков (<select>).
     * Поддерживает плоские списки, иерархию и группировку.
     * @param {HTMLSelectElement} selectElement - DOM-элемент select.
     * @param {Array<Object>} items - Массив объектов для опций.
     * @param {string} valueField - Имя поля в объекте items для значения option.
     * @param {string} textField - Имя поля в объекте items для текста option.
     * @param {string} placeholder - Текст для первой пустой опции.
     * @param {boolean} addHierarchy - Строить ли иерархию (использует parent_id/parent_type_id и priority)?
     * @param {string|null} groupByKey - Группировать ли опции по ключу (например, 'subdivision_id')?
     */
     function populateSelect(selectElement, items, valueField, textField, placeholder, addHierarchy = false, groupByKey = null) {
        const currentSelectedValue = selectElement.value; // Запоминаем текущее значение
        selectElement.innerHTML = `<option value="">${placeholder}</option>`; // Очищаем и добавляем плейсхолдер

        console.debug(`populateSelect: Target element ID: ${selectElement.id}, Placeholder: "${placeholder}", Items: ${items?.length}`); // Добавил лог

        if (!items || items.length === 0) {
            console.warn(`populateSelect for ${selectElement.id}: No items provided.`);
            return; // Выходим, если данных нет
        }

        // --- Логика группировки (если groupByKey задан) ---
        if (groupByKey) {
             const groups = {}; // { groupValue: { name: 'GroupName', items: [...] } }
             // Получаем данные для группировки (например, подразделения)
             const groupSourceData = groupByKey === 'subdivision_id' ? subdivisionsData : []; // Добавьте другие источники, если нужно
             const groupNameMap = Object.fromEntries(groupSourceData.map(g => [g.id, g.short_name || g.name]));

             items.forEach(item => {
                 const groupValue = item[groupByKey];
                 if (!groups[groupValue]) {
                     groups[groupValue] = {
                         name: groupNameMap[groupValue] || `Группа ${groupValue || 'N/A'}`, // Имя группы
                         items: []
                     };
                 }
                 groups[groupValue].items.push(item);
             });

             // Сортируем группы по имени
             const sortedGroupKeys = Object.keys(groups).sort((a, b) => groups[a].name.localeCompare(groups[b].name));

             sortedGroupKeys.forEach(key => {
                 const group = groups[key];
                 const optgroup = document.createElement('optgroup');
                 optgroup.label = group.name;
                 // Сортируем элементы внутри группы
                 group.items.sort((a, b) => (a[textField] || '').localeCompare(b[textField] || ''));
                 group.items.forEach(item => {
                     if (item && typeof item === 'object' && valueField in item && textField in item) {
                         const option = document.createElement('option');
                         option.value = item[valueField];
                         option.textContent = item[textField];
                         optgroup.appendChild(option);
                     } else {
                          console.warn(`populateSelect (grouped) for ${selectElement.id}: Пропущен некорректный item в группе ${group.name}:`, item);
                     }
                 });
                 selectElement.appendChild(optgroup);
             });

        // --- Логика иерархии (если addHierarchy = true и нет группировки) ---
        } else if (addHierarchy) {
            const map = {}; const roots = [];
            // Строим карту и находим корни
            items.forEach(item => { map[item[valueField]] = { ...item, children: [] }; });
            items.forEach(item => {
                const parentFieldKey = valueField === 'id' && item.parent_id !== undefined ? 'parent_id' : (valueField === 'id' && item.parent_type_id !== undefined ? 'parent_type_id' : null);
                const parentId = parentFieldKey ? item[parentFieldKey] : null;
                if (parentId === null || !map[parentId]) {
                     if (!roots.includes(item[valueField])) roots.push(item[valueField]);
                } else if (map[parentId]) {
                     map[parentId].children.push(item[valueField]);
                }
            });

            // Рекурсивная функция добавления опций
            function addOption(itemId, level) {
                 const item = map[itemId]; if (!item) return;
                 const option = document.createElement('option');
                 option.value = item[valueField];
                 const name = item.short_name || item[textField]; // Для подразделений может быть short_name
                 option.textContent = '\u00A0'.repeat(level * 3) + name; // Отступ для иерархии
                 selectElement.appendChild(option);
                 // Сортировка дочерних элементов (по приоритету, потом по имени)
                 item.children
                    .map(id => map[id]).filter(child => child) // Получаем объекты и фильтруем отсутствующие
                    .sort((a, b) => (a.priority ?? 9999) - (b.priority ?? 9999) || (a.short_name || a[textField]).localeCompare(b.short_name || b[textField]))
                    .forEach(child => addOption(child.id, level + 1));
            }

            // Сортировка и рендеринг корневых элементов
             roots
                .map(id => map[id]).filter(root => root)
                .sort((a, b) => (a.priority ?? 9999) - (b.priority ?? 9999) || (a.short_name || a[textField]).localeCompare(b.short_name || b[textField]))
                .forEach(root => addOption(root.id, 0));

        // --- Логика плоского списка (если не иерархия и не группировка) ---
        } else {
            console.log(`populateSelect (flat) for ${selectElement.id}: Processing ${items.length} items.`);
            let optionsAdded = 0; // Счетчик добавленных опций

            if (!Array.isArray(items) || items.length === 0 || typeof items[0] !== 'object' || items[0] === null) {
                console.error(`populateSelect (flat) for ${selectElement.id}: items is not a valid array of objects`, items);
                return;
            }

             items
                .sort((a, b) => { // Сортировка
                    const textA = a && typeof a[textField] === 'string' ? a[textField] : '';
                    const textB = b && typeof b[textField] === 'string' ? b[textField] : '';
                    return textA.localeCompare(textB);
                })
                .forEach((item, index) => {
                    if (item && typeof item === 'object' && valueField in item && textField in item) {
                         const option = document.createElement('option');
                         const value = item[valueField];
                         const text = item[textField];
                         option.value = value;
                         option.textContent = text;

                         console.debug(`  [${selectElement.id}] Adding option ${index + 1}: value="${value}", text="${text}"`);

                         selectElement.appendChild(option);
                         optionsAdded++;
                     } else {
                         console.warn(`populateSelect (flat) for ${selectElement.id}: Пропущен некорректный item или отсутствуют поля (index ${index}):`, item);
                     }
                 });

            console.log(`populateSelect (flat) for ${selectElement.id}: Finished. Added ${optionsAdded} options.`);
         }

         // Восстанавливаем выбор, если он был
         if (currentSelectedValue && selectElement.querySelector(`option[value="${currentSelectedValue}"]`)) {
             selectElement.value = currentSelectedValue;
             console.log(`populateSelect for ${selectElement.id}: Restored selected value: ${currentSelectedValue}`);
         } else {
             selectElement.value = ""; // Устанавливаем плейсхолдер
             console.log(`populateSelect for ${selectElement.id}: Set placeholder selection.`);
         }
    }

    /**
     * Асинхронная функция для выполнения запросов к API.
     * @param {string} url - URL эндпоинта.
     * @param {object} options - Опции для fetch (method, headers, body).
     * @returns {Promise<object|null>} - Promise с распарсенным JSON-ответом или null.
     * @throws {Error} - Кастомная ошибка с деталями при ошибке сети или API.
     */
    async function fetchData(url, options = {}) {
        // Индикация загрузки
        listFeedback.textContent = 'Загрузка...';
        listFeedback.className = 'feedback-area';
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                let errorText = `Ошибка сети: ${response.status} ${response.statusText}`;
                let errorDetails = null; let errorCode = 'NETWORK_ERROR';
                try { /* ... (Парсинг JSON ошибки API) ... */ } catch (e) { /* ... */ }
                const error = new Error(errorText); error.details = errorDetails; error.code = errorCode; error.status = response.status; throw error;
            }
            listFeedback.textContent = ''; // Очищаем при успехе
            if (response.status === 204) return null; // Успех без контента (DELETE)
            const text = await response.text();
            try { return text ? JSON.parse(text) : null; }
            catch (e) { console.warn("Не удалось распарсить JSON ответа:", text); return { rawText: text }; }
        } catch (error) {
             console.error("Ошибка fetchData:", error);
             showListFeedback(`Ошибка сети: ${error.message}`, true);
             throw error; // Передаем ошибку дальше
        }
    }

    // --- Функции UI (Отображение сообщений, валидация) ---

    /**
     * Отображает ошибки валидации в соответствующих div'ах под полями формы.
     * @param {object|string} errors - Объект {field_name: message} или строка с общей ошибкой.
     * @param {string} prefix - Префикс ID элементов формы (не используется здесь).
     */
    function displayValidationErrors(errors, prefix = '') {
        const feedbackEl = formFeedback; // Общий фидбек формы
        clearValidationErrors(); let firstErrorField = null;
        if (typeof errors === 'string') { showFormFeedback(errors, true); return; }
        if (errors && typeof errors === 'object') {
            for (const field in errors) {
                // Преобразуем snake_case -> kebab-case (для ID)
                let elementId = field.replace(/_([a-z])/g, (m, p1) => p1.toUpperCase());
                // Особые случаи имен полей
                if (field === 'method_id') elementId = 'method-id';
                else if (field === 'check_interval_seconds') elementId = 'check-interval';
                else if (field === 'success_criteria') elementId = 'success-criteria'; // Новое поле
                else if (field === 'criteria') elementId = 'target-subdivision-select'; // Ошибка критериев - подсветим первый
                else if (field === 'node_ids') elementId = 'node-search'; // Ошибка выбора узлов - подсветим поиск
                // Ищем элемент для ошибки по ID + '-error'
                const errorElement = document.getElementById(`${elementId}-error`);
                const fieldElement = document.getElementById(elementId); // Ищем само поле для фокуса
                if (errorElement) {
                    errorElement.textContent = errors[field];
                    if (!firstErrorField) firstErrorField = fieldElement || errorElement; // Запоминаем первое поле
                } else { // Если нет спец. div'а, показываем в общей области
                     showFormFeedback(`${field}: ${errors[field]}`, true);
                     if (!firstErrorField && fieldElement) firstErrorField = fieldElement; // Фокус все равно ставим, если можем
                }
            }
        }
        // Устанавливаем фокус на первое поле с ошибкой
        if(firstErrorField) { firstErrorField.focus(); }
    }

    /** Очищает все сообщения об ошибках валидации в форме. */
    function clearValidationErrors() {
         showFormFeedback(''); // Очищаем общий фидбек
         // Очищаем текст в div.error-feedback или удаляем динамически созданные span
         document.querySelectorAll('#assignment-form .error-feedback').forEach(el => { if (el.tagName === 'SPAN' && el.classList.contains('error-feedback')) el.remove(); else el.textContent = ''; });
         // Убираем класс 'invalid' с textarea
         parametersTextarea.classList.remove('invalid');
         successCriteriaTextarea.classList.remove('invalid');
    }

    /**
     * Отображает сообщение в указанном элементе.
     * @param {HTMLElement} element - Элемент для отображения сообщения (formFeedback или listFeedback).
     * @param {string} message - Текст сообщения.
     * @param {boolean} isError - Является ли сообщение ошибкой?
     */
    function showFeedback(element, message, isError = false) {
        element.textContent = message;
        element.className = 'feedback-area'; // Сбрасываем классы
        if (message) { element.classList.add(isError ? 'error-feedback' : 'success-feedback'); }
    }
    /** Показывает сообщение над списком заданий. */
    function showListFeedback(message, isError = false) { showFeedback(listFeedback, message, isError); }
    /** Показывает сообщение внутри формы задания. */
    function showFormFeedback(message, isError = false) { showFeedback(formFeedback, message, isError); }

    /** Сбрасывает форму задания в начальное состояние. */
    function resetFullForm() {
         form.reset(); // Сбрасывает значения полей
         idInput.value = ''; currentEditId = null;
         formTitle.textContent = 'Создать и назначить задание';
         submitBtn.textContent = 'Создать / Назначить Задание(я)';
         submitBtn.disabled = false; // Разблокируем кнопку
         // Сбрасываем JSON поля и убираем ошибки
         parametersTextarea.value = ''; parametersTextarea.classList.remove('invalid');
         successCriteriaTextarea.value = ''; successCriteriaTextarea.classList.remove('invalid');
         // Сбрасываем выбор таргетинга
         targetModeRadios.forEach(radio => radio.checked = (radio.value === 'criteria'));
         criteriaSection.classList.add('active'); specificNodesSection.classList.remove('active');
         // Очищаем выбранные критерии
         targetSubdivisionContainer.querySelectorAll('input:checked').forEach(cb => cb.checked = false);
         targetNodeTypeContainer.querySelectorAll('input:checked').forEach(cb => cb.checked = false);
         targetNameMaskInput.value = '';
         // Очищаем выбор конкретных узлов
         selectedNodeIds.clear(); nodeSearchInput.value = '';
         renderSpecificNodesList(); updateSelectedNodesInfo();
         // Очищаем ошибки и сообщения
         clearValidationErrors(); showFormFeedback('');
         // Разблокируем поля формы
         methodIdSelect.disabled = false; intervalInput.disabled = false; isEnabledCheckbox.disabled = false;
         descriptionInput.disabled = false; parametersTextarea.disabled = false; successCriteriaTextarea.disabled = false;
         document.querySelectorAll('input[name="target-mode"]').forEach(r => r.disabled = false);
         document.querySelectorAll('#criteria-section input, #criteria-section select, #criteria-section textarea').forEach(el => el.disabled = false);
         document.querySelectorAll('#specific-nodes-section input, #specific-nodes-section button').forEach(el => el.disabled = false);
     }

    /**
     * Заполняет контейнер чекбоксами для выбора элементов (подразделений, типов).
     * @param {HTMLElement} containerElement - Контейнер (div) для чекбоксов.
     * @param {Array<Object>} items - Массив данных.
     * @param {string} valueField - Поле для value чекбокса.
     * @param {string} textField - Поле для текста лейбла.
     * @param {string} nameAttribute - Атрибут name для чекбоксов.
     * @param {boolean} addHierarchy - Строить ли иерархию?
     */
    function populateCheckboxList(containerElement, items, valueField, textField, nameAttribute, addHierarchy = false) {
         containerElement.innerHTML = '';
         if (!items || items.length === 0) { containerElement.innerHTML = '<small>Нет данных</small>'; return; }
         // ... (Логика построения иерархии/плоского списка как раньше) ...
         const map = {}; const roots = [];
         if (addHierarchy) { /* ... */ } else { /* ... */ }
         function addCheckbox(itemId, level) { /* ... */ }
         roots.sort(/* ... */).forEach(rootId => addCheckbox(rootId, 0));
    }

    // --- Загрузка данных ---

    /** Загружает начальные данные (справочники) и первую страницу заданий. */
    async function loadInitialData() {
        showListFeedback("Загрузка справочников...");
        try {
             // Загружаем справочники параллельно
             const [nodesRes, methodsRes, subdivisionsRes, nodeTypesRes] = await Promise.all([
                 fetchData(API_URL_NODES), 
                 fetchData(API_URL_METHODS),
                 fetchData(API_URL_SUBDIVISIONS), 
                 fetchData(API_URL_NODE_TYPES)
             ]);
             // Извлекаем массивы items
             allNodesData = (nodesRes && nodesRes.items) ? nodesRes.items : [];
             methodsData = methodsRes || []; // Методы возвращаются массивом
             console.log("Check Methods data fetched:", JSON.stringify(methodsData)); // <<< ЛОГ ДЛЯ ПРОВЕРКИ
             
             subdivisionsData = (subdivisionsRes && subdivisionsRes.items) ? subdivisionsRes.items : [];
             nodeTypesData = (nodeTypesRes && nodeTypesRes.items) ? nodeTypesRes.items : [];

             // Заполняем селекты в форме и фильтрах
             populateSelect(methodIdSelect, methodsData, 'id', 'method_name', '-- Выберите метод --');
             populateCheckboxList(targetSubdivisionContainer, subdivisionsData, 'id', 'short_name', 'target_subdivision_ids', true);
             populateCheckboxList(targetNodeTypeContainer, nodeTypesData, 'id', 'name', 'target_node_type_ids', true);
             populateSelect(filterNodeSelect, allNodesData, 'id', 'name', 'Все узлы', false, 'subdivision_id');
             populateSelect(filterMethodSelect, methodsData, 'id', 'method_name', 'Все методы');
             populateSelect(filterSubdivisionSelect, subdivisionsData, 'id', 'short_name', 'Все подразделения', true);
             populateSelect(filterTypeSelect, nodeTypesData, 'id', 'name', 'Все типы', true);

             console.log("Populating form method select...");
             populateSelect(methodIdSelect, methodsData, 'id', 'method_name', '-- Выберите метод --');

             console.log("Populating filter method select...");
             populateSelect(filterMethodSelect, methodsData, 'id', 'method_name', 'Все методы');
             // Рендерим список узлов для выбора
             renderSpecificNodesList();

             showListFeedback(""); // Убираем "Загрузка справочников..."
             await loadAssignments(); // Загружаем первую страницу заданий

         } catch (error) {
              console.error("Ошибка загрузки начальных данных:", error);
              // Сообщение об ошибке покажет fetchData
              // Очищаем контейнеры на случай, если там осталось "Загрузка..."
              targetSubdivisionContainer.innerHTML = '<small class="error-message">Ошибка загрузки</small>';
              targetNodeTypeContainer.innerHTML = '<small class="error-message">Ошибка загрузки</small>';
              nodesCheckboxList.innerHTML = '<small class="error-message">Ошибка загрузки узлов</small>';
         }
    }

    /**
     * Загружает и отображает страницу заданий с учетом фильтров и пагинации.
     * @param {number} page - Номер запрашиваемой страницы (начиная с 1).
     */
    async function loadAssignments(page = 1) {
         assignmentList.innerHTML = `<tr><td colspan="8" class="loading-message">Загрузка списка заданий...</td></tr>`; // colspan=8
         currentPage = page;
         const offset = (currentPage - 1) * itemsPerPage;
         // Собираем параметры запроса из фильтров
         const params = new URLSearchParams();
         params.append('limit', itemsPerPage); params.append('offset', offset);
         if (filterNodeSelect.value) params.append('node_id', filterNodeSelect.value);
         if (filterMethodSelect.value) params.append('method_id', filterMethodSelect.value);
         if (filterTextInput.value.trim()) params.append('search_text', filterTextInput.value.trim());
         if (filterSubdivisionSelect.value) {
             params.append('subdivision_id', filterSubdivisionSelect.value);
             if (filterSubdivisionIncludeChildren.checked) params.append('include_child_subdivisions', 'true');
         }
         if (filterTypeSelect.value) {
            params.append('node_type_id', filterTypeSelect.value);
             if (filterTypeIncludeNested.checked) params.append('include_nested_types', 'true');
        }
         try {
             const url = `${API_URL_ASSIGNMENTS_ALL}?${params.toString()}`;
             const result = await fetchData(url); // Ожидаем {assignments: [], total_count: N}
             let assignmentsOnPage = [];
              if (result && Array.isArray(result.assignments)) {
                  assignmentsOnPage = result.assignments;
                  totalAssignments = result.total_count || 0;
              } else { console.warn("API /assignments_all вернул некорректные данные:", result); totalAssignments = 0; }
             renderAssignmentTable(assignmentsOnPage); // Отображаем полученные задания
             renderPagination(); // Обновляем пагинацию
         } catch (error) {
             console.error("Ошибка загрузки заданий:", error);
             assignmentList.innerHTML = `<tr><td colspan="8" class="error-message">Ошибка загрузки заданий.</td></tr>`;
             renderPagination(); // Показать пагинацию с 0 записей
         }
    }

    /**
     * Рендерит строки таблицы заданий.
     * @param {Array<Object>} assignments - Массив объектов заданий для отображения.
     */
    function renderAssignmentTable(assignments) {
         let tableHtml = '';
         if (!assignments || assignments.length === 0) {
             // Сообщение, если нет заданий (с учетом фильтров)
             const filtersActive = filterNodeSelect.value || filterMethodSelect.value || filterSubdivisionSelect.value || filterTypeSelect.value || filterTextInput.value;
             tableHtml = `<tr><td colspan="8" style="text-align: center;">Задания не найдены${filtersActive ? ' (с учетом фильтров)' : ''}.</td></tr>`;
         } else {
             // Используем кэши справочников для отображения имен вместо ID
             const nodeMap = Object.fromEntries(allNodesData.map(n => [n.id, n.name]));
             const methodMap = Object.fromEntries(methodsData.map(m => [m.id, m.method_name]));
             // Генерируем HTML для каждой строки
             tableHtml = assignments.map(a => {
                 const nodeName = nodeMap[a.node_id] || `ID: ${a.node_id}`;
                 const methodName = methodMap[a.method_id] || `ID: ${a.method_id}`;
                 // Форматируем JSON для отображения и всплывающей подсказки
                 let paramsHtml = '---'; let paramsTitle = 'Нет параметров'; let paramsClass = '';
                 if (a.parameters && typeof a.parameters === 'object' && Object.keys(a.parameters).length > 0) { // Проверяем что это объект
                     try { paramsHtml = JSON.stringify(a.parameters); paramsTitle = JSON.stringify(a.parameters, null, 2); }
                     catch (e) { paramsHtml = '[Ошибка JSON]'; paramsTitle = String(a.parameters); paramsClass = 'error'; }
                 }
                 let criteriaHtml = '---'; let criteriaTitle = 'Нет критерия'; let criteriaClass = '';
                 if (a.success_criteria && typeof a.success_criteria === 'object' && Object.keys(a.success_criteria).length > 0) {
                     try { criteriaHtml = JSON.stringify(a.success_criteria); criteriaTitle = JSON.stringify(a.success_criteria, null, 2); }
                     catch (e) { criteriaHtml = '[Ошибка JSON]'; criteriaTitle = String(a.success_criteria); criteriaClass = 'error'; }
                 }
                 const enabledText = a.is_enabled ? 'Да' : 'Нет';
                 // HTML строки таблицы
                 return `
                     <tr data-id="${a.id}">
                         <td title="Узел ID: ${a.node_id}">${nodeName}</td>
                         <td title="Метод ID: ${a.method_id}">${methodName}</td>
                         <td class="params-cell ${paramsClass}" title='${paramsTitle.replace(/'/g, '"')}'>${paramsHtml}</td>
                         <td class="criteria-cell ${criteriaClass}" title='${criteriaTitle.replace(/'/g, '"')}'>${criteriaHtml}</td> <!-- Новая колонка -->
                         <td>${a.check_interval_seconds || 'Default'}</td>
                         <td>${enabledText}</td>
                         <td>${a.description || '---'}</td>
                         <td class="actions">
                              <button class="edit-btn" data-id="${a.id}" title="Редактировать">✏️</button>
                              <button class="delete-btn" data-id="${a.id}" data-node-name="${nodeName}" data-method-name="${methodName}" title="Удалить">🗑️</button>
                         </td>
                     </tr>`;
             }).join('');
         }
         assignmentList.innerHTML = tableHtml; // Вставляем HTML в таблицу
    }

    /** Обновляет элементы управления пагинацией. */
    function renderPagination() {
         if (!paginationControls || !pageInfoSpan || !prevPageBtn || !nextPageBtn) return;
         const totalPages = Math.ceil(totalAssignments / itemsPerPage);
         pageInfoSpan.textContent = `Страница ${currentPage} из ${totalPages} (Всего: ${totalAssignments})`;
         prevPageBtn.disabled = currentPage <= 1; // Выключаем "Назад" на первой странице
         nextPageBtn.disabled = currentPage >= totalPages; // Выключаем "Вперед" на последней
         // Показываем пагинацию, только если страниц больше одной
         paginationControls.style.display = totalPages > 1 ? 'block' : 'none';
    }

    // --- Управление формой и таргетингом ---

    /** Переключает видимость секций выбора таргетинга. */
    function handleTargetModeChange() {
         const selectedMode = document.querySelector('input[name="target-mode"]:checked').value;
         criteriaSection.classList.toggle('active', selectedMode === 'criteria');
         specificNodesSection.classList.toggle('active', selectedMode === 'specific');
    }

    /** Фильтрует и рендерит список узлов для выбора в режиме 'specific'. */
    function renderSpecificNodesList() {
        const searchTerm = nodeSearchInput.value.toLowerCase().trim();
        // Фильтруем ПОЛНЫЙ кэш узлов allNodesData
        const filteredNodes = allNodesData.filter(node => !searchTerm || node.name.toLowerCase().includes(searchTerm) || (node.ip_address && node.ip_address.includes(searchTerm)));
        // Обработка пустого результата
        if (filteredNodes.length === 0 && searchTerm) { nodesCheckboxList.innerHTML = '<small>Узлы не найдены.</small>'; return; }
        if (filteredNodes.length === 0 && !searchTerm) { nodesCheckboxList.innerHTML = '<small>Начните вводить имя или IP для поиска...</small>'; return; }
        // Ограничиваем вывод для производительности
        const nodesToDisplay = filteredNodes.slice(0, 100);
        nodesCheckboxList.innerHTML = nodesToDisplay.map(node => `
             <label> <input type="checkbox" value="${node.id}" ${selectedNodeIds.has(node.id) ? 'checked' : ''}> ${node.name} (${node.ip_address || 'No IP'}) </label>
         `).join('');
        if (filteredNodes.length > 100) { nodesCheckboxList.innerHTML += '<small>... показаны не все результаты, уточните поиск.</small>'; }
    }

    /** Обрабатывает изменение состояния чекбоксов узлов. */
    function handleNodeCheckboxChange(event) {
         if (event.target.type === 'checkbox') {
             const nodeId = parseInt(event.target.value, 10);
             if (event.target.checked) { selectedNodeIds.add(nodeId); } else { selectedNodeIds.delete(nodeId); }
             updateSelectedNodesInfo(); // Обновляем счетчик
         }
    }
    /** Обновляет текст с количеством выбранных узлов. */
    function updateSelectedNodesInfo() { selectedNodesInfo.textContent = `Выбрано узлов: ${selectedNodeIds.size}`; }
    /** Очищает выбор конкретных узлов. */
    function clearNodeSelection() { selectedNodeIds.clear(); nodeSearchInput.value = ''; renderSpecificNodesList(); updateSelectedNodesInfo(); }

    /**
     * Валидирует строку как JSON объект.
     * @param {string} jsonString - Строка для валидации.
     * @param {HTMLTextAreaElement} textareaElement - Элемент textarea для подсветки ошибки.
     {% raw %}
     * @returns {{data: object|null, error?: string}} - Объект с данными или ошибкой.
     {% endraw %}
     */
    function validateJsonField(jsonString, textareaElement) {
        textareaElement.classList.remove('invalid');
        // Пустую строку или пустой объект считаем как null (нет параметров/критериев)
        if (!jsonString || jsonString.trim() === '{}' || jsonString.trim() === '') return { data: null };
        try {
            const parsed = JSON.parse(jsonString);
            // Дополнительно проверяем, что это именно объект, а не массив, строка, число и т.д.
            if (typeof parsed !== 'object' || Array.isArray(parsed) || parsed === null) {
                 throw new Error("Ожидается JSON объект { ключ: значение, ... } или пустое значение.");
            }
            return { data: parsed }; // Успех
        } catch (e) { // Ошибка парсинга или типа
            textareaElement.classList.add('invalid'); // Подсвечиваем поле
            return { error: `Некорректный JSON: ${e.message}` }; // Возвращаем ошибку
        }
    }


    // --- Отправка формы (создание/редактирование/назначение) ---
    /** Обрабатывает отправку формы создания/редактирования задания. */
    async function handleFormSubmit(event) {
        event.preventDefault(); // Предотвращаем стандартную отправку
        clearValidationErrors(); showFormFeedback(''); // Очищаем ошибки
        submitBtn.disabled = true; submitBtn.textContent = 'Выполнение...'; // Блокируем кнопку

        const selectedMode = document.querySelector('input[name="target-mode"]:checked').value;
        const isEditMode = !!currentEditId; // Определяем режим (редактирование или создание)

        // Шаг 1: Валидация JSON полей
        const paramsValidation = validateJsonField(parametersTextarea.value.trim(), parametersTextarea);
        const criteriaValidation = validateJsonField(successCriteriaTextarea.value.trim(), successCriteriaTextarea);
        let jsonErrors = {};
        if (paramsValidation.error) jsonErrors['parameters'] = paramsValidation.error;
        if (criteriaValidation.error) jsonErrors['success-criteria'] = criteriaValidation.error;
        if (Object.keys(jsonErrors).length > 0) {
            displayValidationErrors(jsonErrors); submitBtn.disabled = false;
            submitBtn.textContent = isEditMode ? 'Сохранить' : 'Создать / Назначить'; return;
        }
        const parametersData = paramsValidation.data;
        const successCriteriaData = criteriaValidation.data;

        // Шаг 2: Сборка основного объекта данных задания
        const assignmentBaseData = {
             method_id: methodIdSelect.value ? parseInt(methodIdSelect.value, 10) : null,
             check_interval_seconds: intervalInput.value ? parseInt(intervalInput.value, 10) : null,
             is_enabled: isEnabledCheckbox.checked,
             description: descriptionInput.value.trim() || null,
             parameters: parametersData,
             success_criteria: successCriteriaData // Добавлено поле
        };

        // Шаг 3: Клиентская валидация остальных полей
        let clientErrors = {};
        if (!assignmentBaseData.method_id) clientErrors['method-id'] = "Метод проверки обязателен.";
        if (assignmentBaseData.check_interval_seconds !== null && (isNaN(assignmentBaseData.check_interval_seconds) || assignmentBaseData.check_interval_seconds < 0)) {
             clientErrors['check-interval'] = "Интервал должен быть неотрицательным числом.";
        }

        // Шаг 4: Определение URL, метода и тела запроса (payload)
        let url, method, payload;
        if (isEditMode) { // Редактирование
            url = API_URL_ASSIGNMENT_DETAIL_TPL.replace('/0', `/${currentEditId}`); method = 'PUT';
            payload = assignmentBaseData; // Отправляем только данные задания
        } else { // Создание/Назначение
             url = API_URL_ASSIGNMENT_BULK_CREATE; method = 'POST';
             if (selectedMode === 'criteria') { // По критериям
                 const selectedSubdivisionIds = Array.from(targetSubdivisionContainer.querySelectorAll('input:checked')).map(cb => parseInt(cb.value, 10));
                 const selectedNodeTypeIds = Array.from(targetNodeTypeContainer.querySelectorAll('input:checked')).map(cb => parseInt(cb.value, 10));
                 const nameMask = targetNameMaskInput.value.trim() || null;
                 const criteria = {};
                 if (selectedSubdivisionIds.length > 0) criteria.subdivision_ids = selectedSubdivisionIds;
                 if (selectedNodeTypeIds.length > 0) criteria.node_type_ids = selectedNodeTypeIds;
                 if (nameMask) criteria.node_name_mask = nameMask;
                 // Проверяем, выбран ли хоть один критерий
                 if (Object.keys(criteria).length === 0) { clientErrors['criteria'] = "Выберите хотя бы один критерий (подразделение, тип или маску имени)."; }
                 payload = { criteria, assignment_data: assignmentBaseData };
             } else { // По списку узлов
                 if (selectedNodeIds.size === 0) { clientErrors['specific_nodes'] = "Выберите хотя бы один узел."; }
                 payload = { node_ids: Array.from(selectedNodeIds), assignment_data: assignmentBaseData };
             }
        }

        // Если есть ошибки клиентской валидации - показываем их и выходим
        if (Object.keys(clientErrors).length > 0) {
             displayValidationErrors(clientErrors); submitBtn.disabled = false;
             submitBtn.textContent = isEditMode ? 'Сохранить' : 'Создать / Назначить'; return;
        }

        // Шаг 5: Отправка запроса к API
        try {
            const resultData = await fetchData(url, { method: method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            // Формируем сообщение об успехе
             let successMessage = '';
             if (isEditMode) { successMessage = "Задание успешно обновлено!"; }
             else if (selectedMode === 'criteria') { successMessage = `Назначение по критериям завершено. Создано новых заданий: ${resultData?.assignments_created ?? '?'}.`; }
             else { successMessage = `Задание назначено для ${selectedNodeIds.size} узлов. Создано новых: ${resultData?.assignments_created ?? '?'}.`; }
             showListFeedback(successMessage, false); // Показываем над списком
             resetFullForm(); // Сбрасываем форму
             // Обновляем список заданий (текущую или первую страницу)
             await loadAssignments(isEditMode ? currentPage : 1);
        } catch (error) { // Обработка ошибок fetchData (сеть или API >400)
             console.error("Ошибка при отправке формы:", error);
             // Показываем ошибки валидации от сервера или общую ошибку в форме
             displayValidationErrors(error.details || error.message);
             showFormFeedback(`Ошибка: ${error.message}`, true); // Доп. сообщение в форме
        } finally { // В любом случае разблокируем кнопку
             submitBtn.disabled = false;
             submitBtn.textContent = isEditMode ? 'Сохранить' : 'Создать / Назначить';
        }
    }

    // --- Редактирование/Удаление одного задания из списка ---

    /** Загружает данные задания и заполняет форму для редактирования. */
    async function handleEditClick(assignmentId) {
         resetFullForm(); showListFeedback('Загрузка данных задания...'); showFormFeedback('');
         const url = API_URL_ASSIGNMENT_DETAIL_TPL.replace('/0', `/${assignmentId}`);
         try {
             const assignment = await fetchData(url); // fetchData покажет индикатор и обработает ошибки сети/404
             if (assignment) { // Если задание найдено
                 currentEditId = assignment.id; idInput.value = assignment.id;
                 formTitle.textContent = `Редактировать Задание ID: ${assignment.id}`; submitBtn.textContent = 'Сохранить';
                 // Заполняем поля формы
                 methodIdSelect.value = assignment.method_id || ''; intervalInput.value = assignment.check_interval_seconds || '';
                 isEnabledCheckbox.checked = assignment.is_enabled !== false; descriptionInput.value = assignment.description || '';
                 // Заполняем JSON поля, форматируя для читаемости
                 parametersTextarea.value = assignment.parameters && Object.keys(assignment.parameters).length > 0 ? JSON.stringify(assignment.parameters, null, 2) : '';
                 successCriteriaTextarea.value = assignment.success_criteria && Object.keys(assignment.success_criteria).length > 0 ? JSON.stringify(assignment.success_criteria, null, 2) : '';
                 parametersTextarea.classList.remove('invalid'); successCriteriaTextarea.classList.remove('invalid');
                 // Переключаем в режим выбора конкретного узла и блокируем таргетинг
                 targetModeRadios.forEach(radio => radio.checked = (radio.value === 'specific')); handleTargetModeChange();
                 selectedNodeIds.clear(); selectedNodeIds.add(assignment.node_id); renderSpecificNodesList(); updateSelectedNodesInfo();
                 document.querySelectorAll('input[name="target-mode"]').forEach(r => r.disabled = true);
                 document.querySelectorAll('#criteria-section input, #criteria-section select, #criteria-section textarea').forEach(el => el.disabled = true);
                 document.querySelectorAll('#specific-nodes-section input, #specific-nodes-section button').forEach(el => el.disabled = true);
                 // Скролл к форме
                 window.scrollTo({ top: form.offsetTop - 20, behavior: 'smooth' });
                 showListFeedback(''); // Убираем "Загрузка..."
             }
             // Ошибка 404 (не найдено) уже обработана в fetchData и показана в listFeedback
         } catch (error) {
             // Дополнительная обработка не требуется, т.к. fetchData уже показал ошибку
             console.error("Ошибка при загрузке задания для редактирования:", error);
         }
    }

    /** Обрабатывает клик по кнопке удаления задания. */
    async function handleDeleteClick(assignmentId, nodeName, methodName) {
         if (!confirm(`Уверены, что хотите удалить задание ID ${assignmentId} (${methodName} для ${nodeName})?`)) return;
         const url = API_URL_ASSIGNMENT_DETAIL_TPL.replace('/0', `/${assignmentId}`);
         showListFeedback(`Удаление задания ${assignmentId}...`); showFormFeedback('');
         try {
             await fetchData(url, { method: 'DELETE' }); // Ожидаем 204 No Content
             showListFeedback(`Задание ID ${assignmentId} успешно удалено.`, false);
             if (currentEditId === assignmentId) { resetFullForm(); } // Сбрасываем форму, если удалили редактируемое
             // Перезагружаем ТЕКУЩУЮ страницу списка, чтобы не прыгать на первую
             await loadAssignments(currentPage);
         }
         catch (error) {
             // Ошибка уже показана в fetchData / listFeedback
             console.error("Ошибка удаления:", error);
             showListFeedback(`Ошибка удаления: ${error.message}`, true);
         }
    }


    // --- Инициализация страницы и назначение обработчиков событий ---
    // Отправка формы задания
    form.addEventListener('submit', handleFormSubmit);
    // Кнопка сброса формы
    resetBtn.addEventListener('click', resetFullForm);
    // Переключение режима таргетинга
    targetModeRadios.forEach(radio => radio.addEventListener('change', handleTargetModeChange));
    // Поиск узлов
    nodeSearchInput.addEventListener('input', renderSpecificNodesList);
    // Выбор узлов чекбоксами
    nodesCheckboxList.addEventListener('change', handleNodeCheckboxChange);
    // Кнопка очистки выбора узлов
    clearNodeSelectionBtn.addEventListener('click', clearNodeSelection);
    // Валидация JSON при потере фокуса
    parametersTextarea.addEventListener('blur', () => validateJsonField(parametersTextarea.value.trim(), parametersTextarea));
    successCriteriaTextarea.addEventListener('blur', () => validateJsonField(successCriteriaTextarea.value.trim(), successCriteriaTextarea));
    // Делегирование событий для кнопок Редактировать/Удалить в таблице
    assignmentList.addEventListener('click', (event) => {
        const editBtn = event.target.closest('.edit-btn'); const deleteBtn = event.target.closest('.delete-btn');
        if (editBtn) { handleEditClick(parseInt(editBtn.dataset.id, 10)); }
        else if (deleteBtn) { handleDeleteClick(parseInt(deleteBtn.dataset.id, 10), deleteBtn.dataset.nodeName, deleteBtn.dataset.methodName); }
    });
    // Обработчики изменения фильтров (перезагрузка с 1 страницы)
    filterNodeSelect.addEventListener('change', () => loadAssignments(1));
    filterMethodSelect.addEventListener('change', () => loadAssignments(1));
    filterSubdivisionSelect.addEventListener('change', () => loadAssignments(1));
    filterTypeSelect.addEventListener('change', () => loadAssignments(1));
    filterTextInput.addEventListener('input', () => loadAssignments(1)); // Поиск при вводе
    filterSubdivisionIncludeChildren.addEventListener('change', () => loadAssignments(1));
    filterTypeIncludeNested.addEventListener('change', () => loadAssignments(1));
    // Обработчики кнопок пагинации
    prevPageBtn.addEventListener('click', () => { if (currentPage > 1) loadAssignments(currentPage - 1); });
    nextPageBtn.addEventListener('click', () => { if (currentPage * itemsPerPage < totalAssignments) loadAssignments(currentPage + 1); });

    // Загрузка начальных данных при загрузке DOM
    document.addEventListener('DOMContentLoaded', loadInitialData);

</script>
{% endblock %}
