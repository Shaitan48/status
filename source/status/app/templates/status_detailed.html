<!-- status/app/templates/status_detailed.html -->
{% extends "base.html" %} <!-- Наследование от базового шаблона -->
{% block title %}Детальный статус - Мониторинг ПТК{% endblock %} <!-- Заголовок страницы -->

{% block head_extra %}
<!-- Стили для модального окна и других элементов этой страницы определены в style.css -->
<style>
    /* Стили для модального окна */
    .modal { /* Скрытый по умолчанию контейнер на весь экран */
        display: none; position: fixed; z-index: 1001; /* Выше основного контента, но ниже "липкого" навбара, если z-index навбара > 1001 */
        left: 0; top: 0; width: 100%; height: 100%;
        overflow: auto; /* Прокрутка, если контент не помещается */
        background-color: rgba(0,0,0,0.6); /* Полупрозрачный черный фон */
    }
    .modal-content { /* Сам блок модального окна */
        background-color: #fefefe; /* Белый фон */
        margin: 8% auto; /* Центрирование с отступом сверху */
        padding: 20px;
        border: 1px solid #888; /* Рамка */
        width: 90%; /* Ширина относительно родителя */
        max-width: 1000px; /* Максимальная ширина */
        border-radius: 5px; /* Скругление углов */
        position: relative; /* Для позиционирования кнопки закрытия */
        box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Тень */
    }
    .modal-close { /* Кнопка "крестик" для закрытия */
        color: #aaa; float: right; font-size: 28px; font-weight: bold;
        position: absolute; top: 5px; right: 15px; cursor: pointer;
    }
    .modal-close:hover, .modal-close:focus { color: black; text-decoration: none; }
    .modal h3 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; } /* Заголовок модального окна */

    /* Таблица заданий внутри модального окна */
    .assignments-table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; table-layout: fixed; }
    .assignments-table th, .assignments-table td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; word-wrap: break-word; }
    .assignments-table th { background-color: #f2f2f2; font-weight: 600; }
    .assignments-table .params { /* Ячейка с параметрами */
        max-width: 250px; /* Ограничение ширины */
        overflow: hidden; text-overflow: ellipsis; white-space: nowrap; /* Показ многоточия, если не влезает */
        cursor: help; /* Подсказка, что можно навести для полного текста (в title) */
    }
    /* Стили для статуса задания */
    .assignments-table .status-ok { color: var(--success-color); }
    .assignments-table .status-error { color: var(--danger-color); }
    .assignments-table .status-unknown { color: var(--secondary-color); }
    .assignments-table .actions-cell button { margin-right: 5px; margin-bottom: 3px; } /* Ячейка с кнопками "Детали", "История" */
    .details-btn, .history-btn { padding: 3px 8px; font-size: 0.85em; cursor: pointer; border-radius: 3px; color: white; border: none; }
    .details-btn { background-color: var(--secondary-color); }
    .details-btn:hover { background-color: #545b62; }
    .history-btn { background-color: var(--info-color); }
    .history-btn:hover { background-color: #117a8b; }

    /* Блок для отображения JSON-деталей проверки */
    .details-json {
        background-color: #f8f9fa; border: 1px solid #e0e0e0; padding: 10px; margin-top: 10px;
        white-space: pre-wrap; /* Сохранение форматирования и переносов */
        font-family: Consolas, Monaco, monospace; /* Моноширинный шрифт */
        max-height: 250px; /* Ограничение высоты с прокруткой */
        overflow-y: auto; font-size: 0.9em; border-radius: 4px;
    }
    /* Блок для отображения истории проверок задания */
    #modal-history { margin-top: 15px; display: none; /* Изначально скрыт */ }
    #modal-history h4 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 5px; font-size: 1em; }
    .history-list { list-style: none; padding: 0; max-height: 280px; overflow-y: auto; border: 1px solid #ddd; border-radius: 3px; background-color: #fff; }
    .history-list li {
        padding: 6px 10px; border-bottom: 1px solid #eee; font-size: 0.9em;
        display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;
    }
    .history-list li:last-child { border-bottom: none; }
    .history-list .hist-time { color: #444; white-space: nowrap; margin-right: 10px; font-size: 0.95em; }
    .history-list .hist-status { font-weight: bold; margin-right: 10px; }
    .history-list .hist-status.ok { color: var(--success-color); }
    .history-list .hist-status.error { color: var(--danger-color); }
    .history-list .hist-executor { color: #666; font-size: 0.85em; margin-right: 10px; font-style: italic;}
    .history-list .hist-details-link { margin-left: auto; /* Прижимаем ссылку "Детали" вправо */ }

    /* Общие сообщения загрузки/ошибки */
    .loading-message { /* ... (как в base.html или style.css) ... */ }
    .error-message { /* ... (как в base.html или style.css) ... */ }

    /* Стили для основной таблицы детального статуса (копируем из style.css для полноты) */
    .node-table { /* ... (как в style.css) ... */ }
    /* ... (и остальные стили для .node-table th, .subdivision-row, .type-header, .node-table-icon, .status-cell, .assignments-btn) ... */
    /* Они должны быть в основном style.css, здесь дублировать не обязательно, если base.html его подключает */
    .table-controls { margin-bottom: 1rem; }
</style>
{% endblock %}

{% block content %}
<h2>Детальный статус узлов</h2>
<div class="table-controls">
    <button id="toggle-all-btn">Развернуть все</button>
    <!-- Сюда можно добавить фильтры для таблицы или поле поиска, если потребуется -->
</div>

<table class="node-table">
    <thead>
        <tr>
            <!-- Заголовки колонок с data-атрибутами для JavaScript-сортировки -->
            <th data-column="name" title="Сортировать по имени подразделения/узла">Подразделение / Узел</th>
            <th data-column="ip_address" title="Сортировать по IP-адресу">IP-адрес</th>
            <th data-column="status" title="Сортировать по статусу PING">Статус (PING)</th>
            <th data-column="last_checked" title="Сортировать по времени последней проверки">Посл. проверка (PING)</th>
            <th data-column="last_available" title="Сортировать по времени последней доступности">Доступен (PING)</th>
            <th data-column="executor" title="Сортировать по исполнителю">Исполнитель (PING)</th>
            <th data-column="type" title="Сортировать по типу узла">Тип узла</th>
            <th>Действия</th> <!-- Колонка для кнопок (например, "Задания") -->
        </tr>
    </thead>
    <tbody id="status-table-body">
        <!-- Начальное сообщение, пока данные загружаются -->
        <tr><td colspan="8" class="loading-message">Загрузка данных детального статуса...</td></tr>
    </tbody>
</table>

<!-- Модальное окно для отображения заданий узла -->
<div id="assignments-modal" class="modal">
  <div class="modal-content">
    <span class="modal-close" onclick="closeModal()" title="Закрыть окно">&times;</span>
    <h3 id="modal-title">Задания для узла: <span>[Имя узла]</span></h3>
    <div id="modal-body">
        <!-- Сюда JavaScript загрузит таблицу с заданиями -->
        <p class="loading-message">Загрузка назначенных заданий...</p>
    </div>
     <!-- Блок для отображения деталей конкретной проверки (JSON) -->
     <div id="modal-details" style="display: none;"> <!-- Изначально скрыт -->
        <h4>Детали выбранной проверки:</h4>
        <pre class="details-json"></pre> <!-- Используем <pre> для форматированного JSON -->
    </div>
     <!-- Блок для отображения истории проверок выбранного задания -->
     <div id="modal-history" style="display: none;"> <!-- Изначально скрыт -->
        <h4>История проверок для задания ID <span id="history-assignment-id-span">[ID]</span>:</h4>
        <ul class="history-list"><li class="loading-message">Загрузка истории...</li></ul>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // --- Получение ссылок на DOM-элементы ---
    let statusTableBodyElement = null; // Тело основной таблицы статусов
    let toggleAllButtonElement = null; // Кнопка "Развернуть/Свернуть все"
    // Элементы модального окна
    let assignmentsModalElement = null;
    let modalTitleElement = null;
    let modalBodyElement = null;
    let modalDetailsContainerElement = null;
    let modalDetailsJsonPreElement = null; // <pre> для JSON
    let modalHistoryContainerElement = null;
    let modalHistoryListElement = null;
    let historyAssignmentIdDisplaySpan = null; // Для отображения ID задания в заголовке истории

    // --- Переменные состояния ---
    let hierarchialExpandedState = {}; // Состояние раскрытия групп (ключ - ID подразделения, значение - true/false)
    let detailedNodeDataCache = null; // Кэш данных, полученных от API /status_detailed
    let currentSortState = { columnKey: 'name', direction: 'asc' }; // Состояние текущей сортировки таблицы

    // --- URL API-эндпоинтов (генерируются Flask) ---
    const ICONS_STATIC_BASE_URL = "{{ url_for('static', filename='icons/') }}";
    const DEFAULT_NODE_ICON_FILENAME = 'other.svg'; // Имя файла иконки по умолчанию
    const API_URL_DETAILED_STATUS = "{{ url_for('data.api_detailed_status') }}";
    const API_URL_NODE_ASSIGNMENTS_TEMPLATE = "{{ url_for('nodes.api_node_assignments_status_route', node_id=0) }}"; // Шаблон URL для заданий узла
    const API_URL_CHECK_DETAILS_TEMPLATE = "{{ url_for('checks.api_get_node_check_details', check_id=0) }}"; // Шаблон URL для деталей проверки
    const API_URL_ASSIGNMENT_HISTORY_TEMPLATE = "{{ url_for('checks.api_get_assignment_checks_history', assignment_id=0) }}"; // Шаблон URL для истории задания

    // --- Функции для работы с API (fetchData - общая) ---
    /**
     * Асинхронно выполняет GET-запрос к указанному URL и возвращает JSON-ответ.
     * Обрабатывает ошибки сети и некорректные ответы сервера.
     * @param {string} url - URL для запроса.
     * @returns {Promise<object|null>} Promise с распарсенным JSON или null при ошибке 204.
     * @throws {Error} В случае ошибки сети или если ответ сервера не OK.
     */
    async function fetchData(url) { /* ... (Точная копия из dashboard.html или base.html) ... */ }

    /** Загружает данные для детального статуса и вызывает рендеринг таблицы. */
    async function fetchAndRenderDetailedStatus() {
        if (!statusTableBodyElement) {
            console.error("fetchAndRenderDetailedStatus: Элемент status-table-body не найден!");
            return;
        }
        console.debug("Detailed Status: Запрос данных для детальной таблицы...");
        statusTableBodyElement.innerHTML = `<tr><td colspan="8" class="loading-message">Загрузка данных детального статуса...</td></tr>`;
        try {
            detailedNodeDataCache = await fetchData(API_URL_DETAILED_STATUS); // Ожидаем {nodes: [], subdivisions: []}
            console.debug("Detailed Status: Детальные данные успешно получены:", detailedNodeDataCache);
            renderDetailedStatusTable(); // Вызываем рендеринг
        } catch (error) {
            console.error("Detailed Status: Ошибка загрузки данных для детального статуса:", error);
            if (statusTableBodyElement) {
                statusTableBodyElement.innerHTML = `<tr><td colspan="8" class="error-message">Ошибка загрузки данных: ${error.message}</td></tr>`;
            }
        }
    }

    /** Загружает назначенные задания для указанного узла. */
    async function fetchNodeAssignments(nodeId) {
        if (typeof nodeId !== 'number' || nodeId <=0) {
            console.error("fetchNodeAssignments: Передан некорректный nodeId:", nodeId);
            return null;
        }
        const url = API_URL_NODE_ASSIGNMENTS_TEMPLATE.replace('/0/', `/${nodeId}/`); // Подставляем ID узла в шаблон URL
        return await fetchData(url);
    }

    /** Загружает детали для конкретного результата проверки. */
    async function fetchSingleCheckDetails(checkId) {
        if (typeof checkId !== 'number' || checkId <=0) { // ID проверки должен быть числом > 0
            console.warn("fetchSingleCheckDetails: Передан некорректный checkId:", checkId);
            return null;
        }
        const url = API_URL_CHECK_DETAILS_TEMPLATE.replace('/0/', `/${checkId}/`);
        try {
            return await fetchData(url);
        } catch (error) {
             console.error(`Ошибка загрузки деталей для проверки ID ${checkId}:`, error);
             return null; // Возвращаем null при ошибке, чтобы UI мог это обработать
        }
    }

    /** Загружает историю проверок для конкретного задания. */
    async function fetchSingleAssignmentHistory(assignmentId, historyLimit = 15) {
        if (typeof assignmentId !== 'number' || assignmentId <=0) {
            console.error("fetchSingleAssignmentHistory: Передан некорректный assignmentId:", assignmentId);
            return null;
        }
        const url = API_URL_ASSIGNMENT_HISTORY_TEMPLATE.replace('/0/', `/${assignmentId}/`) + `?limit=${historyLimit}`;
        console.debug("Запрос истории для задания:", url);
        try {
             return await fetchData(url);
        } catch (error) {
             console.error(`Ошибка загрузки истории для задания ID ${assignmentId}:`, error);
             return null;
        }
    }

    // --- Функции Рендеринга Таблицы и Модальных Окон ---
    /** Основная функция рендеринга таблицы детального статуса. */
    function renderDetailedStatusTable() {
        if (!statusTableBodyElement || !detailedNodeDataCache || !detailedNodeDataCache.nodes || !detailedNodeDataCache.subdivisions) {
             console.error("renderDetailedStatusTable: Отсутствуют необходимые данные (detailedNodeDataCache) или элемент таблицы (statusTableBodyElement).");
             if(statusTableBodyElement) statusTableBodyElement.innerHTML = `<tr><td colspan="8" class="error-message">Ошибка рендеринга: нет данных для отображения.</td></tr>`;
             return;
        }
        console.debug("renderDetailedStatusTable: Начало рендеринга таблицы.");
        const { nodes, subdivisions } = detailedNodeDataCache;

        // 1. Строим иерархическую структуру подразделений для корректного отображения дерева
        const subdivisionTree = {}; // Карта для быстрого доступа и построения дерева
        const rootSubdivisionIdsInOrder = []; // Массив ID корневых подразделений в порядке сортировки
        subdivisions.forEach(s => { // Инициализируем карту
            subdivisionTree[s.id] = { ...s, children: [], nodesByType: {}, totalNodesInSubtree: 0, onlineNodesInSubtree: 0 };
        });
        subdivisions.forEach(s => { // Строим связи родитель-потомок
            if (s.parent_id === null) {
                if(!rootSubdivisionIdsInOrder.includes(s.id)) rootSubdivisionIdsInOrder.push(s.id);
            } else if (subdivisionTree[s.parent_id]) {
                subdivisionTree[s.parent_id].children.push(s.id);
            } else { // Случай "осиротевшего" подразделения - добавляем как корневой
                console.warn(`Родительское подразделение ID ${s.parent_id} для подразделения '${s.short_name}' (ID: ${s.id}) не найдено. Отображаем как корневое.`);
                if(!rootSubdivisionIdsInOrder.includes(s.id)) rootSubdivisionIdsInOrder.push(s.id);
            }
        });

        // 2. Распределяем узлы по типам внутри их родительских подразделений
        nodes.forEach(node => {
            const parentSubdivisionId = node.subdivision_id;
            if (parentSubdivisionId && subdivisionTree[parentSubdivisionId]) {
                const parentSub = subdivisionTree[parentSubdivisionId];
                // Используем ID типа узла (0 для "Без типа") как ключ для группировки
                const nodeTypeIdForGroup = node.node_type_id === null || node.node_type_id === undefined ? 0 : node.node_type_id;
                if (!parentSub.nodesByType[nodeTypeIdForGroup]) {
                    parentSub.nodesByType[nodeTypeIdForGroup] = {
                        type_path: node.node_type_path || 'Узлы без типа', // Иерархический путь типа
                        type_priority: node.node_type_priority === null || node.node_type_priority === undefined ? 9999 : node.node_type_priority,
                        nodes: []
                    };
                }
                parentSub.nodesByType[nodeTypeIdForGroup].nodes.push(node);
            } else {
                console.warn(`Узел '${node.name}' (ID: ${node.id}) имеет некорректный subdivision_id: ${parentSubdivisionId} или такое подразделение отсутствует в карте.`);
            }
        });

        // 3. Рекурсивный подсчет общей и онлайн статистики для каждого подразделения (включая дочерние)
        function calculateRecursiveNodeStats(subdivisionId) {
            const sub = subdivisionTree[subdivisionId];
            if (!sub) return { total: 0, online: 0 }; // Базовый случай рекурсии

            // Считаем узлы непосредственно в этом подразделении
            let currentSubTotalNodes = Object.values(sub.nodesByType).reduce((sum, typeGroup) => sum + typeGroup.nodes.length, 0);
            let currentSubOnlineNodes = Object.values(sub.nodesByType).reduce((sum, typeGroup) =>
                sum + typeGroup.nodes.filter(n => n && n.status_class === 'available').length, 0);

            // Рекурсивно считаем для дочерних и прибавляем к текущим
            sub.children.forEach(childId => {
                const childStats = calculateRecursiveNodeStats(childId);
                currentSubTotalNodes += childStats.total;
                currentSubOnlineNodes += childStats.online;
            });
            sub.totalNodesInSubtree = currentSubTotalNodes;
            sub.onlineNodesInSubtree = currentSubOnlineNodes;
            return { total: currentSubTotalNodes, online: currentSubOnlineNodes };
        }
        // Запускаем подсчет статистики, начиная с корневых подразделений
        rootSubdivisionIdsInOrder.forEach(rootId => calculateRecursiveNodeStats(rootId));

        // 4. Сортировка узлов внутри каждой группы типов узлов (по display_order, затем по имени)
         Object.values(subdivisionTree).forEach(sub => {
             Object.values(sub.nodesByType).forEach(typeGroup => {
                 typeGroup.nodes.sort(nodeDisplaySorter); // Используем nodeDisplaySorter
             });
         });

        // 5. Генерация HTML-строк для таблицы
        let tableHtmlContent = '';
        // Рекурсивная функция для рендеринга подразделения и его содержимого
        function renderSubdivisionToHtml(subdivisionId, currentLevel = 0) {
            const subData = subdivisionTree[subdivisionId];
            if (!subData) return ''; // Если подразделение не найдено (не должно происходить)

            const subdivisionIdStr = String(subdivisionId); // ID для data-атрибутов
            const isCurrentlyExpanded = !!hierarchialExpandedState[subdivisionIdStr]; // Раскрыто ли это подразделение
            const childElementsDisplayStyle = isCurrentlyExpanded ? 'table-row' : 'none'; // Стиль для дочерних элементов

            let typeHeadersHtml = ''; // HTML для заголовков типов узлов и самих узлов
            // Сортируем группы типов узлов по их приоритету
            const sortedNodeTypeGroups = Object.values(subData.nodesByType).sort((a, b) => a.type_priority - b.type_priority);

            sortedNodeTypeGroups.forEach(typeGroupData => {
                // Рендерим узлы этого типа
                let nodeRowsForTypeHtml = typeGroupData.nodes
                                          .map(node => renderSingleNodeRowHtml(node, currentLevel + 2, subdivisionIdStr, childElementsDisplayStyle))
                                          .join('');
                if (nodeRowsForTypeHtml) { // Если есть узлы этого типа, добавляем заголовок типа
                     typeHeadersHtml += `
                        <tr class="type-header subdivision-${subdivisionIdStr}" data-level="${currentLevel + 1}" style="display: ${childElementsDisplayStyle};">
                            <td colspan="8">${typeGroupData.type_path}</td>
                        </tr>
                        ${nodeRowsForTypeHtml}
                    `;
                 }
             });

            // Рендерим дочерние подразделения рекурсивно
            let childrenSubdivisionsHtml = subData.children
                .map(id => subdivisionTree[id]).filter(s => s) // Получаем объекты и отсеиваем null
                .sort(subdivisionDisplaySorter) // Сортируем дочерние подразделения
                .map(childSub => renderSubdivisionToHtml(childSub.id, currentLevel + 1)).join('');

             // HTML для строки самого подразделения
             const subdivisionRowHtml = `
                <tr class="subdivision-row ${isCurrentlyExpanded ? 'expanded' : ''}" data-subdivision-id="${subdivisionIdStr}" data-level="${currentLevel}">
                    <td colspan="8" title="ID подразделения: ${subData.id}, ObjectID: ${subData.object_id || 'N/A'}">
                        ${subData.short_name} (${subData.onlineNodesInSubtree}/${subData.totalNodesInSubtree} онлайн)
                    </td>
                </tr>`;
            return subdivisionRowHtml + typeHeadersHtml + childrenSubdivisionsHtml;
        }

        // Функция рендеринга HTML для одной строки узла
        function renderSingleNodeRowHtml(nodeData, nodeLevel, parentSubdivisionIdStr, initialDisplayStyle) {
             if (!nodeData || !nodeData.name || !nodeData.status_class) {
                 console.warn("renderSingleNodeRowHtml: Пропущен узел с неполными данными:", nodeData);
                 return '';
             }
             const executorDisplay = nodeData.executor_host ? `${nodeData.executor_object_id || '?'}:${nodeData.executor_host}` : 'N/A';
             const lastCheckedTime = formatDateTime(nodeData.last_checked);
             const lastAvailableTime = formatDateTime(nodeData.last_available);
             const nodeIconFilename = nodeData.icon_filename || DEFAULT_NODE_ICON_FILENAME;
             const nodeIconFullUrl = `${ICONS_STATIC_BASE_URL}${encodeURIComponent(nodeIconFilename)}`;
             const nodeIconStyle = `-webkit-mask-image: url("${nodeIconFullUrl}"); mask-image: url("${nodeIconFullUrl}");`;
             // Кнопка "Задания"
             const assignmentsButtonHtml = `<button class="assignments-btn" data-node-id="${nodeData.id}" data-node-name="${encodeURIComponent(nodeData.name)}" title="Показать задания для узла ${nodeData.name}">Задания</button>`;

             return `
                <tr class="node-row subdivision-${parentSubdivisionIdStr}" data-node-id="${nodeData.id}" data-level="${nodeLevel}" style="display: ${initialDisplayStyle};">
                    <td class="node-name-cell" title="Тип: ${nodeData.node_type_path || 'Не указан'}">
                        <span class="node-table-icon ${nodeData.status_class}" style="${nodeIconStyle}"></span>
                        ${nodeData.name}
                    </td>
                    <td>${nodeData.ip_address || 'N/A'}</td>
                    <td class="status-cell ${nodeData.status_class}">${nodeData.status_text || 'N/A'}</td>
                    <td title="Время проверки на агенте: ${formatDateTime(nodeData.check_timestamp)}">${lastCheckedTime}</td>
                    <td>${lastAvailableTime}</td>
                    <td>${executorDisplay}</td>
                    <td>${nodeData.node_type_name || 'N/A'}</td>
                    <td class="actions-cell">${assignmentsButtonHtml}</td>
                </tr>`;
        }

        // Сортируем корневые подразделения и запускаем рендеринг
        const sortedRootIds = rootSubdivisionIdsInOrder
             .map(id => subdivisionTree[id]).filter(s => s) // Получаем объекты и отсеиваем null
             .sort(subdivisionDisplaySorter)
             .map(s => s.id);

        if (sortedRootIds.length === 0 && nodes.length === 0) { // Если нет ни подразделений, ни узлов
            tableHtmlContent = '<tr><td colspan="8" style="text-align:center; padding:1em;">Нет данных для отображения (нет подразделений и узлов).</td></tr>';
        } else {
            sortedRootIds.forEach(rootId => { tableHtmlContent += renderSubdivisionToHtml(rootId, 0); });
        }

        console.debug("renderDetailedStatusTable: HTML для таблицы сгенерирован.");
        statusTableBodyElement.innerHTML = tableHtmlContent; // Вставляем готовый HTML в таблицу
        updateToggleAllButtonText(); // Обновляем текст кнопки "Развернуть/Свернуть все"
        updateTableSortIndicators(); // Обновляем индикаторы сортировки на заголовках таблицы
        console.debug("renderDetailedStatusTable: HTML таблицы вставлен в DOM.");
    }

    // --- Функции для сортировки данных (используются в renderDetailedStatusTable) ---
    /** Сортировщик для узлов (сначала по display_order, затем по имени). */
    function nodeDisplaySorter(nodeA, nodeB) {
        const sortCol = currentSortState.columnKey;
        const sortDir = currentSortState.direction === 'asc' ? 1 : -1;
        let valA = getNodeSortValue(nodeA, sortCol);
        let valB = getNodeSortValue(nodeB, sortCol);

        if (sortCol === 'name') { // Особая сортировка для имени узла
             const orderA = nodeA.display_order === null || nodeA.display_order === undefined ? Infinity : nodeA.display_order;
             const orderB = b.display_order === null || b.display_order === undefined ? Infinity : b.display_order;
             if (orderA !== orderB) return (orderA - orderB) * sortDir;
             // Если display_order одинаковый, сравниваем по имени (valA и valB уже содержат имена)
        }
        // Общее сравнение
        if (valA < valB) return -1 * sortDir;
        if (valA > valB) return 1 * sortDir;
        return 0;
    }
    /** Сортировщик для подразделений (сначала по priority, затем по short_name). */
    function subdivisionDisplaySorter(subA, subB) {
         const priorityA = subA.priority === null || subA.priority === undefined ? Infinity : subA.priority;
         const priorityB = subB.priority === null || subB.priority === undefined ? Infinity : subB.priority;
         if (priorityA !== priorityB) return priorityA - priorityB; // Приоритет всегда по возрастанию
         return (subA.short_name || '').localeCompare(subB.short_name || ''); // Имя по алфавиту
    }
    /** Возвращает значение поля объекта для сортировки, приводя типы. */
    function getNodeSortValue(nodeObject, fieldKey) {
        const value = nodeObject ? nodeObject[fieldKey] : undefined;
        if (value === null || value === undefined) {
            // Для числовых полей (например, display_order) - бесконечность, чтобы они были в конце при сортировке asc
            // Для статуса - низший приоритет (0), для строк - пустая строка
            return fieldKey === 'status' ? -1 : (fieldKey === 'display_order' ? Infinity : '');
        }
        if (fieldKey === 'status') { // Сортировка по числовому представлению статуса PING
            if (nodeObject.status_class === 'available') return 3;
            if (nodeObject.status_class === 'warning') return 2;
            if (nodeObject.status_class === 'unavailable') return 1;
            return 0; // unknown
        }
         if (fieldKey === 'last_checked' || fieldKey === 'last_available' || fieldKey === 'check_timestamp') { // Даты
             try { return new Date(value).getTime() || 0; } // Преобразуем в миллисекунды для сравнения
             catch { return 0; }
         }
        if (typeof value === 'string') { return value.toLowerCase(); } // Строки сравниваем без учета регистра
        return value; // Числа и булевы значения возвращаем как есть
    }
    /** Обрабатывает клик на заголовок колонки для сортировки. */
    function handleTableSort(clickedColumnKey) {
        if (currentSortState.columnKey === clickedColumnKey) { // Если кликнули по той же колонке
            currentSortState.direction = currentSortState.direction === 'asc' ? 'desc' : 'asc'; // Меняем направление
        } else { // Если кликнули по новой колонке
            currentSortState.columnKey = clickedColumnKey;
            currentSortState.direction = 'asc'; // По умолчанию сортируем по возрастанию
        }
        renderDetailedStatusTable(); // Перерисовываем таблицу с новой сортировкой
    }
    /** Обновляет CSS-классы на заголовках таблицы для отображения текущего направления сортировки. */
    function updateTableSortIndicators() {
         document.querySelectorAll('.node-table th[data-column]').forEach(thElement => {
             thElement.classList.remove('sort-asc', 'sort-desc'); // Сбрасываем классы
             if (thElement.dataset.column === currentSortState.columnKey) {
                 thElement.classList.add(currentSortState.direction === 'asc' ? 'sort-asc' : 'sort-desc');
             }
         });
    }

    // --- Функции Управления UI (раскрытие групп, модальные окна) ---
    /** Переключает состояние раскрытия/сворачивания для указанного подразделения. */
    function toggleSubdivisionDisplay(subdivisionId) {
        if (!statusTableBodyElement || subdivisionId === undefined || subdivisionId === null) return;
        const subdivisionIdString = String(subdivisionId);
        const isNowExpanded = !(hierarchialExpandedState[subdivisionIdString] === true); // Инвертируем текущее состояние
        hierarchialExpandedState[subdivisionIdString] = isNowExpanded; // Сохраняем новое состояние

        // Находим все дочерние строки (узлы И заголовки типов) для этого подразделения
        const childRowElements = statusTableBodyElement.querySelectorAll(
            `.subdivision-${subdivisionIdString}, .type-header.subdivision-${subdivisionIdString}`
        );
        const subdivisionRowElement = statusTableBodyElement.querySelector(
            `tr.subdivision-row[data-subdivision-id="${subdivisionIdString}"]`
        );

        console.debug(`toggleSubdivisionDisplay для ID ${subdivisionIdString}: новое состояние expanded = ${isNowExpanded}`);
        // Устанавливаем стиль display для всех дочерних строк
        childRowElements.forEach(rowEl => { rowEl.style.display = isNowExpanded ? 'table-row' : 'none'; });
        // Обновляем класс 'expanded' для строки самого подразделения (для иконки +/-)
        if (subdivisionRowElement) { subdivisionRowElement.classList.toggle('expanded', isNowExpanded); }

        updateToggleAllButtonText(); // Обновляем текст кнопки "Развернуть/Свернуть все"
    }

    /** Раскрывает или сворачивает все подразделения в таблице. */
    function toggleAllSubdivisions() {
         if (!statusTableBodyElement || !toggleAllButtonElement) return;
        const shouldBeExpandedNow = !isAllCurrentlyExpanded(); // Определяем, какое состояние установить для всех
        const allSubdivisionRowElements = statusTableBodyElement.querySelectorAll('tr.subdivision-row');
        hierarchialExpandedState = {}; // Сбрасываем сохраненные состояния для всех

        allSubdivisionRowElements.forEach(subRowElement => {
            const subId = subRowElement.dataset.subdivisionId;
            if (subId) {
                hierarchialExpandedState[subId] = shouldBeExpandedNow; // Устанавливаем новое состояние
                subRowElement.classList.toggle('expanded', shouldBeExpandedNow);
                // Находим ВСЕ дочерние элементы (узлы и заголовки типов) для этого подразделения
                const childElementsOfSub = statusTableBodyElement.querySelectorAll(
                    `.subdivision-${subId}, .type-header.subdivision-${subId}`
                );
                childElementsOfSub.forEach(childEl => { childEl.style.display = shouldBeExpandedNow ? 'table-row' : 'none'; });
            }
        });
        updateToggleAllButtonText(); // Обновляем текст кнопки
    }

    /** Проверяет, все ли подразделения на странице в данный момент раскрыты. */
    function isAllCurrentlyExpanded() {
        if (!statusTableBodyElement) return false;
        // Получаем все ID подразделений, которые есть в таблице
        const allSubdivisionIdsInTable = Array.from(statusTableBodyElement.querySelectorAll('tr.subdivision-row'))
                                         .map(rowEl => rowEl.dataset.subdivisionId)
                                         .filter(id => id); // Убираем возможные undefined/null
        if (allSubdivisionIdsInTable.length === 0) return false; // Если нет подразделений, то нечего раскрывать
        // Проверяем, что для каждого ID состояние в expandedState равно true
        return allSubdivisionIdsInTable.every(id => hierarchialExpandedState[id] === true);
    }
    /** Обновляет текст на кнопке "Развернуть/Свернуть все". */
    function updateToggleAllButtonText() {
        if (toggleAllButtonElement) {
            toggleAllButtonElement.textContent = isAllCurrentlyExpanded() ? 'Свернуть все' : 'Развернуть все';
        }
    }

    /** Открывает модальное окно. */
    function openAssignmentsModal() {
         if (assignmentsModalElement) {
             assignmentsModalElement.style.display = "block";
             // При открытии основного модального, скрываем секции деталей и истории по умолчанию
             if (modalDetailsContainerElement) modalDetailsContainerElement.style.display = "none";
             if (modalHistoryContainerElement) modalHistoryContainerElement.style.display = "none";
         }
    }
    /** Закрывает модальное окно и очищает его содержимое. */
    function closeModal() {
         if (assignmentsModalElement) assignmentsModalElement.style.display = "none";
         // Очищаем содержимое при закрытии
         if (modalDetailsContainerElement) modalDetailsContainerElement.style.display = "none";
         if (modalDetailsJsonPreElement) modalDetailsJsonPreElement.textContent = '';
         if (modalHistoryContainerElement) modalHistoryContainerElement.style.display = "none";
         if (modalHistoryListElement) modalHistoryListElement.innerHTML = '';
         if (historyAssignmentIdDisplaySpan) historyAssignmentIdDisplaySpan.textContent = '';
    }

    /** Загружает и отображает назначенные задания для узла в модальном окне. */
    async function showNodeAssignmentsInModal(nodeId, nodeName) {
         if (!modalTitleElement || !modalBodyElement) {
             console.error("showNodeAssignmentsInModal: Элементы модального окна не найдены.");
             return;
         }
        modalTitleElement.textContent = `Задания для узла: ${decodeURIComponent(nodeName)} (ID: ${nodeId})`;
        modalBodyElement.innerHTML = '<p class="loading-message">Загрузка назначенных заданий...</p>';
        // Скрываем секции деталей и истории перед загрузкой новых заданий
        if (modalDetailsContainerElement) modalDetailsContainerElement.style.display = "none";
        if (modalHistoryContainerElement) modalHistoryContainerElement.style.display = "none";
        openAssignmentsModal(); // Открываем модальное окно

        try {
            const nodeAssignments = await fetchNodeAssignments(nodeId); // Загружаем задания
            renderNodeAssignmentsInModal(nodeAssignments); // Рендерим их
        } catch (error) {
            console.error(`Ошибка загрузки заданий для узла ID ${nodeId}:`, error);
            modalBodyElement.innerHTML = `<p class="error-message">Ошибка загрузки заданий: ${error.message}</p>`;
        }
    }

    /** Рендерит таблицу с заданиями внутри модального окна. */
    function renderNodeAssignmentsInModal(assignmentsData) {
         if (!modalBodyElement) return;
         if (!Array.isArray(assignmentsData) || assignmentsData.length === 0) {
             modalBodyElement.innerHTML = '<p>Для этого узла нет назначенных заданий.</p>';
             return;
         }
        // Формируем HTML для таблицы заданий
        let assignmentsTableHtml = `
            <table class="assignments-table">
                <thead>
                    <tr>
                        <th>ID Задания</th>
                        <th>Метод</th>
                        <th>Параметры (pipeline)</th>
                        <th>Вкл.</th>
                        <th>Интервал</th>
                        <th>Посл. вып.</th>
                        <th>Статус посл.</th>
                        <th style="min-width: 110px;">Действия</th>
                    </tr>
                </thead>
                <tbody>`;
         assignmentsData.forEach(assign => {
             if (assign.assignment_id === undefined || assign.assignment_id === null) {
                 console.warn("renderNodeAssignmentsInModal: Пропущено задание без assignment_id:", assign);
                 return; // Пропускаем это задание
             }
             // Отображаем pipeline как JSON, если он есть, иначе "Нет"
             const pipelineDisplay = assign.pipeline && Object.keys(assign.pipeline).length > 0
                                  ? JSON.stringify(assign.pipeline)
                                  : 'Нет';
             const pipelineTitle = assign.pipeline && Object.keys(assign.pipeline).length > 0
                                 ? JSON.stringify(assign.pipeline, null, 2) // Форматированный для title
                                 : 'Конвейер не задан';

             const lastExecutedTime = formatDateTime(assign.last_executed_at);
             let checkStatusClass = 'status-unknown';
             let checkStatusText = 'Нет данных';
             if (assign.last_check_id !== null && assign.last_check_is_available !== null) {
                 checkStatusClass = assign.last_check_is_available ? 'status-ok' : 'status-error';
                 checkStatusText = assign.last_check_is_available ? 'Доступен' : 'Недоступен';
             }
             // Кнопка "Детали" отображается, только если есть детали последней проверки (has_details из БД)
             const detailsButtonHtml = assign.has_details && assign.last_check_id
                                     ? `<button class="details-btn" data-check-id="${assign.last_check_id}">Детали</button>`
                                     : '';
             // Кнопка "История" для каждого задания
             const historyButtonHtml = `<button class="history-btn" data-assignment-id="${assign.assignment_id}">История</button>`;

             assignmentsTableHtml += `
                <tr>
                    <td>${assign.assignment_id}</td>
                    <td>${assign.method_name || 'N/A'}</td>
                    <td class="params" title='${pipelineTitle.replace(/'/g, '"')}'>${pipelineDisplay}</td>
                    <td>${assign.is_enabled ? 'Да' : 'Нет'}</td>
                    <td>${assign.check_interval_seconds ? assign.check_interval_seconds + ' сек' : 'По умолч.'}</td>
                    <td>${lastExecutedTime}</td>
                    <td class="${checkStatusClass}">${checkStatusText}</td>
                    <td class="actions-cell">${detailsButtonHtml} ${historyButtonHtml}</td>
                </tr>
            `;
         });
         assignmentsTableHtml += `</tbody></table>`;
         modalBodyElement.innerHTML = assignmentsTableHtml; // Вставляем таблицу в модальное окно
    }

    /** Загружает и отображает детали конкретной проверки в модальном окне. */
    async function showCheckDetailsInModal(checkId) {
         if (!checkId || !modalDetailsContainerElement || !modalDetailsJsonPreElement) {
            console.error("showCheckDetailsInModal: Отсутствуют необходимые элементы DOM или checkId.");
            return;
         }
         modalDetailsContainerElement.style.display = 'block'; // Показываем блок деталей
         modalHistoryContainerElement.style.display = 'none';  // Скрываем блок истории, если был открыт
         modalDetailsJsonPreElement.textContent = 'Загрузка деталей проверки...'; // Сообщение о загрузке

         const checkDetailsList = await fetchSingleCheckDetails(checkId); // Загружаем детали

         if (checkDetailsList === null) { // Ошибка загрузки
            modalDetailsJsonPreElement.textContent = '[Ошибка загрузки деталей проверки]';
         } else if (Array.isArray(checkDetailsList) && checkDetailsList.length > 0) {
            // Форматируем и отображаем детали (каждая запись detail_type + data)
            modalDetailsJsonPreElement.textContent = checkDetailsList.map(detailItem =>
                `Тип детали: ${detailItem.detail_type || 'N/A'}\n` +
                `Данные:\n${JSON.stringify(detailItem.data, null, 2)}` // Форматированный JSON
            ).join('\n\n--------------------------\n\n');
         } else {
            modalDetailsJsonPreElement.textContent = 'Детальная информация для этой проверки отсутствует.';
         }
     }

    /** Загружает и отображает историю проверок для задания в модальном окне. */
     async function showAssignmentHistoryInModal(assignmentId) {
         // Валидация assignmentId (должно быть числом)
         const numericAssignmentId = parseInt(assignmentId, 10);
         if (isNaN(numericAssignmentId) || numericAssignmentId <= 0) {
             console.error("showAssignmentHistoryInModal: Получен неверный assignmentId:", assignmentId);
             if (modalHistoryListElement) modalHistoryListElement.innerHTML = '<li class="error-message">Ошибка: Неверный ID задания для загрузки истории.</li>';
             if (historyAssignmentIdDisplaySpan) historyAssignmentIdDisplaySpan.textContent = 'Ошибка ID';
             if (modalHistoryContainerElement) modalHistoryContainerElement.style.display = 'block'; // Показываем блок, чтобы было видно ошибку
             if (modalDetailsContainerElement) modalDetailsContainerElement.style.display = 'none';
             return;
         }

         if (!modalHistoryContainerElement || !modalHistoryListElement || !historyAssignmentIdDisplaySpan) {
             console.error("showAssignmentHistoryInModal: Отсутствуют необходимые DOM-элементы для истории.");
             return;
         }
         modalHistoryContainerElement.style.display = 'block'; // Показываем блок истории
         modalDetailsContainerElement.style.display = 'none';  // Скрываем блок деталей
         historyAssignmentIdDisplaySpan.textContent = numericAssignmentId; // Отображаем ID задания
         modalHistoryListElement.innerHTML = '<li class="loading-message">Загрузка истории проверок...</li>';

         const historyData = await fetchSingleAssignmentHistory(numericAssignmentId); // Загружаем историю

         if (historyData === null) { // Ошибка загрузки
             modalHistoryListElement.innerHTML = '<li class="error-message">Ошибка загрузки истории проверок.</li>';
         } else if (Array.isArray(historyData) && historyData.length > 0) {
             let historyHtmlContent = historyData.map(histEntry => {
                 const checkTime = formatDateTime(histEntry.checked_at);
                 const agentCheckTime = histEntry.check_timestamp ? ` (Агент: ${formatDateTime(histEntry.check_timestamp)})` : '';
                 const statusCssClass = histEntry.is_available ? 'ok' : 'error';
                 const statusTextDisplay = histEntry.is_available ? 'Доступен' : 'Недоступен';
                 const executorInfo = histEntry.executor_host ? `${histEntry.executor_object_id || '?'}:${histEntry.executor_host}` : 'N/A';
                 // Кнопка "Детали" для каждой записи истории, если у нее есть детали
                 const detailsLinkHtml = histEntry.has_details && histEntry.id
                                       ? `<a href="#" class="details-link" data-check-id="${histEntry.id}" title="Показать детали этой проверки">Детали</a>`
                                       : '';
                 return `
                    <li>
                        <span class="hist-time" title="Время проверки на сервере (и на агенте, если есть)">${checkTime}${agentCheckTime}</span>
                        <span class="hist-status ${statusCssClass}" title="Метод: ${histEntry.method_name || 'N/A'}">${statusTextDisplay}</span>
                        <span class="hist-executor" title="Исполнитель проверки">${executorInfo}</span>
                        <span class="hist-details-link">${detailsLinkHtml}</span>
                    </li>`;
             }).join('');
             modalHistoryListElement.innerHTML = historyHtmlContent;
         } else { // Если история пуста
             modalHistoryListElement.innerHTML = '<li>Нет записей в истории для этого задания.</li>';
         }
     }


    // --- Инициализация страницы и назначение глобальных обработчиков ---
    /** Инициализирует страницу: находит DOM-элементы, назначает обработчики, загружает данные. */
    function initializeDetailedStatusPage() {
        console.log("Detailed Status: Инициализация страницы детального статуса...");
        // Получаем ссылки на все необходимые DOM-элементы
        statusTableBodyElement = document.getElementById('status-table-body');
        toggleAllButtonElement = document.getElementById('toggle-all-btn');
        assignmentsModalElement = document.getElementById('assignments-modal');
        modalTitleElement = document.getElementById('modal-title');
        modalBodyElement = document.getElementById('modal-body');
        modalDetailsContainerElement = document.getElementById('modal-details');
        modalDetailsJsonPreElement = modalDetailsContainerElement?.querySelector('.details-json'); // Используем querySelector для поиска внутри
        modalHistoryContainerElement = document.getElementById('modal-history');
        modalHistoryListElement = modalHistoryContainerElement?.querySelector('.history-list');
        historyAssignmentIdDisplaySpan = modalHistoryContainerElement?.querySelector('#history-assignment-id-span'); // Обновленный ID

        // Проверка, что все критически важные элементы найдены
        if (!statusTableBodyElement || !toggleAllButtonElement || !assignmentsModalElement || !modalTitleElement ||
            !modalBodyElement || !modalDetailsContainerElement || !modalDetailsJsonPreElement ||
            !modalHistoryContainerElement || !modalHistoryListElement || !historyAssignmentIdDisplaySpan) {
            console.error("Критическая ошибка инициализации: Не найдены все необходимые элементы DOM на странице детального статуса!");
            // Можно отобразить сообщение об ошибке пользователю
            document.body.insertAdjacentHTML('afterbegin', '<p style="color:red; background:pink; padding:1em; text-align:center;">Критическая ошибка: Не удалось инициализировать страницу. Некоторые элементы не найдены.</p>');
            return;
        }
        console.debug("Detailed Status: Все необходимые DOM-элементы найдены.");

        // Назначаем обработчики событий
        // Делегирование кликов для основной таблицы (раскрытие групп, кнопки "Задания", сортировка)
        statusTableBodyElement.addEventListener('click', handleDetailedTableClick);
        // Кнопка "Развернуть/Свернуть все"
        toggleAllButtonElement.addEventListener('click', toggleAllSubdivisions);
        // Делегирование кликов для модального окна (кнопки "Детали", "История" внутри таблицы заданий и ссылки "Детали" в истории)
        modalBodyElement.addEventListener('click', handleDetailedTableClick); // Переиспользуем тот же обработчик
        modalHistoryListElement.addEventListener('click', handleDetailedTableClick); // Для ссылок "Детали" в истории

        // Закрытие модального окна при клике вне его контента
        window.onclick = function(event) {
            if (event.target == assignmentsModalElement) {
                closeModal();
            }
        }
        // Также можно добавить закрытие по Escape, но это уже улучшение UX

        console.debug("Detailed Status: Обработчики событий назначены.");
        fetchAndRenderDetailedStatus(); // Загружаем и рендерим данные при инициализации
        // Устанавливаем интервал для автоматического обновления данных
        setInterval(fetchAndRenderDetailedStatus, 30000); // Обновление каждые 30 секунд
        console.log("Detailed Status: Страница детального статуса успешно инициализирована.");
    }

    /** Обрабатывает клики внутри основной таблицы статусов и модального окна. */
    function handleDetailedTableClick(event) {
        const targetElement = event.target;
        // Клик по строке подразделения для раскрытия/сворачивания
        const subdivisionRowTarget = targetElement.closest('tr.subdivision-row');
        if (subdivisionRowTarget) {
            toggleSubdivisionDisplay(subdivisionRowTarget.dataset.subdivisionId);
            return; // Прекращаем дальнейшую обработку, если это был клик по группе
        }
        // Клик по кнопке "Задания" в основной таблице
        const assignmentsButtonTarget = targetElement.closest('button.assignments-btn');
        if (assignmentsButtonTarget) {
            event.stopPropagation(); // Предотвращаем всплытие, если кнопка внутри другой кликабельной области
            const nodeId = assignmentsButtonTarget.dataset.nodeId;
            const nodeName = assignmentsButtonTarget.dataset.nodeName; // Имя уже URL-декодировано при получении из data-атрибута
            if (nodeId && nodeName) {
                showNodeAssignmentsInModal(nodeId, nodeName); // Показываем задания для узла
            } else { console.error("Не удалось получить nodeId или nodeName из кнопки 'Задания'."); }
            return;
        }
        // Клик по кнопке "Детали" (в таблице заданий внутри модального окна)
        const detailsButtonTarget = targetElement.closest('button.details-btn');
        if (detailsButtonTarget) {
            event.stopPropagation();
            const checkId = detailsButtonTarget.dataset.checkId;
            if (checkId) showCheckDetailsInModal(parseInt(checkId, 10));
            else console.error("Не удалось получить checkId из кнопки 'Детали'.");
            return;
        }
        // Клик по кнопке "История" (в таблице заданий внутри модального окна)
        const historyButtonTarget = targetElement.closest('button.history-btn');
        if (historyButtonTarget) {
            event.stopPropagation();
            const assignmentId = historyButtonTarget.dataset.assignmentId;
            if (assignmentId) showAssignmentHistoryInModal(assignmentId); // Передаем строку, парсинг внутри
            else console.error("Не удалось получить assignmentId из кнопки 'История'.");
            return;
        }
        // Клик по ссылке "Детали" в списке истории (внутри модального окна)
        const detailsLinkInHistory = targetElement.closest('a.details-link');
        if (detailsLinkInHistory) {
            event.preventDefault(); event.stopPropagation();
            const checkIdForHistoryDetail = detailsLinkInHistory.dataset.checkId;
            if (checkIdForHistoryDetail) showCheckDetailsInModal(parseInt(checkIdForHistoryDetail, 10));
            else console.error("Не удалось получить checkId из ссылки 'Детали' в истории.");
            return;
        }
        // Клик по заголовку колонки для сортировки
        const tableHeaderCell = targetElement.closest('th[data-column]');
        if (tableHeaderCell) {
            handleTableSort(tableHeaderCell.dataset.column);
            return;
        }
    }

    // --- Общая функция форматирования даты (если еще не определена в base.html или глобально) ---
    // В base.html уже есть formatDateTime, поэтому здесь ее дублировать не нужно,
    // если этот скрипт выполняется ПОСЛЕ скриптов из base.html.
    // Если есть сомнения, можно ее здесь переопределить или убедиться, что она доступна глобально.
    // function formatDateTime(dateStr) { /* ... (реализация как в base.html) ... */ }

    // --- Запуск инициализации страницы ---
    // Ожидаем полной загрузки DOM перед тем, как начать работу со скриптами
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeDetailedStatusPage);
    } else { // Если DOM уже загружен
        console.log("DOM уже был загружен, немедленная инициализация страницы детального статуса...");
        initializeDetailedStatusPage();
    }
</script>
{% endblock %}