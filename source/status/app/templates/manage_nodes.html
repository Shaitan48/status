<!-- status/app/templates/manage_nodes.html -->
{% extends "base.html" %} <!-- Наследование от базового шаблона -->

{% block title %}Управление Узлами - Мониторинг ПТК{% endblock %} <!-- Заголовок страницы -->

{% block head_extra %}
<!-- Дополнительные стили для этой страницы -->
<style>
    /* --- Общие стили для контейнера и секций --- */
    .manage-container {
        display: flex; /* Используем flex для удобного расположения дочерних секций */
        flex-direction: column; /* Располагаем секции вертикально */
        gap: 1.5rem; /* Отступ между секциями */
    }
    /* Стили для сворачиваемой секции с формой */
    .form-section-collapsible {
        background-color: var(--card-bg);
        padding: 0; /* Убираем padding, т.к. он будет у header и content */
        border-radius: 5px;
        box-shadow: var(--card-shadow);
        margin-bottom: 1.5rem; /* Отступ снизу, если это последняя секция */
        border: 1px solid var(--border-color);
        overflow: hidden; /* Чтобы скругленные углы работали с внутренними элементами */
    }
    .form-section-header { /* Заголовок сворачиваемой секции */
        background-color: var(--light-grey);
        padding: 0.8rem 1.5rem;
        cursor: pointer; /* Показываем, что на него можно нажать */
        display: flex;
        justify-content: space-between; /* Текст слева, иконка справа */
        align-items: center;
        border-bottom: 1px solid var(--border-color); /* Линия под заголовком, если контент скрыт */
    }
    .form-section-collapsible.open .form-section-header {
        border-bottom-color: transparent; /* Убираем линию, если контент открыт */
    }
    .form-section-header h3 {
        margin: 0;
        font-size: 1.2em;
        font-weight: 500; /* Менее жирный, чем h2 */
    }
    .form-section-header span.toggle-icon { /* Иконка стрелки */
        font-size: 1.5em;
        transition: transform 0.3s ease; /* Анимация поворота стрелки */
    }
    .form-section-content { /* Контейнер для самой формы */
        padding: 1.5rem;
        display: none; /* По умолчанию форма скрыта */
        border-top: 1px solid var(--border-color); /* Линия над формой, если она открыта */
    }
    .form-section-collapsible.open .form-section-content {
        display: block; /* Показываем форму, если секция открыта */
    }
    .form-section-collapsible.open .form-section-header span.toggle-icon {
        transform: rotate(180deg); /* Поворачиваем стрелку вниз */
    }

    /* --- Стили для элементов формы --- */
    .form-grid { /* Сетка для полей формы */
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Адаптивные колонки */
        gap: 1rem 1.5rem; /* Отступы между ячейками сетки */
    }
    .form-group { margin-bottom: 1rem; }
    .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
    .form-group select,
    .form-group input[type="text"],
    .form-group input[type="number"], /* Если будут числовые поля */
    .form-group textarea {
        width: 100%;
        padding: 8px 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
        font-size: 1em;
    }
    .form-group textarea { min-height: 80px; resize: vertical; }
    .form-actions { /* Контейнер для кнопок формы */
        margin-top: 1.5rem;
        text-align: right; /* Кнопки справа */
        display: flex; /* Для управления кнопками */
        justify-content: flex-end;
        gap: 0.5rem;
    }
    .form-actions button { /* Общие стили для кнопок в форме */
        padding: 8px 15px;
    }
    #cancel-edit-btn { /* Кнопка "Отмена" */
        background-color: var(--secondary-color);
    }
    #cancel-edit-btn:hover {
        background-color: #5a6268; /* Темнее при наведении */
    }

    /* --- Стили для секции списка узлов --- */
    .list-section {
        background-color: var(--card-bg);
        padding: 1.5rem;
        border-radius: 5px;
        box-shadow: var(--card-shadow);
        border: 1px solid var(--border-color);
    }
    .list-section h3 { /* Заголовок списка узлов */
        margin-top: 0;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.8rem;
        margin-bottom: 1rem;
        display: flex; /* Для расположения заголовка и фильтров в одну строку */
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap; /* Разрешаем перенос фильтров на новую строку */
        gap: 10px; /* Отступ между заголовком и блоком фильтров */
    }
    .filter-controls { /* Контейнер для фильтров */
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px 15px; /* Отступы между группами фильтров */
    }
    .filter-group { /* Группа: лейбл + select/input */
        display: flex;
        align-items: center;
        gap: 5px; /* Отступ между лейблом и полем */
    }
    .filter-group label { /* Лейблы фильтров */
        margin-bottom: 0; /* Убираем стандартный отступ снизу */
        font-weight: normal; /* Обычный шрифт (не жирный) */
        font-size: 0.9em;
    }
    .filter-group input[type="checkbox"] { margin-right: 3px; vertical-align: middle; }
    .filter-controls select,
    .filter-controls input[type="search"] { /* Стили для полей фильтров */
        padding: 4px 6px;
        font-size: 0.9em;
        border-radius: 3px;
        border: 1px solid #ccc;
        min-width: 160px; /* Минимальная ширина для селектов */
    }
    .filter-controls label[for^="filter-"] { /* Лейблы для селектов (начинающиеся с "filter-") */
        white-space: nowrap; /* Предотвращение переноса текста */
        font-weight: 500; /* Делаем их чуть жирнее */
    }
    .filter-group label.checkbox-label { /* Лейблы для чекбоксов */
        font-weight: normal;
        cursor: pointer;
    }

    /* --- Стили для таблицы узлов --- */
    .nodes-table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
    .nodes-table th, .nodes-table td {
        border: 1px solid var(--border-color);
        padding: 8px 10px;
        text-align: left;
        vertical-align: middle;
        word-wrap: break-word; /* Перенос длинных слов в ячейках */
    }
    .nodes-table th { background-color: var(--light-grey); white-space: nowrap; font-weight: 600; }
    .nodes-table td:first-child { width: 60px; text-align: center; } /* ID узла */
    .nodes-table .actions { text-align: center; white-space: nowrap; width: 90px; } /* Колонка с кнопками действий */
    .nodes-table .actions button { /* Стили для кнопок "Редактировать" и "Удалить" */
        padding: 4px 8px; font-size: 0.9em; margin-right: 5px; cursor: pointer;
        border: none; border-radius: 3px; color: white;
    }
    .nodes-table .edit-btn { background-color: var(--warning-color); color: #333; }
    .nodes-table .edit-btn:hover { background-color: #e0a800; }
    .nodes-table .delete-btn { background-color: var(--danger-color); }
    .nodes-table .delete-btn:hover { background-color: #c82333; }

    /* --- Стили пагинации (общие, как в других manage_*) --- */
    .pagination-controls { margin-top: 1.5rem; text-align: center; }
    /* ... (остальные стили пагинации) ... */

    /* --- Общие стили для сообщений (feedback) и ошибок валидации --- */
    .feedback-area { /* ... (как в manage_api_keys.html) ... */ }
    .error-feedback { /* ... (как в manage_api_keys.html) ... */ }
    .loading-message { /* ... (как в manage_api_keys.html) ... */ }
    .error-message { /* ... (как в manage_api_keys.html) ... */ }
</style>
{% endblock %}

{% block content %}
<h2>Управление Узлами Мониторинга</h2>

<!-- Область для отображения общих сообщений над списком (например, успех/ошибка CRUD операций) -->
<div id="list-feedback" class="feedback-area"></div>

<div class="manage-container">

    <!-- Секция с формой добавления/редактирования узла (сворачиваемая) -->
    <section class="form-section-collapsible open" id="form-section"> <!-- 'open' класс делает ее открытой по умолчанию -->
         <div class="form-section-header" onclick="toggleNodeForm()"> <!-- Обработчик для сворачивания/разворачивания -->
            <h3 id="form-title">Добавить Новый Узел</h3>
            <span class="toggle-icon" id="form-toggle-icon">🔼</span> <!-- Иконка-стрелка -->
        </div>
        <div class="form-section-content" style="display: block;"> <!-- Контент формы, по умолчанию показан -->
            <form id="node-form">
                <input type="hidden" id="node-edit-id"> <!-- Скрытое поле для ID при редактировании -->

                <div class="form-grid"> <!-- Сетка для полей формы -->
                    <div class="form-group">
                        <label for="node-name">Имя узла (Hostname) *</label>
                        <input type="text" id="node-name" required maxlength="255">
                        <div class="error-feedback" id="node-name-error"></div> <!-- Для ошибки валидации этого поля -->
                    </div>

                    <div class="form-group">
                        <label for="node-subdivision">Подразделение *</label>
                        <select id="node-subdivision" required>
                            <option value="">-- Выберите подразделение --</option>
                            <!-- Опции будут загружены динамически JavaScript'ом -->
                        </select>
                        <div class="error-feedback" id="node-subdivision-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="node-ip">IP-адрес</label>
                        <input type="text" id="node-ip" placeholder="Например, 192.168.1.10" maxlength="45">
                         <div class="error-feedback" id="node-ip-error"></div>
                    </div>

                    <div class="form-group">
                        <label for="node-type">Тип узла</label>
                        <select id="node-type">
                            <option value="">-- Выберите тип --</option>
                            <!-- Опции будут загружены динамически JavaScript'ом -->
                        </select>
                        <div class="error-feedback" id="node-type-error"></div>
                    </div>
                </div> <!-- Конец form-grid -->

                <div class="form-group"> <!-- Описание узла (на всю ширину) -->
                    <label for="node-description">Описание</label>
                    <textarea id="node-description" placeholder="Дополнительная информация об узле..."></textarea>
                </div>

                <!-- Область для общих ошибок формы (например, от API) -->
                <div id="form-feedback" class="feedback-area"></div>
                <!-- Кнопки действий формы -->
                <div class="form-actions">
                    <button type="button" id="cancel-edit-btn" style="display: none;">Отмена</button>
                    <button type="submit" id="submit-btn">Добавить Узел</button>
                </div>
            </form>
        </div>
    </section>

    <!-- Секция со списком существующих узлов -->
    <section class="list-section">
         <h3>
            <span>Список Узлов Мониторинга</span>
            <!-- Фильтры для списка узлов -->
            <span class="filter-controls">
                 <div class="filter-group">
                     <label for="filter-subdivision">Подразделение:</label>
                     <select id="filter-subdivision">
                         <option value="">Все подразделения</option>
                         <!-- Опции загружаются JS -->
                     </select>
                     <input type="checkbox" id="filter-subdivision-include-children" title="Включить узлы из дочерних подразделений">
                     <label for="filter-subdivision-include-children" class="checkbox-label">Вкл. дочерние</label>
                 </div>
                  <div class="filter-group">
                     <label for="filter-type">Тип узла:</label>
                     <select id="filter-type">
                         <option value="">Все типы</option>
                         <!-- Опции загружаются JS -->
                     </select>
                      <input type="checkbox" id="filter-type-include-nested" title="Включить узлы с дочерними типами">
                      <label for="filter-type-include-nested" class="checkbox-label">Вкл. вложенные</label>
                 </div>
                 <!-- Можно добавить текстовый поиск по имени/IP, если нужно -->
                 <!-- <div class="filter-group">
                    <label for="filter-search-text">Поиск:</label>
                    <input type="search" id="filter-search-text" placeholder="Имя или IP...">
                 </div> -->
            </span>
        </h3>
        <table class="nodes-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Имя</th>
                    <th>IP Адрес</th>
                    <th>Подразделение</th>
                    <th>Тип узла</th>
                    <th>Описание</th>
                    <th>Действия</th>
                </tr>
            </thead>
            <tbody id="node-list-table-body"> <!-- Изменил ID для уникальности -->
                <!-- Начальное сообщение о загрузке -->
                <tr><td colspan="7" class="loading-message">Загрузка списка узлов...</td></tr>
            </tbody>
        </table>
         <!-- Элементы управления пагинацией -->
         <div class="pagination-controls" id="pagination-controls" style="display: none;">
             <button id="prev-page-btn" disabled>« Назад</button> <!-- Изменил ID -->
             <span id="page-info-span">Страница - из -</span> <!-- Изменил ID -->
             <button id="next-page-btn" disabled>Вперед »</button> <!-- Изменил ID -->
         </div>
    </section>
</div>
{% endblock %}

{% block scripts %}
<script>
    // --- Получение ссылок на DOM-элементы ---
    const nodeFormSection = document.getElementById('form-section');
    const nodeFormContent = nodeFormSection.querySelector('.form-section-content');
    const nodeFormToggleIcon = document.getElementById('form-toggle-icon');
    const nodeFormElement = document.getElementById('node-form');
    const nodeFormTitleElement = document.getElementById('form-title');
    const nodeSubmitButton = document.getElementById('submit-btn');
    const nodeCancelButton = document.getElementById('cancel-edit-btn');
    const nodeTableBody = document.getElementById('node-list-table-body'); // Обновленный ID
    const nodeFormFeedbackElement = document.getElementById('form-feedback');
    const nodeListFeedbackElement = document.getElementById('list-feedback');

    // Поля формы
    const nodeIdInput = document.getElementById('node-edit-id');
    const nodeNameInput = document.getElementById('node-name');
    const nodeSubdivisionSelect = document.getElementById('node-subdivision');
    const nodeIpInput = document.getElementById('node-ip');
    const nodeTypeSelect = document.getElementById('node-type');
    const nodeDescriptionTextarea = document.getElementById('node-description');

    // Фильтры списка
    const filterSubdivisionSelectElement = document.getElementById('filter-subdivision');
    const filterTypeSelectElement = document.getElementById('filter-type');
    const filterIncludeChildrenCheckbox = document.getElementById('filter-subdivision-include-children');
    const filterIncludeNestedTypesCheckbox = document.getElementById('filter-type-include-nested');
    // const filterSearchTextInput = document.getElementById('filter-search-text'); // Если будет поиск

    // Пагинация
    const paginationControlsDiv = document.getElementById('pagination-controls');
    const prevPageButtonElement = document.getElementById('prev-page-btn'); // Обновленный ID
    const nextPageButtonElement = document.getElementById('next-page-btn'); // Обновленный ID
    const pageInfoSpanElement = document.getElementById('page-info-span');   // Обновленный ID

    // --- API URL-адреса (генерируются Flask) ---
    const API_URL_NODES_CRUD = "{{ url_for('nodes.api_get_nodes') }}"; // Для GET (список) и POST (создание)
    const API_URL_NODE_DETAIL_TEMPLATE = "{{ url_for('nodes.api_get_node_by_id_route', node_id=0) }}"; // Шаблон для GET/PUT/DELETE по ID
    const API_URL_SUBDIVISIONS_LIST = "{{ url_for('subdivisions.api_get_all_subdivisions') }}"; // Для заполнения селекта подразделений
    const API_URL_NODE_TYPES_LIST = "{{ url_for('node_types.api_get_all_node_types') }}";   // Для заполнения селекта типов узлов

    // --- Переменные состояния приложения ---
    let currentNodesPageCache = [];    // Кэш узлов, отображаемых на текущей странице
    let allSubdivisionsDataCache = []; // Кэш всех подразделений (для селектов)
    let allNodeTypesDataCache = [];    // Кэш всех типов узлов (для селектов)
    let currentEditingNodeId = null;   // ID узла, который редактируется (null при создании нового)
    let isNodeFormCurrentlyOpen = true; // Состояние формы (открыта/закрыта)
    let listCurrentPageNumber = 1;      // Текущая страница для пагинации списка узлов
    let listItemsPerPageCount = 25;    // Количество узлов на одной странице
    let listTotalNodesCount = 0;       // Общее количество узлов (с учетом текущих фильтров)

    // --- Вспомогательные функции (fetchData, displayValidationErrors, clearValidationErrors, showFeedback) ---
    // Эти функции можно скопировать из manage_api_keys.html или другого подобного шаблона,
    // так как их логика универсальна. Убедитесь, что они используют правильные ID элементов для сообщений.
    // Пример showFeedback для этой страницы:
    function showNodeListFeedback(message, isError = false) { showFeedback(nodeListFeedbackElement, message, isError); }
    function showNodeFormFeedback(message, isError = false) { showFeedback(nodeFormFeedbackElement, message, isError); }
    // ... (остальные хелперы fetchData, displayValidationErrors, clearValidationErrors также нужны)

    async function fetchData(url, options = {}) { /* ... (реализация из manage_api_keys.html) ... */ }
    function displayValidationErrors(errors, prefix = 'node-') { /* ... (реализация из manage_api_keys.html, адаптировать ID ошибок) ... */ }
    function clearValidationErrors(prefix = 'node-') { /* ... (реализация из manage_api_keys.html) ... */ }
    function showFeedback(element, message, isError = false) { /* ... (реализация из manage_api_keys.html) ... */ }


    /** Переключает видимость формы добавления/редактирования узла. */
    function toggleNodeForm() {
         isNodeFormCurrentlyOpen = !isNodeFormCurrentlyOpen;
         nodeFormSection.classList.toggle('open', isNodeFormCurrentlyOpen);
         nodeFormContent.style.display = isNodeFormCurrentlyOpen ? 'block' : 'none';
         nodeFormToggleIcon.textContent = isNodeFormCurrentlyOpen ? '🔼' : '🔽'; // Меняем иконку стрелки
         // Если форма открывается для добавления нового, ставим фокус на первое поле
         if (isNodeFormCurrentlyOpen && !currentEditingNodeId) {
             nodeNameInput.focus();
         } else if (!isNodeFormCurrentlyOpen && currentEditingNodeId) {
             // Если форма закрывается во время редактирования, сбрасываем ее
             resetNodeForm();
         }
    }

    /**
     * Заполняет HTMLSelectElement опциями из массива данных, поддерживая иерархию.
     * (Эта функция используется для селектов подразделений и типов узлов)
     */
    function populateSelectWithOptions(selectEl, dataItems, valueKey, textKey, placeholderText, useHierarchy = false, excludeItemId = null) {
        // ... (Точная копия функции populateSelectWithOptions из manage_api_keys.html или manage_types.html) ...
        // Важно: убедитесь, что эта функция правильно обрабатывает поля parent_id (для подразделений)
        // и parent_type_id (для типов узлов) при построении иерархии.
        const currentSelectedVal = selectEl.value;
        selectEl.innerHTML = `<option value="">${placeholderText}</option>`;
        if (!dataItems || dataItems.length === 0) return;

        if (useHierarchy) {
            const itemMap = {}; const rootItems = []; const excludedDescendantIds = new Set();
            function findDescendants(itemId) { if (!itemMap[itemId]?.rawChildren) return; itemMap[itemId].rawChildren.forEach(childId => { if (!excludedDescendantIds.has(childId)) { excludedDescendantIds.add(childId); findDescendants(childId); } }); }
            dataItems.forEach(item => { itemMap[item[valueKey]] = { ...item, rawChildren: [] }; });
            dataItems.forEach(item => {
                 // Определяем ключ для родителя в зависимости от типа сущности
                const parentIdField = (valueKey === 'id' && item.parent_id !== undefined) ? 'parent_id' :
                                    (valueKey === 'id' && item.parent_type_id !== undefined) ? 'parent_type_id' : null;
                const parentIdValue = parentIdField ? item[parentIdField] : null;
                if (parentIdValue !== null && itemMap[parentIdValue]) {
                    itemMap[parentIdValue].rawChildren.push(item[valueKey]);
                }
            });
            if (excludeItemId !== null) { excludedDescendantIds.add(excludeItemId); findDescendants(excludeItemId); }

            const selectTreeItemMap = {};
            dataItems.forEach(item => {
                const currentItemId = item[valueKey];
                if (!excludedDescendantIds.has(currentItemId)) {
                    selectTreeItemMap[currentItemId] = { ...item, children: [] };
                    const parentIdField = (valueKey === 'id' && item.parent_id !== undefined) ? 'parent_id' :
                                          (valueKey === 'id' && item.parent_type_id !== undefined) ? 'parent_type_id' : null;
                    const parentIdValue = parentIdField ? item[parentIdField] : null;
                    if (parentIdValue === null || !selectTreeItemMap[parentIdValue]) {
                         if (!rootItems.includes(currentItemId)) rootItems.push(currentItemId);
                    } else if (selectTreeItemMap[parentIdValue]) {
                         selectTreeItemMap[parentIdValue].children.push(currentItemId);
                    }
                }
            });
            function addOptionRecursive(itemId, indentLevel) {
                const itemData = selectTreeItemMap[itemId]; if (!itemData) return;
                const option = document.createElement('option'); option.value = itemData[valueKey];
                const displayName = itemData.short_name || itemData[textKey]; // short_name для подразделений
                option.textContent = '\u00A0'.repeat(indentLevel * 3) + displayName + ` (ID: ${itemData.id})`; // Показываем ID для ясности
                selectEl.appendChild(option);
                itemData.children
                    .map(id => selectTreeItemMap[id]).filter(child => child)
                    .sort((a, b) => (a.priority || 999) - (b.priority || 999) || (a.short_name || a[textKey]).localeCompare(b.short_name || b[textKey]))
                    .forEach(child => addOptionRecursive(child.id, indentLevel + 1));
            }
            rootItems
                .map(id => selectTreeItemMap[id]).filter(root => root)
                .sort((a, b) => (a.priority || 999) - (b.priority || 999) || (a.short_name || a[textKey]).localeCompare(b.short_name || b[textKey]))
                .forEach(root => addOptionRecursive(root.id, 0));
        } else { /* ... (логика для плоского списка, если нужна) ... */ }
        if (currentSelectedVal && selectEl.querySelector(`option[value="${currentSelectedVal}"]`)) {
            selectEl.value = currentSelectedVal;
        } else { selectEl.value = ""; }
    }


    /** Загружает начальные данные: список подразделений и типов узлов для селектов. */
    async function loadInitialSelectData() {
        showNodeListFeedback("Загрузка справочников для формы и фильтров...");
        try {
            const [subdivisionsResponse, nodeTypesResponse] = await Promise.all([
                fetchData(API_URL_SUBDIVISIONS_LIST + "?limit=10000"), // Загружаем все подразделения
                fetchData(API_URL_NODE_TYPES_LIST + "?limit=10000")      // Загружаем все типы узлов
            ]);
            allSubdivisionsDataCache = (subdivisionsResponse && subdivisionsResponse.items) ? subdivisionsResponse.items : [];
            allNodeTypesDataCache = (nodeTypesResponse && nodeTypesResponse.items) ? nodeTypesResponse.items : [];

            if (allSubdivisionsDataCache.length === 0) console.warn("Справочник подразделений пуст.");
            if (allNodeTypesDataCache.length === 0) console.warn("Справочник типов узлов пуст.");

            // Заполняем селекты в форме
            populateSelectWithOptions(nodeSubdivisionSelect, allSubdivisionsDataCache, 'id', 'short_name', '-- Выберите подразделение --', true);
            populateSelectWithOptions(nodeTypeSelect, allNodeTypesDataCache, 'id', 'name', '-- Выберите тип узла --', true);
            // Заполняем селекты в фильтрах
            populateSelectWithOptions(filterSubdivisionSelectElement, allSubdivisionsDataCache, 'id', 'short_name', 'Все подразделения', true);
            populateSelectWithOptions(filterTypeSelectElement, allNodeTypesDataCache, 'id', 'name', 'Все типы', true);

            showNodeListFeedback(""); // Очищаем сообщение о загрузке
        } catch (error) {
            console.error("Ошибка загрузки начальных данных (справочников):", error);
            // Сообщение об ошибке уже было показано в fetchData
            // Можно добавить дополнительное сообщение в фидбек формы
            showNodeFormFeedback("Не удалось загрузить справочники для формы.", true);
        }
    }

    /**
     * Загружает и отображает страницу списка узлов с учетом фильтров и пагинации.
     * @param {number} [page=1] - Номер запрашиваемой страницы (начиная с 1).
     */
    async function loadAndRenderNodesTable(page = 1) {
        nodeTableBody.innerHTML = `<tr><td colspan="7" class="loading-message">Загрузка списка узлов (страница ${page})...</td></tr>`;
        listCurrentPageNumber = page;
        const offset = (listCurrentPageNumber - 1) * listItemsPerPageCount;

        // Собираем параметры для API-запроса из фильтров
        const queryParams = new URLSearchParams();
        queryParams.append('limit', listItemsPerPageCount);
        queryParams.append('offset', offset);
        if (filterSubdivisionSelectElement.value) {
             queryParams.append('subdivision_id', filterSubdivisionSelectElement.value);
             if (filterIncludeChildrenCheckbox.checked) queryParams.append('include_child_subdivisions', 'true');
        }
        if (filterTypeSelectElement.value) {
            queryParams.append('node_type_id', filterTypeSelectElement.value);
             if (filterIncludeNestedTypesCheckbox.checked) queryParams.append('include_nested_types', 'true');
        }
        // if (filterSearchTextInput.value.trim()) { // Если будет текстовый поиск
        //     queryParams.append('search_text', filterSearchTextInput.value.trim());
        // }

        try {
            const apiUrlWithParams = `${API_URL_NODES_CRUD}?${queryParams.toString()}`;
            const responseData = await fetchData(apiUrlWithParams); // fetchData обработает ошибки и JSON

            currentNodesPageCache = (responseData && responseData.items) ? responseData.items : [];
            listTotalNodesCount = (responseData && responseData.total_count !== undefined) ? responseData.total_count : currentNodesPageCache.length;

            renderNodesInTable(currentNodesPageCache); // Отображаем полученные данные в таблице
            renderNodesTablePagination(); // Обновляем элементы управления пагинацией
        } catch (error) {
            // Ошибка уже была показана в fetchData в nodeListFeedbackElement
            console.error("Ошибка загрузки списка узлов:", error);
            nodeTableBody.innerHTML = `<tr><td colspan="7" class="error-message">Ошибка загрузки списка узлов.</td></tr>`;
            renderNodesTablePagination(); // Показываем пагинацию с информацией о 0 записей
        }
    }

    /** Рендерит строки в таблице узлов на основе предоставленных данных. */
    function renderNodesInTable(nodesToDisplay) {
         // Используем кэши allSubdivisionsDataCache и allNodeTypesDataCache для получения имен
         const subdivisionNameMap = Object.fromEntries(allSubdivisionsDataCache.map(s => [s.id, s.short_name]));
         const nodeTypeNameMap = Object.fromEntries(allNodeTypesDataCache.map(t => [t.id, t.name]));
         let tableRowsHtml = '';

         if (nodesToDisplay.length === 0) {
              const filtersAreActive = filterSubdivisionSelectElement.value || filterTypeSelectElement.value; // Добавить другие фильтры, если есть
              tableRowsHtml = `<tr><td colspan="7" style="text-align: center;">Узлы не найдены${filtersAreActive ? ' (с учетом выбранных фильтров)' : ''}.</td></tr>`;
         } else {
             // Сортируем узлы перед отображением (например, по имени)
             nodesToDisplay.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
             tableRowsHtml = nodesToDisplay.map(node => {
                 // Получаем имена для ID из кэшей
                 const subdivisionDisplayName = node.subdivision_id ? (subdivisionNameMap[node.subdivision_id] || `ID: ${node.subdivision_id}`) : '---';
                 const nodeTypeDisplayName = node.node_type_id ? (nodeTypeNameMap[node.node_type_id] || `ID: ${node.node_type_id}`) : '---';
                 // HTML для строки таблицы
                 return `
                     <tr data-node-id="${node.id}">
                         <td>${node.id}</td>
                         <td>${node.name || 'N/A'}</td>
                         <td>${node.ip_address || '---'}</td>
                         <td title="ID подразделения: ${node.subdivision_id || 'N/A'}">${subdivisionDisplayName}</td>
                         <td title="ID типа: ${node.node_type_id || 'N/A'}">${nodeTypeDisplayName}</td>
                         <td>${node.description || '---'}</td>
                         <td class="actions">
                              <button class="edit-btn" data-id="${node.id}" title="Редактировать узел ID ${node.id}">✏️</button>
                              <button class="delete-btn" data-id="${node.id}" data-name="${node.name || 'N/A'}" title="Удалить узел ID ${node.id}">🗑️</button>
                         </td>
                     </tr>`;
             }).join('');
         }
         nodeTableBody.innerHTML = tableRowsHtml; // Вставляем сгенерированный HTML в tbody таблицы
    }

    /** Обновляет элементы управления пагинацией. */
    function renderNodesTablePagination() {
        if (!paginationControlsDiv || !pageInfoSpanElement || !prevPageButtonElement || !nextPageButtonElement) return;
        const totalPages = Math.ceil(listTotalNodesCount / listItemsPerPageCount);
        pageInfoSpanElement.textContent = `Страница ${listCurrentPageNumber} из ${totalPages} (Всего: ${listTotalNodesCount})`;
        prevPageButtonElement.disabled = listCurrentPageNumber <= 1;
        nextPageButtonElement.disabled = listCurrentPageNumber >= totalPages;
        paginationControlsDiv.style.display = listTotalNodesCount > 0 && totalPages > 1 ? 'block' : 'none';
    }

    // --- Функции для управления формой и CRUD-операциями ---
    /** Сбрасывает форму добавления/редактирования узла в начальное состояние. */
    function resetNodeForm() {
        nodeFormElement.reset(); // Стандартный сброс полей формы
        nodeIdInput.value = ''; // Очищаем скрытое поле ID
        currentEditingNodeId = null; // Сбрасываем флаг режима редактирования
        nodeFormTitleElement.textContent = 'Добавить Новый Узел';
        nodeSubmitButton.textContent = 'Добавить Узел';
        nodeSubmitButton.disabled = false; // Разблокируем кнопку
        nodeCancelButton.style.display = 'none'; // Скрываем кнопку "Отмена"
        clearValidationErrors('node-form-feedback', 'node-'); // Очищаем ошибки валидации
        showNodeFormFeedback(''); // Очищаем общие сообщения формы
    }

    /**
     * Заполняет форму данными узла для редактирования.
     * @param {object} nodeData - Объект с данными узла (из API или кэша).
     */
    function fillNodeFormForEditing(nodeData) {
        if (!nodeData) {
            console.error("fillNodeFormForEditing: Передан пустой объект данных узла.");
            showNodeFormFeedback("Не удалось загрузить данные узла для редактирования.", true);
            return;
        }
        resetNodeForm(); // Сначала сбрасываем форму
        currentEditingNodeId = nodeData.id;
        nodeIdInput.value = nodeData.id; // Заполняем скрытое поле ID

        // Заполняем видимые поля формы
        nodeNameInput.value = nodeData.name || '';
        // Устанавливаем значения для селектов. '' если значение null/undefined.
        nodeSubdivisionSelect.value = nodeData.subdivision_id !== null && nodeData.subdivision_id !== undefined ? String(nodeData.subdivision_id) : '';
        nodeIpInput.value = nodeData.ip_address || '';
        nodeTypeSelect.value = nodeData.node_type_id !== null && nodeData.node_type_id !== undefined ? String(nodeData.node_type_id) : '';
        nodeDescriptionTextarea.value = nodeData.description || '';

        // Обновляем UI формы для режима редактирования
        nodeFormTitleElement.textContent = `Редактировать Узел ID: ${nodeData.id}`;
        nodeSubmitButton.textContent = 'Сохранить изменения';
        nodeCancelButton.style.display = 'inline-block'; // Показываем кнопку "Отмена"

        if (!isNodeFormCurrentlyOpen) { // Если форма была свернута, разворачиваем ее
            toggleNodeForm();
        }
        // Плавная прокрутка к форме
        nodeFormSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        nodeNameInput.focus(); // Фокус на первое поле
    }

    /** Обрабатывает отправку формы (создание нового или обновление существующего узла). */
    async function handleNodeFormSubmit(event) {
        event.preventDefault(); // Предотвращаем стандартную отправку
        clearValidationErrors('node-form-feedback','node-'); // Очищаем предыдущие ошибки
        showNodeFormFeedback(''); // Очищаем общий фидбек формы
        nodeSubmitButton.disabled = true; // Блокируем кнопку
        nodeSubmitButton.textContent = currentEditingNodeId ? 'Сохранение...' : 'Добавление...';

        // Собираем данные из полей формы
        const formDataPayload = {
            name: nodeNameInput.value.trim(),
            // Преобразуем значения селектов в числа или null
            parent_subdivision_id: nodeSubdivisionSelect.value ? parseInt(nodeSubdivisionSelect.value, 10) : null,
            ip_address: nodeIpInput.value.trim() || null, // Пустая строка -> null
            node_type_id: nodeTypeSelect.value ? parseInt(nodeTypeSelect.value, 10) : null,
            description: nodeDescriptionTextarea.value.trim() || null
        };

        // --- Клиентская валидация перед отправкой (дополняет серверную) ---
        let clientSideErrors = {};
        if (!formDataPayload.name) {
            clientSideErrors['name'] = "Имя узла является обязательным полем.";
        }
        if (formDataPayload.parent_subdivision_id === null) { // Проверяем именно null после парсинга
            clientSideErrors['subdivision'] = "Необходимо выбрать подразделение.";
        }
        // Проверка IP-адреса (простой regex, серверная валидация может быть строже)
        if (formDataPayload.ip_address && !/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(formDataPayload.ip_address)) {
            clientSideErrors['ip'] = "Введен некорректный формат IP-адреса.";
        }
        if (Object.keys(clientSideErrors).length > 0) {
            displayValidationErrors(clientSideErrors, 'node-'); // Показываем ошибки под полями
            nodeSubmitButton.disabled = false;
            nodeSubmitButton.textContent = currentEditingNodeId ? 'Сохранить изменения' : 'Добавить Узел';
            return; // Прерываем, если есть ошибки на клиенте
        }
        // --- Конец клиентской валидации ---

        // Определяем URL и HTTP-метод
        const apiUrl = currentEditingNodeId ? API_URL_NODE_DETAIL_TEMPLATE.replace('/0', `/${currentEditingNodeId}`) : API_URL_NODES_CRUD;
        const httpMethod = currentEditingNodeId ? 'PUT' : 'POST';

        try {
            // Отправляем запрос на сервер
            const resultData = await fetchData(apiUrl, {
                method: httpMethod,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formDataPayload)
            });
            // Обработка успешного ответа
            showNodeListFeedback(`Узел успешно ${currentEditingNodeId ? 'обновлен' : 'добавлен'}!`, false);
            resetNodeForm(); // Сбрасываем форму
            // Обновляем список узлов: если редактировали - текущую страницу, если создавали - первую
            await loadAndRenderNodesTable(currentEditingNodeId ? listCurrentPageNumber : 1);
            // Если форма была открыта и это было добавление (не редактирование), оставляем ее открытой для следующего ввода.
            // Если было редактирование и форма открыта, можно ее свернуть.
            if (isNodeFormCurrentlyOpen && currentEditingNodeId) {
                // toggleNodeForm(); // Можно свернуть после успешного сохранения редактирования
            } else if (isNodeFormCurrentlyOpen && !currentEditingNodeId) {
                nodeNameInput.focus(); // Фокус на имя для нового узла
            }
        } catch (error) { // Обработка ошибок от fetchData (сеть, HTTP, парсинг JSON)
            console.error(`Ошибка ${httpMethod} для узла:`, error);
            // Отображаем ошибки валидации от сервера или общую ошибку в форме
            displayValidationErrors(error.details || error.message, 'node-');
            // Дополнительно показываем общую ошибку в фидбеке формы, если error.details не было
            if (!error.details) {
                showNodeFormFeedback(`Ошибка: ${error.message || 'Не удалось выполнить операцию.'}`, true);
            }
            showNodeListFeedback(`Ошибка ${currentEditingNodeId ? 'обновления' : 'добавления'} узла.`, true);
        } finally { // В любом случае разблокируем кнопку и восстанавливаем ее текст
            nodeSubmitButton.disabled = false;
            nodeSubmitButton.textContent = currentEditingNodeId ? 'Сохранить изменения' : 'Добавить Узел';
        }
    }

    /** Обрабатывает клик на кнопку "Редактировать" в таблице узлов. */
    async function handleEditNodeClick(nodeId) {
         showNodeListFeedback(`Загрузка данных узла ID ${nodeId} для редактирования...`);
         const apiUrlGetNode = API_URL_NODE_DETAIL_TEMPLATE.replace('/0', `/${nodeId}`);
         try {
             const nodeDataToEdit = await fetchData(apiUrlGetNode); // fetchData покажет индикатор и обработает ошибки сети/404
             if (nodeDataToEdit) { // Если узел найден и данные получены
                 fillNodeFormForEditing(nodeDataToEdit); // Заполняем форму
                 showNodeListFeedback(''); // Очищаем сообщение о загрузке
             }
             // Если узел не найден, fetchData выбросит ошибку, которая будет обработана в catch
         } catch (error) {
              console.error("Ошибка загрузки данных узла для редактирования:", error);
              if (currentEditingNodeId === nodeId) resetNodeForm(); // Если пытались редактировать этот же, сбрасываем форму
              // Сообщение об ошибке уже было показано в nodeListFeedbackElement через fetchData
         }
    }

    /** Обрабатывает клик на кнопку "Удалить" в таблице узлов. */
    async function handleDeleteNodeClick(nodeId, nodeName) {
        // Запрашиваем подтверждение у пользователя
        if (!confirm(`Вы уверены, что хотите удалить узел "${nodeName}" (ID: ${nodeId})? Все связанные с ним задания и история проверок также будут удалены (если настроено каскадное удаление в БД)!`)) {
            return; // Пользователь отменил удаление
        }
        showNodeListFeedback(`Удаление узла ID ${nodeId} ("${nodeName}")...`);
        const apiUrlDeleteNode = API_URL_NODE_DETAIL_TEMPLATE.replace('/0', `/${nodeId}`);
        try {
            await fetchData(apiUrlDeleteNode, { method: 'DELETE' }); // Ожидаем 204 No Content
            showNodeListFeedback(`Узел "${nodeName}" (ID: ${nodeId}) успешно удален.`, false);
            // Если удаляемый узел был в режиме редактирования, сбрасываем форму
            if (currentEditingNodeId === nodeId) {
                resetNodeForm();
            }
            // Перезагружаем ТЕКУЩУЮ страницу списка.
            // Если на текущей странице не осталось элементов после удаления,
            // и это была не первая страница, можно перейти на предыдущую.
            if (currentNodesPageCache.length === 1 && listCurrentPageNumber > 1) {
                await loadAndRenderNodesTable(listCurrentPageNumber - 1);
            } else {
                await loadAndRenderNodesTable(listCurrentPageNumber);
            }
        } catch (error) {
            // Ошибка (например, "узел не найден" или "ошибка сервера") уже была показана в nodeListFeedbackElement через fetchData
            console.error("Ошибка удаления узла:", error);
            // showNodeListFeedback(`Ошибка удаления узла: ${error.message}`, true); // Дублирует сообщение из fetchData
        }
    }

    // --- Инициализация страницы и назначение обработчиков событий ---
    /** Инициализирует страницу: загружает начальные данные (справочники) и первую страницу списка узлов. */
    async function initializeManageNodesPage() {
         // Показываем начальное сообщение о загрузке в таблице
         nodeTableBody.innerHTML = `<tr><td colspan="7" class="loading-message">Инициализация страницы управления узлами...</td></tr>`;
         try {
             await loadInitialSelectData(); // Сначала загружаем данные для селектов
             // await loadAndRenderNodesTable(1); // Затем первую страницу списка узлов (уже вызывается из loadInitialSelectData)
         } catch(e) {
              console.error("Критическая ошибка во время инициализации страницы управления узлами:", e);
              if (!nodeTableBody.querySelector('.error-message')) { // Проверяем, чтобы не дублировать сообщение
                   nodeTableBody.innerHTML = `<tr><td colspan="7" class="error-message">Ошибка инициализации страницы. Не удалось загрузить данные.</td></tr>`;
              }
         }
    }

    // Назначение обработчиков событий
    nodeFormElement.addEventListener('submit', handleNodeFormSubmit);
    nodeCancelButton.addEventListener('click', resetNodeForm);

    // Делегирование событий для кнопок "Редактировать" и "Удалить" в таблице узлов
    nodeTableBody.addEventListener('click', (event) => {
        const editButton = event.target.closest('.edit-btn');
        const deleteButton = event.target.closest('.delete-btn');
        if (editButton) {
            handleEditNodeClick(parseInt(editButton.dataset.id, 10));
        } else if (deleteButton) {
            handleDeleteNodeClick(parseInt(deleteButton.dataset.id, 10), deleteButton.dataset.name);
        }
    });

    // Обработчики для фильтров (перезагрузка списка с первой страницы)
    filterSubdivisionSelectElement.addEventListener('change', () => loadAndRenderNodesTable(1));
    filterTypeSelectElement.addEventListener('change', () => loadAndRenderNodesTable(1));
    filterIncludeChildrenCheckbox.addEventListener('change', () => loadAndRenderNodesTable(1));
    filterIncludeNestedTypesCheckbox.addEventListener('change', () => loadAndRenderNodesTable(1));
    // if (filterSearchTextInput) { // Если будет текстовый поиск
    //    filterSearchTextInput.addEventListener('input', () => loadAndRenderNodesTable(1)); // Или по кнопке
    // }

    // Обработчики для кнопок пагинации
    prevPageButtonElement.addEventListener('click', () => { if (listCurrentPageNumber > 1) loadAndRenderNodesTable(listCurrentPageNumber - 1); });
    nextPageButtonElement.addEventListener('click', () => { if (listCurrentPageNumber * listItemsPerPageCount < listTotalNodesCount) loadAndRenderNodesTable(listCurrentPageNumber + 1); });

    // Начальная загрузка данных при полной загрузке DOM
    document.addEventListener('DOMContentLoaded', initializeManageNodesPage);

</script>
{% endblock %}