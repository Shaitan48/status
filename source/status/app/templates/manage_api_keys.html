<!-- status/app/templates/manage_api_keys.html -->
{# Наследуем базовый шаблон, который содержит общую структуру и навигацию #}
{% extends "base.html" %}

{# Устанавливаем заголовок для этой конкретной страницы #}
{% block title %}Управление API Ключами - Мониторинг ПТК{% endblock %}

{# Добавляем специфичные CSS стили для этой страницы в блок head_extra базового шаблона #}
{% block head_extra %}
<style>
    /* --- Общие стили контейнера и секций --- */
    /* Основной контейнер страницы, разделенный на две колонки: форма слева, список справа */
    .manage-container { display: grid; grid-template-columns: minmax(350px, 1fr) 2fr; gap: 2rem; align-items: start; margin-top: 1rem; }
    /* Стили для карточек (секций) */
    .form-section, .list-section { background-color: var(--card-bg); padding: 1.5rem; border-radius: 5px; box-shadow: var(--card-shadow); border: 1px solid var(--border-color); }
    /* Делаем форму "липкой" при прокрутке */
    .form-section { position: sticky; top: 80px; }
    /* Заголовки секций */
    .form-section h3, .list-section h3 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 0.8rem; margin-bottom: 1rem; }
    /* --- Стили для элементов формы --- */
    .form-group { margin-bottom: 1rem; } /* Отступ между группами полей */
    .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.95em; } /* Лейблы */
    .form-group input[type="text"],
    .form-group input[type="number"],
    .form-group select {
        width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1em;
    } /* Поля ввода и селекты */
    .form-actions { margin-top: 1.5rem; text-align: right; display: flex; justify-content: flex-end; gap: 0.5rem; } /* Контейнер для кнопок формы */
    /* Стили для лейбла и чекбокса "Активен" */
    .form-group label.checkbox-label { display: inline-block; margin-left: 5px; font-weight: normal; cursor: pointer; vertical-align: middle;}
    .form-group input[type="checkbox"] { width: auto; vertical-align: middle;}

    /* --- Стили для фильтров над таблицей --- */
    .filter-controls { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 1.5rem; padding: 1rem; background-color: #f8f9fa; border: 1px solid var(--border-color); border-radius: 4px; }
    .filter-group { display: flex; flex-direction: column; } /* Группа: лейбл + поле */
    .filter-group label { margin-bottom: 5px; font-size: 0.9em; font-weight: 500; }
    .filter-controls select, .filter-controls input { padding: 6px 8px; font-size: 0.95em; border-radius: 3px; border: 1px solid #ccc; min-width: 150px; }
    #apply-filters-btn { align-self: flex-end; padding: 6px 15px; } /* Кнопка Применить */

    /* --- Стили для таблицы ключей --- */
    .keys-table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
    .keys-table th, .keys-table td { border: 1px solid var(--border-color); padding: 8px 12px; text-align: left; vertical-align: middle; }
    .keys-table th { background-color: var(--light-grey); font-weight: 600; white-space: nowrap; }
    .keys-table .actions { text-align: center; white-space: nowrap; width: 100px; } /* Колонка действий */
    .keys-table .actions button { padding: 4px 8px; font-size: 0.9em; cursor: pointer; border: none; border-radius: 3px; color: white; margin: 2px; }
    .keys-table .edit-btn { background-color: var(--warning-color); color: #333; }
    .keys-table .edit-btn:hover { background-color: #e0a800; }
    .keys-table .delete-btn { background-color: var(--danger-color); }
    .keys-table .delete-btn:hover { background-color: #c82333; }

    /* Переключатель статуса "Активен" */
    .active-switch { display: inline-block; position: relative; width: 40px; height: 20px; }
    .active-switch input { opacity: 0; width: 0; height: 0; } /* Скрываем стандартный чекбокс */
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
    .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; } /* Круглый ползунок */
    input:checked + .slider { background-color: var(--success-color); } /* Цвет включенного состояния */
    input:focus + .slider { box-shadow: 0 0 1px var(--success-color); }
    input:checked + .slider:before { transform: translateX(20px); } /* Сдвигаем ползунок вправо */

    /* --- Стили для секции показа сгенерированного ключа --- */
    #generated-key-section { margin-top: 1.5rem; padding: 1rem; border: 1px solid var(--warning-color); background-color: #fff9e6; border-radius: 5px; display: none; /* Изначально скрыто */ }
    #generated-key-section h4 { margin-top: 0; color: #856404; }
    #generated-api-key { font-family: monospace; font-size: 1.1em; word-break: break-all; background-color: #fff; padding: 8px; border: 1px dashed #ccc; border-radius: 3px; display: inline-block; margin-right: 10px; user-select: all; } /* Поле с ключом */
    .copy-key-btn { padding: 5px 10px; font-size: 0.9em; vertical-align: middle;} /* Кнопка копирования */

    /* --- Стили пагинации --- */
    .pagination-controls { margin-top: 1.5rem; text-align: center; }
    .pagination-controls button, .pagination-controls span { display: inline-block; padding: 5px 10px; margin: 0 3px; border: 1px solid #ccc; border-radius: 3px; background-color: #fff; cursor: pointer; font-size: 0.9em; }
    .pagination-controls button:disabled { background-color: #eee; color: #aaa; cursor: not-allowed; }
    .pagination-controls span.current-page { background-color: var(--primary-color); color: white; border-color: var(--primary-color); cursor: default; }

    /* --- Общие стили для сообщений (feedback) --- */
    .feedback-area { min-height: 1.5em; margin-top: 1rem; font-weight: 500; padding: 5px; border-radius: 3px; text-align: center; }
    .feedback-area.error-feedback { color: var(--danger-color); background-color: #f8d7da; border: 1px solid #f5c6cb; }
    .feedback-area.success-feedback { color: var(--success-color); background-color: #d4edda; border: 1px solid #c3e6cb;}
    /* Стили для ошибок валидации конкретных полей */
    .error-feedback { color: var(--danger-color); font-size: 0.9em; margin-top: 5px; display: block; /* Чтобы занимало всю ширину */ min-height: 1em; }

    /* Сообщение о загрузке в таблице */
    .loading-message { text-align: center; padding: 1em; color: var(--secondary-color); font-style: italic; }
    .error-message { color: var(--danger-color); font-weight: bold; text-align: center; padding: 1em;}

</style>
{% endblock %}

{# Основной контент страницы #}
{% block content %}
<h2>Управление API Ключами</h2>

{# Контейнер для основного layout страницы (две колонки) #}
<div class="manage-container">

    <!-- Левая колонка: Форма создания/редактирования ключа -->
    <section class="form-section">
        <h3 id="form-title">Создать Новый API Ключ</h3>
        <form id="api-key-form">
            {# Скрытое поле для хранения ID ключа в режиме редактирования #}
            <input type="hidden" id="edit-key-id">

            {# Поле для ввода описания ключа #}
            <div class="form-group">
                <label for="description">Описание *</label>
                <input type="text" id="description" required placeholder="Например, Онлайн агент для ПУ">
                {# Область для вывода ошибки валидации этого поля #}
                <div class="error-feedback" id="description-error"></div>
            </div>

            {# Выпадающий список для выбора роли ключа #}
            <div class="form-group">
                <label for="role">Роль *</label>
                <select id="role" required>
                    <option value="">-- Выберите роль --</option>
                    <option value="agent">agent (Агент мониторинга)</option>
                    <option value="loader">loader (Загрузчик результатов)</option>
                    <option value="configurator">configurator (Конфигуратор агентов)</option>
                    <option value="admin">admin (Полные права, не рекомендуется)</option>
                </select>
                 <div class="error-feedback" id="role-error"></div>
            </div>

            {# Выпадающий список для привязки к подразделению (по ObjectID) #}
            <div class="form-group">
                <label for="object-id">Привязать к подразделению (опционально)</label>
                <select id="object-id">
                    <option value="">-- Не привязывать --</option>
                    {# Опции будут загружены динамически с помощью JavaScript #}
                </select>
                 <div class="error-feedback" id="object-id-error"></div>
            </div>

            {# Чекбокс "Активен", видимый только при редактировании #}
             <div class="form-group" id="is-active-group" style="display: none;">
                <label class="checkbox-label">
                    <input type="checkbox" id="is-active"> Активен
                </label>
             </div>

            {# Область для вывода общих ошибок формы (например, от API) #}
            <div id="form-feedback" class="feedback-area"></div>

            {# Кнопки действий формы #}
            <div class="form-actions">
                {# Кнопка "Отмена", видимая только при редактировании #}
                <button type="button" id="cancel-edit-btn" style="display: none; background-color: var(--secondary-color);">Отмена</button>
                {# Основная кнопка (Создать/Сохранить) #}
                <button type="submit" id="submit-key-btn">Создать Ключ</button>
            </div>
        </form>

        <!-- Область для показа сгенерированного ключа после успешного создания -->
        <div id="generated-key-section">
            <h4>✅ API Ключ Успешно Создан!</h4>
            <p style="color: #dc3545; font-weight: bold;">
                Пожалуйста, скопируйте ключ сейчас. Он больше не будет показан.
            </p>
            <div style="margin-bottom: 10px;">
                 <code id="generated-api-key"></code> {# Сюда будет вставлен ключ #}
                 <button type="button" class="copy-key-btn" id="copy-key-btn" title="Копировать в буфер">Копировать</button>
            </div>
            <button type="button" id="close-generated-key-btn">Закрыть</button>
        </div>

    </section>

    <!-- Правая колонка: Список существующих ключей -->
    <section class="list-section">
        <h3>Список Существующих Ключей</h3>

        <!-- Блок с фильтрами для таблицы -->
        <div class="filter-controls">
             {# Фильтр по роли #}
             <div class="filter-group">
                 <label for="filter-role">Роль:</label>
                 <select id="filter-role">
                     <option value="">Все</option>
                     <option value="agent">agent</option>
                     <option value="loader">loader</option>
                     <option value="configurator">configurator</option>
                     <option value="admin">admin</option>
                 </select>
             </div>
             {# Фильтр по Object ID подразделения #}
             <div class="filter-group">
                 <label for="filter-object-id">Подразделение (Object ID):</label>
                 <select id="filter-object-id">
                     <option value="">Все</option>
                     {# Опции будут загружены динамически #}
                 </select>
             </div>
             {# Фильтр по статусу активности #}
             <div class="filter-group">
                 <label for="filter-is-active">Статус:</label>
                 <select id="filter-is-active">
                     <option value="">Все</option>
                     <option value="true">Активные</option>
                     <option value="false">Неактивные</option>
                 </select>
             </div>
             {# Кнопка применения фильтров #}
             <button id="apply-filters-btn">Применить</button>
        </div>

        {# Область для сообщений над списком (успех/ошибка удаления/обновления) #}
        <div id="list-feedback" class="feedback-area"></div>

        {# Таблица для отображения ключей #}
        <table class="keys-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Описание</th>
                    <th>Роль</th>
                    <th>Object ID</th>
                    <th>Активен</th>
                    <th>Создан</th>
                    <th>Использован</th>
                    <th>Действия</th>
                </tr>
            </thead>
            {# Тело таблицы, заполняется динамически JavaScript #}
            <tbody id="key-list">
                <tr><td colspan="8" class="loading-message">Загрузка ключей...</td></tr>
            </tbody>
        </table>

        {# Элементы управления пагинацией, изначально скрыты #}
        <div class="pagination-controls" id="pagination-controls" style="display: none;">
            <button id="prev-page" disabled>« Назад</button>
            <span id="page-info">Страница - из -</span>
            <button id="next-page" disabled>Вперед »</button>
        </div>
    </section>
</div>
{% endblock %}

{# Блок для JavaScript кода #}
{% block scripts %}
<script>
    // --- Получение ссылок на элементы DOM ---
    // Элементы формы
    const form = document.getElementById('api-key-form');
    const formTitle = document.getElementById('form-title');
    const submitBtn = document.getElementById('submit-key-btn');
    const cancelBtn = document.getElementById('cancel-edit-btn');
    const editKeyIdInput = document.getElementById('edit-key-id');
    const descriptionInput = document.getElementById('description');
    const roleSelect = document.getElementById('role');
    const objectIdSelect = document.getElementById('object-id'); // Селект для Object ID
    const isActiveGroup = document.getElementById('is-active-group');
    const isActiveCheckbox = document.getElementById('is-active');
    const formFeedback = document.getElementById('form-feedback');
    // Элементы секции сгенерированного ключа
    const generatedKeySection = document.getElementById('generated-key-section');
    const generatedApiKeyElement = document.getElementById('generated-api-key');
    const copyKeyBtn = document.getElementById('copy-key-btn');
    const closeGeneratedKeyBtn = document.getElementById('close-generated-key-btn');
    // Элементы списка и фильтров
    const keyList = document.getElementById('key-list');
    const listFeedback = document.getElementById('list-feedback');
    const filterRoleSelect = document.getElementById('filter-role');
    const filterObjectIdSelect = document.getElementById('filter-object-id'); // Селект для фильтра
    const filterIsActiveSelect = document.getElementById('filter-is-active');
    const applyFiltersBtn = document.getElementById('apply-filters-btn');
    // Элементы пагинации
    const paginationControls = document.getElementById('pagination-controls');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const pageInfoSpan = document.getElementById('page-info');

    // --- URL API эндпоинтов ---
    const API_URL_KEYS = "{{ url_for('api_keys.get_api_keys_route') }}"; // Для GET (список) и POST (создание)
    const API_URL_KEY_DETAIL_TPL = "{{ url_for('api_keys.update_api_key_route', key_id=0) }}"; // Для PUT (обновление) и DELETE
    const API_URL_SUBDIVISIONS = "{{ url_for('subdivisions.api_get_subdivisions') }}"; // Для загрузки подразделений в селекты

    // --- Переменные состояния приложения ---
    let apiKeysCache = []; // Кэш ключей для текущей страницы (для редактирования)
    let subdivisionsCache = []; // Кэш ВСЕХ подразделений для заполнения селектов
    let currentEditKeyId = null; // ID ключа, который редактируется в данный момент
    let currentPage = 1;         // Текущая страница пагинации
    let itemsPerPage = 15;       // Количество ключей на одной странице
    let totalKeys = 0;           // Общее количество ключей (с учетом фильтров)

    // --- Вспомогательные функции ---

    /**
     * Асинхронно выполняет запрос к API, обрабатывает ошибки сети и API.
     * @param {string} url - URL эндпоинта.
     * @param {object} options - Опции для fetch (method, headers, body).
     * @returns {Promise<object|null>} - Promise с распарсенным JSON-ответом или null при успехе без контента (204).
     * @throws {Error} - Кастомная ошибка с полями message, details, code, status при ошибке.
     */
     async function fetchData(url, options = {}) {
        // Показываем индикатор загрузки над списком ТОЛЬКО если это не POST/PUT/DELETE
        const method = options.method ? options.method.toUpperCase() : 'GET';
        if (method === 'GET') {
            showListFeedback('Загрузка...'); // Показываем только для GET
        }
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                // ... (обработка ошибок как раньше) ...
                 let errorText = `Ошибка сети: ${response.status} ${response.statusText}`;
                 let errorDetails = null; let errorCode = 'NETWORK_ERROR';
                 try {
                      const errorData = await response.json();
                      if (errorData && errorData.error) {
                         errorCode = errorData.error.code || 'API_ERROR';
                         if (errorData.error.message) errorText += ` - ${errorData.error.message}`;
                         else if (typeof errorData.error === 'string') errorText += ` - ${errorData.error}`;
                         errorDetails = errorData.error.details || errorData.error.message || errorData.error;
                      } else if (errorData && typeof errorData === 'string') { errorText += ` - ${errorData}`; errorDetails = errorData; }
                      else { errorDetails = errorData; }
                 } catch (e) {
                     try { const rawErrorText = await response.text(); errorText += ` - ${rawErrorText}`; errorDetails = rawErrorText; } catch (e2) {}
                 }
                 const error = new Error(errorText); error.details = errorDetails; error.code = errorCode; error.status = response.status; throw error;
            }
            // Успешный ответ
            if (method === 'GET') {
                 showListFeedback(''); // Очищаем статус загрузки при успехе GET
            }
            if (response.status === 204) return null;
            const text = await response.text();
            try { return text ? JSON.parse(text) : null; }
            catch (e) { console.warn("Не удалось распарсить JSON:", text); return { rawText: text }; }
        } catch (error) {
             console.error("Ошибка fetchData:", error);
             showListFeedback(`Ошибка: ${error.message}`, true); // Показываем ошибку над списком
             throw error;
        }
    }

    /**
     * Отображает ошибки валидации полей формы.
     * @param {object|string} errors - Объект {field_name: message} или строка с общей ошибкой.
     * @param {string} prefix - Префикс ID элементов формы (по умолчанию пустой).
     */
    function displayValidationErrors(errors, prefix = '') {
         clearValidationErrors(prefix); // Очищаем предыдущие ошибки
         let firstErrorField = null; // Для установки фокуса
         const feedbackEl = document.getElementById(`${prefix}form-feedback`); // Область для общих ошибок
         if (!feedbackEl) { console.error("Feedback element not found for prefix:", prefix); return; }

         if (errors && typeof errors === 'object') {
             // Перебираем ошибки по полям
             for (const field in errors) {
                  // Генерируем ID поля и элемента ошибки (e.g., object_id -> object-id)
                  const fieldId = field.replace(/_([a-z])/g, (match, p1) => p1.toUpperCase());
                  const errorElementId = `${prefix}${fieldId}-error`;
                  const inputElementId = `${prefix}${fieldId}`; // ID самого поля ввода/селекта

                  const errorElement = document.getElementById(errorElementId);
                  const inputElement = document.getElementById(inputElementId);

                  if (errorElement) { // Если есть специальный div для ошибки поля
                      errorElement.textContent = errors[field];
                      if (inputElement && !firstErrorField) firstErrorField = inputElement; // Запоминаем первое поле для фокуса
                      if (inputElement) inputElement.classList.add('invalid'); // Можно добавить класс для подсветки поля
                  } else { // Если нет, показываем в общей области под формой
                      console.warn(`Element with id ${errorElementId} not found for field ${field}.`);
                      feedbackEl.textContent += ` ${field}: ${errors[field]}`;
                  }
             }
             if (feedbackEl.textContent) { // Если были общие ошибки
                  feedbackEl.className = 'feedback-area error-feedback';
             } else if (Object.keys(errors).length > 0 && !firstErrorField) {
                  // Если ошибки были, но для них не нашлось полей, покажем общее сообщение
                  feedbackEl.textContent = "Пожалуйста, исправьте ошибки в форме.";
                  feedbackEl.className = 'feedback-area error-feedback';
             }
         } else if (typeof errors === 'string') { // Если передана строка с общей ошибкой
             feedbackEl.textContent = errors;
             feedbackEl.className = 'feedback-area error-feedback';
         }
         // Устанавливаем фокус на первое поле с ошибкой
         if (firstErrorField) { firstErrorField.focus(); }
    }

    /** Очищает ошибки валидации для указанной формы. */
    function clearValidationErrors(prefix = '') {
        const feedbackEl = document.getElementById(`${prefix}form-feedback`);
        if (feedbackEl) { feedbackEl.textContent = ''; feedbackEl.className = 'feedback-area'; }
        document.querySelectorAll(`#${prefix}api-key-form .error-feedback`).forEach(el => el.textContent = '');
        document.querySelectorAll(`#${prefix}api-key-form input.invalid, #${prefix}api-key-form select.invalid`)
                .forEach(el => el.classList.remove('invalid'));
    }

    /** Отображает сообщение в указанном элементе (listFeedback или formFeedback). */
    function showFeedback(element, message, isError = false) {
         if (!element) return;
         element.textContent = message;
         element.className = 'feedback-area'; // Сбрасываем классы
         if (message) { element.classList.add(isError ? 'error-feedback' : 'success-feedback'); }
    }
    /** Показывает сообщение над списком ключей. */
    function showListFeedback(message, isError = false) { showFeedback(listFeedback, message, isError); }
    /** Показывает сообщение под формой создания/редактирования. */
    function showFormFeedback(message, isError = false) { showFeedback(formFeedback, message, isError); }

    /**
     * Форматирует дату в строку локального времени.
     * @param {string|Date} dateStr - Строка даты ISO или объект Date.
     * @returns {string} - Отформатированная строка или 'N/A'.
     */
    function formatDateTime(dateStr) {
        if (!dateStr) return 'N/A';
        try {
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) return 'Неверная дата';
            // Отображаем время в локальной таймзоне пользователя
            return date.toLocaleString('ru-RU', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
        } catch (e) { console.error("Ошибка форматирования даты:", dateStr, e); return 'Ошибка даты'; }
    }

    /**
     * Копирует текст в буфер обмена.
     * @param {string} text - Текст для копирования.
     */
    function copyToClipboard(text) { /* ... (код без изменений из предыдущего ответа) ... */ }

    /**
     * Заполняет HTMLSelectElement опциями из массива данных.
     * Поддерживает иерархию для подразделений (если addHierarchy=true).
     * @param {HTMLSelectElement} selectElement - Целевой select.
     * @param {Array<Object>} items - Массив объектов данных.
     * @param {string} valueField - Имя поля для значения option ('id' или 'object_id').
     * @param {string} textField - Имя поля для текста option ('short_name' или 'name').
     * @param {string} placeholder - Текст для дефолтной пустой опции.
     * @param {boolean} addHierarchy - Строить ли иерархию (использует parent_id и priority)?
     * @param {number|null} excludeId - ID элемента (по 'id'), который и чьих потомков нужно исключить.
     */
     function populateSelect(selectElement, items, valueField, textField, placeholder, addHierarchy = false, excludeId = null) {
        const currentSelectedValue = selectElement.value; // Запоминаем текущее значение
        selectElement.innerHTML = `<option value="">${placeholder}</option>`; // Очищаем и добавляем плейсхолдер

        if (!items || items.length === 0) {
            console.warn(`populateSelect для ${selectElement.id}: нет данных`);
            return;
        }

        if (addHierarchy) { // Логика для иерархического селекта (например, выбор родителя)
            const map = {}; const roots = []; const descendantIds = new Set();
            function getDescendants(itemId) { if (!map[itemId]?.rawChildren) return; map[itemId].rawChildren.forEach(childId => { if (!descendantIds.has(childId)) { descendantIds.add(childId); getDescendants(childId); } }); }
            items.forEach(item => { map[item.id] = { ...item, rawChildren: [] }; }); // Используем ID как ключ карты
            items.forEach(item => { if (item.parent_id !== null && map[item.parent_id]) { map[item.parent_id].rawChildren.push(item.id); } });
            if (excludeId !== null) { descendantIds.add(excludeId); getDescendants(excludeId); }

            const selectMap = {};
            items.forEach(item => { if (!descendantIds.has(item.id)) { selectMap[item.id] = { ...item, children: [] }; if (item.parent_id === null || !selectMap[item.parent_id]) { if (!roots.includes(item.id)) roots.push(item.id); } else if (selectMap[item.parent_id]) { selectMap[item.parent_id].children.push(item.id); } } });

            function addOption(itemId, level) {
                const item = selectMap[itemId]; if (!item) return;
                const option = document.createElement('option');
                option.value = item[valueField]; // valueField здесь обычно 'id'
                const name = item.short_name || item[textField];
                option.textContent = '\u00A0'.repeat(level * 3) + name + ` (ID: ${item.id})`;
                selectElement.appendChild(option);
                item.children.map(id => selectMap[id]).filter(child => child)
                    .sort((a, b) => (a.priority || 999) - (b.priority || 999) || (a.short_name || a[textField]).localeCompare(b.short_name || b[textField]))
                    .forEach(child => addOption(child.id, level + 1));
            }
            roots.map(id => selectMap[id]).filter(root => root)
                .sort((a, b) => (a.priority || 999) - (b.priority || 999) || (a.short_name || a[textField]).localeCompare(b.short_name || b[textField]))
                .forEach(root => addOption(root.id, 0));

        } else { // Плоский список (для фильтра и выбора ObjectID в форме)
            items
                .filter(item => item[valueField] !== null && item[valueField] !== undefined) // Отфильтровываем элементы без нужного значения (особенно для object_id)
                .sort((a, b) => (a[textField] || '').localeCompare(b[textField] || '')) // Сортируем по тексту
                .forEach(item => {
                    const option = document.createElement('option');
                    option.value = item[valueField]; // valueField тут может быть 'object_id'
                    option.textContent = item[textField];
                    // Добавляем ObjectID в текст опции для ясности, если он есть
                    if (item.object_id !== null && item.object_id !== undefined) {
                         option.textContent += ` (OID: ${item.object_id})`;
                    } else {
                         option.textContent += ` (ID: ${item.id})`;
                    }
                    selectElement.appendChild(option);
                });
        }

        // Восстанавливаем выбор
        if (currentSelectedValue && selectElement.querySelector(`option[value="${currentSelectedValue}"]`)) {
            selectElement.value = currentSelectedValue;
        } else {
            selectElement.value = "";
        }
    }


    // --- Функции рендеринга и UI ---

    /** Рендерит таблицу API ключей */
    function renderKeyTable(keys) {
         if (!Array.isArray(keys)) {
             keyList.innerHTML = `<tr><td colspan="8" class="error-message">Ошибка: Некорректные данные ключей.</td></tr>`;
             return;
         }
         // <<< ИСПРАВЛЕНО: Убрали проверку `keys.length === 0` здесь, т.к. она ниже >>>

         // <<< ИСПРАВЛЕНО: Очищаем ЛЮБОЕ предыдущее содержимое, включая "Загрузка..." >>>
         keyList.innerHTML = '';

         // Если массив пустой, показываем сообщение
         if (keys.length === 0) {
             const filtersActive = filterRoleSelect.value || filterObjectIdSelect.value || filterIsActiveSelect.value;
             keyList.innerHTML = `<tr><td colspan="8" style="text-align: center;">API ключи не найдены${filtersActive ? ' (с учетом фильтров)' : ''}.</td></tr>`;
             return;
         }

        // <<< ИСПРАВЛЕНО: Отображаем ObjectID, если он есть, из данных ключа напрямую >>>
         keys.forEach(key => {
             const created = formatDateTime(key.created_at);
             const lastUsed = formatDateTime(key.last_used_at);
             const activeChecked = key.is_active ? 'checked' : '';
             const objIdText = key.object_id !== null ? key.object_id : '---'; // Используем данные ключа

             const activeSwitch = `
                 <label class="active-switch">
                     <input type="checkbox" class="active-toggle" data-id="${key.id}" ${activeChecked}>
                     <span class="slider"></span>
                 </label>
             `;

             const row = keyList.insertRow();
             row.dataset.id = key.id;
             row.innerHTML = `
                 <td>${key.id}</td>
                 <td>${key.description || '---'}</td>
                 <td>${key.role}</td>
                 <td>${objIdText}</td>
                 <td>${activeSwitch}</td>
                 <td title="${key.created_at || ''}">${created}</td>
                 <td title="${key.last_used_at || ''}">${lastUsed}</td>
                 <td class="actions">
                      <button class="edit-btn" data-id="${key.id}" title="Редактировать">✏️</button>
                      <button class="delete-btn" data-id="${key.id}" data-description="${key.description || `ID ${key.id}`}" title="Удалить ключ">🗑️</button>
                 </td>
             `;
         });
    }

    /** Обновляет элементы управления пагинацией */
    function renderPagination() {
        // ... (код рендеринга пагинации без изменений)
         if (!paginationControls || !pageInfoSpan || !prevPageBtn || !nextPageBtn) return;
         const totalPages = Math.ceil(totalKeys / itemsPerPage);
         pageInfoSpan.textContent = `Страница ${currentPage} из ${totalPages} (Всего: ${totalKeys})`;
         prevPageBtn.disabled = currentPage <= 1;
         nextPageBtn.disabled = currentPage >= totalPages;
         paginationControls.style.display = totalKeys > 0 && totalPages > 1 ? 'block' : 'none';
    }

    /** Загружает и рендерит ключи с учетом фильтров и пагинации */
    async function loadAndRenderKeys(page = 1) {
        // Показываем "Загрузка..." в ТАБЛИЦЕ, а не в общем фидбеке
        keyList.innerHTML = `<tr><td colspan="8" class="loading-message">Загрузка ключей...</td></tr>`;
        // Очищаем общий фидбек
        showListFeedback('');
        currentPage = page;
        const offset = (currentPage - 1) * itemsPerPage;

        const params = new URLSearchParams();
        params.append('limit', itemsPerPage);
        params.append('offset', offset);
        if (filterRoleSelect.value) params.append('role', filterRoleSelect.value);
        if (filterObjectIdSelect.value) params.append('object_id', filterObjectIdSelect.value);
        if (filterIsActiveSelect.value) params.append('is_active', filterIsActiveSelect.value);

        try {
            const url = `${API_URL_KEYS}?${params.toString()}`;
            // Вызываем fetchData без показа "Загрузка..." в listFeedback
            const result = await fetchData(url); // fetchData сама очистит listFeedback при успехе GET
            apiKeysCache = (result && result.items) ? result.items : [];
            totalKeys = (result && result.total_count !== undefined) ? result.total_count : apiKeysCache.length;
            renderKeyTable(apiKeysCache); // Рендерим таблицу (она обработает пустой массив)
            renderPagination();
            // showListFeedback(''); // Уже очищено в fetchData
        } catch (error) {
            console.error("Ошибка загрузки API ключей:", error);
            // Сообщение об ошибке покажется в listFeedback из fetchData
            keyList.innerHTML = `<tr><td colspan="8" class="error-message">Не удалось загрузить ключи.</td></tr>`;
            renderPagination(); // Показываем пагинацию с 0 записей
        }
    }

    /** Показывает секцию с сгенерированным ключом */
    function displayGeneratedKey(apiKey) {
        generatedApiKeyElement.textContent = apiKey;
        generatedKeySection.style.display = 'block';
        generatedKeySection.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // --- Функции формы ---
    /** Сбрасывает форму в состояние добавления нового ключа */
    function resetForm() {
        form.reset(); // Сбрасывает значения полей
        editKeyIdInput.value = ''; currentEditKeyId = null; // Сбрасываем ID редактирования
        formTitle.textContent = 'Создать Новый API Ключ'; // Возвращаем заголовок
        submitBtn.textContent = 'Создать Ключ'; // Возвращаем текст кнопки
        submitBtn.disabled = false; // Разблокируем кнопку
        cancelBtn.style.display = 'none'; // Скрываем кнопку Отмена
        isActiveGroup.style.display = 'none'; // Скрываем чекбокс Active
        // objectIdSelect.disabled = false; // Разблокируем селект, если блокировали
        clearValidationErrors(); // Очищаем ошибки валидации
        showFormFeedback(''); // Очищаем общие сообщения формы
        generatedKeySection.style.display = 'none'; // Скрываем секцию с ключом
    }

    /**
     * Заполняет форму данными ключа для редактирования.
     * @param {object} apiKeyData - Объект с данными ключа (из API или кэша).
     */
    function fillFormForEdit(apiKeyData) {
        resetForm(); // Сначала сбрасываем форму
        currentEditKeyId = apiKeyData.id;
        editKeyIdInput.value = apiKeyData.id; // Заполняем скрытое поле ID
        formTitle.textContent = `Редактировать API Ключ ID: ${apiKeyData.id}`;
        submitBtn.textContent = 'Сохранить';
        cancelBtn.style.display = 'inline-block'; // Показываем кнопку Отмена
        isActiveGroup.style.display = 'block'; // Показываем чекбокс Active

        // Заполняем поля формы
        descriptionInput.value = apiKeyData.description || '';
        roleSelect.value = apiKeyData.role || '';
        objectIdSelect.value = apiKeyData.object_id !== null ? apiKeyData.object_id : ''; // Устанавливаем селект
        isActiveCheckbox.checked = apiKeyData.is_active === true;

        // Можно заблокировать изменение роли/object_id, если нужно
        // roleSelect.disabled = true;
        // objectIdSelect.disabled = true;

        generatedKeySection.style.display = 'none'; // Скрываем секцию с ключом
        form.scrollIntoView({ behavior: 'smooth', block: 'start' }); // Прокрутка к форме
    }

    // --- Обработчики событий ---

    /** Обрабатывает отправку формы (создание или обновление) */
    async function handleFormSubmit(event) {
        event.preventDefault();
        clearValidationErrors();
        showFormFeedback('');
        generatedKeySection.style.display = 'none'; // Скрываем на случай, если была открыта
        submitBtn.disabled = true;
        submitBtn.textContent = currentEditKeyId ? 'Сохранение...' : 'Создание...';

        // Собираем данные из формы
        const formData = {
            description: descriptionInput.value.trim(),
            role: roleSelect.value, // Роль берем из селекта
            object_id: objectIdSelect.value ? parseInt(objectIdSelect.value, 10) : null // ObjectID берем из селекта
        };

        // Добавляем статус активности только при редактировании
        if (currentEditKeyId) {
            formData.is_active = isActiveCheckbox.checked;
        }

        // Валидация на клиенте
        let clientErrors = {};
        if (!formData.description) clientErrors.description = 'Описание обязательно.';
        if (!currentEditKeyId && !formData.role) clientErrors.role = 'Роль обязательна при создании.';
        // Проверка object_id не нужна, т.к. используем select

        if (Object.keys(clientErrors).length > 0) {
            displayValidationErrors(clientErrors);
            submitBtn.disabled = false; submitBtn.textContent = currentEditKeyId ? 'Сохранить' : 'Создать Ключ';
            return;
        }

        // Определяем URL и метод
        const url = currentEditKeyId ? API_URL_KEY_DETAIL_TPL.replace('/0', `/${currentEditKeyId}`) : API_URL_KEYS;
        const method = currentEditKeyId ? 'PUT' : 'POST';

        // При редактировании удаляем роль из отправляемых данных, если она пустая (чтобы не сбросить случайно)
        if (currentEditKeyId && !formData.role) {
            delete formData.role;
        }

        try {
            const result = await fetchData(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            });

            // Обработка результата
            if (method === 'POST' && result && result.api_key) { // Успешное создание
                 displayGeneratedKey(result.api_key);
                 form.reset(); // Очищаем форму
                 showListFeedback('Ключ успешно создан! Не забудьте его сохранить.', false);
                 await loadAndRenderKeys(1); // Обновляем таблицу (переходим на 1 страницу)
            } else if (method === 'PUT') { // Успешное обновление
                 showListFeedback(`Ключ ID ${currentEditKeyId} успешно обновлен.`, false);
                 resetForm(); // Сбрасываем форму после редактирования
                 await loadAndRenderKeys(currentPage); // Обновляем ТЕКУЩУЮ страницу
            } else if (method === 'POST') { // Ошибка создания (API не вернул ключ)
                 throw new Error("API не вернул сгенерированный ключ.");
            }

        } catch (error) {
            console.error(`Ошибка ${method} API ключа:`, error);
            displayValidationErrors(error.details); // Показываем ошибки валидации от сервера
            showFormFeedback(`Ошибка: ${error.message}`, true); // Общая ошибка формы
        } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = currentEditKeyId ? 'Сохранить' : 'Создать Ключ';
        }
    }

    /** Обрабатывает изменение статуса активности ключа */
    async function handleToggleActive(keyId, isActive) {
        showListFeedback(`Обновление статуса ключа ID ${keyId}...`);
        const url = API_URL_KEY_DETAIL_TPL.replace('/0', `/${keyId}`);
        try {
            // Отправляем только изменение статуса
            await fetchData(url, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ is_active: isActive })
            });
            showListFeedback(`Статус ключа ID ${keyId} успешно обновлен.`, false);
            // Обновляем кэш локально для консистентности
            const keyInCache = apiKeysCache.find(k => k.id === keyId);
            if (keyInCache) keyInCache.is_active = isActive;
        } catch (error) {
            console.error("Ошибка обновления статуса ключа:", error);
            showListFeedback(`Ошибка обновления статуса: ${error.message}`, true);
            // Откатываем чекбокс
            const checkbox = keyList.querySelector(`.active-toggle[data-id="${keyId}"]`);
            if (checkbox) checkbox.checked = !isActive;
        }
    }

    /** Обрабатывает удаление ключа */
    async function handleDeleteClick(keyId, description) {
        if (!confirm(`Вы уверены, что хотите удалить API ключ "${description}" (ID: ${keyId})? Это действие необратимо.`)) return;
        showListFeedback(`Удаление ключа ID ${keyId}...`);
        const url = API_URL_KEY_DETAIL_TPL.replace('/0', `/${keyId}`);
        try {
            await fetchData(url, { method: 'DELETE' }); // Ожидаем 204 No Content
            showListFeedback(`Ключ ID ${keyId} "${description}" успешно удален.`, false);
            // Если удалили редактируемый ключ, сбрасываем форму
            if (currentEditKeyId === keyId) { resetForm(); }
            // Перезагружаем ТЕКУЩУЮ страницу (или первую, если на текущей не осталось элементов?)
            // Простой вариант: перезагрузить текущую
            await loadAndRenderKeys(currentPage);
        } catch (error) {
            console.error("Ошибка удаления ключа:", error);
            // Сообщение об ошибке уже показано в fetchData
        }
    }

     /** Обрабатывает клик на кнопку редактирования в таблице */
     function handleEditClick(keyId) {
         const keyData = apiKeysCache.find(k => k.id === keyId); // Ищем в кэше текущей страницы
         if (keyData) {
             fillFormForEdit(keyData); // Заполняем форму
         } else {
             // Если данных нет в кэше (например, после фильтрации/пагинации),
             // нужно запросить их отдельно (можно добавить эту логику при необходимости)
             console.error(`Данные для ключа ${keyId} не найдены в кэше текущей страницы.`);
             showListFeedback(`Не удалось найти данные для редактирования ключа ${keyId}. Попробуйте обновить список.`, true);
         }
     }

     // <<< Функция для начальной загрузки данных для селектов >>>
    async function loadSelectData() {
        showListFeedback("Загрузка данных для фильтров...");
        try {
            const subdivisionsRes = await fetchData(API_URL_SUBDIVISIONS + '?limit=1000'); // Загружаем все подразделения
            subdivisionsCache = (subdivisionsRes && subdivisionsRes.items) ? subdivisionsRes.items : [];

            console.log("Subdivisions loaded for selects:", subdivisionsCache); // Лог загруженных подразделений

            // Заполняем селект в форме (значение - object_id, текст - short_name + OID)
            // Используем textField='short_name' и valueField='object_id'
            // Третий параметр textfield не используется для иерархии, она берет short_name
            populateSelect(objectIdSelect, subdivisionsCache, 'object_id', 'short_name', '-- Не привязывать --', true);

            // Заполняем селект в фильтре (значение - object_id, текст - short_name + OID)
            // Без иерархии
            populateSelect(filterObjectIdSelect, subdivisionsCache, 'object_id', 'short_name', 'Все объекты', false);

            showListFeedback(""); // Очищаем сообщение о загрузке
        } catch (error) {
             console.error("Ошибка загрузки данных для селектов:", error);
             // Ошибка уже показана в fetchData
             // Можно добавить специфичное сообщение, если нужно
             // showListFeedback("Ошибка загрузки справочников для фильтров.", true);
        }
    }


    // --- Инициализация страницы ---
    /** Загружает начальные данные (подразделения) и первую страницу ключей */
    async function initializePage() {
         // Сначала покажем сообщение в таблице
         keyList.innerHTML = `<tr><td colspan="8" class="loading-message">Инициализация...</td></tr>`;
         try {
             await loadSelectData(); // Загружаем данные для селектов
             await loadAndRenderKeys(1); // Затем первую страницу ключей
         } catch(e) {
              // Ошибки уже обработаны и выведены в loadSelectData и loadAndRenderKeys
              console.error("Критическая ошибка во время инициализации:", e);
              // Убедимся, что в таблице сообщение об ошибке, а не "Инициализация"
              if (!keyList.querySelector('.error-message')) {
                   keyList.innerHTML = `<tr><td colspan="8" class="error-message">Ошибка инициализации страницы.</td></tr>`;
              }
         }
    }

    // --- Назначение обработчиков событий ---
    form.addEventListener('submit', handleFormSubmit);
    copyKeyBtn.addEventListener('click', () => copyToClipboard(generatedApiKeyElement.textContent));
    closeGeneratedKeyBtn.addEventListener('click', () => generatedKeySection.style.display = 'none');
    // Кнопка Применить фильтры
    applyFiltersBtn.addEventListener('click', () => loadAndRenderKeys(1));
    // Кнопка отмены редактирования
    cancelBtn.addEventListener('click', resetForm);

    // Делегирование событий для таблицы
    keyList.addEventListener('change', (event) => {
        if (event.target.classList.contains('active-toggle')) {
            const keyId = parseInt(event.target.dataset.id, 10);
            const isActive = event.target.checked;
            handleToggleActive(keyId, isActive);
        }
    });
    keyList.addEventListener('click', (event) => {
        const deleteBtn = event.target.closest('.delete-btn');
        const editBtn = event.target.closest('.edit-btn');
        if (deleteBtn) {
            handleDeleteClick(parseInt(deleteBtn.dataset.id, 10), deleteBtn.dataset.description);
        } else if (editBtn) {
             handleEditClick(parseInt(editBtn.dataset.id, 10));
        }
    });

    // Обработчики пагинации
    prevPageBtn.addEventListener('click', () => { if (currentPage > 1) loadAndRenderKeys(currentPage - 1); });
    nextPageBtn.addEventListener('click', () => { if (currentPage * itemsPerPage < totalKeys) loadAndRenderKeys(currentPage + 1); });

    // Начальная загрузка данных
    document.addEventListener('DOMContentLoaded', initializePage);

</script>
{% endblock %}