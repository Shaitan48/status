# **Status Monitor DB — Архитектура и Документация (v5.0.1)**

## **Назначение**

**Status Monitor** — модульная система централизованного мониторинга серверов, рабочих станций и сетевых узлов.
Проект поддерживает сценарии для гибридного агента, позволяет гибко задавать задания и их последовательность (pipeline) через JSON, поддерживает расширяемый набор методов контроля, хранит историю проверок и событий.

---

## **Структура схемы**

База разделена на следующие ключевые блоки:

*   Настройки и пользователи: параметры, пользователи, API-ключи
*   Организационная структура: подразделения, узлы, их типы и свойства
*   Методы и свойства проверок: справочники методов (шагов pipeline)
*   Назначения и история проверок: задания на проверки (pipeline), сами проверки и детализация результатов
*   Системные события: аудит/журналирование
*   Версионирование оффлайн-агентов

---

## **Схема и основные таблицы**

### 1. **settings**

| Поле        | Тип  | Описание                     |
| ----------- | ---- | ---------------------------- |
| key         | TEXT | Уникальный ключ настройки    |
| value       | TEXT | Значение настройки           |
| description | TEXT | Пояснение для администратора |

**Используется для хранения глобальных настроек приложения.**

---

### 2. **users**

| Поле           | Тип          | Описание                   |
| -------------- | ------------ | -------------------------- |
| id             | SERIAL PK    | Уникальный ID пользователя |
| username       | VARCHAR(80)  | Логин пользователя         |
| password\_hash | VARCHAR(255) | Хеш пароля (bcrypt/sha256) |
| is\_active     | BOOLEAN      | Активен ли пользователь    |
| created\_at    | TIMESTAMPTZ  | Дата создания              |

**Аутентификация и управление доступом в UI.**

---

### 3. **api\_keys**

| Поле           | Тип         | Описание                      |
| -------------- | ----------- | ----------------------------- |
| id             | SERIAL PK   | Уникальный ID ключа           |
| key\_hash      | VARCHAR(64) | SHA-256 хеш ключа             |
| description    | TEXT        | Описание ключа                |
| role           | VARCHAR(50) | Роль (agent, admin, ...)      |
| object\_id     | INTEGER     | Связь с подразделением        |
| is\_active     | BOOLEAN     | Ключ активен                  |
| created\_at    | TIMESTAMPTZ | Дата создания                 |
| last\_used\_at | TIMESTAMPTZ | Дата последнего использования |

**Аутентификация агентов и внешних сервисов.**

---

### 4. **subdivisions**

Организационная иерархия — подразделения (например, филиалы, цеха, группы).

**Ключевые поля:**

* `object_id` — внешний ID для привязки (например, из ERP)
* `parent_id` — иерархия
* `transport_system_code` — уникальный код для offline-агентов
* `priority` — сортировка, `icon_filename` — для UI

---

### 5. **nodes**

Сущности для мониторинга: сервера, ПК, сетевые устройства, виртуалки, контейнеры и др.

| Поле                    | Тип     | Описание               |
| ----------------------- | ------- | ---------------------- |
| id                      | SERIAL  | PK                     |
| name                    | VARCHAR | Имя (hostname)         |
| parent\_subdivision\_id | INTEGER | Связь с подразделением |
| ip\_address             | VARCHAR | IP (если есть)         |
| node\_type\_id          | INTEGER | Ссылка на node\_types  |
| description             | TEXT    | Описание               |

---

### 6. **node\_types, node\_property\_types, node\_properties**

* **node\_types** — справочник типов (сервер, ПК, контроллер и пр.)
* **node\_property\_types** — определяет возможные свойства типа узла (например, таймаут, путь иконки)
* **node\_properties** — значения свойств для конкретного типа узла

---

### 7. **check_methods**
**Справочник методов контроля (типов шагов pipeline)** — PING, PROCESS_LIST, POWERSHELL_EXECUTE, SQL_EXECUTE, LOG_FILE_ANALYZE и т.д.
Каждый шаг в `pipeline` задания будет иметь тип из этого справочника.
**Расширяется при добавлении новых типов шагов для агента!**

---

### 8. **node_check_assignments** (ядро: задания)

| Поле                     | Тип     | Описание                                       |
| ------------------------ | ------- | ---------------------------------------------- |
| id                       | SERIAL  | PK                                             |
| node_id                  | INT     | Ссылка на узел (`nodes.id`)                    |
| method_id                | INT     | Ссылка на основной метод/тип задания (`check_methods.id`) для классификации. |
| pipeline                 | JSONB   | **Описание pipeline** (массив объектов шагов). |
| check_interval_seconds | INT     | Периодичность выполнения задания (агентом).    |
| is_enabled               | BOOLEAN | **Флаг активности задания** (true/false).      |
| description              | TEXT    | Пояснение к заданию.                           |
| last_executed_at         | TIMESTAMPTZ | Время последнего выполнения (или записи результата). |
| last_node_check_id       | INT     | Ссылка на последнюю запись в `node_checks`.    |

**`pipeline`** — это JSON-массив объектов, где каждый объект описывает один шаг мониторинга.
Пример `pipeline` для задания "Проверить диск, затем проанализировать результат":
```json
[
  {
    "type": "DISK_USAGE", // Имя из check_methods
    "description": "Проверка диска C:",
    "parameters": { "drives": ["C"] },
    "success_criteria": { // Критерии успеха для ЭТОГО шага
      "disks": {
        "_condition_": "all",
        "_where_": {"drive_letter": "C"},
        "_criteria_": {"percent_free": {">=": 10}}
      }
    }
  },
  {
    "type": "POWERSHELL_EXECUTE",
    "description": "Анализ свободного места (если предыдущий шаг вернул данные в $input)",
    "parameters": {
      "script": "if ($input.disks[0].percent_free -lt 5) { Write-Error 'Мало места!' }"
    }
    // success_criteria для PowerShell может быть основан на exit code или выводе
  }
]
---

### 9. **node\_checks** (история выполнения)

| Поле             | Тип         | Описание                 |
| ---------------- | ----------- | ------------------------ |
| id               | SERIAL      | PK                       |
| node\_id         | INT         | Узел                     |
| assignment\_id   | INT         | Задание                  |
| method\_id       | INT         | Метод                    |
| is\_available    | BOOLEAN     | Основной результат       |
| checked\_at      | TIMESTAMPTZ | Когда пришёл результат   |
| check\_timestamp | TIMESTAMPTZ | Когда агент выполнил чек |
| ...              | ...         | Отладочные поля          |

---

### 10. **node\_check\_details**

JSON-детализация для node\_checks — можно хранить структуру любых результатов (например, список процессов, файл-логи, таблицы и т.д.).

---

### 11. **system\_events**

Журнал событий системы.
Все ошибки, критические сообщения, действия агентов и пользователей.

---

### 12. **offline\_config\_versions**

Трекинг версий заданий и скриптов для offline-агентов.

---

Особенности архитектуры
Pipeline

    Позволяет реализовать многошаговые задания, подобные конвейеру PowerShell (или bash).

    Каждый шаг pipeline определяется своим type (из check_methods), может иметь свои parameters и success_criteria.

    Агент выполняет шаги последовательно. Результат предыдущего шага может (но не обязан) передаваться на вход следующему.

    Расширяемо: для новых видов проверки/действия добавь новый тип в check_methods и реализуй его логику в агенте.

Гибкость

    Можно задать сложную логику анализа, например:

        Шаг 1: Получить список процессов (type: PROCESS_LIST).

        Шаг 2: Если найден процесс "X", выполнить SQL-запрос (type: SQL_QUERY_EXECUTE).

        Шаг 3: Проанализировать лог-файл (type: LOG_FILE_ANALYZE).

### **История и аудит**

* Вся история выполнения (успех/ошибка, детали) фиксируется для последующего аудита и аналитики.
* Журнал событий сохраняет критические инциденты, неудачные попытки аутентификации и действия агентов.

---

## **Примеры pipeline**

**Пример 1: Простой Пинг**

[
  {
    "type": "PING",
    "description": "Пинг узла 8.8.8.8",
    "parameters": { "target": "8.8.8.8", "count": 3 },
    "success_criteria": { "rtt_ms": { "<=": 100 }, "packet_loss_percent": { "==": 0 } }
  }
]
```

**Пример 2: Проверка службы и запись в лог, если остановлена**

```json
[
  {
    "type": "SERVICE_STATUS",
    "description": "Проверка службы 'Spooler'",
    "parameters": { "service_name": "Spooler" },
    "success_criteria": { "status": "Running" }
  },
  {
    "type": "POWERSHELL_EXECUTE",
    "description": "Залогировать, если Spooler не запущен (шаг выполняется, если предыдущий вернул $false в CheckSuccess)",
    "parameters": {
      "script": "if (-not $previous_step_success) { Add-Content -Path C:\\temp\\spooler_stopped.log -Value \"Spooler stopped at $(Get-Date)\" }"
    }
    // Условие выполнения этого шага должно быть частью логики агента или специального "conditional_execute" шага
  }
]
```

---

## **Расширение схемы**

* Для добавления нового типа задания — впиши его в `check_methods`.
* Для новых параметров pipeline — просто используй новые свойства в JSON объекта шага.
* Можно интегрировать новые типы агентов (например, для Linux — bash-скрипты или сторонние команды).

---

## **Рекомендации по миграциям**

* Используй liquibase, Flyway, Alembic или стандартные миграционные скрипты.
* Сохраняй совместимость pipeline (JSON) при изменениях шагов или структуры.

---

## **Контакт и поддержка**

**Главный разработчик/архитектор:**

* Telegram: @doushi-shousa
* E-mail: \[добавь свой e-mail/контакт]
* \[GitHub/GitLab проекта, если есть]

---

## **История изменений**

* v5.0: Архитектура с pipeline, полный отказ от success\_criteria, максимальная модульность
* v4.3: Переход на jsonb параметры, расширение справочников
* v3.x: Первая production-версия с offline-агентами

---

## **Примеры интеграции и старта**

**Запуск контейнера с PostgreSQL:**

```bash
docker run -d \
  --name status_pg \
  -e POSTGRES_PASSWORD=your_password \
  -v /your/path/initdb:/docker-entrypoint-initdb.d \
  -p 5432:5432 \
  postgres:14
```

---

**Остались вопросы?**
Пиши, если нужно добавить расширенную инструкцию по API, или примеры SQL-запросов для выгрузки/анализа данных.

---

**Status Monitor** — твой инструмент для комплексного, кастомного и автоматизированного мониторинга любых инфраструктур!
