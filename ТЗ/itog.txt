Хорошо, давайте сформируем итоговое ТЗ версии 5.2, включающее **Гибридный Агент** и все сопутствующие доработки. Я добавлю пояснения и комментарии (`*** Комментарий: ... ***` или внутри кода) для лучшего понимания изменений и логики.

---

## Технические Задания (ТЗ) для Модулей Проекта "Status Monitor" (v5.2 Комплексное, Гибридный Агент)

### Введение (Без изменений)

Это техническое задание (ТЗ) описывает доработанную и объединенную архитектуру проекта "Status Monitor", системы мониторинга IT-инфраструктуры. Основная цель — обеспечить гибкость для добавления новых типов проверок (например, мониторинг загрузки процессора, дискового пространства, кастомных SQL-запросов) и визуализации их результатов, включая исторические данные, в веб-интерфейсе. Проект разделен на ключевые модули, каждый из которых обновлен для поддержки модульности, хранения исторических данных, динамической конфигурации и визуализации. Эти изменения позволят вести разработку отдельных модулей и тестов для каждой системы, минимизируя риски и обеспечивая масштабируемость.

### Общая Схема Взаимодействия Модулей (Обновлено для Гибридного Агента и унифицированного API)

```mermaid
graph LR
    subgraph "Клиентская Часть (PowerShell)"
        UA["Utils: StatusMonitorAgentUtils"]
        HA["Агент: Гибридный (Online/Offline режим)"]
        CFG["Утилита: Конфигуратор"]
        LOAD["Утилита: Загрузчик Результатов"]
    end

    subgraph "Серверная Часть (Docker)"
        API["API Сервер (Flask)"]
        UI["Web UI (Flask Templates + Frontend Logic)"]
        NG["Веб-Сервер (Nginx)"]
        DB["БД (PostgreSQL)"]
        DBInit["[Инициализация БД]"]
    end

    subgraph "Внешние Системы/Пользователи"
        User[("Пользователь (Администратор)")]
        FS[("Файловая Система/Транспорт")]
    end

    %% Связи
    User -- Управление, Просмотр --> UI
    UI -- HTTP Запросы (HTML, AJAX), WS --> NG
    NG -- Проксирует UI запросы, WS --> API
    NG -- Отдает статику (JS, CSS, Images) --> User
    NG -- Проксирует API запросы --> API
    API -- SQL Запросы, вызовы процедур --> DB
    API -- WebSocket Events --> UI %% Через Nginx -> Клиент
    DBInit -- Инициализирует --> DB

    %% --- Связи Гибридного Агента (HA) ---
    HA -- Использует --> UA

    subgraph "HA - Online Режим"
        HA -- Запрос заданий (GET /api/v1/assignments) --> API
        %% Отправляет массив из одного элемента
        HA -- Отправка результатов (POST /api/v1/checks, Body: [ {...} ]) --> API
    end

    subgraph "HA - Offline Режим + Вспомогательные"
        CFG -- Запрос конфига (GET /api/v1/objects/.../offline_config) --> API
        CFG -- Записывает файл (атомарно) --> FS
        FS -- Доставка конфига --> HA

        HA -- Читает конфиг (Offline) --> FS
        HA -- Записывает результат (*.zrpu, атомарно, Offline) --> FS
        FS -- Доставка результата --> LOAD

        LOAD -- Читает результат (*.zrpu) --> FS
        LOAD -- Отправка результатов (POST /api/v1/checks, Body: [ {...}, {...} ]) --> API
        LOAD -- Отправка события (POST /api/v1/events) --> API
        LOAD -- Перемещает файл (атомарно, в Processed/Error/DLQ) --> FS
    end


    style DBInit fill:#ddd,stroke:#333,stroke-width:1px,stroke-dasharray: 5 5
```
***Комментарий:*** *Диаграмма обновлена: Online и Offline агенты заменены на единый Гибридный Агент (HA). API для отправки результатов унифицирован (POST /checks принимает массив), эндпоинт /checks/bulk удален из схемы.*

---

### 1. Модуль: База Данных (Инициализация и Схема)

*   **Версия:** ~5.1.0 *(Без изменений от предыдущей итерации)*
*   **Назначение и область ответственности:**
    *   Определение и поддержка реляционной схемы PostgreSQL.
    *   Обеспечение целостности и непротиворечивости данных.
    *   Механизм автоматической инициализации/обновления схемы.
    *   Инкапсуляция логики в хранимых функциях/процедурах.
*   **Ключевые Компоненты/Файлы:**
    *   `postgres/db_schema/*.sql`: Структура БД.
    *   `postgres/db_core_data/*.sql`: Базовые справочники.
    *   `postgres/db_seed_data/**/*.sql`: Тестовые данные.
    *   `postgres/docker-compose.yaml`: Настройка сервиса.
*   **Входные данные:** SQL-скрипты, Переменные Docker.
*   **Методы обработки (основная логика):**
    1.  **Инициализация Docker:** Выполнение скриптов `/docker-entrypoint-initdb.d/`.
    2.  **Хранимые процедуры/функции:**
        *   `record_check_result(...)`: Принимает данные **одной** проверки. Вызывается API для каждой записи из пакета. Проверяет FK, записывает `node_checks` и `node_check_details`, обновляет статус в `node_check_assignments`, создает события.
        *   `generate_offline_config(...)`: Формирует JSON конфигурации для оффлайн-режима агента, управляет версионированием, создает событие.
        *   `get_active_assignments_for_object(...)`: Возвращает задания для онлайн-режима агента.
        *   `get_node_base_info(...)`, `get_processed_node_status(...)`, `create_api_key(...)`: Вспомогательные функции.
*   **Выходные данные:**
    *   Экземпляр PostgreSQL с настроенной БД (`pu_db`).
    *   **Структура БД:** (Как в v5.1, включает `check_methods` с полями для визуализации, `system_events` с расширенными типами и т.д.)
    *   **Данные:** Заполненные справочники, настройки.
*   **Описание взаимодействия с другими модулями:**
    *   <-> **Модуль 2 (Backend API).**
    *   <- **Docker Compose.**
*   **Конфигурация:** `docker-compose.yaml`, SQL файлы.
*   **Error Handling:** Ограничения БД, ошибки процедур.
*   **Future Considerations/Improvements:** Alembic для миграций, Оптимизация/партиционирование, TimescaleDB.

---

### 2. Модуль: Центральный Сервер (Backend API)

*   **Версия:** ~5.2 (Основа v5.1 + унификация API + WebSocket)
*   **Назначение и область ответственности:**
    *   Предоставление HTTP RESTful API.
    *   **Обработка входящих массивов результатов проверок.**
    *   Предоставление конфигурации агентам.
    *   Реализация бизнес-логики.
    *   Аутентификация/Авторизация.
    *   Взаимодействие с БД.
    *   Отправка real-time уведомлений через WebSocket (Flask-SocketIO).
*   **Ключевые Компоненты/Файлы:**
    *   `status/app/`: Код Flask-приложения.
    *   `status/app/app.py`: Инициализация SocketIO.
    *   `status/app/routes/check_routes.py`: **Обработчик `POST /api/v1/checks` модифицирован для приема массива.**
    *   `status/wsgi.py`, `status/Dockerfile`, `status/entrypoint.sh`, `status/.env`, `status/docker-compose.yaml`.
*   **Входные данные:**
    *   HTTP Запросы: GET, POST, PUT, DELETE.
    *   **URL:** `/api/v1/...` (эндпоинт `/checks/bulk` **удален**).
    *   Query Params, Headers.
    *   **JSON Body:**
        *   ***`POST /api/v1/checks`***: **Принимает МАССИВ `[ { ...результат_1... }, { ... } ]`**.
        *   *POST `/api/v1/events`:* (Без изменений).
        *   *CRUD запросы:* (Без изменений).
    *   `.env`: (Без изменений).
*   **Методы обработки (основная логика):**
    1.  Gunicorn/Flask: Прием запроса, middleware.
    2.  **View-функция API:**
        *   Парсинг/валидация.
        *   Вызов Репозиториев/Сервисов.
        *   **Обработка `POST /api/v1/checks`:**
            *   Логирование начала (`BULK_PROCESSING_STARTED`).
            *   **Итерация по массиву результатов в теле запроса.**
            *   Для каждого элемента:
                *   Валидация данных элемента.
                *   Вызов `record_check_result` (хранимая процедура) через репозиторий.
                *   Обработка возможных ошибок от процедуры (например, задание не найдено).
                *   **При успехе записи: получение ID узла, вызов `node_service.get_processed_node_status`, отправка `socketio.emit('node_status_update', node_data)`.**
                *   Агрегация статусов обработки (success/fail) для ответа API.
            *   Логирование завершения (`BULK_PROCESSING_COMPLETED`).
        *   Формирование JSON-ответа.
        *   Обработка ошибок.
*   **Выходные данные (API Ответы JSON):**
    *   *`GET /api/v1/assignments?object_id=X`*: (Без изменений).
    *   *`GET /api/v1/objects/X/offline_config`*: (Без изменений).
    *   ***`POST /api/v1/checks`***: **Возвращает 200 OK или 207 Multi-Status с телом `{ "status": "...", "processed_count": N, "failed_count": M, "errors": [...] }`**.
    *   *`POST /api/v1/events`*: (Без изменений).
    *   *CRUD-ответы:* (Без изменений).
    *   *Ответы об ошибках:* (Без изменений).
*   **Описание взаимодействия с другими модулями:**
    *   <-> **Модуль 1 (БД).**
    *   <- **Модули 4 (Utils), 5 (Гибридный Агент), 7 (Конфигуратор), 8 (Загрузчик).**
    *   <-> **Модуль 3 (Web UI):** API + WebSocket.
    *   -> **Nginx.**
*   **Конфигурация:** `status/.env`.
*   **Error Handling:** `ApiException`, обработчики ошибок, JSON ошибок.
*   **Future Considerations/Improvements:** API v2, RBAC, Уведомления, Кэширование, Тесты.

---

### 3. Модуль: Web UI (Frontend)

*   **Версия:** ~1.1 *(Без изменений от предыдущей итерации)*
*   **Назначение и область ответственности:**
    *   Графический веб-интерфейс.
    *   Отображение данных (сводки, детали, история).
    *   **Визуализация истории** (графики) и **сложных `details`**.
    *   Интерфейсы CRUD (включая **`check_methods`**).
    *   Аутентификация пользователей.
    *   **Прием и отображение real-time обновлений через WebSocket.**
*   **Ключевые Компоненты/Файлы:**
    *   `status/app/templates/`: Шаблоны (включая `manage_methods.html`).
    *   `status/app/static/`: Статика (CSS, JS, иконки, Chart.js).
    *   `status/app/blueprints/ui.py`: Маршруты UI.
    *   JavaScript: AJAX, графики, **WebSocket-клиент**, рендеринг деталей.
*   **Входные данные:** Действия пользователя, Данные от API, **Сообщения WebSocket (`node_status_update`)**, Данные форм.
*   **Методы обработки (основная логика):**
    1.  **Сервер (Flask):** Обработка HTTP UI-запросов, аутентификация, рендеринг шаблонов, обработка POST-форм.
    2.  **Клиент (JS):** AJAX, обновление DOM, **обработка WebSocket событий (`node_status_update`) для обновления UI**, отрисовка графиков, рендеринг сложных `details`.
*   **Выходные данные:** HTML Страницы, Визуальные элементы.
*   **Примеры взаимодействия:** *(Как в v5.1, с WebSocket)*
*   **Описание взаимодействия с другими модулями:**
    *   <-> **Модуль 2 (Backend API):** API + WebSocket.
    *   <- **Пользователь (Браузер).**
    *   <-> **Nginx.**
*   **Конфигурация:** Через Backend.
*   **Error Handling:** Отображение ошибок пользователю.
*   **Future Considerations/Improvements:** Настраиваемые дашборды, UX/UI, Тестирование.

---

### 4. Модуль: PowerShell Agent Utilities (`StatusMonitorAgentUtils`)

*   **Версия:** ~2.1.0 *(Без изменений от предыдущей итерации)*
*   **Назначение и область ответственности:**
    *   Стандартизированная, переиспользуемая PowerShell-библиотека.
    *   Абстрагирование логики проверок.
    *   Единый формат результата.
    *   **Универсальная проверка критериев успеха (`Test-SuccessCriteria`).**
    *   Динамическая загрузка скриптов проверок.
*   **Ключевые Компоненты/Файлы:**
    *   `StatusMonitorAgentUtils.psm1`: `Invoke-StatusMonitorCheck`, `New-CheckResultObject`, `Test-SuccessCriteria`, `Compare-Values`, `Test-ArrayCriteria`.
    *   `StatusMonitorAgentUtils.psd1`.
    *   `Checks/Check-*.ps1`.
*   **Входные данные (для `Invoke-StatusMonitorCheck`):** `$Assignment` (с возможно сложным `success_criteria`).
*   **Методы обработки (основная логика):**
    1.  `Invoke-StatusMonitorCheck`: Вызывает нужный скрипт.
    2.  Скрипты `Checks/Check-*.ps1`: Выполняют проверку, **вызывают `Test-SuccessCriteria`**, возвращают результат через `New-CheckResultObject`.
    3.  `Test-SuccessCriteria`, `Compare-Values`, `Test-ArrayCriteria`: Обрабатывают критерии.
    4.  `New-CheckResultObject`: Формирует результат.
*   **Выходные данные:** Стандартизированная PowerShell Hashtable.
*   **Описание взаимодействия с другими модулями:**
    *   <- **Модуль 5 (Гибридный Агент).**
*   **Error Handling:** Перехват ошибок, стандартизированный результат.
*   **Future Considerations/Improvements:** Новые скрипты, `Invoke-Command`, расширение `Test-SuccessCriteria`, безопасная передача учетных данных, тесты Pester.

---

### 5. Модуль: Гибридный Агент Мониторинга (`StatusMonitorHybridAgent`)

*   **Версия:** ~7.0 (Объединение Online v6.1 и Offline v4.1)
*   **Назначение и область ответственности:**
    *   Выполнение мониторинга в **Online** или **Offline** режиме (задается конфигурацией).
    *   **Online:** Получение заданий с API, выполнение по расписанию, отправка результатов (массивом из 1 элемента) на `POST /checks`.
    *   **Offline:** Чтение заданий из файла, выполнение цикла проверок, атомарная запись результатов в `.zrpu`.
    *   Использование `StatusMonitorAgentUtils`.
*   **Ключевые Компоненты/Файлы:**
    *   `powershell/hybrid-agent/hybrid-agent.ps1`: Основной скрипт.
    *   `powershell/hybrid-agent/config.json`: Единый конфиг.
    *   `powershell/hybrid-agent/README.md`.
*   **Входные данные:**
    *   **`config.json` (Единый):**
        ```json
        {
            "mode": "Online", // "Online" или "Offline"
            "object_id": 1516,
            "log_file": "...", "log_level": "INFO",
            "agent_script_version": "hybrid_agent_v7.0",

            // --- Online параметры ---
            "api_base_url": "http://...", // Обяз. для Online
            "api_key": "...",             // Обяз. для Online
            "api_poll_interval_seconds": 60,
            "default_check_interval_seconds": 300,

            // --- Offline параметры ---
            "assignments_file_path_pattern": "...", // Обяз. для Offline
            "output_path": "...",                  // Обяз. для Offline
            "output_name_template": "{ddMMyy_HHmmss}_{object_id}_HybridOffline.zrpu",
            "offline_cycle_interval_seconds": 3600 // Интервал цикла Offline (0 = однократный запуск)
        }
        ```
    *   **Online:** API Ответ `GET /assignments`.
    *   **Offline:** Файл конфигурации `*.json.status.*`.
    *   **Оба:** Результат `Invoke-StatusMonitorCheck`.
*   **Методы обработки (основная логика):**
    1.  Чтение `config.json`, валидация параметров для выбранного `mode`.
    2.  Импорт `StatusMonitorAgentUtils`.
    3.  **Запуск соответствующего режима:**
        *   **`Run-OnlineModeLoop`:**
            *   Цикл опроса API (`GET /assignments`).
            *   Цикл проверки и выполнения заданий по расписанию.
            *   Вызов `Invoke-StatusMonitorCheck`.
            *   Формирование **массива `[ { ... } ]`**.
            *   Отправка на **`POST /api/v1/checks`**.
            *   Обработка ответа 200/207, обновление времени выполнения.
        *   **`Run-OfflineModeCycle`:**
            *   Чтение файла конфигурации (если изменился).
            *   Выполнение *всех* заданий из файла через `Invoke-StatusMonitorCheck`.
            *   Сбор результатов (с добавлением `assignment_id`).
            *   Формирование `.zrpu` payload.
            *   **Атомарное сохранение `.zrpu` файла.**
            *   Пауза или выход (в зависимости от `offline_cycle_interval_seconds`).
*   **Выходные данные:**
    *   **Online:** HTTP `POST /api/v1/checks` (тело: `[ { ... } ]`).
    *   **Offline:** Файл `*.zrpu`.
    *   Лог-файл.
*   **Описание взаимодействия с другими модулями:**
    *   -> **Модуль 4 (Utils).**
    *   **Online:** -> **Модуль 2 (API Сервер).**
    *   **Offline:** <- **Модуль 7 (Конфигуратор)**, -> **Модуль 8 (Загрузчик Результатов)**.
    *   **Offline:** <-> **Файловая Система.**
*   **Конфигурация:** `powershell/hybrid-agent/config.json`.
*   **Error Handling:** Валидация конфига, Retry API (Online), Ошибки FS (Offline), Логирование.
*   **Future Considerations/Improvements:** Служба Windows, Улучшение планирования/цикла, Кэширование заданий (Online), Ротация файлов (Offline), Возможность гибридного переключения.

---

### 6. Модуль: Offline Агент (УДАЛЕН)

***Комментарий:*** *Модуль упразднен, его функциональность вошла в Модуль 5.*

---

### 7. Модуль: Конфигуратор Оффлайн Агентов

*   **Версия:** ~4.1 *(Без изменений от предыдущей итерации)*
*   **Назначение и область ответственности:**
    *   Генерация и **атомарная** доставка файлов конфигурации для Offline-режима Гибридного Агента.
    *   Получение информации из API.
*   **Ключевые Компоненты/Файлы:** `powershell/configurator/generate_and_deliver_config.ps1`, `config.json`.
*   **Входные данные:** `config.json`, API Ответ `/offline_config`.
*   **Методы обработки (основная логика):**
    1.  Чтение конфига.
    2.  Определение списка `ObjectId`.
    3.  Цикл по `ObjectId`:
        *   Запрос `/offline_config`.
        *   Обработка ошибок API.
        *   Формирование имени файла.
        *   **Атомарное сохранение** JSON ответа в файл в `output_path_base`.
        *   **Атомарное копирование** файла в `delivery_path_base`.
*   **Выходные данные:** Файлы `*.json.status.*`, Лог-файл.
*   **Описание взаимодействия с другими модулями:**
    *   -> **Модуль 2 (API Сервер).**
    *   -> **Модуль 5 (Гибридный Агент - Offline режим).**
    *   <-> **Файловая Система.**
*   **Конфигурация:** `config.json`.
*   **Error Handling:** Ошибки API, Файловой системы.
*   **Future Considerations/Improvements:** Авто-запуск по триггеру.

---

### 8. Модуль: Загрузчик Результатов Оффлайн Агентов

*   **Версия:** ~4.2 (Основа v4.1 + унифицированный API)
*   **Назначение и область ответственности:**
    *   Загрузка данных из `.zrpu` (созданных Гибридным Агентом в Offline режиме) через **унифицированный API `/checks`**.
    *   Обеспечение надежной доставки.
    *   Информирование системы (событие `FILE_PROCESSED`).
    *   Предотвращение повторной загрузки (перемещение) и обработка ошибок (DLQ).
*   **Ключевые Компоненты/Файлы:** `powershell/result_loader/result_loader.ps1`, `config.json`.
*   **Входные данные:**
    *   **`config.json`:** (Как в v5.1, **без `use_bulk_api`**, с `unrecoverable_error_folder`).
        ```json
        {
            "api_base_url": "http://...",
            "api_key": "...",
            "check_folder": "...",
            "processed_folder": ".../Processed",
            "error_folder": ".../Error", // Локальные ошибки
            "unrecoverable_error_folder": ".../Unrecoverable", // Ошибки API
            "scan_interval_seconds": 60,
            "log_file": "...", "log_level": "INFO",
            "max_api_retries": 3, "retry_delay_seconds": 10
        }
        ```
    *   Файлы `*.zrpu`.
*   **Методы обработки (основная логика):**
    1.  Чтение конфига.
    2.  **Основной цикл:**
        *   Сканировать `check_folder`.
        *   **Для каждого файла `.zrpu`:**
            *   Прочитать/распарсить JSON. Ошибка -> `error_folder`.
            *   Извлечь метаданные и массив `results`.
            *   Подготовить **массив** `$payloadArray` для `POST /api/v1/checks` (добавляя метаданные файла в каждый элемент).
            *   **Отправить `$payloadArray` на `POST /api/v1/checks`** (с retry).
            *   Обработать ответ (200/207), определить статус обработки файла.
            *   Отправить событие `FILE_PROCESSED`.
            *   **Атомарно переместить файл** в `processed_folder` (если все ОК), `unrecoverable_error_folder` (если были ошибки API или отправки события) или оставить в `error_folder` (если была ошибка парсинга).
            *   Логировать.
*   **Выходные данные:** HTTP `POST /api/v1/checks` (с массивом), HTTP `POST /api/v1/events`, Перемещенные файлы, Лог-файл.
*   **Описание взаимодействия с другими модулями:**
    *   <- **Модуль 5 (Гибридный Агент - Offline режим).**
    *   -> **Модуль 2 (API Сервер).**
    *   <-> **Файловая Система.**
*   **Конфигурация:** `config.json`.
*   **Error Handling:** Retry API, логирование, перемещение в `error_folder` / **`unrecoverable_error_folder`**.
*   **Future Considerations/Improvements:** Обработка 207, Повторная обработка из DLQ.

---

Этот ТЗ версии 5.2 отражает предложенное объединение агентов и связанные с этим изменения в API и Загрузчике, сохраняя при этом все остальные улучшения из версии 5.1.