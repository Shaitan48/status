=== СПИСОК ФАЙЛОВ ===
Файл: F:\status\source\powershell\Dockerfile.tests (Кодировка: UTF8)
Файл: F:\status\source\powershell\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\configurator\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\configurator\README.txt (Кодировка: UTF8)
Файл: F:\status\source\powershell\hybrid-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\hybrid-agent\hybrid-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\hybrid-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\offline-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\offline-agent\offline-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\offline-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\online-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\online-agent\online-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\online-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\result_loader.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)


=== ДЕРЕВО КАТАЛОГОВ ===
F:\status\source\powershell
  |-- Dockerfile.tests (Кодировка: UTF8)
  |-- README.md (Кодировка: UTF8)
  |-- configurator\config.json (Кодировка: UTF8)
  |-- configurator\generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
  |-- configurator\README.txt (Кодировка: UTF8)
  |-- hybrid-agent\config.json (Кодировка: UTF8)
  |-- hybrid-agent\hybrid-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- hybrid-agent\README.md (Кодировка: UTF8)
  |-- offline-agent\config.json (Кодировка: UTF8)
  |-- offline-agent\offline-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- offline-agent\README.md (Кодировка: UTF8)
  |-- online-agent\config.json (Кодировка: UTF8)
  |-- online-agent\online-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- online-agent\README.md (Кодировка: UTF8)
  |-- result_loader\config.json (Кодировка: UTF8)
  |-- result_loader\README.md (Кодировка: UTF8)
  |-- result_loader\result_loader.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\README.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-PING.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\configurator
  |-- config.json (Кодировка: UTF8)
  |-- generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
  |-- README.txt (Кодировка: UTF8)
F:\status\source\powershell\hybrid-agent
  |-- config.json (Кодировка: UTF8)
  |-- hybrid-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\offline-agent
  |-- config.json (Кодировка: UTF8)
  |-- offline-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\online-agent
  |-- config.json (Кодировка: UTF8)
  |-- online-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\result_loader
  |-- config.json (Кодировка: UTF8)
  |-- README.md (Кодировка: UTF8)
  |-- result_loader.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\StatusMonitorAgentUtils
  |-- ManualTest-Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
  |-- TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_PING.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- Checks\README-Check-PING.md (Кодировка: UTF8)
  |-- Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
  |-- tests\Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\StatusMonitorAgentUtils\Checks
  |-- Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- README-Check-PING.md (Кодировка: UTF8)
  |-- README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
F:\status\source\powershell\StatusMonitorAgentUtils\tests
  |-- Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)


==== BEGIN FILE: F:\status\source\powershell\Dockerfile.tests ====
# powershell/Dockerfile.tests
# Dockerfile для запуска Pester тестов для PowerShell модулей проекта Status Monitor

# Используем официальный образ PowerShell (например, на базе Linux Alpine для легковесности)
# Выберите версию PowerShell, наиболее близкую к вашей целевой среде (5.1),
# но учтите, что официальные образы в основном идут с PowerShell 7+.
# Для PS 5.1 может потребоваться образ Windows Server Core, что усложнит сборку.
# Давайте пока остановимся на последней версии PowerShell Core, т.к. Pester 5 лучше работает с ней.
# Если возникнут проблемы совместимости с 5.1, нужно будет пересмотреть базовый образ.
FROM mcr.microsoft.com/powershell:latest

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app/tests

# Копируем ВСЮ папку powershell из хоста ВНУТРЬ /app/powershell в контейнере
# Это включает сам модуль StatusMonitorAgentUtils и папку tests
COPY ./ /app/powershell/

# Устанавливаем Pester последней версии
# Используем pwsh для выполнения команд PowerShell внутри контейнера
# Set-PSRepository -Name PSGallery -InstallationPolicy Trusted # Доверенный репозиторий
# Install-Module Pester -Force -SkipPublisherCheck # Установка Pester
# Убрал Scope CurrentUser, т.к. в контейнере это не так важно и может вызвать проблемы
# <<< УЛУЧШЕННАЯ УСТАНОВКА PESTER (обходит возможные проблемы с репозиторием) >>>
RUN pwsh -Command " \
    Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force; \
    Set-PSRepository -Name PSGallery -InstallationPolicy Trusted; \
    Install-Module -Name Pester -Repository PSGallery -Force -SkipPublisherCheck; \
    Write-Host 'Pester установлен.'"

# Установка других зависимостей, если они нужны для тестов
# Например, если бы тесты SQL требовали модуль SqlServer ВНУТРИ контейнера
# RUN pwsh -Command "Install-Module -Name SqlServer -Repository PSGallery -Force -SkipPublisherCheck"

# Устанавливаем рабочую директорию ВНУТРИ папки с тестами модуля Utils
# Это нужно, чтобы Invoke-Pester корректно находил тесты
WORKDIR /app/powershell/StatusMonitorAgentUtils/tests

# Команда по умолчанию для запуска всех *.Tests.ps1 файлов Pester в текущей директории
# -Output Detailed : Подробный вывод
# -CI : Режим для CI/CD систем (меняет exit code при ошибках)
# -PassThru : Возвращает объект с результатами (может быть полезно для CI)
# Можно добавить -Path для указания конкретных файлов/папок
CMD ["pwsh", "-Command", "Invoke-Pester -Output Detailed -CI -PassThru"]

# Альтернативная команда для запуска конкретного файла:
# CMD ["pwsh", "-Command", "Invoke-Pester -Path ./Check-PING.Tests.ps1 -Output Detailed -CI"]
==== END FILE: F:\status\source\powershell\Dockerfile.tests ====

==== BEGIN FILE: F:\status\source\powershell\README.md ====
# PowerShell Скрипты для Status Monitor

Эта папка содержит PowerShell скрипты и модули, которые выполняют роль агентов мониторинга и вспомогательных утилит для системы Status Monitor.

## Структура

*   **`online-agent/`**: Содержит скрипт и конфигурацию для **Онлайн-агента**, работающего на машинах с прямым доступом к API сервера мониторинга.
    *   [`online-agent/README.md`](online-agent/README.md)
*   **`offline-agent/`**: Содержит скрипт и конфигурацию для **Оффлайн-агента**, работающего в изолированных сетях без доступа к API.
    *   [`offline-agent/README.md`](offline-agent/README.md)
*   **`result_loader/`**: Скрипт и конфигурация **Загрузчика Результатов**, который обрабатывает файлы (`*.zrpu`) от оффлайн-агентов и отправляет данные в API.
    *   [`result_loader/README.md`](result_loader/README.md)
*   **`configurator/`**: Скрипт и конфигурация **Конфигуратора**, который генерирует файлы с заданиями для оффлайн-агентов, запрашивая данные у API.
    *   [`configurator/README.md`](configurator/README.md)
*   **`StatusMonitorAgentUtils/`**: **ОБЩИЙ МОДУЛЬ PowerShell**, содержащий основную логику выполнения проверок. Используется как онлайн, так и оффлайн агентами.
    *   [`StatusMonitorAgentUtils/README.md`](StatusMonitorAgentUtils/README.md)

## Ключевой компонент: `StatusMonitorAgentUtils`

Этот модуль является сердцем выполнения проверок на стороне PowerShell.

*   **Диспетчер (`Invoke-StatusMonitorCheck`)**: Основная экспортируемая функция модуля. Агенты вызывают именно ее, передавая объект задания. Функция определяет, какой метод проверки нужно выполнить (`method_name` из задания), находит соответствующий скрипт `Checks/Check-*.ps1` и **запускает его локально** на машине агента, передавая нужные параметры.
*   **Скрипты проверок (`Checks/Check-*.ps1`)**: Папка `Checks` внутри `StatusMonitorAgentUtils` содержит отдельные `.ps1` файлы для каждого метода проверки (например, `Check-PING.ps1`, `Check-SERVICE_STATUS.ps1`). Каждый такой скрипт выполняет **только свою конкретную проверку**, используя переданные ему параметры (например, IP-адрес цели, имя службы), и возвращает стандартизированный результат.
*   **Вспомогательные функции**: Модуль также содержит функции для стандартизации формата результата (`New-CheckResultObject`) и, в будущем, может содержать другие общие утилиты.

**Важно:** Для добавления поддержки нового метода мониторинга необходимо создать соответствующий `Check-METHOD_NAME.ps1` файл в папке `Checks/` и реализовать в нем логику проверки и возврата стандартизированного результата.

## Принцип работы с Заданиями (Assignments)

Система использует модель "Заданий" (`Assignments`), хранящихся в центральной БД. Каждый результат проверки должен быть связан с конкретным заданием через `assignment_id`.

*   **Online-агент:** Получает задания (с `assignment_id`) от API. Вызывает `Invoke-StatusMonitorCheck`. Получает результат. Отправляет результат **вместе с `assignment_id`** в API `/api/v1/checks`.
*   **Offline-агент:** Получает задания (с `assignment_id`) из файла `.json.status.КОД_ТС`. Вызывает `Invoke-StatusMonitorCheck`. Получает результат. **Добавляет `assignment_id`** к полученному результату. Сохраняет массив дополненных результатов в файл `*.zrpu`.
*   **Загрузчик (`result_loader`):** Читает файл `*.zrpu`. Для каждой записи результата извлекает `assignment_id` и остальные данные, формирует запрос и отправляет его в API `/api/v1/checks`.

Это позволяет серверу точно сопоставить каждый полученный результат с конкретным заданием, настроенным администратором.
==== END FILE: F:\status\source\powershell\README.md ====

==== BEGIN FILE: F:\status\source\powershell\configurator\config.json ====
{
  "api_base_url": "http://localhost:48030/api",
  "api_key": "eWfRuIrdREe_Bt8jaOzUmZ23JYIwk6Keeu9dQZnywwI",
  "output_path_base": "F:\\status\\builds\\configs\\Generated",
  "delivery_path_base": "F:\\status\\builds\\delivery_conf",
  "log_file": "F:\\status\\builds\\Logs\\configurator.log",
  "log_level": "Info", 
  "subdivision_ids_to_process": [1516, 1060],
  "output_filename_template": "{version_tag}_assignments.json.status.{transport_code}",
  "delivery_subdir_template": "{transport_code}",
  "api_timeout_sec": 60
}
==== END FILE: F:\status\source\powershell\configurator\config.json ====

==== BEGIN FILE: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 ====
# powershell/configurator/generate_and_deliver_config.ps1
# --- Версия 4.1 ---
# Изменения:
# - Добавлена атомарность при сохранении и доставке файлов.
<#
.SYNOPSIS
    Генерирует и доставляет конфигурационные файлы для оффлайн-режима
    гибридного агента Status Monitor (v4.1).
.DESCRIPTION
    Запрашивает конфигурацию у API и АТОМАРНО сохраняет/доставляет JSON файлы.
    1. Читает `config.json`.
    2. Определяет список ObjectId для обработки.
    3. Для каждого ObjectId:
       - Запрашивает `GET /api/v1/objects/{ObjectId}/offline_config`.
       - Проверяет ответ.
       - Формирует имя файла.
       - **Сохраняет JSON во временный файл в `output_path_base`.**
       - **Переименовывает временный файл в основной.**
       - Если задан `delivery_path_base`:
         - **Копирует основной файл во временный файл в папке доставки.**
         - **Переименовывает временный файл доставки в основной.**
.NOTES
    Версия: 4.1
    Дата: [Актуальная Дата]
#>
param(
    [string]$ConfigFile = "$PSScriptRoot\config.json",
    [string]$ParamLogFile = $null,
    [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
    [string]$ParamLogLevel = $null
)

# --- Вспомогательные функции (без изменений от предыдущей версии) ---
filter Get-OrElse_Internal { param([object]$DefaultValue); if ($_) { $_ } else { $DefaultValue } }
function Write-Log { param ([Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)][string]$Level = "Info"); if (-not $script:Config -or -not $script:Config.log_file) { Write-Host "[$Level] $Message"; return }; $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }; $currentLevelValue = $logLevels[$script:EffectiveLogLevel]; if ($null -eq $currentLevelValue) { $currentLevelValue = $logLevels["Info"] }; $messageLevelValue = $logLevels[$Level]; if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] }; if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] - $Message"; Write-Host $logMessage -ForegroundColor $(switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}); try { $logDir = Split-Path $script:Config.log_file -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки для лога: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }; $logMessage | Out-File -FilePath $script:Config.log_file -Append -Encoding UTF8 -ErrorAction Stop } catch { Write-Host "[Error] Невозможно записать в лог '$($script:Config.log_file)': $($_.Exception.Message)" -ForegroundColor Red } } }

# --- Начало скрипта ---
$ScriptVersion = "4.1"
$script:Config = $null
$script:EffectiveLogLevel = "Info"
$script:ApiKey = $null

# --- Шаг 1: Чтение и валидация конфигурации ---
# (Код без изменений, проверяет все поля, включая delivery_path_base)
Write-Host "Загрузка конфигурации из файла: $ConfigFile"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Error "Критическая ошибка: Файл конфигурации '$ConfigFile' не найден."; exit 1 }
try { $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error "Критическая ошибка: Ошибка чтения/парсинга JSON '$ConfigFile'. Ошибка: $($_.Exception.Message)"; exit 1 }
$requiredConfigFields = @("api_base_url", "api_key", "output_path_base", "delivery_path_base", "log_file", "log_level", "subdivision_ids_to_process", "output_filename_template", "delivery_subdir_template", "api_timeout_sec")
$missingFields = $requiredConfigFields | Where-Object { -not $script:Config.PSObject.Properties.Name.Contains($_) -or (-not ($script:Config.PSObject.Properties.$_ -ne $null) -and $_ -ne 'delivery_path_base') } # delivery_path_base может быть null
if ($missingFields) { Write-Error "Критическая ошибка: В '$ConfigFile' отсутствуют поля: $($missingFields -join ', ')"; exit 1 }
if ($script:Config.subdivision_ids_to_process -isnot [array]) { Write-Error "..."; exit 1 }
if ($ParamLogFile) { $script:Config.log_file = $ParamLogFile }
if ($ParamLogLevel) { $script:Config.log_level = $ParamLogLevel }
$validLogLevelsMap = @{ "Debug" = 0; "Verbose" = 1; "Info" = 2; "Warn" = 3; "Error" = 4 }
if (-not $validLogLevelsMap.ContainsKey($script:Config.log_level)) { $script:Config.log_level = "Info" }
$script:EffectiveLogLevel = $script:Config.log_level
$script:ApiKey = $script:Config.api_key

# --- Шаг 2: Инициализация и логирование ---
# (Код без изменений)
$logDir = Split-Path $script:Config.log_file -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { try { New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null } catch { Write-Error "..."; exit 1 } }
Write-Log "Скрипт конфигуратора (v$ScriptVersion) запущен." "Info"
# ... (логирование параметров конфига) ...

# --- Шаг 3: Определение списка ObjectId для обработки ---
# (Код без изменений, использует Invoke-RestMethod)
$objectIdsToProcess = @()
if ($script:Config.subdivision_ids_to_process.Count -gt 0) { $objectIdsToProcess = $script:Config.subdivision_ids_to_process | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ } }
else {
    Write-Log "Запрос всех подразделений с кодом ТС из API..." "Info"
    $apiUrlSubdivisions = "$($script:Config.api_base_url.TrimEnd('/'))/v1/subdivisions?limit=1000"
    $headers = @{ 'X-API-Key' = $script:ApiKey }
    try {
        $response = Invoke-RestMethod -Uri $apiUrlSubdivisions -Method Get -Headers $headers -TimeoutSec ($script:Config.api_timeout_sec | Get-OrElse_Internal 60) -ErrorAction Stop
        if ($response -and $response.items -is [array]) { $objectIdsToProcess = $response.items | Where-Object { $_.transport_system_code -and $_.object_id } | Select-Object -ExpandProperty object_id; Write-Log "Найдено для обработки: $($objectIdsToProcess.Count)" "Info" }
    } catch {
        $rawErrorMessage = $_.Exception.Message; $responseBody="[N/A]"; $statusCode=$null; if($_.Exception.Response){try{$statusCode=$_.Exception.Response.StatusCode}catch{}; try{$stream=[System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream());$responseBody=$stream.ReadToEnd();$stream.Close()}catch{}};
        Write-Log "Критическая ошибка получения списка подразделений: $rawErrorMessage - Code: $statusCode - Resp: $responseBody" "Error"; exit 1
    }
}
if ($objectIdsToProcess.Count -eq 0) { Write-Log "Нет ObjectId для обработки. Завершение." "Info"; exit 0 }

# --- Шаг 4: Цикл обработки каждого ObjectId ---
Write-Log "Начало цикла обработки для $($objectIdsToProcess.Count) подразделений." "Info"
foreach ($currentObjectId in $objectIdsToProcess) {
    Write-Log "--- Обработка ObjectId: $currentObjectId ---" "Info"
    $apiResponse = $null
    $versionTag = "[error]" # Значение по умолчанию
    $transportCode = "[error]" # Значение по умолчанию

    # 1. Запрос конфигурации
    $apiUrlConfig = "$($script:Config.api_base_url.TrimEnd('/'))/v1/objects/${currentObjectId}/offline_config"
    $headersConfig = @{ 'X-API-Key' = $script:ApiKey }
    Write-Log "Запрос конфигурации: GET $apiUrlConfig" "Verbose"
    try {
        $apiResponse = Invoke-RestMethod -Uri $apiUrlConfig -Method Get -Headers $headersConfig -TimeoutSec ($script:Config.api_timeout_sec | Get-OrElse_Internal 60) -ErrorAction Stop
        # Валидация ответа API
        if (-not ($apiResponse -is [PSCustomObject]) -or (-not $apiResponse.PSObject.Properties.Name.Contains('assignment_config_version')) -or (-not $apiResponse.PSObject.Properties.Name.Contains('transport_system_code')) -or (-not $apiResponse.PSObject.Properties.Name.Contains('assignments'))) {
             if($apiResponse -is [PSCustomObject] -and $apiResponse.error){ throw "API вернул ошибку: $($apiResponse.error)" }
             else { throw "Некорректная структура ответа API /offline_config." }
        }
        $versionTag = $apiResponse.assignment_config_version
        $transportCode = $apiResponse.transport_system_code
        $assignmentCount = $apiResponse.assignments.Count
        Write-Log "Конфигурация получена. Версия: ${versionTag}. Заданий: ${assignmentCount}. Код ТС: ${transportCode}." "Info"

    } catch {
        # Обработка ошибок API
        $exceptionMessage = $_.Exception.Message; $statusCode = $null; if ($_.Exception.Response) { try {$statusCode = $_.Exception.Response.StatusCode} catch {} };
        Write-Log "Ошибка получения конфигурации от API для ObjectId ${currentObjectId}: $exceptionMessage (Код: $statusCode)" "Error";
        continue # Пропускаем этот ID
    }

    # 2. Формирование имен файлов
    $outputFileNameBase = $script:Config.output_filename_template -replace "{version_tag}", $versionTag -replace "{transport_code}", $transportCode
    $outputFileName = $outputFileNameBase -replace '[\\/:*?"<>|]', '_' # Убираем недопустимые символы
    # Полные пути
    $outputFilePath = Join-Path -Path $script:Config.output_path_base -ChildPath $outputFileName
    $tempOutputFilePath = $outputFilePath + ".tmp" # Временный файл рядом
    $outputDir = Split-Path $outputFilePath -Parent

    # 3. Создание папки вывода
    if (-not (Test-Path $outputDir -PathType Container)) {
        Write-Log "Создание папки вывода '$outputDir'" "Verbose"
        try { New-Item -Path $outputDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }
        catch { Write-Log "Ошибка создания папки вывода '$outputDir'. Пропуск ${currentObjectId}. Error: $($_.Exception.Message)" "Error"; continue }
    }

    # --- 4. Атомарное сохранение JSON в output_path_base ---
    Write-Log "Сохранение конфигурации во временный файл: $tempOutputFilePath" "Verbose"
    $saveSuccess = $false
    try {
        $jsonToSave = $apiResponse | ConvertTo-Json -Depth 10 -WarningAction SilentlyContinue
        $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false)
        [System.IO.File]::WriteAllText($tempOutputFilePath, $jsonToSave, $Utf8NoBomEncoding)
        Write-Log "Данные записаны во временный файл." "Debug"
        # Переименование во временный файл
        Move-Item -Path $tempOutputFilePath -Destination $outputFilePath -Force -ErrorAction Stop
        Write-Log "Файл '$outputFileName' успешно сохранен (атомарно) в '$outputDir'." "Info"
        $saveSuccess = $true
    } catch {
        Write-Log "Ошибка сохранения/переименования файла '$outputFilePath'. Пропуск ${currentObjectId}. Error: $($_.Exception.Message)" "Error"
        # Пытаемся удалить временный файл, если он остался
        if (Test-Path $tempOutputFilePath -PathType Leaf) { try { Remove-Item -Path $tempOutputFilePath -Force -ErrorAction SilentlyContinue } catch {} }
        continue # Пропускаем доставку, если сохранение не удалось
    }

    # --- 5. Атомарная доставка файла (если нужно) ---
    if ($saveSuccess -and $script:Config.delivery_path_base) {
        $deliverySubDir = $script:Config.delivery_subdir_template -replace "{transport_code}", $transportCode
        $deliveryPath = Join-Path -Path $script:Config.delivery_path_base -ChildPath $deliverySubDir
        $deliveryFileName = $outputFileName # Имя файла то же
        $deliveryFilePath = Join-Path -Path $deliveryPath -ChildPath $deliveryFileName
        $tempDeliveryFilePath = $deliveryFilePath + ".tmp" # Временный файл доставки
        Write-Log "Проверка пути доставки: $deliveryFilePath" "Info"

        # Создаем папку доставки, если ее нет
        if (-not (Test-Path $deliveryPath -PathType Container)) {
            Write-Log "Папка доставки '$deliveryPath' не найдена. Создание..." "Warn"
            try { New-Item -Path $deliveryPath -ItemType Directory -Force -ErrorAction Stop | Out-Null; Write-Log "Папка '$deliveryPath' создана." "Verbose" }
            catch { Write-Log "Ошибка создания папки доставки '$deliveryPath'. Пропуск доставки. Error: $($_.Exception.Message)" "Error"; continue } # Пропускаем, если не удалось создать
        }

        # Атомарное копирование (Copy -> Rename)
        Write-Log "Копирование '$outputFilePath' -> '$tempDeliveryFilePath'" "Verbose"
        try {
             # 1. Копируем во временный файл
             Copy-Item -Path $outputFilePath -Destination $tempDeliveryFilePath -Force -ErrorAction Stop
             Write-Log "Временный файл доставки создан." "Debug"
             # 2. Переименовываем временный в основной
             Move-Item -Path $tempDeliveryFilePath -Destination $deliveryFilePath -Force -ErrorAction Stop
             Write-Log "Файл '$outputFileName' успешно доставлен (атомарно) в '$deliveryPath'." "Info"
        } catch {
             Write-Log "Ошибка копирования/переименования при доставке в '$deliveryFilePath'. Error: $($_.Exception.Message)" "Error"
             # Пытаемся удалить временный файл доставки, если он остался
             if (Test-Path $tempDeliveryFilePath -PathType Leaf) { try { Remove-Item -Path $tempDeliveryFilePath -Force -ErrorAction SilentlyContinue } catch {} }
        }
    } elseif ($saveSuccess) {
         Write-Log "delivery_path_base не задан. Пропуск доставки." "Info"
    }

    Write-Log "--- Обработка ObjectId: $currentObjectId завершена ---" "Info"
} # --- Конец цикла foreach ---

Write-Log "Работа скрипта конфигуратора успешно завершена." "Info"
==== END FILE: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\configurator\README.txt ====

---

### 3. README для Конфигуратора Оффлайн Агентов

**Файл:** `powershell/configurator/README.md` (Обновленный)

```markdown
# PowerShell Конфигуратор Оффлайн Агентов (configurator) v4.1

Этот скрипт (`generate_and_deliver_config.ps1`) предназначен для автоматической генерации и (опционально) **атомарной** доставки файлов конфигурации с заданиями для **Гибридного Агента** в **Offline режиме**.

## Назначение

*   Подключаться к центральному API системы мониторинга.
*   Запрашивать актуальную конфигурацию заданий для одного или нескольких подразделений (объектов), идентифицируемых по их `ObjectId`.
*   **Атомарно** сохранять полученную конфигурацию (включая метаданные и список заданий) в JSON файлы специального формата (`{version_tag}_assignments.json.status.{transport_code}`).
*   Опционально **атомарно** доставлять (копировать) сгенерированные файлы в указанные папки.

## Принцип Работы

1.  Скрипт запускается (вручную или по расписанию).
2.  Читает параметры из файла `config.json`.
3.  Определяет список `ObjectId` для обработки (из конфига или через API).
4.  Для каждого `ObjectId`:
    *   Выполняет GET-запрос к `/api/v1/objects/{ObjectId}/offline_config`.
    *   API возвращает JSON-объект конфигурации.
    *   Скрипт проверяет корректность ответа.
    *   Формирует имя файла на основе шаблона и данных из ответа.
    *   **Сохраняет JSON во временный файл (`.tmp`) в `output_path_base`.**
    *   **При успехе сохранения, переименовывает временный файл в основной (`.json.status.*`).**
    *   Если задан `delivery_path_base`:
        *   Формирует путь к целевой папке.
        *   **Копирует основной файл во временный файл (`.tmp`) в папке доставки.**
        *   **При успехе копирования, переименовывает временный файл доставки в основной.**
5.  Логирует свою работу.

**Атомарность:** Использование временных файлов и операции переименования (которая обычно атомарна в пределах одного тома файловой системы) гарантирует, что Гибридный Агент не прочитает частично записанный или скопированный файл конфигурации.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке:

```json
{
  "api_base_url": "http://localhost:48030/api", // ОБЯЗАТЕЛЬНО
  "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_CONFIGURATOR", // ОБЯЗАТЕЛЬНО
  "output_path_base": "F:\\status\\builds\\configs\\Generated", // ОБЯЗАТЕЛЬНО
  "delivery_path_base": "F:\\status\\builds\\delivery_conf", // ОБЯЗАТЕЛЬНО (или null, если доставка не нужна)
  "log_file": "F:\\status\\builds\\Logs\\configurator.log", // ОБЯЗАТЕЛЬНО
  "log_level": "Info", // Опционально (default: Info)
  "subdivision_ids_to_process": [], // ОБЯЗАТЕЛЬНО: [] для авто, [1060, ...] для конкретных
  "output_filename_template": "{version_tag}_assignments.json.status.{transport_code}", // ОБЯЗАТЕЛЬНО
  "delivery_subdir_template": "{transport_code}", // ОБЯЗАТЕЛЬНО
  "api_timeout_sec": 60 // Опционально (default: 60)
}

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Сеть: Доступ к api_base_url.

    Права: Права на запись/переименование в output_path_base и delivery_path_base. Права на запись в log_file.

    API Ключ: Действительный ключ с ролью configurator.

    Запуск: Вручную или через Планировщик Задач.

Замечания

    Скрипт генерирует файлы для Гибридного Агента в Offline режиме.

    Убедитесь, что транспортная система (или сам агент) настроена на чтение файлов из папки доставки (delivery_path_base/{transport_code}/).
==== END FILE: F:\status\source\powershell\configurator\README.txt ====

==== BEGIN FILE: F:\status\source\powershell\hybrid-agent\config.json ====
{
    "mode": "Online",
    "object_id": 1516,
    "log_file": "C:/StatusMonitor/Logs/hybrid-agent.log",
    "log_level": "Info",
    "agent_script_version": "hybrid_agent_v7.0",
    "api_base_url": "http://localhost:48030/api",
    "api_key": "ЗАМЕНИТЕ_НА_ВАШ_AGENT_КЛЮЧ",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 300,
    "assignments_file_path_pattern": "C:/StatusMonitor/OfflineConfig/*.json.status.*",
    "output_path": "C:/StatusMonitor/OfflineResults",
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_HybridOffline.zrpu",
    "offline_cycle_interval_seconds": 0
}
==== END FILE: F:\status\source\powershell\hybrid-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\hybrid-agent\hybrid-agent.ps1 ====
# powershell/hybrid-agent/hybrid-agent.ps1
# --- Гибридный Агент Мониторинга v7.0 ---
<#
.SYNOPSIS
    Гибридный агент системы мониторинга Status Monitor v7.0.
    Работает в режимах Online или Offline в зависимости от конфигурации.
.DESCRIPTION
    Этот агент выполняет мониторинг узлов и отправляет результаты.
    Режим работы определяется параметром 'mode' в файле config.json.

    Online режим:
    - Получает задания от API сервера (/api/v1/assignments).
    - Выполняет задания по расписанию.
    - Отправляет результат КАЖДОЙ проверки массивом из одного элемента на API (/api/v1/checks).

    Offline режим:
    - Читает задания из локального файла конфигурации (*.json.status.*).
    - Выполняет ВСЕ задания за один цикл.
    - Собирает результаты и сохраняет их в файл *.zrpu для последующей загрузки.
.NOTES
    Версия: 7.0
    Дата: [Актуальная Дата]
    Объединяет функциональность Online и Offline агентов.
    Использует модуль StatusMonitorAgentUtils.
    Требует PowerShell 5.1+.
    Совместим с API Status Monitor v5.2+.
#>
param (
    # Путь к единому файлу конфигурации агента.
    [string]$ConfigFile = "$PSScriptRoot\config.json"
)

# --- 1. Загрузка общего модуля утилит ---
$ErrorActionPreference = "Stop" # Строгий режим на время импорта
try {
    # Путь к манифесту Utils относительно папки hybrid-agent
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils успешно загружен."
} catch {
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "[CRITICAL] Агент не может работать без модуля Utils. Завершение." -ForegroundColor Red
    exit 1 # Критическая ошибка - выходим
} finally {
    $ErrorActionPreference = "Continue" # Возвращаем стандартный режим
}
# --- Конец загрузки модуля ---

# --- 2. Глобальные переменные ---
$script:ComputerName = $env:COMPUTERNAME
$script:Config = $null         # Конфигурация из config.json
$script:LogLevel = "Info"      # Уровень логирования
$script:LogFilePath = $null    # Полный путь к лог-файлу
$script:AgentVersion = "hybrid_agent_v7.0" # Версия скрипта для логов/результатов

# Переменные для Online режима
$script:ActiveAssignmentsOnline = @{} # Активные задания (ID -> Объект)
$script:LastExecutedTimesOnline = @{} # Время последнего выполнения (ID -> DateTimeOffset UTC)
$script:LastApiPollTimeOnline = [DateTimeOffset]::MinValue # Время последнего опроса API

# Переменные для Offline режима
$script:CurrentAssignmentsOffline = $null # Текущие задания из файла (массив)
$script:CurrentConfigVersionOffline = $null # Текущая версия файла конфига
$script:LastProcessedConfigFileOffline = $null # Путь к последнему обработанному файлу

# --- 3. Вспомогательные функции ---

#region Функции

<#
.SYNOPSIS Записывает сообщение в лог и/или консоль.
#>
function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
        [string]$Level = "Info"
    )
    # Уровни логирования (числовое представление)
    $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }
    $effectiveLogLevelValue = $logLevels[$script:LogLevel] # Текущий установленный уровень
    if ($null -eq $effectiveLogLevelValue) { $effectiveLogLevelValue = $logLevels["Info"] } # Fallback
    $messageLevelValue = $logLevels[$Level] # Уровень текущего сообщения
    if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] } # Fallback

    # Проверяем, нужно ли писать сообщение
    if ($messageLevelValue -le $effectiveLogLevelValue) {
        $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        $logMessage = "[$timestamp] [$Level] [$script:ComputerName] - $Message"
        # Определение цвета для консоли
        $consoleColor = switch($Level) {
            "Error"   { "Red" }
            "Warn"    { "Yellow" }
            "Info"    { "White" }
            "Verbose" { "Gray" }
            "Debug"   { "DarkGray" }
            Default   { "Gray" }
        }
        # Вывод в консоль
        Write-Host $logMessage -ForegroundColor $consoleColor

        # Запись в файл, если путь задан
        if ($script:LogFilePath) {
            try {
                # Проверяем/создаем папку для лога
                $logDir = Split-Path $script:LogFilePath -Parent
                if ($logDir -and (-not (Test-Path $logDir -PathType Container))) {
                    Write-Host "[INFO] Создание папки для лога: '$logDir'"
                    New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                }
                # Добавляем сообщение в файл
                Add-Content -Path $script:LogFilePath -Value $logMessage -Encoding UTF8 -Force -ErrorAction Stop
            } catch {
                # Ошибка записи в основной лог
                Write-Host ("[CRITICAL] Ошибка записи в лог '{0}': {1}" -f $script:LogFilePath, $_.Exception.Message) -ForegroundColor Red
                # Попытка записи в запасной лог в папке скрипта
                try {
                    $fallbackLog = "$PSScriptRoot\hybrid_agent_fallback.log"
                    $fallbackMessage = "[$timestamp] [$Level] [$script:ComputerName] - $Message"
                    $errorMessageLine = "[CRITICAL] FAILED TO WRITE TO '$($script:LogFilePath)': $($_.Exception.Message)"
                    Add-Content -Path $fallbackLog -Value $fallbackMessage -Encoding UTF8 -Force -ErrorAction SilentlyContinue
                    Add-Content -Path $fallbackLog -Value $errorMessageLine -Encoding UTF8 -Force -ErrorAction SilentlyContinue
                } catch {
                    # Игнорируем ошибки записи в запасной лог
                }
            }
        }
    }
}

<#
.SYNOPSIS Возвращает значение по умолчанию, если входное значение $null или пустое.
#>
filter Get-OrElse {
    param([object]$DefaultValue)
    if ($null -ne $_ -and (($_ -isnot [string]) -or (-not [string]::IsNullOrWhiteSpace($_)))) {
        $_
    } else {
        $DefaultValue
    }
}

<#
.SYNOPSIS Выполняет HTTP-запрос к API с логикой повторных попыток.
#>
function Invoke-ApiRequestWithRetry {
    param(
        [Parameter(Mandatory=$true)][string]$Uri,
        [Parameter(Mandatory=$true)][string]$Method,
        [Parameter(Mandatory=$false)]$BodyObject = $null, # Принимаем объект PS
        [Parameter(Mandatory=$true)][hashtable]$Headers, # Включая X-API-Key
        [Parameter(Mandatory=$true)][string]$Description # Описание для логов
    )

    $retryCount = 0
    $responseObject = $null # Результат (распарсенный JSON)
    $maxRetries = $script:Config.max_api_retries | Get-OrElse 3
    $timeoutSec = $script:Config.api_timeout_sec | Get-OrElse 60
    $retryDelaySec = $script:Config.retry_delay_seconds | Get-OrElse 5

    # Параметры для Invoke-RestMethod
    $invokeParams = @{
        Uri         = $Uri
        Method      = $Method
        Headers     = $Headers
        TimeoutSec  = $timeoutSec
        ErrorAction = 'Stop' # Ловим ошибки через try/catch
    }
    # Добавляем тело, если это не GET/DELETE и тело передано
    if ($BodyObject -ne $null -and $Method.ToUpper() -notin @('GET', 'DELETE')) {
        try {
            # Преобразуем объект в JSON строку
            $jsonBody = $BodyObject | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
            # Устанавливаем ContentType и тело запроса (байты UTF-8)
            $invokeParams.ContentType = 'application/json; charset=utf-8'
            $invokeParams.Body = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
             Write-Log "Тело запроса для ($Description): $jsonBody" -Level Debug
        } catch {
            Write-Log "Критическая ошибка ConvertTo-Json для ($Description): $($_.Exception.Message)" -Level Error
            # Write-Log "Проблемный объект: $($BodyObject | Out-String -Width 500)" -Level Debug # Может быть очень большим
            throw "Ошибка преобразования тела запроса в JSON." # Прерываем
        }
    }

    # Цикл повторных попыток
    while ($retryCount -lt $maxRetries -and $responseObject -eq $null) {
        try {
            Write-Log ("Выполнение запроса ({0}) (Попытка {1}/{2}): {3} {4}" -f $Description, ($retryCount + 1), $maxRetries, $Method, $Uri) -Level Verbose
            # Выполняем запрос
            $responseObject = Invoke-RestMethod @invokeParams
            # Успех!
            Write-Log ("Успешный ответ API ({0})." -f $Description) -Level Verbose
            return $responseObject # Возвращаем результат (распарсенный JSON)

        } catch [System.Net.WebException] { # Ловим специфичные ошибки веб-запросов
            $retryCount++
            $exception = $_.Exception
            $statusCode = $null
            $errorResponseBody = "[Не удалось прочитать тело ошибки]"
            if ($exception.Response -ne $null) {
                try { $statusCode = [int]$exception.Response.StatusCode } catch { }
                try {
                    $errorStream = $exception.Response.GetResponseStream()
                    $reader = New-Object System.IO.StreamReader($errorStream)
                    $errorResponseBody = $reader.ReadToEnd()
                    $reader.Close()
                    $errorStream.Dispose()
                     # Попытка распарсить тело ошибки как JSON
                     try { $errorJson = $errorResponseBody | ConvertFrom-Json; $errorResponseBody = $errorJson } catch {}
                } catch { }
            }
            # Формируем сообщение об ошибке
            $errorMessage = $exception.Message.Replace('{','{{').Replace('}','}}') # Экранируем фигурные скобки для -f
            $errorDetails = $errorResponseBody
            Write-Log ("Ошибка API ({0}) (Попытка {1}/{2}). Код: {3}. Error: {4}. Ответ: {5}" -f `
                        $Description, $retryCount, $maxRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage, ($errorDetails | Out-String -Width 300)) -Level Error

            # Критические ошибки, после которых нет смысла повторять
            if ($statusCode -in @(400, 401, 403, 404, 409, 422)) { # Bad Request, Unauthorized, Forbidden, Not Found, Conflict, Validation
                Write-Log ("Критическая ошибка API ({0} - Код {1}), повторные попытки отменены." -f $Description, $statusCode) -Level Error
                throw $exception # Пробрасываем исключение, чтобы основной код мог его обработать
            }
            # Если не критическая ошибка и попытки не кончились - пауза и повтор
            if ($retryCount -ge $maxRetries) {
                 Write-Log ("Превышено кол-во попыток ({0}) для ({1})." -f $maxRetries, $Description) -Level Error
                 throw $exception # Пробрасываем последнюю ошибку
            }
            Write-Log ("Пауза $retryDelaySec сек перед повторной попыткой...") -Level Warn
            Start-Sleep -Seconds $retryDelaySec

        } catch { # Ловим другие возможные ошибки (например, ConvertTo-Json выше или ошибки PS)
             $retryCount++ # Считаем попытку
             $errorMessage = $_.Exception.Message.Replace('{','{{').Replace('}','}}')
             Write-Log ("Неожиданная ошибка ({0}) (Попытка {1}/{2}): {3}" -f $Description, $retryCount, $maxRetries, $errorMessage) -Level Error
             # Сразу пробрасываем другие ошибки
             throw $_.Exception
        }
    } # Конец while
    # Сюда не должны попасть, если все работает как надо
    return $null
}

#endregion Функции

# --- 4. Основная логика ---

# 4.1 Чтение и валидация конфигурации
Write-Host "Запуск Гибридного Агента Мониторинга v$($script:AgentVersion)..."
Write-Log "Чтение конфигурации из '$ConfigFile'..." -Level Info
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Log "Критическая ошибка: Файл конфигурации '$ConfigFile' не найден." -Level Error; exit 1 }
try {
    $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop
} catch {
    Write-Log "Критическая ошибка: Ошибка чтения/парсинга JSON из '$ConfigFile': $($_.Exception.Message)" -Level Error
    exit 1
}

# --- Валидация ОБЩИХ обязательных полей ---
$requiredCommonFields = @("mode", "object_id", "log_file", "log_level", "agent_script_version")
$missingCommon = $requiredCommonFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or ($script:Config.$_ -is [string] -and [string]::IsNullOrWhiteSpace($script:Config.$_)) }
if ($missingCommon) { Write-Log ("Критическая ошибка: В '$ConfigFile' отсутствуют или пусты обязательные общие поля: $($missingCommon -join ', ')") -Level Error; exit 1 }

# Установка пути к лог-файлу и уровня логирования
$script:LogFilePath = $script:Config.log_file
$script:LogLevel = $script:Config.log_level
$validLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")
if ($script:LogLevel -notin $validLogLevels) { Write-Log ("Некорректный LogLevel '$($script:LogLevel)'. Используется 'Info'.") -Level Warn; $script:LogLevel = "Info" }

# Логирование базовой информации
Write-Log "Гибридный агент v$($script:AgentVersion) запущен. Имя хоста: $script:ComputerName" -Level Info
Write-Log "Режим работы: $($script:Config.mode)" -Level Info
Write-Log "ObjectID: $($script:Config.object_id)" -Level Info
Write-Log "Логирование в '$script:LogFilePath' с уровнем '$script:LogLevel'" -Level Info

# --- 4.2 Запуск логики для выбранного режима ---
$agentMode = $script:Config.mode.Trim().ToLower()

# --- ========================== ---
# ---      ONLINE РЕЖИМ        ---
# --- ========================== ---
if ($agentMode -eq 'online') {

    # --- Валидация параметров Online режима ---
    Write-Log "Проверка конфигурации для Online режима..." -Level Verbose
    $requiredOnlineFields = @("api_base_url", "api_key", "api_poll_interval_seconds", "default_check_interval_seconds")
    $missingOnline = $requiredOnlineFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or ($script:Config.$_ -is [string] -and [string]::IsNullOrWhiteSpace($script:Config.$_)) }
    if ($missingOnline) { Write-Log ("Критическая ошибка: Для Online режима в '$ConfigFile' отсутствуют поля: $($missingOnline -join ', ')") -Level Error; exit 1 }

    # Получаем интервалы (с проверкой)
    $apiPollInterval = 60; if ($script:Config.api_poll_interval_seconds -and [int]::TryParse($script:Config.api_poll_interval_seconds,[ref]$null) -and $script:Config.api_poll_interval_seconds -ge 10) { $apiPollInterval = $script:Config.api_poll_interval_seconds } else { Write-Log "..." "Warn" }
    $defaultCheckInterval = 300; if ($script:Config.default_check_interval_seconds -and [int]::TryParse($script:Config.default_check_interval_seconds,[ref]$null) -and $script:Config.default_check_interval_seconds -ge 5) { $defaultCheckInterval = $script:Config.default_check_interval_seconds } else { Write-Log "..." "Warn" }
    $apiPollTimeSpan = [TimeSpan]::FromSeconds($apiPollInterval)
    $defaultCheckTimeSpan = [TimeSpan]::FromSeconds($defaultCheckInterval)
    Write-Log ("Online режим: Опрос API каждые {0} сек, стандартный интервал {1} сек." -f $apiPollInterval, $defaultCheckInterval) -Level Info

    # --- Основной цикл Online режима ---
    Write-Log "Запуск основного цикла Online режима..." -Level Info
    while ($true) {
        $loopStartTime = [DateTimeOffset]::UtcNow # Используем UTC для сравнений
        Write-Log "Начало итерации цикла Online." -Level Verbose

        # --- Обновление списка заданий по расписанию ---
        if (($loopStartTime - $script:LastApiPollTimeOnline) -ge $apiPollTimeSpan) {
            Write-Log "Время обновить список заданий с API." -Level Info
            $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/assignments?object_id=$($script:Config.object_id)"
            $headers = @{ 'X-API-Key' = $script:Config.api_key }
            try {
                # Запрашиваем задания с помощью обертки с retry
                $fetchedAssignmentsRaw = Invoke-ApiRequestWithRetry `
                                            -Uri $apiUrl `
                                            -Method Get `
                                            -Headers $headers `
                                            -Description "Получение заданий (ObjectID $($script:Config.object_id))"

                if ($fetchedAssignmentsRaw -ne $null -and $fetchedAssignmentsRaw -is [array]) {
                     Write-Log "Получено $($fetchedAssignmentsRaw.Count) активных заданий от API." -Level Info
                    $newAssignmentMap = @{} # ID -> Объект
                    $fetchedIds = [System.Collections.Generic.List[int]]::new()
                    foreach ($assignmentRaw in $fetchedAssignmentsRaw) {
                        # Валидация полученного задания
                        if ($assignmentRaw -ne $null -and $assignmentRaw.PSObject -ne $null `
                            -and $assignmentRaw.PSObject.Properties.Name -contains 'assignment_id' `
                            -and $assignmentRaw.assignment_id -ne $null)
                        {
                            $id = $null
                            if([int]::TryParse($assignmentRaw.assignment_id, [ref]$id)) {
                                $newAssignmentMap[$id] = [PSCustomObject]$assignmentRaw # Сохраняем как PSCustomObject
                                $fetchedIds.Add($id)
                            } else { Write-Log "Нечисловой assignment_id получен от API: '$($assignmentRaw.assignment_id)'" -Level Warn }
                        } else { Write-Log "Получено некорректное задание от API: $($assignmentRaw | Out-String)" -Level Warn }
                    }

                    # Синхронизация с текущим списком
                    $currentIds = $script:ActiveAssignmentsOnline.Keys | ForEach-Object { [int]$_ }
                    $removedIds = $currentIds | Where-Object { $fetchedIds -notcontains $_ }
                    $addedCount = 0; $updatedCount = 0
                    # Удаляем устаревшие
                    if ($removedIds) {
                        foreach ($removedId in $removedIds) {
                            Write-Log "Удалено задание ID $removedId из активного списка." -Level Info
                            $script:ActiveAssignmentsOnline.Remove($removedId)
                            $script:LastExecutedTimesOnline.Remove($removedId)
                        }
                    }
                    # Добавляем/обновляем
                    foreach ($id in $fetchedIds) {
                        if (-not $script:ActiveAssignmentsOnline.ContainsKey($id)) {
                            $script:ActiveAssignmentsOnline[$id] = $newAssignmentMap[$id]
                            # Устанавливаем время последнего выполнения в далекое прошлое, чтобы выполнилось сразу
                            $script:LastExecutedTimesOnline[$id] = [DateTimeOffset]::UtcNow.AddDays(-1)
                            $addedCount++
                            Write-Log "Добавлено новое задание ID $id." -Level Info
                        } else {
                            # Проверка на изменения (сравниваем JSON представления)
                            $oldJson = $script:ActiveAssignmentsOnline[$id] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                            $newJson = $newAssignmentMap[$id] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                            if ($oldJson -ne $newJson) {
                                $script:ActiveAssignmentsOnline[$id] = $newAssignmentMap[$id]
                                # Не сбрасываем время выполнения при обновлении, чтобы не было всплеска
                                $updatedCount++
                                Write-Log "Обновлено задание ID $id." -Level Verbose
                            }
                        }
                    }
                    Write-Log ("Синхронизация заданий завершена. Добавлено:{0}. Обновлено:{1}. Удалено:{2}." `
                                -f $addedCount, $updatedCount, $removedIds.Count) -Level Info
                    $script:LastApiPollTimeOnline = $loopStartTime # Обновляем время последней успешной синхронизации

                } elseif ($fetchedAssignmentsRaw -eq $null) {
                    Write-Log "API вернул пустой ответ (возможно, нет активных заданий или ошибка)." -Level Warn
                    # Обработка случая, когда ВСЕ задания были удалены
                    if ($script:ActiveAssignmentsOnline.Count -gt 0) {
                         Write-Log "Очистка активных заданий, так как API вернул пустой список." -Level Info
                         $script:ActiveAssignmentsOnline.Clear()
                         $script:LastExecutedTimesOnline.Clear()
                    }
                    $script:LastApiPollTimeOnline = $loopStartTime # Считаем опрос успешным, хоть и пустым
                } else { # Не массив
                     Write-Log "API вернул некорректные данные заданий (не массив). Текущий список не изменен." -Level Error
                     # Не обновляем $script:LastApiPollTimeOnline, попробуем в след. раз
                }
            } catch { # Ошибка при вызове Invoke-ApiRequestWithRetry
                 Write-Log "Ошибка при получении заданий от API: $($_.Exception.Message). Используется текущий список заданий." -Level Error
                 # Не обновляем $script:LastApiPollTimeOnline
            }
        } else {
            Write-Log "Опрос API еще не требуется..." -Level Verbose
        }

        # --- Выполнение запланированных проверок ---
        $currentTime = [DateTimeOffset]::UtcNow # Текущее время UTC
        if ($script:ActiveAssignmentsOnline.Count -gt 0) {
            Write-Log "Проверка запланированных заданий ($($script:ActiveAssignmentsOnline.Count) активно)..." -Level Verbose
            # Копируем ключи, чтобы избежать проблем при изменении коллекции во время итерации
            $assignmentIdsToCheck = @($script:ActiveAssignmentsOnline.Keys)

            foreach ($id in $assignmentIdsToCheck) {
                # Проверяем, не удалили ли задание во время синхронизации
                if (-not $script:ActiveAssignmentsOnline.ContainsKey($id)) { continue }

                $assignment = $script:ActiveAssignmentsOnline[$id]
                # Определяем интервал для этого задания
                $checkIntervalSec = $assignment.check_interval_seconds | Get-OrElse $defaultCheckInterval
                if ($checkIntervalSec -le 0) { $checkIntervalSec = $defaultCheckInterval }
                $checkIntervalTimeSpan = [TimeSpan]::FromSeconds($checkIntervalSec)

                # Получаем время последнего выполнения
                $lastRunTime = [DateTimeOffset]::MinValue # Если не выполнялось, то давно пора
                if ($script:LastExecutedTimesOnline.ContainsKey($id)) {
                    $lastRunTime = $script:LastExecutedTimesOnline[$id]
                }

                # Вычисляем время следующего запуска
                $nextRunTime = $lastRunTime + $checkIntervalTimeSpan

                # Если пора выполнять
                if ($currentTime -ge $nextRunTime) {
                     Write-Log ("НАЧАЛО ВЫПОЛНЕНИЯ задания ID {0} ({1} для '{2}')." -f `
                                 $id, $assignment.method_name, $assignment.node_name) -Level Info
                    $checkResult = $null
                    try {
                        # --- Вызов основной функции проверки ---
                        $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment `
                                                                  -Verbose:$false ` # Передаем текущие настройки Verbose/Debug
                                                                  -Debug:$false   # или можно жестко задать $false

                        if ($checkResult -eq $null -or $checkResult.IsAvailable -eq $null) { throw "Invoke-StatusMonitorCheck вернул некорректный результат." }

                        Write-Log ("Результат проверки ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f `
                                   $id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) -Level Verbose

                        # --- Формирование payload для API ---
                        # API /checks теперь ожидает МАССИВ результатов
                        $payloadItem = @{
                            assignment_id        = $id
                            is_available         = $checkResult.IsAvailable
                            # CheckSuccess и ErrorMessage ИДУТ ВНУТРЬ details!
                            check_timestamp      = $checkResult.Timestamp # Уже в UTC ISO 8601
                            executor_object_id   = $script:Config.object_id # ID объекта, где работает агент
                            executor_host        = $script:ComputerName
                            resolution_method    = $assignment.method_name
                            detail_type          = $null # Тип будет определен по методу или внутри details
                            detail_data          = $checkResult.Details # Передаем объект Details как есть
                            agent_script_version = $script:AgentVersion
                            # assignment_config_version не актуально для Online
                        }
                        # Добавляем CheckSuccess и ErrorMessage в details, если они есть
                         if ($checkResult.PSObject.Properties.Name -contains 'CheckSuccess' -and $checkResult.CheckSuccess -ne $null) {
                             if ($payloadItem.detail_data -eq $null) { $payloadItem.detail_data = @{} }
                             $payloadItem.detail_data.CheckSuccess = $checkResult.CheckSuccess
                         }
                         if (-not [string]::IsNullOrEmpty($checkResult.ErrorMessage)) {
                              if ($payloadItem.detail_data -eq $null) { $payloadItem.detail_data = @{} }
                             $payloadItem.detail_data.ErrorMessageFromCheck = $checkResult.ErrorMessage
                             # Устанавливаем тип детализации ERROR, если он еще не установлен
                             if ($payloadItem.detail_type -eq $null) { $payloadItem.detail_type = "ERROR" }
                         }
                         # Если тип детализации все еще не установлен, используем имя метода
                         if ($payloadItem.detail_type -eq $null) {
                             $payloadItem.detail_type = $assignment.method_name.ToUpper() -replace '[^A-Z0-9_]','_'
                         }


                        # Создаем МАССИВ из одного элемента
                        $payloadArray = @( $payloadItem )

                        # --- Отправка результата в API ---
                        $apiUrlChecks = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/checks"
                        $sendSuccess = $false
                        try {
                             # Вызов API с retry (передаем МАССИВ в BodyObject)
                             $apiResponse = Invoke-ApiRequestWithRetry `
                                                -Uri $apiUrlChecks `
                                                -Method Post `
                                                -BodyObject $payloadArray `
                                                -Headers $headers `
                                                -Description "Отправка результата ID $id"

                             # Анализируем ответ (200 OK или 207 Multi-Status)
                             # Для массива из 1 элемента ожидаем 200 OK или 207 с 1 обработанным и 0 ошибок
                             if ($apiResponse -ne $null -and $apiResponse.status -eq 'success' `
                                 -and $apiResponse.processed -eq 1 -and $apiResponse.failed -eq 0) {
                                 $sendSuccess = $true
                                 Write-Log "Результат ID $id успешно отправлен в API." -Level Info
                             } elseif ($apiResponse -ne $null) { # Ответ есть, но не success или не 1/0
                                Write-Log ("Ответ API при отправке ID {0} не был 'success' или счетчики неверны. Статус: {1}, Обработано: {2}, Ошибки: {3}" -f `
                                            $id, $apiResponse.status, $apiResponse.processed, $apiResponse.failed) -Level Error
                                if($apiResponse.errors) { Write-Log "Ошибки от API: $($apiResponse.errors | ConvertTo-Json -Depth 3 -Compress)" -Level Error }
                            } else { # apiResponse = $null (Invoke-ApiRequestWithRetry не смог)
                                Write-Log "Не удалось отправить результат ID $id в API после всех попыток." -Level Error
                            }
                        } catch { # Ошибка в Invoke-ApiRequestWithRetry
                            Write-Log "Критическая ошибка при отправке результата ID $id в API: $($_.Exception.Message)" -Level Error
                        }

                        # Обновляем время выполнения только при УСПЕШНОЙ отправке
                        if ($sendSuccess) {
                            $script:LastExecutedTimesOnline[$id] = $currentTime
                            Write-Log "Время последнего выполнения ID $id обновлено." -Level Verbose
                        } else {
                             Write-Log "Время последнего выполнения ID $id НЕ обновлено из-за ошибки отправки." -Level Warn
                        }

                    } catch { # Ошибка при ВЫПОЛНЕНИИ Invoke-StatusMonitorCheck
                        Write-Log "Критическая ошибка при ВЫПОЛНЕНИИ задания ID ${id}: $($_.Exception.Message)" -Level Error
                        # Время выполнения НЕ обновляем
                    } finally {
                         Write-Log "ЗАВЕРШЕНИЕ ВЫПОЛНЕНИЯ задания ID $id." -Level Info
                    }
                } # Конец if ($currentTime -ge $nextRunTime)
            } # Конец foreach ($id in $assignmentIdsToCheck)
        } else {
            Write-Log "Нет активных заданий для выполнения." -Level Verbose
        }

        # --- Пауза перед следующей итерацией основного цикла ---
        # Короткая пауза, чтобы не загружать процессор на 100%
        Start-Sleep -Seconds 1

    } # --- Конец while ($true) Online ---

# --- =========================== ---
# ---      OFFLINE РЕЖИМ        ---
# --- =========================== ---
} elseif ($agentMode -eq 'offline') {

    # --- Валидация параметров Offline режима ---
    Write-Log "Проверка конфигурации для Offline режима..." -Level Verbose
    $requiredOfflineFields = @("assignments_file_path_pattern", "output_path", "output_name_template", "offline_cycle_interval_seconds")
    $missingOffline = $requiredOfflineFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or (($script:Config.$_ -is [string]) -and ([string]::IsNullOrWhiteSpace($script:Config.$_))) } # Позволяем 0 для offline_cycle_interval_seconds
    if ($missingOffline) { Write-Log ("Критическая ошибка: Для Offline режима в '$ConfigFile' отсутствуют поля: $($missingOffline -join ', ')") -Level Error; exit 1 }

    # Проверка путей
    $assignmentsFolderPath = $script:Config.assignments_file_path_pattern.TrimEnd('\*') # Убираем маску для проверки папки
    $outputPath = $script:Config.output_path
    $outputNameTemplate = $script:Config.output_name_template
    if(-not(Test-Path $assignmentsFolderPath -PathType Container)){ Write-Log "Критическая ошибка: Папка для файлов заданий '$assignmentsFolderPath' не найдена." -Level Error; exit 1 }
    if(-not(Test-Path $outputPath -PathType Container)){ Write-Log "Папка для результатов '$outputPath' не найдена. Попытка создать..." -Level Warn; try { New-Item -Path $outputPath -ItemType Directory -Force -EA Stop | Out-Null; Write-Log "Папка '$outputPath' успешно создана." -Level Info } catch { Write-Log "Критическая ошибка: Не удалось создать папку '$outputPath': $($_.Exception.Message)" -Level Error; exit 1 } };

    # Интервал цикла
    $offlineInterval = 0; if($script:Config.offline_cycle_interval_seconds -and [int]::TryParse($script:Config.offline_cycle_interval_seconds,[ref]$null) -and $script:Config.offline_cycle_interval_seconds -gt 0){ $offlineInterval = $script:Config.offline_cycle_interval_seconds }
    $runContinuously = ($offlineInterval -gt 0)
    if ($runContinuously) { Write-Log ("Offline режим: Запуск в циклическом режиме с интервалом {0} сек." -f $offlineInterval) -Level Info }
    else { Write-Log "Offline режим: Запуск в однократном режиме." -Level Info }

    # --- Основной цикл/запуск Offline режима ---
    do { # Используем do-while для гарантии хотя бы одного выполнения
        $cycleStartTime = [DateTimeOffset]::UtcNow
        Write-Log "Начало цикла/запуска Offline ($($cycleStartTime.ToString('s')))." -Level Info

        # --- Поиск и чтение файла конфигурации заданий ---
        $latestConfigFile = $null; $configError = $null; $configData = $null
        try {
            $assignmentsFilePattern = $script:Config.assignments_file_path_pattern
            Write-Log ("Поиск файла конфигурации в '$assignmentsFolderPath' по шаблону '$assignmentsFilePattern'...") -Level Debug
            # Ищем самый новый файл по LastWriteTime
            $foundFiles = Get-ChildItem -Path $assignmentsFilePattern -File -ErrorAction SilentlyContinue
            if ($Error.Count -gt 0 -and $Error[0].CategoryInfo.Category -eq 'ReadError') { throw ("Ошибка доступа при поиске файла: " + $Error[0].Exception.Message); $Error.Clear() }

            if ($foundFiles) {
                $latestConfigFile = $foundFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                Write-Log "Найден последний файл конфигурации: $($latestConfigFile.FullName)" -Level Verbose
            } else { Write-Log "Файлы конфигурации по шаблону '$assignmentsFilePattern' не найдены." -Level Warn }
        } catch { $configError = "Ошибка поиска файла конфигурации: $($_.Exception.Message)"; Write-Log $configError -Level Error }

        # Обрабатываем файл, только если он новый или еще не обрабатывался
        if ($latestConfigFile -ne $null -and $configError -eq $null) {
            if ($latestConfigFile.FullName -ne $script:lastProcessedConfigFileOffline) {
                Write-Log "Обнаружен новый/обновленный файл конфигурации: $($latestConfigFile.Name). Чтение..." -Level Info
                $tempAssignments = $null; $tempVersionTag = $null
                try {
                    $fileContent = Get-Content -Path $latestConfigFile.FullName -Raw -Encoding UTF8 -ErrorAction Stop
                    $fileContentClean = $fileContent.TrimStart([char]0xFEFF); # Убираем BOM, если есть
                    $configData = $fileContentClean | ConvertFrom-Json -ErrorAction Stop
                    # Валидация структуры конфига
                    if ($null -eq $configData -or (-not $configData.PSObject.Properties.Name.Contains('assignments')) -or ($configData.assignments -isnot [array]) -or (-not $configData.PSObject.Properties.Name.Contains('assignment_config_version')) -or (-not $configData.assignment_config_version) ) { throw ("Файл '$($latestConfigFile.Name)' имеет некорректную структуру JSON (отсутствуют 'assignments' или 'assignment_config_version').") };

                    $tempVersionTag = $configData.assignment_config_version
                    $tempAssignments = $configData.assignments
                    Write-Log ("Файл '{0}' успешно прочитан. Заданий: {1}, Версия конфига: '{2}'." -f $latestConfigFile.Name, $tempAssignments.Count, $tempVersionTag) -Level Info
                    # Обновляем глобальные переменные Offline режима
                    $script:CurrentAssignmentsOffline = $tempAssignments
                    $script:CurrentConfigVersionOffline = $tempVersionTag
                    $script:LastProcessedConfigFileOffline = $latestConfigFile.FullName
                } catch {
                    $errorMsg = "Критическая ошибка обработки файла '$($latestConfigFile.Name)': $($_.Exception.Message)"; Write-Log $errorMsg -Level Error
                    Write-Log ("Продолжаем использовать предыдущий список заданий (версия: {0})." -f ($script:currentConfigVersionOffline | Get-OrElse '[неизвестно]')) -Level Warn
                    # Не обновляем $script:lastProcessedConfigFileOffline
                }
            } else { Write-Log "Файл конфигурации '$($latestConfigFile.Name)' не изменился." -Level Verbose }
        } elseif ($configError -ne $null) { Write-Log "Продолжаем использовать предыдущий список заданий из-за ошибки поиска файла." -Level Warn }
        elseif ($script:lastProcessedConfigFileOffline -ne $null) { Write-Log "Файлы конфигурации не найдены. Продолжаем использовать предыдущий список." -Level Warn }
        else { Write-Log "Файлы конфигурации не найдены и нет предыдущего списка. Задания не будут выполнены." -Level Info }

        # --- Выполнение текущего списка заданий ---
        $cycleCheckResultsList = [System.Collections.Generic.List[object]]::new()
        if ($script:CurrentAssignmentsOffline -ne $null -and $script:CurrentAssignmentsOffline.Count -gt 0) {
            $assignmentsCount = $script:CurrentAssignmentsOffline.Count
            Write-Log ("Начало выполнения {0} заданий (Версия конфига: {1})..." -f $assignmentsCount, ($script:CurrentConfigVersionOffline | Get-OrElse 'N/A')) -Level Info
            $completedCount = 0

            foreach ($assignmentRaw in $script:CurrentAssignmentsOffline) {
                $completedCount++
                $assignment = $null # Сбрасываем перед каждой итерацией
                $currentAssignmentId = $null
                $currentMethodName = "[unknown method]"
                $currentNodeName = "[unknown node]"

                try {
                     # Преобразуем в PSCustomObject и валидируем базовую структуру
                     $assignment = [PSCustomObject]$assignmentRaw
                     $currentAssignmentId = $assignment.assignment_id
                     $currentMethodName = $assignment.method_name
                     $currentNodeName = $assignment.node_name | Get-OrElse "Assignment $currentAssignmentId"

                     if ($null -eq $assignment -or $null -eq $currentAssignmentId -or -not $currentMethodName) { throw "Некорректная структура задания в файле конфигурации." }

                     Write-Log ("Выполнение {0}/{1} (ID: {2}, Метод: {3}, Узел: '{4}')..." -f $completedCount, $assignmentsCount, $currentAssignmentId, $currentMethodName, $currentNodeName) -Level Verbose

                     # --- Вызов основной функции проверки ---
                     $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment `
                                                               -Verbose:$false `
                                                               -Debug:$false

                     if ($checkResult -eq $null -or $checkResult.IsAvailable -eq $null) { throw "Invoke-StatusMonitorCheck вернул некорректный результат." }

                     Write-Log ("Результат ID {0}: IsAvail={1}, ChkSucc={2}, Err='{3}'" -f `
                                $currentAssignmentId, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) -Level Verbose

                    # --- СОЗДАЕМ НОВЫЙ ОБЪЕКТ С ДОБАВЛЕННЫМ assignment_id ---
                     $resultToSave = @{ assignment_id = $currentAssignmentId } + $checkResult
                    # --- КОНЕЦ СОЗДАНИЯ ---

                     # Добавляем результат в список для файла
                     $cycleCheckResultsList.Add($resultToSave)

                } catch { # Ловим ошибки ВАЛИДАЦИИ или ВЫПОЛНЕНИЯ КОНКРЕТНОГО ЗАДАНИЯ
                     $errorMessage = "Ошибка обработки/выполнения задания ID {0} ({1} для '{2}'): {3}" -f `
                                     ($currentAssignmentId | Get-OrElse '[N/A]'), $currentMethodName, $currentNodeName, $_.Exception.Message
                     Write-Log $errorMessage -Level Error
                     # Формируем результат с ошибкой и добавляем его в список
                     $errorDetails = @{ ErrorRecord = $_.ToString(); OriginalAssignment = ($assignmentRaw | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue) }
                     $errorResultBase = New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details $errorDetails
                     # Добавляем ID, если он был
                     $errorResultToSave = @{ assignment_id = $currentAssignmentId } + $errorResultBase
                     $cycleCheckResultsList.Add($errorResultToSave)
                 }
            } # Конец foreach assignment
            Write-Log "Выполнение $assignmentsCount заданий завершено. Собрано результатов: $($cycleCheckResultsList.Count)." -Level Info
        } else { Write-Log "Нет активных заданий для выполнения." -Level Verbose }

        # --- Формирование и АТОМАРНОЕ сохранение файла *.zrpu ---
        if ($cycleCheckResultsList.Count -gt 0) {
             $timestampForFile = Get-Date -Format "ddMMyy_HHmmss"
             $outputFileName = $outputNameTemplate -replace "{object_id}", $script:Config.object_id -replace "{ddMMyy_HHmmss}", $timestampForFile
             $outputFileName = $outputFileName -replace '[\\/:*?"<>|]', '_' # Убираем недопустимые символы
             $outputFileFullPath = Join-Path $outputPath $outputFileName
             # Путь к временному файлу
             $tempOutputFileFullPath = $outputFileFullPath + ".tmp"

             Write-Log ("Сохранение {0} результатов в файл: '{1}'" -f $cycleCheckResultsList.Count, $outputFileFullPath) -Level Info
             Write-Log ("Версия агента: {0}, Версия конфига заданий: {1}" -f $script:AgentVersion, ($script:CurrentConfigVersionOffline | Get-OrElse 'N/A')) -Level Verbose

             # Формируем итоговый объект
             $finalPayload = @{
                 agent_script_version      = $script:AgentVersion
                 assignment_config_version = $script:CurrentConfigVersionOffline
                 object_id                 = $script:Config.object_id # Для идентификации источника Загрузчиком
                 execution_timestamp_utc   = $cycleStartTime.ToString("o") # Время начала цикла
                 results                   = $cycleCheckResultsList
             }

             # Атомарное сохранение
             try {
                 # 1. Сохраняем во временный файл
                 $jsonToSave = $finalPayload | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
                 $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false)
                 [System.IO.File]::WriteAllText($tempOutputFileFullPath, $jsonToSave, $Utf8NoBomEncoding)
                 Write-Log "Данные успешно записаны во временный файл: '$tempOutputFileFullPath'" -Level Debug

                 # 2. Переименовываем временный файл в основной (атомарно в NTFS)
                 Move-Item -Path $tempOutputFileFullPath -Destination $outputFileFullPath -Force -ErrorAction Stop
                 Write-Log "Файл результатов '$outputFileName' успешно сохранен (атомарно)." -Level Info

             } catch {
                 Write-Log ("Критическая ошибка сохранения/переименования файла результатов '{0}': {1}" `
                            -f $outputFileFullPath, $_.Exception.Message) -Level Error
                 # Пытаемся удалить временный файл, если он остался
                 if (Test-Path $tempOutputFileFullPath -PathType Leaf) {
                     try { Remove-Item -Path $tempOutputFileFullPath -Force -ErrorAction SilentlyContinue } catch {}
                 }
             }
        } else {
             Write-Log "Нет результатов для сохранения в файл." -Level Verbose
        }

        # --- Пауза (если в циклическом режиме) ---
        if ($runContinuously) {
            $cycleEndTime = [DateTimeOffset]::UtcNow
            $elapsedSeconds = ($cycleEndTime - $cycleStartTime).TotalSeconds
            $sleepSeconds = $offlineInterval - $elapsedSeconds
            if ($sleepSeconds -lt 1) { $sleepSeconds = 1 }
            Write-Log ("Итерация Offline заняла {0:N2} сек. Пауза {1:N2} сек..." -f $elapsedSeconds, $sleepSeconds) -Level Verbose
            Start-Sleep -Seconds $sleepSeconds
        }

    } while ($runContinuously) # --- Конец do-while Offline ---

    Write-Log ("Offline режим завершен ({0})." -f ($runContinuously ? 'цикл прерван?' : 'однократный запуск')) -Level Info
    exit 0 # Успешный выход (особенно для однократного режима)

# --- ============================= ---
# --- НЕИЗВЕСТНЫЙ РЕЖИМ / ОШИБКА  ---
# --- ============================= ---
} else {
     Write-Log "Критическая ошибка: Неизвестный или некорректный режим работы '$($script:Config.mode)' в файле конфигурации." -Level Error
     Write-Log "Допустимые режимы: 'Online' или 'Offline'." -Level Error
     exit 1
}

# Код сюда не должен доходить при нормальной работе
Write-Log "Агент завершает работу непредвиденно." -Level Error
exit 1
==== END FILE: F:\status\source\powershell\hybrid-agent\hybrid-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\hybrid-agent\README.md ====
# PowerShell Гибридный Агент Мониторинга (hybrid-agent) v7.0

Этот скрипт (`hybrid-agent.ps1`) выполняет роль универсального агента мониторинга для системы Status Monitor, способного работать в двух режимах: **Online** и **Offline**.

## Назначение

*   Выполнять мониторинг узлов как с прямым сетевым доступом к API сервера (**Online режим**), так и в изолированных сетевых сегментах без доступа к API (**Offline режим**).
*   Режим работы определяется параметром `"mode"` в файле конфигурации `config.json`.
*   Использовать общий модуль `StatusMonitorAgentUtils` для выполнения конкретных проверок, обеспечивая единообразие логики.
*   Взаимодействовать с API сервера или файловой системой в зависимости от выбранного режима.
*   Вести детальный лог своей работы.

## Режимы Работы

### Online Режим (`"mode": "Online"`)

*   **Получение заданий:** Периодически (раз в `api_poll_interval_seconds`) запрашивает актуальный список активных заданий для своего `object_id` у API сервера (`GET /api/v1/assignments`).
*   **Выполнение:** Планирует и выполняет каждое полученное задание согласно его индивидуальному интервалу (`check_interval_seconds` из задания или `default_check_interval_seconds` из конфига).
*   **Отправка результатов:** Немедленно после выполнения КАЖДОЙ проверки отправляет результат на API сервер (`POST /api/v1/checks`). Результат отправляется в виде **массива из одного элемента**.
*   **Требования:** Прямой сетевой доступ к `api_base_url`, валидный `api_key` с ролью `agent`.

### Offline Режим (`"mode": "Offline"`)

*   **Получение заданий:** Ищет и читает самый новый файл конфигурации (`*.json.status.*`, соответствующий `object_id`) из папки, указанной в `assignments_file_path_pattern`. Задания выполняются только при обнаружении нового/обновленного файла конфигурации или при первом запуске.
*   **Выполнение:** Запускает ВСЕ задания из файла конфигурации за один проход (цикл). Цикличность выполнения всего набора проверок определяется параметром `offline_cycle_interval_seconds`. Если он равен 0, скрипт выполнит проверки один раз и завершится (подходит для запуска по расписанию).
*   **Отправка результатов:** Собирает результаты ВСЕХ проверок за цикл в один массив. **Атомарно** сохраняет этот массив вместе с метаданными (версии, ID объекта) в JSON-файл с расширением `.zrpu` в папку `output_path`. Этот файл затем должен быть передан и обработан **Загрузчиком Результатов**.
*   **Требования:** Доступ к папке с файлами конфигурации, доступ на запись в `output_path`. Сетевой доступ к API не требуется.

## Принцип работы

1.  Скрипт `hybrid-agent.ps1` запускается.
2.  Читает `config.json`.
3.  Определяет режим работы (`mode`).
4.  Валидирует необходимые параметры конфигурации для выбранного режима.
5.  Импортирует модуль `StatusMonitorAgentUtils`.
6.  Запускает логику для выбранного режима (либо бесконечный цикл для Online, либо цикл/однократный запуск для Offline).
7.  **В обоих режимах:** Для выполнения конкретной проверки вызывается `Invoke-StatusMonitorCheck` из модуля `StatusMonitorAgentUtils`.
8.  Логирует свою работу.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `hybrid-agent.ps1`.

```json
{
    "mode": "Online", // "Online" или "Offline" - ОБЯЗАТЕЛЬНО
    "object_id": 1516, // ID объекта (подразделения/узла) - ОБЯЗАТЕЛЬНО
    "log_file": "C:/StatusMonitor/Logs/hybrid-agent.log", // ОБЯЗАТЕЛЬНО
    "log_level": "Info", // "Debug", "Verbose", "Info", "Warn", "Error" - ОБЯЗАТЕЛЬНО
    "agent_script_version": "hybrid_agent_v7.0", // Версия скрипта агента - ОБЯЗАТЕЛЬНО

    // --- Параметры для режима "Online" ---
    "api_base_url": "http://your-server-address:5000/api/v1", // ОБЯЗАТЕЛЬНО для Online
    "api_key": "your_agent_api_key",                     // ОБЯЗАТЕЛЬНО для Online (роль 'agent')
    "api_poll_interval_seconds": 60,                      // ОБЯЗАТЕЛЬНО для Online
    "default_check_interval_seconds": 300,               // ОБЯЗАТЕЛЬНО для Online
    "max_api_retries": 3,                                // Опционально для Online (default: 3)
    "retry_delay_seconds": 5,                            // Опционально для Online (default: 5)
    "api_timeout_sec": 60,                               // Опционально для Online (default: 60)

    // --- Параметры для режима "Offline" ---
    "assignments_file_path_pattern": "C:/StatusMonitor/OfflineConfig/*.json.status.*", // ОБЯЗАТЕЛЬНО для Offline
    "output_path": "C:/StatusMonitor/OfflineResults",          // ОБЯЗАТЕЛЬНО для Offline
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_HybridOffline.zrpu", // ОБЯЗАТЕЛЬНО для Offline
    "offline_cycle_interval_seconds": 3600                   // ОБЯЗАТЕЛЬНО для Offline (0 для однократного запуска)
}

Важно: Убедитесь, что для выбранного режима (mode) заданы все обязательные параметры.
Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль Utils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой hybrid-agent (т.е. ..\StatusMonitorAgentUtils) или в путях $env:PSModulePath.

    Online режим: Требуется сетевой доступ к api_base_url и к целевым узлам для проверок. Нужен действительный API ключ с ролью agent.

    Offline режим: Требуется доступ на чтение к папке с файлами конфигурации (assignments_file_path_pattern) и на запись в output_path. Необходим механизм доставки файлов конфигурации и отправки файлов результатов (.zrpu).

    Права: Права на запись в log_file. Права, необходимые для выполнения конкретных проверок (зависят от метода проверки).

    Запуск:

        Online: Рекомендуется запускать как Службу Windows для непрерывной работы.

        Offline (циклический): Рекомендуется запускать как Службу Windows.

        Offline (однократный, offline_cycle_interval_seconds = 0): Рекомендуется запускать через Планировщик Задач Windows с нужным интервалом.

Замечания

    Логика конкретных проверок находится в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.

    Атомарная запись .zrpu в Offline режиме обеспечивается через создание временного файла и его переименование.
==== END FILE: F:\status\source\powershell\hybrid-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\config.json ====
{
    "object_id": 1060, 
    "config_type": "offline_multi_check_agent_v2.3", 
    "check_interval_seconds": 60,
    "output_path": "F:\\status\\builds\\results_offline", 
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_OfflineChecks.json.status.zrpu", 
    "logFile": "F:\\status\\builds\\Logs\\offline_agent.log",
    "LogLevel": "Debug", 
    "assignments_file_path": "F:\\status\\builds\\delivery_conf\\TSP"
}
==== END FILE: F:\status\source\powershell\offline-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\offline-agent.ps1 ====
# powershell\offline-agent\offline-agent.ps1
# Оффлайн-агент мониторинга v3.1.
# Исправлено добавление assignment_id к результатам.
<#
.SYNOPSIS
    Оффлайн-агент системы мониторинга Status Monitor v3.1.
.DESCRIPTION
    Предназначен для работы в изолированных сетях без доступа к API.
    1. Читает локальную конфигурацию агента ('config.json').
    2. Периодически проверяет наличие файла с заданиями
       в папке 'assignments_file_path'.
    3. При обнаружении нового файла заданий:
       - Читает JSON-содержимое.
       - Извлекает список 'assignments' и 'assignment_config_version'.
       - Сохраняет их для выполнения.
    4. В цикле выполняет ВСЕ активные задания с помощью
       Invoke-StatusMonitorCheck из модуля StatusMonitorAgentUtils.
    5. Собирает стандартизированные результаты всех проверок.
    6. **Создает новый объект для каждого результата, объединяя
       стандартный результат и 'assignment_id'.**
    7. Формирует итоговый JSON-файл (*.zrpu) в папке 'output_path',
       включая метаданные (версии агента и конфига) и массив 'results'.
    8. Этот *.zrpu файл затем передается и загружается на сервер.
.NOTES
    Версия: 3.1
    Дата: 2024-05-20
    Изменения v3.1:
        - Исправлен способ добавления 'assignment_id' к результатам. Вместо
          Add-Member теперь создается новый объект путем слияния хэш-таблиц.
    Изменения v3.0:
        - Попытка добавить поле 'assignment_id' к каждому элементу в массиве 'results'.
    Зависимости: PowerShell 5.1+, модуль StatusMonitorAgentUtils, наличие файла конфигурации заданий.
#>

param (
    # Путь к файлу конфигурации агента.
    [string]$configFile = "$PSScriptRoot\config.json",

    # Параметры для переопределения лог-файла и уровня логирования из командной строки.
    [string]$paramLogFile = $null,
    [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
    [string]$paramLogLevel = $null
)

# --- Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try {
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils загружен."
} catch {
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    exit 1
} finally {
    $ErrorActionPreference = "Continue"
}
# --- Конец загрузки модуля ---

# --- Глобальные переменные ---
# Версия текущего скрипта оффлайн-агента
$AgentScriptVersion = "agent_script_v3.1" # Обновили версию

# Имя компьютера
$script:ComputerName = $env:COMPUTERNAME
# Текущий список заданий (массив объектов PSCustomObject из файла конфигурации)
$script:currentAssignments = $null
# Текущая версия файла конфигурации заданий (строка из файла)
$script:currentAssignmentVersion = $null
# Путь к последнему обработанному файлу конфигурации заданий
$script:lastProcessedConfigFile = $null
# Объект с конфигурацией самого агента (из config.json)
$script:localConfig = $null
# Путь к лог-файлу агента
$script:logFile = $null
# Установленный уровень логирования
$script:LogLevel = "Info"
# Допустимые уровни логирования
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")


# --- Функции ---

#region Функции

<#
.SYNOPSIS Записывает сообщение в лог.
#>
function Write-Log{
    param( [Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug","Verbose","Info","Warn","Error",IgnoreCase=$true)] [string]$Level="Info" ); if (-not $script:localConfig -or -not $script:logFile) { Write-Host "[$Level] $Message"; return }; $logLevels=@{"Debug"=4;"Verbose"=3;"Info"=2;"Warn"=1;"Error"=0}; $effectiveLogLevel = $script:LogLevel; if(-not $logLevels.ContainsKey($effectiveLogLevel)){ $effectiveLogLevel="Info" }; $currentLevelValue = $logLevels[$effectiveLogLevel]; $messageLevelValue = $logLevels[$Level]; if($null -eq $messageLevelValue){ $messageLevelValue=$logLevels["Info"] }; if($messageLevelValue -le $currentLevelValue){ $timestamp=Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage="[$timestamp] [$Level] [$script:ComputerName] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; if($script:logFile){ try { $logDir = Split-Path $script:logFile -Parent; if($logDir -and (-not(Test-Path $logDir -PathType Container))){ Write-Host "[INFO] Создание папки логов: '$logDir'."; New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null }; Add-Content -Path $script:logFile -Value $logMessage -Encoding UTF8 -Force -EA Stop } catch { Write-Host "[CRITICAL] Ошибка записи в лог '$script:logFile': $($_.Exception.Message)" -ForegroundColor Red; try { $fallbackLog = "$PSScriptRoot\offline_agent_fallback.log"; Add-Content -Path $fallbackLog -Value $logMessage -Encoding UTF8 -Force -EA SilentlyContinue; Add-Content -Path $fallbackLog -Value "[CRITICAL] Ошибка записи в '$script:logFile': $($_.Exception.Message)" -Encoding UTF8 -Force -EA SilentlyContinue } catch {} } } }
}

<#
.SYNOPSIS Возвращает значение по умолчанию, если входное значение ложно.
#>
filter Get-OrElse_Internal{ param([object]$DefaultValue); if ($_) { $_ } else { $DefaultValue } }

#endregion Функции

# --- Основной код агента ---

# 1. Чтение и валидация конфигурации агента
# ... (код чтения и валидации конфига без изменений) ...
Write-Host "Оффлайн-агент мониторинга v$AgentScriptVersion"; Write-Host "Чтение конфигурации агента: $configFile"
if(-not(Test-Path $configFile -PathType Leaf)){ Write-Error "Критическая ошибка: Файл конфигурации '$configFile' не найден."; exit 1 }
try { $script:localConfig = Get-Content -Path $configFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error "Критическая ошибка: Ошибка чтения/парсинга JSON из '$configFile': $($_.Exception.Message)"; exit 1 }
$requiredLocalConfigFields = @("object_id","output_path","output_name_template","assignments_file_path","logFile","LogLevel","check_interval_seconds"); $missingFields = $requiredLocalConfigFields | Where-Object { -not ($script:localConfig.PSObject.Properties.Name.Contains($_)) -or $null -eq $script:localConfig.$_ -or ($script:localConfig.$_ -is [string] -and [string]::IsNullOrWhiteSpace($script:localConfig.$_))}; if($missingFields){ Write-Error "Критическая ошибка: Отсутствуют/пусты обязательные поля в '$configFile': $($missingFields -join ', ')"; exit 1 }
$script:logFile = if($PSBoundParameters.ContainsKey('paramLogFile') -and $paramLogFile){ $paramLogFile } else { $script:localConfig.logFile }; $script:LogLevel = if($PSBoundParameters.ContainsKey('paramLogLevel') -and $paramLogLevel){ $paramLogLevel } else { $script:localConfig.LogLevel }; if(-not $ValidLogLevels.Contains($script:LogLevel)){ Write-Host "[WARN] Некорректный LogLevel '$($script:LogLevel)'. Используется 'Info'." -ForegroundColor Yellow; $script:LogLevel = "Info" }; $checkInterval = 60; if($script:localConfig.check_interval_seconds -and [int]::TryParse($script:localConfig.check_interval_seconds,[ref]$null) -and $script:localConfig.check_interval_seconds -ge 5){ $checkInterval = $script:localConfig.check_interval_seconds } else { Write-Log "Некорректное значение check_interval_seconds ('$($script:localConfig.check_interval_seconds)'). Используется $checkInterval сек." "Warn" }
$objectId = $script:localConfig.object_id; $outputPath = $script:localConfig.output_path; $outputNameTemplate = $script:localConfig.output_name_template; $assignmentsFolderPath = $script:localConfig.assignments_file_path


# 2. Инициализация и проверка путей
# ... (код инициализации и проверки путей без изменений) ...
Write-Log "Оффлайн-агент запущен. Версия: $AgentScriptVersion. Имя хоста: $script:ComputerName" "Info"; Write-Log ("Параметры: ObjectID={0}, Интервал={1} сек, Папка заданий='{2}', Папка результатов='{3}'" -f $objectId, $checkInterval, $assignmentsFolderPath, $outputPath) "Info"; Write-Log "Логирование в '$script:logFile' с уровнем '$script:LogLevel'" "Info"; if(-not(Test-Path $outputPath -PathType Container)){ Write-Log "Папка для результатов '$outputPath' не найдена. Попытка создать..." "Warn"; try { New-Item -Path $outputPath -ItemType Directory -Force -ErrorAction Stop | Out-Null; Write-Log "Папка '$outputPath' успешно создана." "Info" } catch { Write-Log "Критическая ошибка: Не удалось создать папку для результатов '$outputPath': $($_.Exception.Message)" "Error"; exit 1 } }; if(-not(Test-Path $assignmentsFolderPath -PathType Container)){ Write-Log "Критическая ошибка: Папка для файлов заданий '$assignmentsFolderPath' не найдена." "Error"; exit 1 }


# --- 3. Основной цикл работы агента ---
Write-Log "Запуск основного цикла агента..." "Info"
while ($true) {
    $cycleStartTime = Get-Date
    Write-Log "Начало итерации цикла ($($cycleStartTime.ToString('s')))." "Verbose"

    # --- 3.1 Поиск и чтение файла конфигурации заданий ---
    # ... (код поиска и чтения файла конфига без изменений) ...
    $latestConfigFile = $null; $configError = $null; $configData = $null
    try { $configFileNamePattern = "*_${objectId}_*_assignments.json.status.*"; Write-Log "Поиск файла конфигурации в '$assignmentsFolderPath' по шаблону '$configFileNamePattern'..." "Debug"; $foundFiles = Get-ChildItem -Path $assignmentsFolderPath -Filter $configFileNamePattern -File -ErrorAction SilentlyContinue; if ($Error.Count -gt 0 -and $Error[0].CategoryInfo.Category -eq 'ReadError') { throw ("Ошибка доступа при поиске файла конфигурации в '$assignmentsFolderPath': " + $Error[0].Exception.Message); $Error.Clear() }; if ($foundFiles) { $latestConfigFile = $foundFiles | Sort-Object Name -Descending | Select-Object -First 1; Write-Log "Найден последний файл конфигурации: $($latestConfigFile.FullName)" "Verbose" } else { Write-Log "Файлы конфигурации для ObjectID $objectId в '$assignmentsFolderPath' не найдены." "Warn" } } catch { $configError = "Ошибка поиска файла конфигурации: $($_.Exception.Message)"; Write-Log $configError "Error" }
    if ($latestConfigFile -ne $null -and $configError -eq $null) { if ($latestConfigFile.FullName -ne $script:lastProcessedConfigFile) { Write-Log "Обнаружен новый/обновленный файл конфигурации: $($latestConfigFile.Name). Чтение..." "Info"; $tempAssignments = $null; $tempVersionTag = $null; try { $fileContent = Get-Content -Path $latestConfigFile.FullName -Raw -Encoding UTF8 -ErrorAction Stop; $fileContentClean = $fileContent.TrimStart([char]0xFEFF); $configData = $fileContentClean | ConvertFrom-Json -ErrorAction Stop; if ($null -eq $configData -or (-not $configData.PSObject.Properties.Name.Contains('assignments')) -or ($configData.assignments -isnot [array]) -or (-not $configData.PSObject.Properties.Name.Contains('assignment_config_version')) -or (-not $configData.assignment_config_version) ) { throw ("Файл '$($latestConfigFile.Name)' имеет некорректную структуру JSON...") }; $tempVersionTag = $configData.assignment_config_version; $tempAssignments = $configData.assignments; Write-Log ("Файл '{0}' успешно прочитан..." -f $latestConfigFile.Name, $tempAssignments.Count, $tempVersionTag) "Info"; $script:currentAssignments = $tempAssignments; $script:currentAssignmentVersion = $tempVersionTag; $script:lastProcessedConfigFile = $latestConfigFile.FullName; Write-Log "Список заданий обновлен (версия: $tempVersionTag)..." "Info" } catch { $errorMsg = "Критическая ошибка обработки файла '$($latestConfigFile.Name)': $($_.Exception.Message)"; Write-Log $errorMsg "Error"; Write-Log ("Продолжаем использовать предыдущий список заданий (версия: {0})." -f ($script:currentAssignmentVersion | Get-OrElse_Internal '[неизвестно]')) "Warn" } } else { Write-Log "Файл конфигурации '$($latestConfigFile.Name)' не изменился." "Verbose" } } elseif ($configError -ne $null) { Write-Log "Продолжаем использовать предыдущий список заданий..." "Warn" } elseif ($script:lastProcessedConfigFile -ne $null) { Write-Log "Файлы конфигурации не найдены. Продолжаем использовать предыдущий список..." "Warn" } else { Write-Log "Файлы конфигурации не найдены..." "Info" }

    # --- 3.2 Выполнение текущего списка заданий ---
    $cycleCheckResultsList = [System.Collections.Generic.List[object]]::new()

    if ($script:currentAssignments -ne $null -and $script:currentAssignments.Count -gt 0) {
        $assignmentsCount = $script:currentAssignments.Count
        Write-Log "Начало выполнения $assignmentsCount заданий (Версия конфига: $($script:currentAssignmentVersion | Get-OrElse_Internal 'N/A'))..." "Info"
        $completedCount = 0

        foreach ($assignmentRaw in $script:currentAssignments) {
            $completedCount++
            $assignment = [PSCustomObject]$assignmentRaw
            Write-Log "Выполнение $completedCount/$assignmentsCount (ID: $($assignment.assignment_id))..." "Verbose"

            if ($null -eq $assignment -or $null -eq $assignment.assignment_id -or -not $assignment.method_name) {
                Write-Log "Пропущено некорректное задание в списке: $($assignment | Out-String)" "Warn"
                # --- ИЗМЕНЕНО: Создаем объект ошибки через слияние ---
                $errorDetails = @{ assignment_object = ($assignment | Out-String) }
                $errorResultBase = New-CheckResultObject -IsAvailable $false `
                                      -ErrorMessage "Некорректная структура задания в файле конфигурации." `
                                      -Details $errorDetails
                $idPart = @{ assignment_id = ($assignment.assignment_id | Get-OrElse_Internal $null) }
                $errorResultToSave = $idPart + $errorResultBase
                $cycleCheckResultsList.Add($errorResultToSave)
                # --- КОНЕЦ ИЗМЕНЕНИЯ ---
                continue
            }

            $checkResult = $null
            try {
                # Вызываем диспетчер проверок
                $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment `
                                                        -Verbose:$VerbosePreference `
                                                        -Debug:$DebugPreference

                Write-Log ("Результат ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f `
                           $assignment.assignment_id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) "Verbose"

                # --- ИЗМЕНЕНО: Создаем НОВЫЙ объект результата с ID через слияние ---
                $idPart = @{ assignment_id = $assignment.assignment_id }
                $resultToSave = $idPart + $checkResult
                # --- КОНЕЦ ИЗМЕНЕНИЯ ---

                # Отладочный вывод (если включен Debug)
                Write-Debug ("Объект ДО добавления в список (ID: {0}): {1}" -f `
                             $assignment.assignment_id, ($resultToSave | ConvertTo-Json -Depth 4 -Compress))

                # Добавляем результат в список для файла
                $cycleCheckResultsList.Add($resultToSave)

            } catch {
                 # Обработка критической ошибки выполнения Invoke-StatusMonitorCheck
                 $errorMessage = "Критическая ошибка при выполнении задания ID $($assignment.assignment_id): $($_.Exception.Message)"
                 Write-Log $errorMessage "Error"
                 # Создаем запись об ошибке
                 $errorDetails = @{ ErrorRecord = $_.ToString() }
                 $errorResultBase = New-CheckResultObject -IsAvailable $false `
                                      -ErrorMessage $errorMessage `
                                      -Details $errorDetails
                 # --- ИЗМЕНЕНО: Создаем НОВЫЙ объект ошибки с ID через слияние ---
                 $idPart = @{ assignment_id = $assignment.assignment_id }
                 $errorResultToSave = $idPart + $errorResultBase
                 # --- КОНЕЦ ИЗМЕНЕНИЯ ---

                 # Отладочный вывод для ошибки
                 Write-Debug ("ОБЪЕКТ ОШИБКИ ДО добавления в список (ID: {0}): {1}" -f `
                              $assignment.assignment_id, ($errorResultToSave | ConvertTo-Json -Depth 4 -Compress))

                 # Добавляем результат с ошибкой в общий список
                 $cycleCheckResultsList.Add($errorResultToSave)
            }
        } # Конец foreach assignment

        Write-Log "Выполнение $assignmentsCount заданий завершено. Собрано результатов: $($cycleCheckResultsList.Count)." "Info"

    } else {
        Write-Log "Нет активных заданий для выполнения в этой итерации." "Verbose"
    }

    # --- 3.3 Формирование и сохранение файла результатов (*.zrpu) ---
    if ($cycleCheckResultsList.Count -gt 0) {
        # ... (код формирования $finalPayload и сохранения файла без изменений) ...
        $finalPayload = @{ agent_script_version = $AgentScriptVersion; assignment_config_version = $script:currentAssignmentVersion; results = $cycleCheckResultsList }
        $timestampForFile = Get-Date -Format "ddMMyy_HHmmss"; $outputFileName = $outputNameTemplate -replace "{object_id}", $objectId -replace "{ddMMyy_HHmmss}", $timestampForFile; $outputFileName = $outputFileName -replace '[\\/:*?"<>|]', '_'; $outputFileFullPath = Join-Path $outputPath $outputFileName
        Write-Log "Сохранение $($cycleCheckResultsList.Count) результатов в файл: '$outputFileFullPath'" "Info"; Write-Log ("Версия агента: {0}, Версия конфига заданий: {1}" -f $AgentScriptVersion, ($script:currentAssignmentVersion | Get-OrElse_Internal 'N/A')) "Verbose"
        try { $jsonToSave = $finalPayload | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue; $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false); [System.IO.File]::WriteAllText($outputFileFullPath, $jsonToSave, $Utf8NoBomEncoding); Write-Log "Файл результатов '$outputFileName' успешно сохранен." "Info" }
        catch { Write-Log "Критическая ошибка сохранения файла результатов '$outputFileFullPath': $($_.Exception.Message)" "Error" }
    } else {
        Write-Log "Нет результатов для сохранения в файл в этой итерации." "Verbose"
    }

    # --- 3.4 Пауза перед следующей итерацией ---
    # ... (код расчета паузы и Start-Sleep без изменений) ...
    $cycleEndTime = Get-Date; $elapsedSeconds = ($cycleEndTime - $cycleStartTime).TotalSeconds; $sleepSeconds = $checkInterval - $elapsedSeconds; if ($sleepSeconds -lt 1) { $sleepSeconds = 1 }
    Write-Log ("Итерация заняла {0:N2} сек. Пауза {1:N2} сек до следующего цикла..." -f $elapsedSeconds, $sleepSeconds) "Verbose"; Start-Sleep -Seconds $sleepSeconds

} # --- Конец while ($true) ---

Write-Log "Оффлайн-агент завершает работу (неожиданный выход из основного цикла)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\offline-agent\offline-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\README.md ====

---

**6. `powershell/offline-agent/README.md` (Обновление)**

```markdown
# PowerShell Offline Агент (offline-agent) v3.1

Этот скрипт (`offline-agent.ps1`) выполняет роль агента мониторинга для узлов, работающих в **изолированных сетевых сегментах** без прямого доступа к центральному API системы Status Monitor.

## Назначение

*   Периодически проверять наличие/обновление локального файла с заданиями мониторинга (`*.json.status.*`).
*   Читать и выполнять задания из этого файла с помощью `Invoke-StatusMonitorCheck` из модуля `StatusMonitorAgentUtils`.
*   Собирать **стандартизированные результаты** каждой проверки (включая `IsAvailable`, `CheckSuccess`, `Details`, `ErrorMessage`, `Timestamp`).
*   **Добавлять `assignment_id`** к каждому полученному результату.
*   Сохранять массив этих дополненных результатов в единый JSON-файл (`*.zrpu`) вместе с метаданными (версии скрипта и конфига) в указанную папку для последующей передачи и загрузки в центральную систему.

## Принцип работы

1.  Администратор с помощью скрипта **Конфигуратора** генерирует файл конфигурации заданий (`{version_tag}_assignments.json.status.{transport_code}`) для данного объекта.
2.  Этот файл доставляется на машину агента (например, с помощью Транспортной Системы) в папку, указанную в параметре `assignments_file_path` в локальном `config.json` оффлайн-агента.
3.  Скрипт `offline-agent.ps1` запускается (например, через Планировщик Задач Windows).
4.  Читает параметры из своего локального файла `config.json`.
5.  Импортирует модуль `StatusMonitorAgentUtils`.
6.  В бесконечном цикле (с интервалом `check_interval_seconds`):
    *   Ищет самый новый файл конфигурации заданий в папке `assignments_file_path`.
    *   Если найден новый или измененный файл:
        *   Читает JSON, извлекает массив `assignments` и `assignment_config_version`.
        *   Сохраняет их в памяти (`$script:currentAssignments`, `$script:currentAssignmentVersion`).
    *   Если список `$script:currentAssignments` не пуст:
        *   Для **каждого** задания:
            *   Вызывает **локально** `Invoke-StatusMonitorCheck`, передавая объект задания.
            *   Получает стандартизированный результат (`$checkResult`).
            *   **Создает новый объект**, объединяя `$checkResult` и `assignment_id`.
            *   Добавляет этот новый объект в массив `$cycleCheckResultsList`.
            *   Обрабатывает ошибки выполнения, также добавляя `assignment_id` к записи об ошибке.
    *   Если `$cycleCheckResultsList` не пуст:
        *   Формирует итоговый JSON (`$finalPayload`), включающий `agent_script_version`, `assignment_config_version` и массив `results` (содержащий дополненные результаты).
        *   Сохраняет `$finalPayload` в файл `.zrpu` в папку `output_path`.
    *   Ожидает интервал `check_interval_seconds` перед следующим циклом.
    *   Логирует свою работу.
7.  Файлы `*.zrpu` из папки `output_path` затем забираются и доставляются для обработки Загрузчиком Результатов.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `offline-agent.ps1`:

```json
{
    "object_id": 1060,
    "config_type": "offline_multi_check_agent_v3.1",
    "check_interval_seconds": 60,
    "output_path": "C:\\StatusMonitor\\Results",
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_OfflineChecks.json.status.zrpu",
    "logFile": "C:\\Logs\\StatusMonitor\\offline_agent.log",
    "LogLevel": "Info",
    "assignments_file_path": "C:\\StatusMonitor\\Config"
}

Поля конфигурации:

    object_id: (Число, Обязательно) Внешний ID подразделения (subdivisions.object_id), которому соответствует этот агент. Используется для поиска файла конфигурации.

    config_type: (Строка, Информационно) Тип и версия агента.

    check_interval_seconds: (Число, Опционально, По умолчанию 60) Как часто (в секундах) агент будет выполнять весь цикл проверок и генерировать файл результатов.

    output_path: (Строка, Обязательно) Папка, куда будут сохраняться файлы с результатами (*.zrpu). Папка должна существовать и быть доступна для записи.

    output_name_template: (Строка, Обязательно) Шаблон имени файла результатов. Плейсхолдеры: {ddMMyy_HHmmss}, {object_id}. Расширение должно быть .zrpu.

    logFile: (Строка, Обязательно) Полный путь к лог-файлу агента.

    LogLevel: (Строка, Опционально, По умолчанию "Info") Уровень детализации логов (Debug, Verbose, Info, Warn, Error).

    assignments_file_path: (Строка, Обязательно) Папка, где агент ищет самый новый файл конфигурации, соответствующий его object_id и шаблону (*_<object_id>_*_assignments.json.status.*).

Формат файла результатов (*.zrpu)

Файл представляет собой JSON-объект со следующей структурой:

{
  "agent_script_version": "agent_script_v3.1", // Версия скрипта offline-agent.ps1
  "assignment_config_version": "20240520120000_1060_abc...", // Версия файла с заданиями
  "results": [ // Массив результатов проверок
    {
      // Стандартизированный результат от Invoke-StatusMonitorCheck
      "IsAvailable": true,
      "CheckSuccess": true,
      "Timestamp": "2024-05-20T12:05:30.1234567Z",
      "Details": {
        "disk_letter": "C",
        "percent_free": 25.5,
        "execution_mode": "local_agent",
        // ... другие детали ...
      },
      "ErrorMessage": null,
      // Добавленное поле:
      "assignment_id": 101
    },
    {
      "IsAvailable": false,
      "CheckSuccess": null,
      "Timestamp": "2024-05-20T12:05:35.9876543Z",
      "Details": {
        "error": "Служба 'MyService' не найдена.",
        // ... другие детали ...
      },
      "ErrorMessage": "Служба 'MyService' не найдена.",
      "assignment_id": 102
    }
    // ... другие результаты ...
  ]
}

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль StatusMonitorAgentUtils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой offline-agent или в путях $env:PSModulePath.

    Конфиг Заданий: Необходим файл конфигурации заданий (*.json.status.*), сгенерированный Конфигуратором и доставленный в assignments_file_path.

    Права: Права на чтение из assignments_file_path, запись в output_path и logFile. Права для выполнения конкретных проверок.

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows.

Замечания

    Агент не требует прямого доступа к API.

    Логика конкретных проверок находится в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.

    Убедитесь, что Транспортная Система корректно доставляет файлы конфигурации и забирает файлы результатов (*.zrpu).
==== END FILE: F:\status\source\powershell\offline-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\config.json ====
{
    "object_id": 1516,
    "config_type": "online_multi_check_agent_v3",
    "apiBaseUrl": "http://localhost:48030/api",
    "api_key": "HC_ig1ko5JM8mPs1pNM-mE2aDoUJDrtruD_6zpOp1aw",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 120,
    "logFile": "online_check.log",
    "LogLevel": "Debug"
}
==== END FILE: F:\status\source\powershell\online-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\online-agent.ps1 ====
# powershell\online-agent\online-agent.ps1
# Версия с поддержкой нового диспетчера, формата результата,
# улучшенным форматированием, комментариями и исправленными ошибками.
<#
.SYNOPSIS
    Онлайн-агент для системы мониторинга Status Monitor v5.5.
.DESCRIPTION
    Этот агент предназначен для работы на машинах, имеющих прямой сетевой
    доступ к API сервера мониторинга. Он выполняет следующие действия:
    1. Читает локальную конфигурацию из файла 'config.json'.
    2. Импортирует необходимый модуль StatusMonitorAgentUtils.
    3. Периодически (раз в api_poll_interval_seconds) обращается к API
       сервера (/api/v1/assignments) для получения списка активных заданий
       мониторинга, предназначенных для его object_id.
    4. Хранит список заданий в памяти и самостоятельно планирует их выполнение
       согласно интервалам, указанным в заданиях или в конфиге по умолчанию.
    5. Для выполнения каждой проверки вызывает функцию Invoke-StatusMonitorCheck
       из импортированного модуля.
    6. Получает стандартизированный результат от Invoke-StatusMonitorCheck.
    7. Преобразует результат в формат, ожидаемый API /checks (v1).
    8. Немедленно отправляет результат каждой проверки на сервер через
       POST-запрос к API /api/v1/checks, используя API-ключ для аутентификации.
    9. Ведет лог своей работы в указанный файл.
.NOTES
    Версия: 5.5
    Дата: 2024-05-20
    Изменения v5.5:
        - Исправлена ошибка CommandNotFoundException из-за заглушек "..." в ConvertTo-Json при сравнении заданий.
    Изменения v5.4:
        - Исправлена ошибка ParameterBindingException при вызове Write-Verbose с уровнем Debug. Заменено на Write-Debug.
    Изменения v5.3:
        - Исправлена ошибка парсинга строки в блоке catch функции Send-CheckResultToApi.
    Изменения v5.2:
        - Исправлена ошибка CommandNotFoundException из-за заглушек "...".
        - Реализовано корректное частичное отображение API ключа в логах.
        - Разбиты длинные строки кода на несколько для читаемости.
        - Добавлены подробные комментарии.
        - Улучшено форматирование.
        - Функция Get-ActiveAssignments вынесена и исправлена.
    Изменения v5.1:
        - Адаптация под новый формат результата Invoke-StatusMonitorCheck.
        - Использование полей IsAvailable и CheckSuccess из результата проверки.
        - Формирование detail_type и detail_data для API на основе результата.
        - Использование IsAvailable для определения доступности узла при отправке.
    Зависимости: PowerShell 5.1+, модуль StatusMonitorAgentUtils, доступ к API.
#>
param(
    # Путь к файлу конфигурации агента.
    [string]$ConfigFile = "$PSScriptRoot\config.json"
)

# --- Загрузка необходимого модуля утилит ---
# Устанавливаем строгий режим обработки ошибок на время импорта
$ErrorActionPreference = "Stop"
try {
    # Определяем путь к манифесту модуля относительно текущего скрипта
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot `
                                    -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    # Принудительно импортируем модуль
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils загружен."
} catch {
    # Критическая ошибка - агент не может работать без модуля
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    # Завершаем работу скрипта с кодом ошибки
    exit 1
} finally {
    # Возвращаем стандартное поведение обработки ошибок
    $ErrorActionPreference = "Continue"
}
# --- Конец загрузки модуля ---

# --- Глобальные переменные и константы ---

# Версия текущего скрипта агента
$ScriptVersion = "5.5" # Обновили версию

# Хэш-таблица для хранения активных заданий (ключ - assignment_id, значение - объект задания)
$script:ActiveAssignments = @{}
# Хэш-таблица для хранения времени последнего выполнения каждого задания (ключ - assignment_id, значение - строка ISO 8601 UTC)
$script:LastExecutedTimes = @{}
# Объект для хранения конфигурации из файла config.json
$script:Config = $null
# API ключ для аутентификации на сервере
$script:ApiKey = $null
# Имя текущего компьютера для идентификации в логах и результатах
$script:ComputerName = $env:COMPUTERNAME

# --- Значения по умолчанию для параметров конфигурации ---
# Как часто опрашивать API на предмет новых/измененных заданий (секунды)
$DefaultApiPollIntervalSeconds = 60
# Интервал выполнения проверки по умолчанию (если не указан в задании, секунды)
$DefaultCheckIntervalSeconds = 120
# Уровень логирования по умолчанию
$DefaultLogLevel = "Info"
# Путь к лог-файлу по умолчанию (в папке со скриптом)
$DefaultLogFile = "$PSScriptRoot\online_agent.log"
# Таймаут ожидания ответа от API (секунды)
$ApiTimeoutSeconds = 30
# Максимальное количество попыток запроса к API при ошибке
$MaxApiRetries = 3
# Задержка между повторными попытками запроса к API (секунды)
$RetryDelaySeconds = 5
# Допустимые уровни логирования
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")
# Эффективный уровень логирования (будет установлен после чтения конфига)
$script:EffectiveLogLevel = $DefaultLogLevel

# --- Функции ---

#region Функции

<#
.SYNOPSIS
    Записывает сообщение в лог-файл и/или выводит в консоль.
# ... (документация Write-Log без изменений) ...
#>
function Write-Log {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
        [string]$Level = "Info"
    )
    # ... (код функции Write-Log без изменений) ...
    $logFilePath = $script:Config.logFile | Get-OrElse $DefaultLogFile; $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }; $currentLevelValue = $logLevels[$script:EffectiveLogLevel]; if ($null -eq $currentLevelValue) { $currentLevelValue = $logLevels["Info"] }; $messageLevelValue = $logLevels[$Level]; if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] }; if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] [$script:ComputerName] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; try { $logDir = Split-Path $logFilePath -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки логов: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }; $logMessage | Out-File -FilePath $logFilePath -Append -Encoding UTF8 -ErrorAction Stop } catch { Write-Host "[Error] Не удалось записать в лог '$($logFilePath)': $($_.Exception.Message)" -ForegroundColor Red } }
}

<#
.SYNOPSIS
    Возвращает значение по умолчанию, если входное значение ложно.
# ... (документация Get-OrElse без изменений) ...
#>
filter Get-OrElse {
    param([object]$DefaultValue)
    if ($_) { $_ } else { $DefaultValue }
}

<#
.SYNOPSIS
    Отправляет результат ОДНОЙ проверки в API /checks.
# ... (документация Send-CheckResultToApi без изменений) ...
#>
function Send-CheckResultToApi {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$CheckResult,
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Assignment
    )

    $assignmentId = $Assignment.assignment_id
    Write-Log "Отправка результата для задания ID $assignmentId..." "Verbose"

    # --- Формируем тело запроса для API /checks ---
    $isAvailableApi = [bool]$CheckResult.IsAvailable
    $checkTimestampApi = $CheckResult.Timestamp
    $detailTypeApi = $null
    $detailDataApi = $null

    if ($CheckResult.Details -ne $null -and $CheckResult.Details -is [hashtable]) {
        $detailTypeApi = $Assignment.method_name
        $detailDataApi = $CheckResult.Details
        if ($CheckResult.ContainsKey('CheckSuccess')) {
            $detailDataApi.check_success = $CheckResult.CheckSuccess
        }
        if (-not [string]::IsNullOrEmpty($CheckResult.ErrorMessage)) {
             $detailDataApi.error_message_from_check = $CheckResult.ErrorMessage
        }
    }
    elseif (-not [string]::IsNullOrEmpty($CheckResult.ErrorMessage)) {
        $detailTypeApi = "ERROR"
        $detailDataApi = @{ message = $CheckResult.ErrorMessage }
    }

    $body = @{
        assignment_id        = $assignmentId
        is_available         = $isAvailableApi
        check_timestamp      = $checkTimestampApi
        executor_object_id   = $script:Config.object_id
        executor_host        = $script:ComputerName
        resolution_method    = $Assignment.method_name
        detail_type          = $detailTypeApi
        detail_data          = $detailDataApi
        agent_script_version = $ScriptVersion
    }
    # --- Конец формирования тела запроса ---

    # Преобразуем тело в JSON строку
    try {
        $jsonBody = $body | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
    } catch {
         # Используем -f для форматирования строки
         Write-Log ("Критическая ошибка ConvertTo-Json для ID {0}: {1}" -f $assignmentId, $_.Exception.Message) "Error"
         Write-Log "Проблемный объект: $($body | Out-String)" "Error"
         return $false
    }

    # Заголовки и URL
    $headers = @{
        'Content-Type' = 'application/json; charset=utf-8'
        'X-API-Key'    = $script:ApiKey
    }
    $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/checks"
    Write-Log "URL отправки: $apiUrl" "Debug"
    Write-Log "Тело JSON: $jsonBody" "Debug"

    # --- Отправка запроса с логикой повторных попыток (retry) ---
    $retryCount = 0; $success = $false
    while ($retryCount -lt $MaxApiRetries -and (-not $success)) {
        try {
            $response = Invoke-RestMethod -Uri $apiUrl `
                                          -Method Post `
                                          -Body ([System.Text.Encoding]::UTF8.GetBytes($jsonBody)) `
                                          -Headers $headers `
                                          -TimeoutSec $ApiTimeoutSeconds `
                                          -ErrorAction Stop

            Write-Log ("Результат ID {0} отправлен. Ответ API: {1}" -f `
                        $assignmentId, ($response | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue)) "Info"
            $success = $true

        } catch {
            $retryCount++; $statusCode = $null; if ($_.Exception.Response) { try { $statusCode = [int]$_.Exception.Response.StatusCode } catch {} }; $errorMessage = $_.Exception.Message;
            $errorResponseBody = "[не удалось прочитать тело ответа]"; if ($_.Exception.Response) { try { $errorStream = $_.Exception.Response.GetResponseStream(); $reader = New-Object System.IO.StreamReader($errorStream); $errorResponseBody = $reader.ReadToEnd(); $reader.Close(); $errorStream.Dispose() } catch {} };
            Write-Log ("Ошибка отправки ID {0} (попытка {1}/{2}). Код: {3}. Error: {4}. Ответ: {5}" -f $assignmentId, $retryCount, $MaxApiRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage, $errorResponseBody) "Error"
            if ($statusCode -eq 401 -or $statusCode -eq 403) { Write-Log "Критическая ошибка: Неверный API ключ или права (Код: $statusCode). Завершение работы." "Error"; exit 1 }
            if ($retryCount -ge $MaxApiRetries) { Write-Log "Превышено кол-во попыток ($MaxApiRetries) для ID $assignmentId." "Error"; break }
            Write-Log "Пауза $RetryDelaySeconds сек..." "Warn"; Start-Sleep -Seconds $RetryDelaySeconds
        }
    } # Конец while retry
    return $success
}

<#
.SYNOPSIS
    Запрашивает активные задания у API сервера.
# ... (документация Get-ActiveAssignments без изменений) ...
#>
function Get-ActiveAssignments {
    Write-Log "Запрос активных заданий у API..." "Info"
    $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/assignments?object_id=$($script:Config.object_id)"
    Write-Log "URL: $apiUrl" "Verbose"

    # Отображение части API ключа
    $apiKeyPartial = "[Не задан]"
    if ($script:ApiKey) {
        $len = $script:ApiKey.Length; $prefix = $script:ApiKey.Substring(0, [math]::Min(4, $len)); $suffix = if ($len -gt 8) { $script:ApiKey.Substring($len - 4, 4) } else { "" }; $apiKeyPartial = "$prefix....$suffix"
    }
    Write-Log "Исп. API ключ (частично): $apiKeyPartial" "Debug"

    $headers = @{ 'X-API-Key' = $script:ApiKey }
    $newAssignments = $null; $retryCount = 0
    while ($retryCount -lt $MaxApiRetries -and $newAssignments -eq $null) {
        try {
            $newAssignments = Invoke-RestMethod -Uri $apiUrl `
                                                -Method Get `
                                                -Headers $headers `
                                                -TimeoutSec $ApiTimeoutSeconds `
                                                -ErrorAction Stop
            if ($newAssignments -isnot [array]) { throw ("API ответ не является массивом: $($newAssignments | Out-String)") }
            Write-Log "Получено $($newAssignments.Count) активных заданий." "Info"
            return $newAssignments
        } catch {
            $retryCount++; $statusCode = $null; if ($_.Exception.Response) { try { $statusCode = [int]$_.Exception.Response.StatusCode } catch {} }; $errorMessage = $_.Exception.Message;
            Write-Log ("Ошибка API при получении заданий (попытка {0}/{1}). Код: {2}. Error: {3}" -f $retryCount, $MaxApiRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage) "Error"
            if ($statusCode -eq 401 -or $statusCode -eq 403) { Write-Log "Критическая ошибка: Неверный API ключ или права (Код: $statusCode). Завершение работы." "Error"; exit 1 }
            if ($retryCount -ge $MaxApiRetries) { Write-Log "Превышено кол-во попыток ($MaxApiRetries) получения заданий." "Error"; return $null }
            Write-Log "Пауза $RetryDelaySeconds сек..." "Warn"; Start-Sleep -Seconds $RetryDelaySeconds
        }
    } # Конец while retry
    return $null
}

#endregion Функции

# --- Основной код агента ---

# 1. Чтение конфигурации из файла
Write-Host "Чтение конфигурации из: $ConfigFile"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Error ...; exit 1 }
try { $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error ...; exit 1 }
$requiredCfg=@("object_id","apiBaseUrl","api_key","logFile","LogLevel","api_poll_interval_seconds","default_check_interval_seconds"); $missingCfg=$requiredCfg|?{-not $script:Config.PSObject.Properties.Name.Contains($_) -or !$script:Config.$_}; if($missingCfg){ Write-Error ...; exit 1 }
$script:EffectiveLogLevel = $script:Config.LogLevel | Get-OrElse $DefaultLogLevel
if ($script:EffectiveLogLevel -notin $ValidLogLevels) { Write-Host ...; $script:EffectiveLogLevel = $DefaultLogLevel }
$script:ApiKey = $script:Config.api_key

# 2. Инициализация и логирование старта агента
Write-Log "Онлайн-агент v$ScriptVersion запущен." "Info"
Write-Log "Конфигурация: ObjectID=$($script:Config.object_id), API URL=$($script:Config.apiBaseUrl)" "Info"
Write-Log ("Интервал опроса API: {0} сек, Стандартный интервал проверки: {1} сек." -f `
    $script:Config.api_poll_interval_seconds, $script:Config.default_check_interval_seconds) "Verbose"
Write-Log "Логирование в '$($script:Config.logFile)' с уровнем '$($script:EffectiveLogLevel)'" "Info"

# 3. Основной цикл работы агента
$lastApiPollTime = [DateTime]::MinValue
$apiPollInterval = [TimeSpan]::FromSeconds($script:Config.api_poll_interval_seconds)
$DefaultCheckInterval = [TimeSpan]::FromSeconds($script:Config.default_check_interval_seconds)

Write-Log "Запуск основного цикла обработки заданий..." "Info"
while ($true) {
    $loopStartTime = Get-Date
    Write-Log "Начало итерации цикла." "Verbose"

    # 3.1 Запрос/обновление списка активных заданий у API
    if (($loopStartTime - $lastApiPollTime) -ge $apiPollInterval) {
        Write-Log "Время обновить список заданий с API." "Info"; $fetchedAssignments = Get-ActiveAssignments
        if ($fetchedAssignments -ne $null) {
            Write-Log "Обработка полученных заданий..." "Info"; $newAssignmentMap = @{}; $fetchedIds = [System.Collections.Generic.List[int]]::new()
            foreach ($assignment in $fetchedAssignments) { if ($assignment.assignment_id -ne $null) { $id = $assignment.assignment_id; $newAssignmentMap[$id] = $assignment; $fetchedIds.Add($id) } else { Write-Log "..." "Warn" } }
            $currentIds = $script:ActiveAssignments.Keys | ForEach-Object { [int]$_ }; $removedIds = $currentIds | Where-Object { $fetchedIds -notcontains $_ }
            if ($removedIds) { foreach ($removedId in $removedIds) { Write-Log "... $removedId" "Info"; $script:ActiveAssignments.Remove($removedId); $script:LastExecutedTimes.Remove($removedId) } }
            $addedCount = 0; $updatedCount = 0
            foreach ($assignmentId in $fetchedIds) {
                if (-not $script:ActiveAssignments.ContainsKey($assignmentId)) {
                    # Добавление нового задания
                    Write-Log "Добавлено новое задание ID $assignmentId" "Info"
                    $script:ActiveAssignments[$assignmentId] = $newAssignmentMap[$assignmentId]
                    $script:LastExecutedTimes[$assignmentId] = (Get-Date).AddDays(-1).ToUniversalTime().ToString("o")
                    $addedCount++
                } else {
                    # Проверка, изменилось ли существующее задание
                    # --- ИСПРАВЛЕНО: Убраны заглушки "..." ---
                    $oldJson = $script:ActiveAssignments[$assignmentId] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                    $newJson = $newAssignmentMap[$assignmentId] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                    # --- КОНЕЦ ИСПРАВЛЕНИЯ ---
                    if ($oldJson -ne $newJson) {
                         Write-Log "Обновлено задание ID $assignmentId" "Verbose"
                         $script:ActiveAssignments[$assignmentId] = $newAssignmentMap[$assignmentId]
                         # Сбрасывать ли LastExecutedTimes при обновлении?
                         # Пока не будем, чтобы не вызвать выполнение сразу после обновления.
                         $updatedCount++
                    }
                }
            } # Конец foreach ($assignmentId in $fetchedIds)
            Write-Log ("Синхронизация заданий завершена. Добавлено:{0}. Обновлено:{1}. Удалено:{2}." -f $addedCount, $updatedCount, $removedIds.Count) "Info"
            $lastApiPollTime = $loopStartTime
        } else { Write-Log "Не удалось получить задания от API..." "Error" }
    } else { Write-Log "Опрос API еще не требуется..." "Verbose" }

    # 3.2 Выполнение запланированных проверок
    # ... (код выполнения проверок, вызова Invoke-StatusMonitorCheck и Send-CheckResultToApi без изменений) ...
    $currentTime = Get-Date
    if ($script:ActiveAssignments.Count -gt 0) {
        Write-Log "Проверка запланированных заданий ($($script:ActiveAssignments.Count) активно)..." "Verbose"
        $assignmentIdsToCheck = $script:ActiveAssignments.Keys | ForEach-Object { $_ }
        foreach ($id in $assignmentIdsToCheck) {
            if (-not $script:ActiveAssignments.ContainsKey($id)) { continue }
            $assignment = $script:ActiveAssignments[$id]; $checkIntervalSeconds = $assignment.check_interval_seconds | Get-OrElse $script:Config.default_check_interval_seconds; if ($checkIntervalSeconds -le 0) { $checkIntervalSeconds = $script:Config.default_check_interval_seconds }; $checkInterval = [TimeSpan]::FromSeconds($checkIntervalSeconds); $lastRunString = $script:LastExecutedTimes[$id]; $lastRunTime = [DateTime]::MinValue; if ($lastRunString) { try { $lastRunTime = [DateTime]::ParseExact($lastRunString,"o",$null).ToLocalTime() } catch { Write-Log "... ID ${id}: '$lastRunString'" "Error"; $lastRunTime = [DateTime]::MinValue } }; $nextRunTime = $lastRunTime + $checkInterval
            Write-Debug ("Задание ID {0}: Интервал={1} сек, Посл.={2}, След.={3}" -f $id, $checkInterval.TotalSeconds, $lastRunTime.ToString('s'), $nextRunTime.ToString('s'))
            if ($currentTime -ge $nextRunTime) {
                Write-Log ("ВЫПОЛНЕНИЕ ЗАДАНИЯ ID {0} ({1} для {2})." -f $id, $assignment.method_name, $assignment.node_name) "Info"; $checkResult = $null
                try { $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment -Verbose:$VerbosePreference -Debug:$DebugPreference; Write-Log ("Результат проверки ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f $id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) "Verbose"; Write-Log ("Детали результата ID {0}: {1}" -f $id, ($checkResult.Details | ConvertTo-Json -Depth 3 -Compress -WarningAction SilentlyContinue)) "Debug"; $sendSuccess = Send-CheckResultToApi -CheckResult $checkResult -Assignment $assignment; if ($sendSuccess) { $script:LastExecutedTimes[$id] = $currentTime.ToUniversalTime().ToString("o"); Write-Log "Время последнего выполнения ID $id обновлено." "Verbose" } else { Write-Log "Результат для ID $id НЕ был успешно отправлен в API." "Error" } } catch { Write-Log "Критическая ошибка при ВЫПОЛНЕНИИ задания ID ${id}: $($_.Exception.Message)" "Error" }
            }
        }
    } else { Write-Log "Нет активных заданий для выполнения." "Verbose" }

    # 3.3 Пауза перед следующей итерацией
    Start-Sleep -Seconds 1

} # --- Конец while ($true) ---

Write-Log "Онлайн-агент завершает работу (неожиданный выход из основного цикла)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\online-agent\online-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\README.md ====
# PowerShell Online Агент (online-agent) v5.5

Этот скрипт (`online-agent.ps1`) выполняет роль агента мониторинга для узлов, имеющих **прямой сетевой доступ** к центральному API системы Status Monitor.

## Назначение

*   Периодически подключаться к API и запрашивать актуальный список заданий мониторинга (`Assignments`), предназначенных для подразделения, в котором он работает (определяется по `object_id` в конфигурации).
*   Самостоятельно планировать и выполнять полученные задания с заданными интервалами.
*   Для выполнения каждой проверки использовать **локально** модуль `StatusMonitorAgentUtils` и его функцию-диспетчер `Invoke-StatusMonitorCheck`.
*   Немедленно отправлять стандартизированный результат **каждой** выполненной проверки обратно в API (`POST /api/v1/checks`), используя API-ключ для аутентификации.

## Принцип работы

1.  Скрипт `online-agent.ps1` запускается (например, через Планировщик Задач или как Служба Windows).
2.  Читает параметры из локального файла `config.json`.
3.  Импортирует модуль `StatusMonitorAgentUtils` (он должен находиться рядом или в путях PowerShell).
4.  Периодически (с интервалом `api_poll_interval_seconds`) выполняет GET-запрос к API (`/api/v1/assignments?object_id=...`), используя `object_id` и `api_key`.
5.  Хранит полученный список активных заданий в памяти (`$script:ActiveAssignments`). Сравнивает с предыдущим списком, добавляет новые, удаляет неактуальные.
6.  В бесконечном цикле проверяет, не пришло ли время выполнить какое-либо из активных заданий (с учетом `check_interval_seconds` из задания или `default_check_interval_seconds` из конфига).
7.  При наступлении времени выполнения для задания:
    *   Вызывает **локально** `Invoke-StatusMonitorCheck`, передавая ему объект задания.
    *   `Invoke-StatusMonitorCheck` находит и **локально** запускает соответствующий скрипт `Checks/Check-*.ps1`.
    *   Скрипт `Check-*.ps1` выполняет проверку (например, `Test-Connection` к целевому IP, `Get-Service` и т.д.).
    *   Агент получает стандартизированный результат (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
    *   Агент формирует тело запроса для `POST /api/v1/checks`, включая `assignment_id`, статус `is_available` (из результата), `timestamp` (из результата), `details` (включая `CheckSuccess` и `ErrorMessage`), `agent_script_version`.
    *   Отправляет POST-запрос в API с помощью функции `Send-CheckResultToApi`, используя API-ключ.
    *   Обновляет время последнего выполнения для этого задания локально (только при успешной отправке).
8.  Логирует свою работу в файл, указанный в `config.json`.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `online-agent.ps1`:

```json
{
    "object_id": 1516,
    "config_type": "online_multi_check_agent_v5.5",
    "apiBaseUrl": "http://localhost:48030/api",
    "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_AGENT",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 120,
    "logFile": "C:\\Logs\\StatusMonitor\\online_agent.log",
    "LogLevel": "Info"
}

Поля конфигурации:

    object_id: (Число, Обязательно) Уникальный внешний ID подразделения (subdivisions.object_id) из центральной БД. Агент будет получать задания только для узлов этого подразделения.

    config_type: (Строка, Информационно) Тип и версия агента.

    apiBaseUrl: (Строка, Обязательно) Базовый URL API сервера Status Monitor (например, http://status.example.com/api). Без /v1/ в конце.

    api_key: (Строка, Обязательно) API ключ, сгенерированный в системе Status Monitor с ролью agent. Используется для аутентификации при запросах к API.

    api_poll_interval_seconds: (Число, Опционально, По умолчанию 60) Как часто (в секундах) агент будет опрашивать API для обновления списка своих заданий.

    default_check_interval_seconds: (Число, Опционально, По умолчанию 120) Интервал выполнения проверки (в секундах), который будет использоваться, если интервал не указан в самом задании, полученном от API.

    logFile: (Строка, Обязательно) Полный путь к файлу, куда агент будет писать логи. Папка должна существовать и быть доступна для записи.

    LogLevel: (Строка, Опционально, По умолчанию "Info") Уровень детализации логов (Debug, Verbose, Info, Warn, Error).

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль StatusMonitorAgentUtils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой online-agent (т.е. ..\StatusMonitorAgentUtils) или в одном из путей, перечисленных в $env:PSModulePath.

    Сеть: Требуется сетевой доступ с машины агента к apiBaseUrl И к целевым узлам, которые он будет проверять (например, для PING, Get-Service).

    Права:

        Права на запись в logFile.

        Права, необходимые для выполнения конкретных проверок (например, для Get-Service на удаленной машине могут потребоваться права администратора и настроенный WinRM).

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows для обеспечения непрерывной работы и автоматического перезапуска.

Замечания

    Убедитесь, что API ключ, указанный в config.json, действителен и имеет роль agent.

    Для методов проверки, отличных от PING, необходимо реализовать соответствующую логику в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.
==== END FILE: F:\status\source\powershell\online-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\config.json ====
{
  "api_base_url": "http://localhost:48030/api",
  "api_key": "ЗАМЕНИТЕ_НА_ВАШ_LOADER_КЛЮЧ",
  "check_folder": "F:\\status\\builds\\results_offline",
  "processed_folder": "F:\\status\\builds\\results_offline\\Processed",
  "error_folder": "F:\\status\\builds\\results_offline\\Error",
  "unrecoverable_error_folder": "F:\\status\\builds\\results_offline\\Unrecoverable",
  "log_file": "F:\\status\\builds\\Logs\\result_loader.log",
  "log_level": "Info",
  "scan_interval_seconds": 30,
  "max_api_retries": 3,
  "retry_delay_seconds": 5,
  "api_timeout_sec": 60
}
==== END FILE: F:\status\source\powershell\result_loader\config.json ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\README.md ====

---

### 2. README для Загрузчика Результатов

**Файл:** `powershell/result_loader/README.md` (Обновленный)

```markdown
# PowerShell Загрузчик Результатов (result_loader) v4.2

Этот скрипт (`result_loader.ps1`) предназначен для обработки файлов с результатами мониторинга (`*.zrpu`), сгенерированных **Гибридным Агентом** в **Offline режиме**, и загрузки этих данных в центральное API системы Status Monitor v5.2+.

## Назначение

*   Периодически сканировать указанную папку (`check_folder`) на наличие файлов результатов (`*.zrpu`).
*   Читать содержимое каждого файла `.zrpu`.
*   Извлекать метаданные (`agent_script_version`, `assignment_config_version`, `object_id`) и массив `results`.
*   Для **каждой** записи результата проверки из массива `results` формировать объект для API, **добавляя метаданные файла**.
*   Отправлять **весь пакет** результатов из одного файла **одним POST-запросом** на унифицированный эндпоинт `/api/v1/checks` центрального API.
*   После обработки файла API, отправить событие `FILE_PROCESSED` на эндпоинт `/api/v1/events` для логирования факта и статуса обработки файла.
*   **Атомарно** перемещать обработанный файл в соответствующую подпапку (`Processed`, `Error`, `Unrecoverable`).

## Принцип работы

1.  Транспортная Система доставляет файлы результатов (`*.zrpu`) от Гибридных Агентов (Offline режим) в папку, указанную как `check_folder` в `config.json` загрузчика.
2.  Скрипт `result_loader.ps1` запускается (например, через Планировщик Задач) на машине, имеющей доступ к `check_folder` и центральному API.
3.  Читает параметры из своего файла `config.json`.
4.  В бесконечном цикле (с интервалом `scan_interval_seconds`):
    *   Сканирует папку `check_folder` на наличие файлов `*.zrpu`.
    *   Для каждого найденного файла:
        *   Пытается прочитать и распарсить его как JSON. **При ошибке** - логирует и перемещает файл в **`error_folder`**.
        *   Извлекает метаданные и массив `results`. Валидирует базовую структуру. **При ошибке** - логирует и перемещает файл в **`error_folder`**.
        *   Формирует **массив** объектов (`$payloadArray`) для отправки на `POST /checks`, добавляя метаданные файла в каждый элемент.
        *   Если `$payloadArray` не пуст, отправляет его **одним POST-запросом** на `/api/v1/checks`, используя функцию `Invoke-ApiRequestWithRetry`.
        *   Анализирует ответ API (ожидается 200 OK или 207 Multi-Status). Определяет статус обработки (`success`, `error_api`).
        *   Формирует тело события `FILE_PROCESSED` с информацией об обработке (включая количество ошибок API, если были).
        *   Отправляет событие в API `/api/v1/events`. Обрабатывает возможные ошибки отправки события.
        *   **Атомарно перемещает файл:**
            *   В `processed_folder` - если API вернул 200 OK (или 207 без ошибок *для этого файла*) И событие успешно отправлено.
            *   В **`unrecoverable_error_folder` (DLQ)** - если API вернул ошибку (любой статус, кроме 200/207) ИЛИ вернул 207 с ошибками ИЛИ не удалось отправить событие `FILE_PROCESSED`. Эти файлы требуют ручного анализа.
            *   В `error_folder` - если произошла ошибка чтения/парсинга файла (до отправки в API).
        *   Логирует результат обработки файла.
    *   Ожидает интервал `scan_interval_seconds` перед следующим сканированием.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `result_loader.ps1`.

```json
{
    "api_base_url": "http://localhost:48030/api", // ОБЯЗАТЕЛЬНО
    "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_LOADER",     // ОБЯЗАТЕЛЬНО
    "check_folder": "C:/StatusMonitor/IncomingResults", // ОБЯЗАТЕЛЬНО - Откуда брать .zrpu
    "processed_folder": "C:/StatusMonitor/Processed",    // ОБЯЗАТЕЛЬНО - Куда перемещать успешно обработанные
    "error_folder": "C:/StatusMonitor/Error",            // ОБЯЗАТЕЛЬНО - Куда перемещать при ошибках чтения/парсинга
    "unrecoverable_error_folder": "C:/StatusMonitor/Unrecoverable", // ОБЯЗАТЕЛЬНО - Куда перемещать при ошибках API/событий (DLQ)
    "log_file": "C:/Logs/StatusMonitor/result_loader.log", // ОБЯЗАТЕЛЬНО
    "log_level": "Info", // "Debug", "Verbose", "Info", "Warn", "Error" - ОБЯЗАТЕЛЬНО
    "scan_interval_seconds": 30, // Опционально (default: 30)
    "api_timeout_sec": 60,       // Опционально (default: 60)
    "max_api_retries": 3,        // Опционально (default: 3)
    "retry_delay_seconds": 5     // Опционально (default: 5)
}


Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Сеть: Требуется сетевой доступ с машины загрузчика к api_base_url.

    Доступ к Файлам: Требуются права на чтение, запись и удаление файлов в check_folder и ее подпапках Processed, Error, Unrecoverable.

    Права: Скрипту нужны права на запись в log_file.

    API Ключ: Убедитесь, что API ключ имеет роль loader.

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows для обеспечения непрерывной работы.

Замечания

    Скрипт ожидает, что файлы *.zrpu имеют корректную JSON-структуру, созданную hybrid-agent.ps1 (v7.0+).

    Файлы, вызвавшие ошибки при взаимодействии с API (например, из-за невалидных assignment_id внутри), будут перемещены в папку unrecoverable_error_folder для последующего анализа.
==== END FILE: F:\status\source\powershell\result_loader\README.md ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\result_loader.ps1 ====
# powershell/result_loader/result_loader.ps1
# --- Загрузчик Результатов v4.2 ---
# Изменения:
# - Удалена опция и логика use_bulk_api.
# - Всегда отправляет массив результатов на POST /api/v1/checks.
# - Добавлена папка unrecoverable_error_folder (DLQ) для ошибок API.
# - Улучшено атомарное перемещение файлов.
# - Убрана зависимость от PowerShell v5.1 (он и так был совместим).

<#
.SYNOPSIS
    Обрабатывает файлы *.zrpu от оффлайн-агентов и отправляет данные
    массивом на унифицированный API эндпоинт /api/v1/checks (v4.2).
.DESCRIPTION
    Скрипт-загрузчик результатов оффлайн мониторинга.
    1. Читает конфигурацию из 'config.json'.
    2. Циклически сканирует `check_folder` на наличие *.zrpu файлов.
    3. Для каждого файла:
       - Читает и парсит JSON. При ошибке - перемещает в `error_folder`.
       - Извлекает метаданные и массив 'results'.
       - Формирует payload (массив объектов для API), добавляя метаданные
         из файла в КАЖДЫЙ элемент массива.
       - Отправляет ВЕСЬ payload ОДНИМ запросом на `POST /api/v1/checks`.
       - Обрабатывает ответ API (200/207).
       - Отправляет событие `FILE_PROCESSED` в API.
       - Атомарно перемещает файл:
         - В `processed_folder` при полном успехе.
         - В `unrecoverable_error_folder` при ошибках API (включая 207)
           или ошибке отправки события.
         - В `error_folder` при локальных ошибках (парсинг).
.PARAMETER ConfigFile
    [string] Путь к файлу конфигурации загрузчика (JSON).
    По умолчанию: "$PSScriptRoot\config.json".
.NOTES
    Версия: 4.2
    Дата: [Актуальная Дата]
    Зависимости: PowerShell 5.1+, Сетевой доступ к API, Права доступа к папкам.
#>
param(
    [string]$ConfigFile = "$PSScriptRoot\config.json",
    # Параметры для переопределения конфига (можно убрать, если не нужны)
    [string]$apiBaseUrlOverride = $null,
    [string]$apiKeyOverride = $null,
    [string]$checkFolderOverride = $null,
    [string]$logFileOverride = $null,
    [string]$logLevelOverride = $null
)

# --- 1. Глобальные переменные и константы ---
$ScriptVersion = "4.2" # Обновляем версию
$script:Config = $null
$script:EffectiveLogLevel = "Info"
$script:LogFilePath = $null
$script:ComputerName = $env:COMPUTERNAME
$DefaultLogLevel = "Info"; $DefaultScanInterval = 30; $DefaultApiTimeout = 30; $DefaultMaxRetries = 3; $DefaultRetryDelay = 5;
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error");
$script:EffectiveApiKey = $null

# --- 2. Функции ---

#region Функции

<#
.SYNOPSIS Пишет сообщение в лог и/или консоль. (Код без изменений от Hybrid)
#>
function Write-Log {
    param( [Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)][string]$Level = "Info" )
    $logLevels=@{"Debug"=4;"Verbose"=3;"Info"=2;"Warn"=1;"Error"=0}; $currentLevelValue=$logLevels[$script:EffectiveLogLevel]; if($null -eq $currentLevelValue){ $currentLevelValue = $logLevels["Info"] }; $messageLevelValue=$logLevels[$Level]; if($null -eq $messageLevelValue){ $messageLevelValue = $logLevels["Info"] };
    if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] [$($script:ComputerName)] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; if ($script:LogFilePath) { try { $logDir = Split-Path $script:LogFilePath -Parent; if ($logDir -and (-not(Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки логов: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null }; Add-Content -Path $script:LogFilePath -Value $logMessage -Encoding UTF8 -Force -EA Stop } catch { Write-Host ("[Error] Не удалось записать в лог '{0}': {1}" -f $script:LogFilePath, $_.Exception.Message) -ForegroundColor Red } } }
}

<#
.SYNOPSIS Возвращает значение по умолчанию, если исходное пустое. (Код без изменений от Hybrid)
#>
filter Get-OrElse {
    param([object]$DefaultValue)
    if ($null -ne $_ -and (($_ -isnot [string]) -or (-not [string]::IsNullOrWhiteSpace($_)))) { $_ } else { $DefaultValue }
}

<#
.SYNOPSIS Выполняет HTTP-запрос к API с логикой повторных попыток. (Код без изменений от Hybrid)
#>
function Invoke-ApiRequestWithRetry {
    param(
        [Parameter(Mandatory=$true)][string]$Uri,
        [Parameter(Mandatory=$true)][string]$Method,
        [Parameter(Mandatory=$false)]$BodyObject = $null,
        [Parameter(Mandatory=$true)][hashtable]$Headers,
        [Parameter(Mandatory=$true)][string]$Description
    )
    $retryCount=0; $responseObject=$null; $maxRetries=$script:Config.max_api_retries | Get-OrElse 3; $timeoutSec=$script:Config.api_timeout_sec | Get-OrElse 60; $retryDelaySec=$script:Config.retry_delay_seconds | Get-OrElse 5;
    $invokeParams=@{Uri=$Uri; Method=$Method; Headers=$Headers; TimeoutSec=$timeoutSec; ErrorAction='Stop'}; if($BodyObject -ne $null -and $Method.ToUpper() -notin @('GET','DELETE')){ try{ $jsonBody = $BodyObject | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue; $invokeParams.ContentType = 'application/json; charset=utf-8'; $invokeParams.Body = [System.Text.Encoding]::UTF8.GetBytes($jsonBody); Write-Log "Тело запроса для ($Description): $jsonBody" -Level Debug } catch { Write-Log "Критическая ошибка ConvertTo-Json для ($Description): $($_.Exception.Message)" -Level Error; throw "Ошибка преобразования тела запроса в JSON." } }
    while($retryCount -lt $maxRetries -and $responseObject -eq $null){ try{ Write-Log ("Выполнение запроса ({0}) (Попытка {1}/{2}): {3} {4}" -f $Description,($retryCount+1),$maxRetries,$Method,$Uri) -Level Verbose; $responseObject = Invoke-RestMethod @invokeParams; Write-Log ("Успешный ответ API ({0})." -f $Description) -Level Verbose; return $responseObject } catch [System.Net.WebException]{ $retryCount++; $exception=$_.Exception; $statusCode=$null; $errorResponseBody="[Не удалось прочитать тело ошибки]"; if($exception.Response -ne $null){ try{ $statusCode = [int]$exception.Response.StatusCode } catch {}; try{ $errorStream = $exception.Response.GetResponseStream(); $reader=New-Object System.IO.StreamReader($errorStream); $errorResponseBody = $reader.ReadToEnd(); $reader.Close(); $errorStream.Dispose(); try{ $errorJson=$errorResponseBody|ConvertFrom-Json; $errorResponseBody=$errorJson }catch{} }catch{} }; $errorMessage=$exception.Message.Replace('{','{{').Replace('}','}}'); $errorDetails=$errorResponseBody; Write-Log ("Ошибка API ({0}) (Попытка {1}/{2}). Код: {3}. Error: {4}. Ответ: {5}" -f $Description,$retryCount,$maxRetries,($statusCode|Get-OrElse 'N/A'),$errorMessage,($errorDetails|Out-String -Width 300)) -Level Error; if($statusCode -in @(400,401,403,404,409,422)){ Write-Log ("Критическая ошибка API ({0} - Код {1}), повторные попытки отменены." -f $Description,$statusCode) -Level Error; throw $exception }; if($retryCount -ge $maxRetries){ Write-Log ("Превышено кол-во попыток ({0}) для ({1})." -f $maxRetries,$Description) -Level Error; throw $exception }; Write-Log ("Пауза $retryDelaySec сек перед повторной попыткой...") -Level Warn; Start-Sleep -Seconds $retryDelaySec } catch { $retryCount++; $errorMessage=$_.Exception.Message.Replace('{','{{').Replace('}','}}'); Write-Log ("Неожиданная ошибка ({0}) (Попытка {1}/{2}): {3}" -f $Description,$retryCount,$maxRetries,$errorMessage) -Level Error; throw $_.Exception } }; return $null
}

#endregion Функции

# --- 3. Основная логика ---

# 3.1 Чтение и валидация конфигурации
Write-Host "Запуск Загрузчика Результатов PowerShell v$ScriptVersion"
Write-Log "Чтение конфигурации..." "Info"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Log "Критическая ошибка: Файл конфигурации '$ConfigFile' не найден." -Level Error; exit 1 }
try { $script:Config = Get-Content $ConfigFile -Raw -Enc UTF8 | ConvertFrom-Json -EA Stop } catch { Write-Log "Критическая ошибка: Ошибка чтения/парсинга JSON из '$ConfigFile': $($_.Exception.Message)" -Level Error; exit 1 }

# Переопределение из параметров командной строки (если нужно)
$effectiveConfig = $script:Config.PSObject.Copy() # Копируем для изменений
if ($apiBaseUrlOverride) { $effectiveConfig.api_base_url = $apiBaseUrlOverride }
if ($apiKeyOverride) { $effectiveConfig.api_key = $apiKeyOverride }
if ($checkFolderOverride) { $effectiveConfig.check_folder = $checkFolderOverride }
if ($logFileOverride) { $effectiveConfig.log_file = $logFileOverride }
if ($logLevelOverride) { $effectiveConfig.log_level = $logLevelOverride }
$script:Config = [PSCustomObject]$effectiveConfig # Обновляем глобальный конфиг

# Валидация ОБЯЗАТЕЛЬНЫХ полей (убрали use_bulk_api)
$requiredFields = @(
    "api_base_url", "api_key", "check_folder", "log_file", "log_level",
    "processed_folder", "error_folder", "unrecoverable_error_folder", # Добавили папки
    "scan_interval_seconds", "max_api_retries", "retry_delay_seconds"
)
$missingFields = $requiredFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or (($script:Config.$_ -is [string]) -and ([string]::IsNullOrWhiteSpace($script:Config.$_))) }
if ($missingFields) { Write-Log ("Критическая ошибка: В конфигурации отсутствуют или пусты обязательные поля: $($missingFields -join ', ')") -Level Error; exit 1 }

# Установка лог-файла и уровня
$script:LogFilePath = $script:Config.log_file
$script:EffectiveLogLevel = $script:Config.log_level
if ($script:EffectiveLogLevel -notin $ValidLogLevels) { Write-Log "..." "Warn"; $script:EffectiveLogLevel = $DefaultLogLevel }
$script:EffectiveApiKey = $script:Config.api_key

# Проверка и создание папок
$checkFolder = $script:Config.check_folder
$processedFolder = $script:Config.processed_folder
$errorFolder = $script:Config.error_folder
$unrecoverableFolder = $script:Config.unrecoverable_error_folder # DLQ
$foldersToCheck = @($checkFolder, $processedFolder, $errorFolder, $unrecoverableFolder)
foreach ($folder in $foldersToCheck) {
     if (-not (Test-Path $folder -PathType Container)) {
         Write-Log "Папка '$folder' не найдена. Попытка создать..." -Level Warn
         try { New-Item -Path $folder -ItemType Directory -Force -EA Stop | Out-Null; Write-Log "Папка '$folder' создана." -Level Info }
         catch { Write-Log "Критическая ошибка: Не удалось создать папку '$folder': $($_.Exception.Message)" -Level Error; exit 1 }
     }
}

# Получение интервалов/попыток
$scanInterval = 30; if($script:Config.scan_interval_seconds -and [int]::TryParse($script:Config.scan_interval_seconds,[ref]$null) -and $script:Config.scan_interval_seconds -ge 5){ $scanInterval = $script:Config.scan_interval_seconds } else { Write-Log "..." "Warn" }

Write-Log "Инициализация загрузчика v$ScriptVersion завершена." -Level Info
Write-Log ("Параметры: API='{0}', Папка='{1}', Интервал={2} сек, Лог='{3}', Уровень='{4}'" `
    -f $script:Config.api_base_url, $checkFolder, $scanInterval, $script:LogFilePath, $script:EffectiveLogLevel) -Level Info

# --- 4. Основной цикл сканирования и обработки ---
Write-Log "Начало цикла сканирования папки '$checkFolder'..." -Level Info
while ($true) {
    Write-Log "Сканирование папки..." -Level Verbose
    $filesToProcess = @()
    try {
        # Маска файла теперь может быть разной, используем *.zrpu
        $resultsFileFilter = "*.zrpu"
        $filesToProcess = Get-ChildItem -Path $checkFolder -Filter $resultsFileFilter -File -ErrorAction Stop
    } catch {
        # Ошибка доступа к папке - критично, но пробуем дальше
        Write-Log ("Критическая ошибка доступа к папке '$checkFolder': $($_.Exception.Message). Пропуск итерации.") -Level Error
        Start-Sleep -Seconds $scanInterval; continue # Ждем и повторяем
    }

    if ($filesToProcess.Count -eq 0) {
        Write-Log "Нет файлов *.zrpu для обработки." -Level Verbose
    } else {
        Write-Log "Найдено файлов для обработки: $($filesToProcess.Count)." -Level Info

        # --- Обработка каждого файла ---
        foreach ($file in $filesToProcess) {
            $fileStartTime = [DateTimeOffset]::UtcNow
            Write-Log "--- Начало обработки файла: '$($file.FullName)' ---" -Level Info
            $fileProcessingStatus = "unknown" # Статусы: unknown, success, partial_error, error_local, error_api, error_event
            $fileProcessingMessage = ""
            $fileEventDetails = @{} # Детали для события FILE_PROCESSED
            $apiResponse = $null # Ответ от API /checks
            $payloadArray = $null # Массив результатов для отправки
            $totalRecordsInFile = 0 # Общее кол-во записей в файле
            $fileAgentVersion = "[неизвестно]"; $fileAssignmentVersion = "[неизвестно]"

            # Блок try/catch для ЛОКАЛЬНЫХ ошибок (чтение, парсинг)
            try {
                # --- Чтение и парсинг файла ---
                Write-Log "Чтение файла '$($file.Name)'..." -Level Debug
                $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
                $fileContentClean = $fileContent.TrimStart([char]0xFEFF)
                $payloadFromFile = $fileContentClean | ConvertFrom-Json -ErrorAction Stop
                Write-Log "Файл '$($file.Name)' успешно прочитан и распарсен." -Level Debug

                # --- Валидация структуры файла ---
                if ($null -eq $payloadFromFile `
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('results')) `
                    -or ($payloadFromFile.results -isnot [array]) `
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('agent_script_version')) `
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('assignment_config_version'))
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('object_id')) ) {
                    throw "Некорректная структура JSON файла '$($file.Name)'. Отсутствуют обязательные поля (results, agent_script_version, assignment_config_version, object_id)."
                }

                # Извлекаем метаданные
                $resultsArray = $payloadFromFile.results
                $fileAgentVersion = $payloadFromFile.agent_script_version | Get-OrElse "[не указана]"
                $fileAssignmentVersion = $payloadFromFile.assignment_config_version | Get-OrElse "[не указана]"
                $fileObjectId = $payloadFromFile.object_id # ID объекта, СГЕНЕРИРОВАВШЕГО файл

                $totalRecordsInFile = $resultsArray.Count
                Write-Log ("Файл '{0}' содержит записей: {1}. AgentVer: '{2}', ConfigVer: '{3}', SourceOID: {4}" `
                    -f $file.Name, $totalRecordsInFile, $fileAgentVersion, $fileAssignmentVersion, $fileObjectId) -Level Info

                # --- Формирование payload для API /checks ---
                if ($totalRecordsInFile -gt 0) {
                    $payloadArray = [System.Collections.Generic.List[object]]::new()
                    $skippedCount = 0
                    foreach ($res in $resultsArray) {
                         # Базовая валидация элемента result
                         if ($res -ne $null -and $res -is [hashtable] `
                             -and $res.ContainsKey('assignment_id') -and $res.assignment_id -ne $null `
                             -and $res.ContainsKey('IsAvailable') -and $res.IsAvailable -ne $null `
                             -and $res.ContainsKey('Timestamp') -and $res.Timestamp -ne $null)
                         {
                             # Формируем объект для API
                             $payloadItem = @{
                                 assignment_id        = $res.assignment_id
                                 is_available         = $res.IsAvailable
                                 check_timestamp      = $res.Timestamp
                                 details              = $res.Details # Передаем как есть
                                 # Добавляем метаданные из файла В КАЖДЫЙ результат
                                 agent_script_version = $fileAgentVersion
                                 assignment_config_version = $fileAssignmentVersion
                                 executor_object_id   = $fileObjectId # OID агента, сделавшего проверку
                                 executor_host        = $null # Оффлайн агент не пишет имя хоста в zrpu
                                 resolution_method    = 'offline_loader'
                             }
                             # Включаем CheckSuccess и ErrorMessage в details, если они есть
                             if ($res.ContainsKey('CheckSuccess') -and $res.CheckSuccess -ne $null) {
                                if ($payloadItem.details -eq $null) { $payloadItem.details = @{} }
                                $payloadItem.details.CheckSuccess = $res.CheckSuccess
                             }
                             if (-not [string]::IsNullOrEmpty($res.ErrorMessage)) {
                                if ($payloadItem.details -eq $null) { $payloadItem.details = @{} }
                                $payloadItem.details.ErrorMessageFromCheck = $res.ErrorMessage
                             }
                             $payloadArray.Add($payloadItem)
                         } else {
                            $skippedCount++
                             Write-Log ("Пропущен некорректный элемент в файле '{0}': отсутствует assignment_id, IsAvailable или Timestamp. Данные: {1}" `
                                         -f $file.Name, ($res | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue)) -Level Warn
                         }
                    } # End foreach ($res in $resultsArray)

                    if ($skippedCount -gt 0) {
                        $fileProcessingMessage = " Записей в файле: $totalRecordsInFile. Пропущено из-за ошибок формата: $skippedCount."
                        # Устанавливаем статус как частичная ошибка, т.к. не все данные будут отправлены
                        $fileProcessingStatus = "partial_error"
                        $fileEventDetails.skipped_format_error = $skippedCount
                    }
                    if ($payloadArray.Count -eq 0 -and $totalRecordsInFile -gt 0) {
                        # Все записи были пропущены
                         throw "Все записи в файле '$($file.Name)' некорректны."
                    } elseif ($payloadArray.Count -eq 0 -and $totalRecordsInFile -eq 0) {
                         # Изначально не было записей
                         $fileProcessingStatus = "success_empty"
                         $fileProcessingMessage = "Обработка файла завершена (пустой массив results)."
                         $fileEventDetails = @{ total_records_in_file = 0; agent_version_in_file = $fileAgentVersion; assignment_version_in_file = $fileAssignmentVersion }
                    }
                } else { # totalRecordsInFile == 0
                    $fileProcessingStatus = "success_empty"
                    $fileProcessingMessage = "Обработка файла завершена (пустой массив results)."
                    $fileEventDetails = @{ total_records_in_file = 0; agent_version_in_file = $fileAgentVersion; assignment_version_in_file = $fileAssignmentVersion }
                }

                # --- Отправка запроса в API (если есть что отправлять) ---
                if ($payloadArray -ne $null -and $payloadArray.Count -gt 0) {
                    $apiUrlChecks = "$($script:Config.api_base_url.TrimEnd('/'))/v1/checks"
                    $headersForChecks = @{ 'X-API-Key' = $script:EffectiveApiKey } # Content-Type добавится в Invoke-ApiRequestWithRetry
                    $apiParams = @{
                        Uri = $apiUrlChecks
                        Method = 'Post'
                        BodyObject = $payloadArray # Передаем массив объектов
                        Headers = $headersForChecks
                        Description = "Отправка {0} результатов из файла '{1}'" -f $payloadArray.Count, $file.Name
                    }
                    Write-Log ("Отправка {0} результатов из файла '{1}' на {2}..." -f $payloadArray.Count, $file.Name, $apiUrlChecks) -Level Info

                    # Вызов API с логикой retry
                    $apiResponse = Invoke-ApiRequestWithRetry @apiParams # Может выбросить исключение

                    # Анализ ответа API (если не было исключения)
                    if ($apiResponse -ne $null) {
                        $processedApi = $apiResponse.processed | Get-OrElse 0
                        $failedApi = $apiResponse.failed | Get-OrElse 0
                        $statusApi = $apiResponse.status | Get-OrElse "unknown"
                        $apiErrors = $apiResponse.errors # Может быть $null или массив

                         Write-Log ("Ответ API для файла '{0}': Статус='{1}', Обработано={2}, Ошибки API={3}" `
                                    -f $file.Name, $statusApi, $processedApi, $failedApi) -Level Info
                         if ($apiErrors) { Write-Log "Детали ошибок API: $($apiErrors | ConvertTo-Json -Depth 3 -Compress -WarningAction SilentlyContinue)" -Level Warn }

                        # Определяем итоговый статус файла на основе ответа API
                        if ($statusApi -eq "success" -and $failedApi -eq 0) {
                            $fileProcessingStatus = "success"
                            $fileProcessingMessage += " Успешно обработано API: $processedApi."
                        } else { # partial_error или error от API
                            $fileProcessingStatus = "error_api" # Любая ошибка от API - файл в DLQ
                            $fileProcessingMessage += " Обработано API: $processedApi, Ошибки API: $failedApi."
                            $fileEventDetails.api_status = $statusApi
                            $fileEventDetails.api_processed = $processedApi
                            $fileEventDetails.api_failed = $failedApi
                            if ($apiErrors) { $fileEventDetails.api_errors = $apiErrors }
                        }
                    } else {
                        # Если Invoke-ApiRequestWithRetry вернул $null (все попытки неудачны)
                         $fileProcessingStatus = "error_api" # Ошибка API, файл в DLQ
                         $fileProcessingMessage += " Ошибка отправки в API после всех попыток."
                         $fileEventDetails.error = "API request failed after retries."
                    }
                } # Конец if ($payloadArray -ne $null -and $payloadArray.Count -gt 0)

            # <<< Закрываем локальный try >>>
            } catch {
                # Ошибка чтения/парсинга файла ИЛИ ошибка валидации структуры
                $errorMessage = "Критическая локальная ошибка обработки файла '$($file.FullName)': $($_.Exception.Message)"
                Write-Log $errorMessage -Level Error
                $fileProcessingStatus = "error_local"
                $fileProcessingMessage = "Ошибка чтения, парсинга JSON или валидации структуры файла."
                $fileEventDetails = @{ error = $errorMessage; ErrorRecord = $_.ToString() }
            }
            # --- Конец локального try/catch ---

            # --- Отправка события FILE_PROCESSED (даже если были ошибки) ---
            $fileEndTime = [DateTimeOffset]::UtcNow
            $processingTimeMs = ($fileEndTime - $fileStartTime).TotalSeconds * 1000

            # Определяем Severity для события
            $eventSeverity = "INFO"
            if ($fileProcessingStatus -like "error*") { $eventSeverity = "ERROR" }
            elseif ($fileProcessingStatus -eq "partial_error") { $eventSeverity = "WARN" }

            # Дополняем детали события
            $fileEventDetails.processing_status = $fileProcessingStatus
            $fileEventDetails.processing_time_ms = [math]::Round($processingTimeMs)
            $fileEventDetails.file_name = $file.Name
            # Добавляем метаданные файла в событие
            if ($fileAgentVersion -ne "[неизвестно]") { $fileEventDetails.agent_version_in_file = $fileAgentVersion }
            if ($fileAssignmentVersion -ne "[неизвестно]") { $fileEventDetails.assignment_version_in_file = $fileAssignmentVersion }
            if ($fileObjectId) { $fileEventDetails.source_object_id_in_file = $fileObjectId }
            if ($totalRecordsInFile -gt 0) { $fileEventDetails.total_records_in_file = $totalRecordsInFile }

            $eventBody = @{
                event_type      = "FILE_PROCESSED"
                severity        = $eventSeverity
                message         = $fileProcessingMessage | Get-OrElse ("Обработка файла '{0}' завершена со статусом '{1}'." -f $file.Name, $fileProcessingStatus)
                source          = "result_loader.ps1 (v$ScriptVersion)"
                related_entity  = "ZRPU_FILE" # Указываем тип сущности
                related_entity_id = $file.Name
                details         = $fileEventDetails
            }
            $eventApiResponse = $null
            try {
                 $eventApiUrl = "$($script:Config.api_base_url.TrimEnd('/'))/v1/events"
                 $eventHeaders = @{ 'X-API-Key' = $script:EffectiveApiKey }
                 $eventApiParams = @{ Uri=$eventApiUrl; Method='Post'; BodyObject=$eventBody; Headers=$eventHeaders; Description="Отправка события FILE_PROCESSED для '$($file.Name)'"}
                 Write-Log ("Отправка события FILE_PROCESSED для '{0}' (Статус файла: {1})..." -f $file.Name, $fileProcessingStatus) -Level Info
                 $eventApiResponse = Invoke-ApiRequestWithRetry @eventApiParams # Отправляем событие
                 if ($eventApiResponse -eq $null) { throw "Не удалось отправить событие после всех попыток." }
                 Write-Log ("Событие FILE_PROCESSED для '{0}' успешно отправлено (EventID: {1})." -f $file.Name, ($eventApiResponse.event_id | Get-OrElse '?')) -Level Info
            } catch {
                # Ошибка отправки события - это ухудшает статус файла до error_event
                 Write-Log ("Критическая ошибка отправки события FILE_PROCESSED для '{0}': {1}" -f $file.Name, $_.Exception.Message) -Level Error
                 # Если до этого была ошибка API, она важнее
                 if ($fileProcessingStatus -ne "error_api") { $fileProcessingStatus = "error_event" }
            }

            # --- Атомарное перемещение файла ---
            # Определяем целевую папку
            $destinationFolder = $null
            switch ($fileProcessingStatus) {
                "success"           { $destinationFolder = $processedFolder }
                "success_empty"     { $destinationFolder = $processedFolder }
                "error_local"       { $destinationFolder = $errorFolder }
                "error_api"         { $destinationFolder = $unrecoverableFolder } # Ошибки API -> в DLQ
                "partial_error"     { $destinationFolder = $unrecoverableFolder } # Частичные ошибки API -> тоже в DLQ
                "error_event"       { $destinationFolder = $unrecoverableFolder } # Ошибка события -> в DLQ
                default             { $destinationFolder = $errorFolder } # Неизвестный статус -> в Error
            }

            $destinationPath = Join-Path $destinationFolder $file.Name
            # Используем временный файл при перемещении на ДРУГОЙ том (если папки на разных дисках)
            # Но т.к. папки рядом, скорее всего, том один, и Move-Item атомарен.
            # Для надежности можно всегда копировать во временный, потом удалять исходный.
            # Но пока используем Move-Item.
            Write-Log ("Перемещение файла '{0}' в '{1}' (Итоговый статус: {2})..." `
                        -f $file.Name, $destinationFolder, $fileProcessingStatus) -Level Info
            try {
                Move-Item -Path $file.FullName -Destination $destinationPath -Force -ErrorAction Stop
                Write-Log ("Файл '{0}' успешно перемещен." -f $file.Name) -Level Info
            } catch {
                 # Если перемещение не удалось - это ОЧЕНЬ ПЛОХО, т.к. файл обработается снова
                 Write-Log ("КРИТИЧЕСКАЯ ОШИБКА перемещения файла '{0}' в '{1}'. ФАЙЛ МОЖЕТ БЫТЬ ОБРАБОТАН ПОВТОРНО! Ошибка: {2}" `
                            -f $file.Name, $destinationPath, $_.Exception.Message) -Level Error
                 # Здесь можно попытаться переименовать файл на месте с добавлением .failed_to_move
            }

            Write-Log "--- Завершение обработки файла: '$($file.FullName)' ---" -Level Info

        } # Конец foreach ($file in $filesToProcess)
    } # Конец else ($filesToProcess.Count -eq 0)

    # --- Пауза перед следующим сканированием ---
    Write-Log "Пауза $scanInterval сек перед следующим сканированием..." -Level Verbose
    Start-Sleep -Seconds $scanInterval

} # --- Конец while ($true) ---

Write-Log "Загрузчик результатов завершил работу непредвиденно (выход из цикла while)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\result_loader\result_loader.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 ====
# ManualTest-Check-CERT_EXPIRY.ps1 (v2.1)
# Скрипт для ручного тестирования Check-CERT_EXPIRY.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseCertAssignment = @{
    assignment_id = 500; method_name = 'CERT_EXPIRY'; node_name = 'Cert Test'; ip_address = $null
    parameters = @{}; success_criteria = $null
}

# --- !!! ВАЖНО: Замените на реальный отпечаток для тестов !!! ---
$existingThumbprint = 'YOUR_CERT_THUMBPRINT_HERE' # Найдите отпечаток в certlm.msc -> Личное -> Сертификаты

$testCases = @(
    @{ Name = "Все SSL серт. сервера (>14 дней)";
       Params = @{ eku_oid = @('1.3.6.1.5.5.7.3.1'); require_private_key = $true; min_days_warning = 30 };
       # Критерий: Для ВСЕХ сертификатов в результате, поле days_left > 14
       Criteria = @{ certificates=@{_condition_='all';_criteria_=@{days_left=@{'>'=14}}} } }
    @{ Name = "Конкретный отпечаток (>60 дней)";
       Params = @{ thumbprint = $existingThumbprint };
       # Критерий: Для ВСЕХ сертификатов, где thumbprint совпадает, поле days_left > 60
       Criteria = @{ certificates=@{_condition_='all';_where_=@{thumbprint=$existingThumbprint};_criteria_=@{days_left=@{'>'=60}}} } }
    @{ Name = "Конкретный отпечаток (Fail < 10000 дней)";
       Params = @{ thumbprint = $existingThumbprint };
       # Критерий: Для ВСЕХ сертификатов, где thumbprint совпадает, поле days_left < 10000 (должен НЕ пройти)
       Criteria = @{ certificates=@{_condition_='all';_where_=@{thumbprint=$existingThumbprint};_criteria_=@{days_left=@{'<'=10000}}} } }
    @{ Name = "Сертификаты от Let's Encrypt (>0 дней)";
       Params = @{ issuer_like = "*Let's Encrypt*" };
       # Критерий: Для ВСЕХ сертификатов от LE, поле days_left > 0
       Criteria = @{ certificates=@{_condition_='all';_where_=@{issuer=@{'contains'="Let's Encrypt"}};_criteria_=@{days_left=@{'>'=0}}} } } # Используем contains
    @{ Name = "Хотя бы один сертификат истекает менее чем через 90 дней (ANY)";
       Params = @{ require_private_key = $true };
       # Критерий: Найти ХОТЯ БЫ ОДИН сертификат, где days_left < 90
       Criteria = @{ certificates=@{_condition_='any';_criteria_=@{days_left=@{'<'=90}}} } }
    @{ Name = "Ошибка: Неверное хранилище";
       Params = @{ store_location = 'InvalidPlace'; store_name = 'My' }; Criteria = $null }
    @{ Name = "Ошибка: Неверный OID";
       Params = @{ eku_oid = @('invalid-oid') }; Criteria = $null }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений, но с проверкой плейсхолдера)
$testIdCounter = $baseCertAssignment.assignment_id
foreach ($testCase in $testCases) {
    if (($testCase.Params.thumbprint -eq 'YOUR_CERT_THUMBPRINT_HERE') -or ($testCase.Criteria -and $testCase.Criteria.certificates -and $testCase.Criteria.certificates._where_ -and $testCase.Criteria.certificates._where_.thumbprint -eq 'YOUR_CERT_THUMBPRINT_HERE')) { Write-Warning "...Пропуск..."; Write-Host ("-"*50); continue }
    $testIdCounter++; $currentAssignment = $baseCertAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 3 -Compress)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"
    $detailsCopy = $result.Details.PSObject.Copy(); if ($detailsCopy.certificates -is [System.Collections.Generic.List[object]] -and $detailsCopy.certificates.Count -gt 3) { $detailsCopy.certificates = $detailsCopy.certificates | Select-Object -First 3; $detailsCopy.Add('certificates_truncated', $true) }
    $resultOutput = $result.PSObject.Copy(); $resultOutput.Details = $detailsCopy
    Write-Host ($resultOutput | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Milliseconds 500
}
Write-Host "Ручное тестирование CERT_EXPIRY завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 ====
# ManualTest-Check-DISK_USAGE.ps1 (v2.1)
# Скрипт для ручного тестирования Check-DISK_USAGE.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseDiskAssignment = @{
    assignment_id = 300; method_name = 'DISK_USAGE'; node_name = 'Disk Test'; ip_address = $null
    parameters = $null; success_criteria = $null
}

# *** ВАЖНО: Результаты зависят от состояния дисков на машине, где запускается тест! ***
$testCases = @(
    @{ Name = "Все диски (без критериев)"; Params = $null; Criteria = $null }
    @{ Name = "Только диск C: (без критериев)"; Params = @{ drives = @('C') }; Criteria = $null }
    @{ Name = "Диск C: > 5% свободно (OK?)"; Params = @{ drives = @('C') };
       # Критерий: Для массива 'disks', где drive_letter='C', поле percent_free должно быть >= 5
       Criteria = @{ disks=@{_condition_='all'; _where_=@{drive_letter='C'}; _criteria_=@{percent_free=@{'>='=5}}} } }
    @{ Name = "Диск C: > 99% свободно (FAIL?)"; Params = @{ drives = @('C') };
       # Критерий: Для C: % свободно > 99 (скорее всего не пройдет)
       Criteria = @{ disks=@{_condition_='all'; _where_=@{drive_letter='C'}; _criteria_=@{percent_free=@{'>'=99}}} } }
    @{ Name = "Все диски: > 1% свободно (OK?)"; Params = $null;
       # Критерий: Для ВСЕХ дисков в массиве 'disks', % свободно > 1
       Criteria = @{ disks=@{_condition_='all'; _criteria_=@{percent_free=@{'>'=1}}} } }
    @{ Name = "Хотя бы один диск < 10% свободно (ANY + <)"; Params = $null;
        # Критерий: Найти ХОТЯ БЫ ОДИН диск, где % свободно < 10
       Criteria = @{ disks=@{_condition_='any'; _criteria_=@{percent_free=@{'<'=10}}} } }
    @{ Name = "Все диски > 0 байт свободно"; Params = $null;
       # Критерий: Проверить, что у всех free_bytes > 0
       Criteria = @{ disks=@{_condition_='all'; _criteria_=@{free_bytes=@{'>'=1}}} } } # Используем >=1, т.к. 0 может быть валидным
    @{ Name = "Ошибка: Некорректный оператор в критерии"; Params = @{drives=@('C')};
       Criteria = @{ disks=@{_condition_='all'; _where_=@{drive_letter='C'}; _criteria_=@{percent_free=@{'bad_op'=10}}} } }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений)
$testIdCounter = $baseDiskAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++; $currentAssignment = $baseDiskAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 2 -Compress)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Seconds 1
}
Write-Host "Ручное тестирование DISK_USAGE завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 ====
# ManualTest-Check-PING.ps1 (v2.1)
# Скрипт для ручного тестирования Check-PING.ps1 через диспетчер

    

# --- 1. Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try {
    $modulePath = Join-Path -Path $PSScriptRoot -ChildPath "StatusMonitorAgentUtils.psd1"
    Write-Host "Загрузка модуля из '$modulePath'..." -ForegroundColor Cyan
    Import-Module $modulePath -Force
    Write-Host "Модуль загружен." -ForegroundColor Green
} catch { Write-Error "Критическая ошибка загрузки модуля Utils: $($_.Exception.Message)"; exit 1 } finally { $ErrorActionPreference = "Continue" }
Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$basePingAssignment = @{
    assignment_id = 200; method_name = 'PING'; node_name = 'Ping Test'
    parameters = @{}; success_criteria = $null
}

$testCases = @(
    @{ Name = "Успешный пинг localhost (без критериев)"; Target = '127.0.0.1'; Params = @{ count = 1 } }
    @{ Name = "Неуспешный пинг (несущ. IP)"; Target = '192.0.2.1'; Params = @{ timeout_ms = 500; count = 1 } }
    @{ Name = "Успешный пинг ya.ru (RTT <= 1000ms)"; Target = 'ya.ru';
       # Критерий: RTT должен быть меньше или равен 1000
       Criteria = @{ rtt_ms = @{ '<=' = 1000 } } }
    @{ Name = "Успешный пинг ya.ru (RTT <= 1ms - НЕ пройдет)"; Target = 'ya.ru';
       # Критерий: RTT должен быть меньше или равен 1 (заведомо ложно)
       Criteria = @{ rtt_ms = @{ '<=' = 1 } } }
    @{ Name = "Успешный пинг ya.ru (Потери == 0%)"; Target = 'ya.ru';
       # Критерий: Процент потерь должен быть равен 0
       Criteria = @{ packet_loss_percent = @{ '==' = 0 } } }
    @{ Name = "Успешный пинг ya.ru (Потери < 50% - пройдет)"; Target = 'ya.ru'; Params = @{ count = 4 };
       # Критерий: Процент потерь должен быть меньше 50
       Criteria = @{ packet_loss_percent = @{ '<' = 50 } } }
    @{ Name = "Успешный пинг ya.ru (RTT > 10ms И Потери < 50%)"; Target = 'ya.ru'; Params = @{ count = 4 };
       # Критерий: Оба условия должны выполниться
       Criteria = @{ rtt_ms=@{'>'=10}; packet_loss_percent=@{'<'=50} } }
    @{ Name = "Ошибка: Некорректный критерий (не число)"; Target = 'ya.ru';
       # Критерий: Некорректное значение порога
       Criteria = @{ rtt_ms=@{'>'='abc'} } }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений, как в предыдущем ответе)
$testIdCounter = $basePingAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++
    $currentAssignment = $basePingAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name; $currentAssignment.ip_address = $testCase.Target
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }

    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -ForegroundColor Yellow
    Write-Host "  Target: $($currentAssignment.ip_address)"
    Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 2 -Compress)"
    Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 3 -Compress)"

    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 4) -ForegroundColor Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Seconds 1
}
Write-Host "Ручное тестирование PING завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 ====
# ManualTest-Check-PROCESS_LIST.ps1 (v2.1)
# Скрипт для ручного тестирования Check-PROCESS_LIST.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseProcessAssignment = @{
   assignment_id = 400; method_name = 'PROCESS_LIST'; node_name = 'Process Test'; ip_address = $null # <--- ip_address = $null
   parameters = @{}; success_criteria = $null
}

# *** Результаты зависят от запущенных процессов на машине теста! ***
$testCases = @(
    @{ Name = "Топ 5 по памяти (без критериев)"; Params = @{ sort_by = 'Memory'; sort_descending = $true; top_n = 5 } }
    @{ Name = "Процессы PowerShell (с деталями)"; Params = @{ process_names = @('*powershell*'); include_username = $true; include_path = $true } }
    @{ Name = "Найти svchost (ожидаем >=1)"; Params = @{ process_names = @('svchost') };
       # Критерий: Количество найденных процессов должно быть >= 1
       Criteria = @{ processes=@{_condition_='count';_count_=@{'>='=1}} } }
    @{ Name = "Найти notepad (ожидаем == 0, если не запущен)"; Params = @{ process_names = @('notepad') };
       # Критерий: Количество найденных == 0
       Criteria = @{ processes=@{_condition_='count';_count_=@{'=='=0}} } }
    @{ Name = "Проверить, что НЕТ процесса 'malware.exe'"; Params = $null;
       # Критерий: Ни один процесс не должен соответствовать _where_
       Criteria = @{ processes=@{_condition_='none';_where_=@{name='malware.exe'}} } }
    @{ Name = "Найти хотя бы один процесс с CPU > 10 сек (ANY)"; Params = @{ include_username=$true };
       # Критерий: Хотя бы один процесс (_condition_=any) имеет cpu_seconds > 10
       Criteria = @{ processes=@{_condition_='any';_criteria_=@{cpu_seconds=@{'>'=10.0}}} } }
    @{ Name = "ВСЕ процессы explorer.exe имеют память < 1000 MB (ALL + WHERE)"; Params = $null;
       # Критерий: Все (_condition_=all) процессы, где имя explorer.exe (_where_),
       # должны иметь память < 1000 (_criteria_)
       Criteria = @{ processes=@{_condition_='all'; _where_=@{name='explorer.exe'}; _criteria_=@{memory_ws_mb=@{'<'=1000}}} } }
    @{ Name = "Несуществующий процесс (ожидаем count=0)"; Params = @{ process_names = @('__NoSuchProcess__') };
       Criteria = @{ processes=@{_condition_='count';_count_=@{'=='=0}} } } # Этот критерий должен пройти
    @{ Name = "Ошибка: Неверное поле сортировки"; Params = @{ sort_by = 'InvalidField' } }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений, но с урезанием вывода Details.processes)
$testIdCounter = $baseProcessAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++; $currentAssignment = $baseProcessAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 2 -Compress)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"
    $detailsCopy = $result.Details.PSObject.Copy(); if ($detailsCopy.processes -is [System.Collections.Generic.List[object]] -and $detailsCopy.processes.Count -gt 5) { $detailsCopy.processes = $detailsCopy.processes | Select -First 5; $detailsCopy.Add('processes_truncated', $true) }
    $resultOutput = $result.PSObject.Copy(); $resultOutput.Details = $detailsCopy
    Write-Host ($resultOutput | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Milliseconds 500
}
Write-Host "Ручное тестирование PROCESS_LIST завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 ====
# ManualTest-Check-SERVICE_STATUS.ps1 (v2.1)
# Скрипт для ручного тестирования Check-SERVICE_STATUS.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseServiceAssignment = @{
    assignment_id = 100; method_name = 'SERVICE_STATUS'; node_name = 'Service Test'; ip_address = $null
    parameters = @{}; success_criteria = $null
}

# *** ВАЖНО: Убедитесь, что службы Spooler и wuauserv существуют на машине, где запускается тест! ***
# *** Состояние служб (Running/Stopped) может влиять на результат тестов с критериями. ***
$testCases = @(
    @{ Name = "Spooler - Без критериев (ожидаем CheckSuccess=true если доступна)"; Service = 'Spooler' }
    @{ Name = "Spooler - Критерий: status = Running"; Service = 'Spooler'; Criteria = @{ status = 'Running' } }
    @{ Name = "Spooler - Критерий: status = Stopped (ожидаем FAIL если работает)"; Service = 'Spooler'; Criteria = @{ status = 'Stopped' } }
    @{ Name = "Spooler - Критерий: status != Stopped (ожидаем OK если работает)"; Service = 'Spooler'; Criteria = @{ status = @{'!=' = 'Stopped'} } }
    @{ Name = "Несуществующая служба (ожидаем IsAvailable=false)"; Service = '__NonExistentService__'; Criteria = $null }
    @{ Name = "wuauserv - Критерий: start_type = Manual"; Service = 'wuauserv'; Criteria = @{ start_type = 'Manual' } } # Проверяем тип запуска
    @{ Name = "wuauserv - Критерий: can_stop = true"; Service = 'wuauserv'; Criteria = @{ can_stop = $true } } # Проверяем булево поле
    @{ Name = "Ошибка: Неверный критерий"; Service = 'Spooler'; Criteria = @{ status = @{'invalid_op' = 1} } } # Ожидаем CheckSuccess=null
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений)
$testIdCounter = $baseServiceAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++; $currentAssignment = $baseServiceAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    $currentAssignment.parameters = @{ service_name = $testCase.Service }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Service: $($currentAssignment.parameters.service_name)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 2 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 4) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Seconds 1
}
Write-Host "Ручное тестирование SERVICE_STATUS завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 ====
# ManualTest-SQL-Checks-Kaskad.ps1 (v2.1)
# --- Скрипт для ручного тестирования SQL-проверок на базе testDB_kaskad через диспетчер ---

# --- 1. Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try { $modulePath = Join-Path -Path $PSScriptRoot -ChildPath "StatusMonitorAgentUtils.psd1"; Import-Module $modulePath -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }
# Проверка модуля SqlServer
if (-not (Get-Command Invoke-Sqlcmd -EA SilentlyContinue)) { Write-Warning "Модуль SqlServer не найден!" }
Write-Host "Модуль Utils загружен." -FG Green; Write-Host $('-'*80)

# --- 2. Параметры ТЕСТОВОЙ БД Kaskad (из testDB_kaskad/docker-compose.yml) ---
$TestSqlServerInstance = "localhost,48010" # Порт из docker-compose
$TestDatabaseName = "kaskad"
$TestSqlUsername = "sa"
$TestSqlPassword = "escort123" # Пароль из docker-compose

Write-Host "ПАРАМЕТРЫ ТЕСТОВОЙ БД Kaskad:"; Write-Host "  Сервер: $TestSqlServerInstance"; Write-Host "  База:   $TestDatabaseName"; Write-Host "  Режим:  SQL Auth ($TestSqlUsername)"; Write-Host $('-'*80)

# --- 3. Базовый объект Задания ---
$baseAssignment = @{
    assignment_id = 9000; node_name = "Kaskad DB Test"; ip_address = $TestSqlServerInstance
    parameters = @{ sql_database = $TestDatabaseName; sql_username = $TestSqlUsername; sql_password = $TestSqlPassword }; success_criteria = $null
}

# --- Функция для выполнения и вывода теста ---
function Run-ManualSqlTest {
    param([Parameter(Mandatory=$true)]$Assignment, [string]$ExpectedResult = "")
    Write-Host "ЗАПУСК: $($Assignment.node_name)" -ForegroundColor Yellow
    Write-Host "  Method: $($Assignment.method_name)"
    Write-Host "  Parameters: $($Assignment.parameters | ConvertTo-Json -Depth 3 -Compress)"
    Write-Host "  SuccessCriteria: $($Assignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$Assignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS $ExpectedResult" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL $ExpectedResult" -FG Red } else { Write-Host "  Критерии: N/A $ExpectedResult" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*40)
}

# =================================================
# === ТЕСТЫ Check-SQL_QUERY_EXECUTE ===
# =================================================
Write-Host "ТЕСТЫ: Check-SQL_QUERY_EXECUTE" -FG Yellow

$execBase = $baseAssignment.PSObject.Copy(); $execBase.method_name = 'SQL_QUERY_EXECUTE'
$execId = $execBase.assignment_id

# --- first_row ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - First Row"; $assign.parameters.sql_query = "SELECT TOP 1 * FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'first_row'
Run-ManualSqlTest -Assignment $assign

# --- row_count ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Row Count (1)"; $assign.parameters.sql_query = "SELECT id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'row_count'
Run-ManualSqlTest -Assignment $assign

# --- row_count с критерием (PASS) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Row Count Criteria OK"; $assign.parameters.sql_query = "SELECT id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'row_count'; $assign.success_criteria = @{ row_count = @{ '==' = 1 } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем PASS)"

# --- row_count с критерием (FAIL) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Row Count Criteria FAIL"; $assign.parameters.sql_query = "SELECT id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'row_count'; $assign.success_criteria = @{ row_count = @{ '>' = 5 } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем FAIL)"

# --- scalar ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Scalar (Get ID)"; $assign.parameters.sql_query = "SELECT TOP 1 id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'scalar'
Run-ManualSqlTest -Assignment $assign

# --- scalar с критерием (PASS) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Scalar Criteria OK"; $assign.parameters.sql_query = "SELECT COUNT(*) FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'scalar'; $assign.success_criteria = @{ scalar_value = @{ '>=' = 1 } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем PASS)"

# --- non_query ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Non-Query (Temp)"; $assign.parameters.sql_query = "IF OBJECT_ID('tempdb..#TempTestExec') IS NULL CREATE TABLE #TempTestExec(col1 INT);"; $assign.parameters.return_format = 'non_query'
Run-ManualSqlTest -Assignment $assign

# --- Ошибка SQL (Bad Table) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - SQL Error (Bad Table)"; $assign.parameters.sql_query = "SELECT * FROM dbo.NonExistentTable"; $assign.parameters.return_format = 'first_row'
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

# --- Ошибка подключения (Bad DB) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Connect Error (Bad DB)"; $assign.parameters.sql_database = "NonExistentDB"; $assign.parameters.sql_query = "SELECT 1"; $assign.parameters.return_format = 'scalar'
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

Write-Host "КОНЕЦ ТЕСТОВ: Check-SQL_QUERY_EXECUTE" -FG Green; Write-Host $('='*80); Write-Host ""

# =================================================
# === ТЕСТЫ Check-SQL_XML_QUERY ===
# =================================================
Write-Host "ТЕСТЫ: Check-SQL_XML_QUERY" -FG Yellow

$xmlBase = $baseAssignment.PSObject.Copy(); $xmlBase.method_name = 'SQL_XML_QUERY'
$xmlId = $xmlBase.assignment_id + 10 # Смещаем ID

# --- Успешное извлечение ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Extract OK"; $assign.parameters.sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('VersionStat', 'TS_Version', 'NonExistentKey')
Run-ManualSqlTest -Assignment $assign

# --- Успех с критерием ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Criteria OK"; $assign.parameters.sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('VersionStat', 'TS_Version'); $assign.success_criteria = @{ extracted_data = @{ VersionStat = @{ '==' = '20221206' }; TS_Version = @{ '>' = 100 } } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем PASS)"

# --- Неуспех по критерию ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Criteria FAIL"; $assign.parameters.sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('TS_Version'); $assign.success_criteria = @{ extracted_data = @{ TS_Version = @{ '<' = 100 } } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем FAIL)"

# --- Ошибка (Bad XML Column) ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Error (Bad Column)"; $assign.parameters.sql_query = "SELECT TOP 1 id, Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'InvalidXmlColumn'; $assign.parameters.keys_to_extract = @('VersionStat')
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

# --- Ошибка (Column Not XML) ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Error (Not XML)"; $assign.parameters.sql_query = "SELECT TOP 1 CreationDate FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'CreationDate'; $assign.parameters.keys_to_extract = @('Year')
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

# --- Ошибка (No Rows) ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Error (No Rows)"; $assign.parameters.sql_query = "SELECT Revise FROM dbo.ReviseData WHERE id = 99999"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('VersionStat')
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: OK, но нет данных)" # IsAvailable=true, т.к. SQL запрос выполнился

Write-Host "КОНЕЦ ТЕСТОВ: Check-SQL_XML_QUERY" -FG Green; Write-Host $('='*80)
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\README.md ====

---

### 4. README для Модуля Утилит

**Файл:** `powershell/StatusMonitorAgentUtils/README.md` (Обновленный)

```markdown
# Модуль PowerShell: StatusMonitorAgentUtils (v1.1.0+)

Этот модуль PowerShell (`StatusMonitorAgentUtils.psm1` и папка `Checks/`) предоставляет общую функциональность для **Гибридного Агента Мониторинга** системы Status Monitor.

## Назначение

*   **Инкапсуляция логики проверок:** Содержит код для выполнения различных типов проверок (PING, статус службы, использование диска, SQL-запросы, проверка сертификатов и т.д.).
*   **Диспетчеризация:** Предоставляет единую точку входа (`Invoke-StatusMonitorCheck`) для Гибридного Агента, которая определяет нужный метод проверки и запускает соответствующий скрипт.
*   **Стандартизация результатов:** Обеспечивает возврат результатов проверок в едином формате (стандартная хэш-таблица).
*   **Проверка Критериев Успеха:** Содержит универсальную функцию `Test-SuccessCriteria` (и вспомогательные `Compare-Values`, `Test-ArrayCriteria`) для гибкой проверки результатов на соответствие заданным критериям (`success_criteria` в задании).
*   **Переиспользование кода:** Содержит общие вспомогательные функции.

## Ключевые компоненты

1.  **`StatusMonitorAgentUtils.psm1`**: Основной файл модуля. Содержит:
    *   **`Invoke-StatusMonitorCheck` (Экспортируемая):**
        *   **Роль:** Диспетчер проверок. Вызывается Гибридным Агентом.
        *   **Вход:** Объект задания (`$Assignment`).
        *   **Логика:** Определяет метод, находит скрипт `Checks/Check-*.ps1`, подготавливает параметры (включая `$SuccessCriteria`), запускает скрипт локально, возвращает результат.
    *   **`New-CheckResultObject` (Экспортируемая):**
        *   **Роль:** Формирование стандартного объекта результата. Используется скриптами `Checks/*.ps1`.
        *   **Вход:** `$IsAvailable`, `$CheckSuccess`, `$Details`, `$ErrorMessage`.
        *   **Выход:** Стандартная хэш-таблица результата.
    *   **`Test-SuccessCriteria` (Экспортируемая):**
        *   **Роль:** Универсальная рекурсивная проверка соответствия объекта `$Details` заданным `$SuccessCriteria`.
        *   **Вход:** `$DetailsObject`, `$CriteriaObject`.
        *   **Логика:** Рекурсивно обходит структуру критериев, использует `Compare-Values` для сравнения значений и `Test-ArrayCriteria` для обработки массивов (с ключами `_condition_`, `_where_`, `_criteria_`, `_count_`).
        *   **Выход:** `@
{ Passed = $true/$false/$null; FailReason = "..."/$null }`.
    *   **`Compare-Values` (Экспортируемая):** Сравнивает два значения с помощью указанного оператора (`==`, `>`, `contains` и т.д.).
    *   **`Test-ArrayCriteria` (Приватная):** Обрабатывает критерии для массивов в `$Details`.

2.  **Папка `Checks/`**: Содержит отдельные `.ps1` файлы для **каждого** метода проверки.
    *   **Именование:** `Check-METHOD_NAME.ps1`.
    *   **Назначение:** Реализация логики конкретной проверки.
    *   **Вход:** Параметры `$TargetIP`, `$Parameters`, `$SuccessCriteria`, `$NodeName`.
    *   **Логика:** Выполнить проверку, сформировать `$details`, определить `$isAvailable`, вызвать `Test-SuccessCriteria` для определения `$checkSuccess` (если нужно), сформировать `$errorMessage`, вернуть результат через `New-CheckResultObject`.

## Стандартный Формат Результата Проверки

(Описание формата результата без изменений)

```powershell
@{
    IsAvailable = [bool] # УДАЛОСЬ ли выполнить проверку?
    CheckSuccess = [nullable[bool]] # Соответствует ли результат КРИТЕРИЯМ? (null если IsAvailable=false или ошибка критериев)
    Timestamp = [string] # UTC ISO 8601
    Details = [hashtable] # Детали проверки (зависят от метода)
    ErrorMessage = [string] # Описание ошибки (если IsAvailable=false ИЛИ CheckSuccess=false/null)
}

Добавление Новых Методов Проверки

(Процесс без изменений)

    Добавить запись в таблицу check_methods БД.

    Создать файл Checks/Check-METHOD_NAME.ps1.

    Реализовать логику:

        Получить параметры.

        Выполнить проверку.

        Сформировать $details.

        Определить $isAvailable.

        Вызвать Test-SuccessCriteria, если нужно.

        Сформировать $errorMessage.

        Вернуть New-CheckResultObject.

    Протестировать через Invoke-StatusMonitorCheck.

    Создать Задание в UI.

Установка и Использование

Модуль копируется вместе с Гибридным Агентом.

    Структура папок:

          
    <Папка_Агента>/
    ├── hybrid-agent/
    │   ├── hybrid-agent.ps1
    │   └── config.json
    └── StatusMonitorAgentUtils/  <-- Модуль здесь
        ├── Checks/
        │   ├── Check-PING.ps1
        │   └── ...
        ├── StatusMonitorAgentUtils.psd1
        └── StatusMonitorAgentUtils.psm1
        └── README.md (этот файл)

        

    IGNORE_WHEN_COPYING_START

    Use code with caution.
    IGNORE_WHEN_COPYING_END

    Скрипт hybrid-agent.ps1 импортирует модуль из ..\StatusMonitorAgentUtils.

      
---

Эти README файлы отражают последние изменения в ТЗ v5.2, включая переход на Гибридный Агент, унификацию API, атомарные операции и папку DLQ для Загрузчика.

    
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\README.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1
# Манифест PowerShell модуля для общих утилит агентов Status Monitor

@{

    # --- ОБНОВЛЕНО: Версия модуля ---
    # Версия 2.0.0: Существенно доработана логика проверки критериев (Test-SuccessCriteria)
    ModuleVersion = '2.0.0'

    # Уникальный идентификатор модуля (GUID). Не меняется.
    GUID = 'e5fa7cfe-608d-47c9-898d-215bb6b0ef0d'

    # Автор модуля
    Author = 'User & AI'

    # Компания (опционально)
    # CompanyName = 'Your Company'

    # Авторские права (опционально)
    # Copyright = '(c) 2024 Your Company. All rights reserved.'

    # --- ОБНОВЛЕНО: Описание модуля ---
    Description = 'Общий модуль для Гибридного Агента системы мониторинга Status Monitor. Содержит диспетчер проверок (Invoke-StatusMonitorCheck), функцию форматирования результата (New-CheckResultObject), универсальную функцию проверки критериев (Test-SuccessCriteria) и скрипты для конкретных проверок в папке Checks.'

    # Минимально необходимая версия PowerShell
    PowerShellVersion = '5.1'

    # Зависимости от других модулей (раскомментировать и добавить при необходимости)
    # Например, если бы использовались командлеты ActiveDirectory:
    # RequiredModules = @{ ModuleName = 'ActiveDirectory'; RequiredVersion = '1.0.0.0' }
    # Для SQL проверок модуль SqlServer ДОЛЖЕН БЫТЬ установлен на машине агента,
    # но его не обязательно указывать здесь, т.к. он используется ВНУТРИ Check-*.ps1
    # RequiredModules = @()

    # Основной файл модуля .psm1
    RootModule = 'StatusMonitorAgentUtils.psm1'

    # --- ПОДТВЕРЖДЕНО: Экспортируемые функции ---
    # Список функций, видимых снаружи модуля.
    # Test-SuccessCriteria и Compare-Values экспортируются для возможности
    # их потенциального использования в более сложных сценариях или тестах.
    FunctionsToExport = @(
        'Invoke-StatusMonitorCheck', # Диспетчер для агента
        'New-CheckResultObject',     # Стандартизация результата (для Checks/*.ps1)
        'Test-SuccessCriteria',      # Универсальная проверка критериев
        'Compare-Values'             # Вспомогательная для Test-SuccessCriteria
        # Test-ArrayCriteria является приватной и не экспортируется
    )

    # Список командлетов, экспортируемых модулем (у нас таких нет).
    CmdletsToExport = @()

    # Список переменных, экспортируемых модулем (не рекомендуется).
    VariablesToExport = @() # Явно указываем пустой список

    # Список псевдонимов (aliases), экспортируемых модулем.
    AliasesToExport = @()

    # Остальные поля манифеста (оставлены без изменений)
    # ModuleList = @()
    # ScriptsToProcess = @()
    # TypesToProcess = @()
    # FormatsToProcess = @()
    # RequiredAssemblies = @()
    # FileList = @()
    # PrivateData = @{}
    # HelpInfoURI = ''
    # DefaultCommandPrefix = ''
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1
# --- Версия 2.1.2 --- (внутренне Test-SuccessCriteria ~v2.0.6, Handle-ArrayCriteriaProcessing ~v1.0.3)
# Улучшена логика FailReason для all/any и в Test-SuccessCriteria

#--------------------------------------------------------------------------
# Приватные функции (не экспортируются модулем)
#--------------------------------------------------------------------------

#region Функция Compare-Values (v1.1.2 - Без изменений от предыдущего полного листинга)
function Compare-Values {
    param(
        $Value,
        $Operator,
        $Threshold
    )
    Write-Debug "Compare-Values: Value=`"$($Value | Out-String -Width 100 | ForEach-Object {$_.Trim()})`", Operator=`"$Operator`", Threshold=`"$($Threshold | Out-String -Width 100 | ForEach-Object {$_.Trim()})`""
    $result = @{ Passed = $true; Reason = '' }
    $opLower = $Operator.ToString().ToLower() 

    try {
        if ($opLower -eq 'exists') {
            if (($Threshold -eq $true -and $Value -eq $null) -or `
                ($Threshold -eq $false -and $Value -ne $null)) {
                $result.Passed = $false
                $result.Reason = "Проверка существования (exists=$Threshold) не пройдена для значения (Value is `$(if($Value -eq $null){'null'}else{'not null'}))."
            }
            return $result
        }

        if ($Value -eq $null -and $opLower -ne '==' -and $opLower -ne '!=') {
             $result.Passed = $false
             $result.Reason = "Невозможно применить оператор '$Operator' к значению `$null (если только оператор не '==' или '!=' для сравнения с `$null)."
             if ($opLower -in @('>', '>=', '<', '<=')) { $result.Passed = $null } 
             return $result
        }

        if ($opLower -eq '==') {
             if (-not ($Value -eq $Threshold)) {
                 $result.Passed = $false; $result.Reason = "'$Value' не равно '$Threshold'"
             }
        }
        elseif ($opLower -eq '!=') {
             if (-not ($Value -ne $Threshold)) {
                 $result.Passed = $false; $result.Reason = "'$Value' равно '$Threshold'"
             }
        }
        elseif ($opLower -in @('>', '>=', '<', '<=')) {
            $numValue = 0.0; $numThreshold = 0.0
            $culture = [System.Globalization.CultureInfo]::InvariantCulture
            
            $valueIsNumber = $false
            if ($Value -is [ValueType] -and $Value -isnot [bool] -and $Value -isnot [datetime]) {
                try { $numValue = [double]$Value; $valueIsNumber = $true } catch {}
            }
            if (-not $valueIsNumber) {
                $valueIsNumber = [double]::TryParse($Value, [System.Globalization.NumberStyles]::Any, $culture, [ref]$numValue)
            }

            $thresholdIsNumber = $false
            if ($Threshold -is [ValueType] -and $Threshold -isnot [bool] -and $Threshold -isnot [datetime]) {
                try { $numThreshold = [double]$Threshold; $thresholdIsNumber = $true } catch {}
            }
            if (-not $thresholdIsNumber) {
                $thresholdIsNumber = [double]::TryParse($Threshold, [System.Globalization.NumberStyles]::Any, $culture, [ref]$numThreshold)
            }

            #Write-Host "DEBUG (Compare-Values NUM): Op='$opLower'. Value='$Value' -> ParsedValue($valueIsNumber):$numValue. Threshold='$Threshold' -> ParsedThreshold($thresholdIsNumber):$numThreshold" -ForegroundColor Cyan

            if (-not $valueIsNumber -or -not $thresholdIsNumber) {
                $result.Passed = $null 
                $reasonParts = @()
                if (-not $valueIsNumber) { $reasonParts += "Не удалось преобразовать значение '$Value' в число." }
                if (-not $thresholdIsNumber) { $reasonParts += "Не удалось преобразовать порог '$Threshold' в число." }
                $result.Reason = "Ошибка числового сравнения '$opLower': $($reasonParts -join ' ')"
                return $result
            }
            switch ($opLower) {
                '>'  { if (-not ($numValue -gt $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' ($numValue) не больше (>) '$Threshold' ($numThreshold)" } }
                '>=' { if (-not ($numValue -ge $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' ($numValue) не больше или равно (>=) '$Threshold' ($numThreshold)" } }
                '<'  { if (-not ($numValue -lt $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' ($numValue) не меньше (<) '$Threshold' ($numThreshold)" } }
                '<=' { if (-not ($numValue -le $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' ($numValue) не меньше или равно (<=) '$Threshold' ($numThreshold)" } }
            }
        }
        elseif ($opLower -in @('contains', 'not_contains', 'matches', 'not_matches')) {
            $strValue = "$Value"
            $strThreshold = "$Threshold"
            switch ($opLower) {
                'contains'     { if ($strValue -notlike "*$strThreshold*") { $result.Passed = $false; $result.Reason = "'$strValue' не содержит '$strThreshold'" } }
                'not_contains' { if ($strValue -like "*$strThreshold*")    { $result.Passed = $false; $result.Reason = "'$strValue' содержит '$strThreshold'" } }
                'matches'      { if ($strValue -notmatch $strThreshold)    { $result.Passed = $false; $result.Reason = "'$strValue' не соответствует регулярному выражению '$strThreshold'" } }
                'not_matches'  { if ($strValue -match $strThreshold)       { $result.Passed = $false; $result.Reason = "'$strValue' соответствует регулярному выражению '$strThreshold'" } }
            }
        } else {
            $result.Passed = $null
            $result.Reason = "Неизвестный оператор сравнения: '$Operator'"
        }
    } catch {
        $result.Passed = $null
        $result.Reason = "Исключение при сравнении оператором '$Operator' для '$Value' и '$Threshold': $($_.Exception.Message)"
    }
    Write-Debug "Compare-Values Result: Passed=$($result.Passed), Reason=`"$($result.Reason)`""
    return $result
}
#endregion

#region Вспомогательная функция Test-IsOperatorBlock (v1.0.1 - Без изменений)
function Test-IsOperatorBlock {
    param (
        [Parameter(Mandatory=$true)] $CriteriaObject 
    )
    if (-not ($CriteriaObject -is [hashtable] -or $CriteriaObject -is [System.Management.Automation.PSCustomObject])) {
        return $false
    }
    $validOperators = @('>', '>=', '<', '<=', '==', '!=', 'contains', 'not_contains', 'matches', 'not_matches', 'exists')
    $keysInCriteria = $null
    if ($CriteriaObject -is [hashtable]) {
        $keysInCriteria = $CriteriaObject.Keys
    } elseif ($CriteriaObject -is [System.Management.Automation.PSCustomObject]) {
        $keysInCriteria = @($CriteriaObject.PSObject.Properties.Name)
    } else { return $false }
    if ($keysInCriteria.Count -eq 0) { return $false }
    foreach ($key in $keysInCriteria) {
        if ($validOperators -notcontains $key.ToString().ToLower()) { return $false }
    }
    return $true 
}
#endregion

#region Вспомогательная функция Handle-OperatorBlockProcessing (v1.0.1 - Без изменений)
function Handle-OperatorBlockProcessing {
    param(
        [Parameter(Mandatory=$true)] 
        $DetailsValue,    
        [Parameter(Mandatory=$true)]
        $OperatorBlock,   
        [Parameter(Mandatory=$true)]
        [string]$KeyName, 
        [Parameter(Mandatory=$true)]
        [string]$BasePath   
    )
    Write-Debug "Handle-OperatorBlockProcessing: Path=`"$BasePath.$KeyName`", DetailsValue=`"$($DetailsValue | Out-String -Width 100 | ForEach-Object {$_.Trim()})`""
    foreach ($operatorEntry in $OperatorBlock.GetEnumerator()) {
        $operator = $operatorEntry.Name
        $threshold = $operatorEntry.Value
        $comparisonResult = Compare-Values -Value $DetailsValue -Operator $operator -Threshold $threshold
        if ($comparisonResult.Passed -ne $true) {
            return @{ Passed = $comparisonResult.Passed; Reason = "Оператор '$operator' для ключа '$KeyName' не пройден. $($comparisonResult.Reason)" }
        }
    }
    return @{ Passed = $true; Reason = $null }
}
#endregion

#region Вспомогательная функция Handle-ArrayCriteriaProcessing (v1.0.3 - Улучшен FailReason и логика all/any)
function Handle-ArrayCriteriaProcessing {
    param(
        [Parameter(Mandatory=$true)]
        $DetailsArray,    
        [Parameter(Mandatory=$true)]
        [hashtable]$ArrayCriteria, 
        [Parameter(Mandatory=$true)]
        [string]$PathPrefix 
    )
    Write-Debug ("Handle-ArrayCriteriaProcessing: Начало обработки для пути `"{0}`". Условие: `"{1}`". Критерии массива: {2}" -f `
        $PathPrefix, $ArrayCriteria._condition_, ($ArrayCriteria | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue))

    $result = @{ Passed = $null; FailReason = $null } 
    $condition = $ArrayCriteria._condition_
    $whereClause = $ArrayCriteria._where_          
    $criteriaForItems = $ArrayCriteria._criteria_  
    $countCriteria = $ArrayCriteria._count_       

    if (-not $condition -or $condition.ToString().ToLower() -notin @('all', 'any', 'none', 'count')) {
        $result.Passed = $null
        $result.FailReason = "Отсутствует или неверный ключ '_condition_' в критерии для массива по пути '$PathPrefix'. Допустимые значения: 'all', 'any', 'none', 'count'."
        Write-Debug ("Handle-ArrayCriteriaProcessing: Ошибка валидации _condition_. Result: $($result | ConvertTo-Json -Compress)")
        return $result
    }
    $conditionLower = $condition.ToString().ToLower()

    if ($conditionLower -in @('all', 'any') -and ($null -eq $criteriaForItems -or ($criteriaForItems -is [hashtable] -and $criteriaForItems.Count -eq 0))) {
        $result.Passed = $null
        $result.FailReason = "Для _condition_ '$condition' в критерии массива по пути '$PathPrefix' требуется непустой ключ '_criteria_' (Hashtable)."
        Write-Debug ("Handle-ArrayCriteriaProcessing: Ошибка валидации _criteria_ для '$condition'. Result: $($result | ConvertTo-Json -Compress)")
        return $result
    }
    if ($conditionLower -eq 'count' -and ($null -eq $countCriteria -or -not (Test-IsOperatorBlock -CriteriaObject $countCriteria))) {
        $result.Passed = $null
        $result.FailReason = "Для _condition_ 'count' в критерии массива по пути '$PathPrefix' требуется ключ '_count_', содержащий корректный операторный блок."
        Write-Debug ("Handle-ArrayCriteriaProcessing: Ошибка валидации _count_. Result: $($result | ConvertTo-Json -Compress)")
        return $result
    }

    $filteredArray = $DetailsArray
    if ($null -ne $whereClause) {
        Write-Verbose "[$PathPrefix] Фильтрация массива (исходный размер: $($DetailsArray.Count)) с использованием _where_..."
        $tempFiltered = [System.Collections.Generic.List[object]]::new() 
        $itemIndex = -1
        foreach ($item in $DetailsArray) {
            $itemIndex++
            $itemPathForWhere = "$PathPrefix" + "[$itemIndex_where]" 
            $filterCheckResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $whereClause -Path $itemPathForWhere
            if ($filterCheckResult.Passed -eq $true) {
                $tempFiltered.Add($item)
            } elseif ($filterCheckResult.Passed -eq $null) {
                $result.Passed = $null
                $result.FailReason = "Ошибка при фильтрации (проверке _where_) элемента массива [$itemIndex] по пути '$itemPathForWhere': $($filterCheckResult.FailReason)"
                Write-Debug ("Handle-ArrayCriteriaProcessing: Ошибка фильтрации элемента. Result: $($result | ConvertTo-Json -Compress)")
                return $result
            }
        }
        $filteredArray = $tempFiltered.ToArray() 
        Write-Verbose "[$PathPrefix] Массив отфильтрован. Размер после _where_: $($filteredArray.Count)."
    }

    # 3. Применение основного условия
    $finalPassedStatus = $null 
    #Write-Host "DEBUG (HAProc): Перед switch, conditionLower = $conditionLower"

    switch ($conditionLower) {
        'all' {
            #Write-Host "DEBUG (HAProc): Внутри 'all'. filteredArray.Count = $($filteredArray.Count)"
            if ($filteredArray.Count -eq 0) {
                $finalPassedStatus = $true
            } else {
                 $allPassedFlag = $true 
                 $firstFailReason = $null 
                 $encounteredNullPassed = $false # Флаг, что встретили ошибку оценки
                 foreach ($item in $filteredArray) {
                     # ... $itemPathForCriteria ...
                     $itemProcessingResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteriaForItems -Path $itemPathForCriteria
                     # ... Write-Host ...
                     if ($itemProcessingResult.Passed -eq $null) { # Явная проверка на $null
                         $allPassedFlag = $null # Если ошибка, 'all' не может быть true или false
                         $encounteredNullPassed = $true
                         $firstFailReason = "Условие 'all': Ошибка оценки для элемента по пути '$itemPathForCriteria'. Причина: $($itemProcessingResult.FailReason)"
                         break 
                     } elseif ($itemProcessingResult.Passed -eq $false) { # Явная проверка на $false
                         $allPassedFlag = $false 
                         $firstFailReason = "Условие 'all' не выполнено для элемента по пути '$itemPathForCriteria'. Причина: $($itemProcessingResult.FailReason)"
                         break 
                     }
                     # Если $itemProcessingResult.Passed -eq $true, ничего не делаем, $allPassedFlag остается true
                 }
                 $finalPassedStatus = $allPassedFlag
                 if ($finalPassedStatus -ne $true) { $result.FailReason = $firstFailReason }
            }
            #Write-Host "DEBUG (HAProc 'all'): Итоговый finalPassedStatus = $finalPassedStatus, FailReason = $($result.FailReason)"
        } 
        'any' {
             #Write-Host "DEBUG (HAProc): Внутри 'any'. filteredArray.Count = $($filteredArray.Count)"
             $anyPassedFlag = $false 
             $firstErrorReasonForAny = $null # Причина первой ошибки
             $firstSuccessReasonForAny = $null # Для отладки
             $foundTrue = $false

             if ($filteredArray.Count -gt 0) {
                 foreach ($item in $filteredArray) {
                     # ... $itemPathForCriteria ...
                     $itemProcessingResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteriaForItems -Path $itemPathForCriteria
                     # ... Write-Host ...
                     if ($itemProcessingResult.Passed -eq $true) {
                         $anyPassedFlag = $true
                         $firstSuccessReasonForAny = "Условие 'any' выполнено для элемента: $itemPathForCriteria"
                         $foundTrue = $true
                         break 
                     } elseif ($itemProcessingResult.Passed -eq $null) {
                         # Если встретили ошибку, 'any' не может быть true. Он становится $null.
                         $anyPassedFlag = $null 
                         $firstErrorReasonForAny = "Условие 'any': Ошибка оценки для элемента по пути '$itemPathForCriteria'. Причина: $($itemProcessingResult.FailReason)"
                         break 
                     }
                     # Если Passed -eq $false, просто запоминаем причину на случай, если true так и не найдется
                     # Этот FailReason будет использован, только если в итоге $anyPassedFlag останется $false
                     if (-not $foundTrue) { # Обновляем причину, только если еще не нашли true
                        $result.FailReason = "Условие 'any': Элемент '$itemPathForCriteria' не соответствует. Причина: $($itemProcessingResult.FailReason)"
                     }
                 }
             }
             
             if ($anyPassedFlag -eq $true) {
                 $result.FailReason = $null # Успех, причина не нужна
             } elseif ($anyPassedFlag -eq $null) { # Была ошибка оценки
                 $result.FailReason = $firstErrorReasonForAny
             } else { # $anyPassedFlag -eq $false, ни один не подошел, и не было ошибок
                 if ([string]::IsNullOrEmpty($result.FailReason)) { # Если FailReason не был установлен от последнего элемента
                    $result.FailReason = "Условие 'any': ни один элемент в (отфильтрованном) массиве по пути '$PathPrefix' не соответствует указанным _criteria_."
                 }
             }
             $finalPassedStatus = $anyPassedFlag
             #Write-Host "DEBUG (HAProc 'any'): Итоговый finalPassedStatus = $finalPassedStatus, FailReason = $($result.FailReason)"
        } 
        'none' {
             $nonePassedFlag = $true 
             if ($filteredArray.Count -gt 0) {
                 if ($null -eq $criteriaForItems) { 
                      $nonePassedFlag = $false
                      $result.FailReason = "Условие 'none' (без _criteria_): в (отфильтрованном) массиве по пути '$PathPrefix' есть элементы ($($filteredArray.Count) шт.), а ожидалось 0."
                 } else {
                     $itemIndex = -1
                     foreach ($item in $filteredArray) {
                         $itemIndex++
                         $itemPathForCriteria = "$PathPrefix" + $(if ($null -ne $whereClause) { "[filtered:$itemIndex]" } else { "[$itemIndex]" })
                         $itemProcessingResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteriaForItems -Path $itemPathForCriteria
                         if ($itemProcessingResult.Passed -eq $true) { 
                             $nonePassedFlag = $false
                             $result.FailReason = "Условие 'none': элемент по пути '$itemPathForCriteria' СООТВЕТСТВУЕТ _criteria_, а не должен был."
                             break
                         } elseif ($itemProcessingResult.Passed -eq $null) {
                             $nonePassedFlag = $null 
                             $result.FailReason = "Ошибка проверки элемента по пути '$itemPathForCriteria' для условия 'none': $($itemProcessingResult.FailReason)"
                             break
                         }
                     }
                 }
             }
             $finalPassedStatus = $nonePassedFlag
             Write-Debug "[$PathPrefix] Условие 'none': результат = $finalPassedStatus. Причина (если fail/null): $($result.FailReason)"
        } 
        'count' {
            $actualItemCount = $filteredArray.Count
            Write-Verbose "[$PathPrefix] Проверка количества элементов ($actualItemCount) для условия '_count_..."
            $countCheckResult = Handle-OperatorBlockProcessing -DetailsValue $actualItemCount -OperatorBlock $countCriteria -KeyName "_count_" -BasePath $PathPrefix 
            $finalPassedStatus = $countCheckResult.Passed
            if ($finalPassedStatus -ne $true) {
                $result.FailReason = "Критерий количества ('count') элементов по пути '$PathPrefix' не пройден. $($countCheckResult.Reason)"
            }
            Write-Debug "[$PathPrefix] Условие 'count': результат = $finalPassedStatus. Причина (если fail/null): $($result.FailReason)"
        }
    } 

    $result.Passed = $finalPassedStatus
    Write-Debug ("Handle-ArrayCriteriaProcessing: Завершение обработки для пути `"{0}`". Итоговый Passed: {1}. FailReason: {2}" -f $PathPrefix, $result.Passed, $result.FailReason)
    return $result
}
#endregion

#region Основная функция Test-SuccessCriteria (v2.0.6 - Улучшено определение типа критерия для массивов и FailReason)
function Test-SuccessCriteria {
    [CmdletBinding()] 
    param(
        [Parameter(Mandatory=$true)] $DetailsObject,
        [Parameter(Mandatory=$true)] $CriteriaObject,
        [string]$Path = '$Details' 
    )
    Write-Debug "--- Test-SuccessCriteria [Вход] --- Path: `"$Path`", Details Type: `"$($DetailsObject.GetType().Name)`", Criteria Type: `"$($CriteriaObject.GetType().Name)`""
    if (-not ($CriteriaObject -is [hashtable] -or $CriteriaObject -is [System.Management.Automation.PSCustomObject])) {
        return @{ Passed = $null; FailReason = "Объект критерия по пути '$Path' не является Hashtable или PSCustomObject (получен тип: $($CriteriaObject.GetType().FullName))." }
    }

    foreach ($criterionEntry in $CriteriaObject.GetEnumerator()) {
        $criterionKey = $criterionEntry.Name
        $criterionValue = $criterionEntry.Value 
        $currentEvaluationPath = "$Path.$criterionKey" 
        Write-Debug "  [Цикл TSC] Path=`"$Path`", Key=`"$criterionKey`", CriteriaValue Type=`"$($criterionValue.GetType().FullName)`""

        if ($criterionKey -in @('_condition_', '_where_', '_criteria_', '_count_') -and -not ($Path -match '\[.+\]$')) {
            Write-Debug "    Пропуск служебного ключа массива '$criterionKey' на уровне объекта '$Path'."
            continue
        }

        $detailsValue = $null       
        $keyExistsInDetails = $false  
        $propertyAccessError = $null  

        if ($null -ne $DetailsObject) {
            if ($DetailsObject -is [hashtable]) {
                if ($DetailsObject.ContainsKey($criterionKey)) {
                    try { $detailsValue = $DetailsObject[$criterionKey]; $keyExistsInDetails = $true }
                    catch { $propertyAccessError = "Исключение при доступе к ключу '$criterionKey' в Hashtable '$Path': $($_.Exception.Message)" }
                }
            } elseif ($DetailsObject -is [System.Management.Automation.PSCustomObject]) {
                $propInfo = $DetailsObject.PSObject.Properties[$criterionKey]
                if ($null -ne $propInfo) {
                    try { $detailsValue = $propInfo.Value; $keyExistsInDetails = $true }
                    catch { $propertyAccessError = "Исключение при доступе к свойству '$criterionKey' в PSCustomObject '$Path': $($_.Exception.Message)" }
                }
            } elseif ($DetailsObject -is [array] -and $criterionKey -match '^\d+$' -and [int]::TryParse($criterionKey, [ref]$null)) {
                try {
                    $idx = [int]$criterionKey
                    if ($idx -ge 0 -and $idx -lt $DetailsObject.Count) {
                        $detailsValue = $DetailsObject[$idx]; $keyExistsInDetails = $true
                    }
                } catch { $propertyAccessError = "Исключение при доступе по индексу '$criterionKey' к массиву '$Path': $($_.Exception.Message)" }
            }
        }

        if ($null -ne $propertyAccessError) {
            Write-Debug "  [Ошибка доступа к свойству TSC] Path=`"$Path`", Key=`"$criterionKey`", Error=`"$propertyAccessError`""
            return @{ Passed = $null; FailReason = $propertyAccessError }
        }
        Write-Debug "    DetailsValue для '$criterionKey' (существует: $keyExistsInDetails): `"$($detailsValue | Out-String -Width 100 | ForEach-Object {$_.Trim()})`""

        $comparisonResult = $null 
        $isCriterionValueComplex = $criterionValue -is [hashtable] -or $criterionValue -is [System.Management.Automation.PSCustomObject]

        if ($isCriterionValueComplex) {
            $isCriterionForArray = $false
            $criterionValueContainsCondition = $false
            if ($criterionValue -is [hashtable]) {
                $criterionValueContainsCondition = $criterionValue.ContainsKey('_condition_')
            } elseif ($criterionValue -is [System.Management.Automation.PSCustomObject]) {
                $criterionValueContainsCondition = $criterionValue.PSObject.Properties.Name -contains '_condition_'
            }

            if ($criterionValueContainsCondition) {
                 $condVal = $null
                 if ($criterionValue -is [hashtable]) {$condVal = $criterionValue['_condition_']} else {$condVal = $criterionValue._condition_}
                 if ($condVal -and $condVal.ToString().ToLower() -in @('all', 'any', 'none', 'count')) {
                    $isCriterionForArray = $true
                 } else {
                    $comparisonResult = @{ Passed = $null; Reason = "Ключ '_condition_' в критерии для '$currentEvaluationPath' имеет недопустимое значение '$($condVal | Out-String -Width 50)'. Ожидались 'all', 'any', 'none', 'count'." }
                 }
            }
            
            if ($null -eq $comparisonResult) { 
                if ($isCriterionForArray) {
                    Write-Debug "    Тип критерия для '$criterionKey': Массив (_condition_ найден и валиден)"
                    $isDetailsValueACollection = $false
                    if ($null -ne $detailsValue) {
                        if (($detailsValue -is [array]) -or ($detailsValue -is [System.Collections.IList])) {
                            $isDetailsValueACollection = $true
                        }
                    }
                    if (-not $keyExistsInDetails) {
                         $comparisonResult = @{ Passed = $false; Reason = "Ключ '$criterionKey', для которого ожидался массив данных, отсутствует в '$Path'." }
                    } elseif (-not $isDetailsValueACollection) {
                        $actualType = if ($null -eq $detailsValue) { '$null' } else { $detailsValue.GetType().FullName }
                        $comparisonResult = @{ Passed = $false; Reason = "Для критерия массива по пути '$currentEvaluationPath' ожидался массив или коллекция (System.Array или System.Collections.IList) в данных, но получен '$actualType'." }
                    } else {
                        $detailsArrayForProcessing = @($detailsValue) 
                        $comparisonResult = Handle-ArrayCriteriaProcessing -DetailsArray $detailsArrayForProcessing -ArrayCriteria $criterionValue -PathPrefix $currentEvaluationPath
                    }
                } elseif (Test-IsOperatorBlock -CriteriaObject $criterionValue) {
                    Write-Debug "    Тип критерия для '$criterionKey': Операторный блок"
                    if (-not $keyExistsInDetails -and -not ($criterionValue.PSObject.Properties.Name -contains 'exists' -and $criterionValue.exists -eq $false)) { # Проверка для Hashtable/PSCustomObject
                         # Для Hashtable $criterionValue.Keys -contains 'exists'
                         $isExistsFalseCheck = $false
                         if ($criterionValue -is [hashtable]) { $isExistsFalseCheck = ($criterionValue.ContainsKey('exists') -and $criterionValue['exists'] -eq $false) }
                         else { $isExistsFalseCheck = ($criterionValue.PSObject.Properties.Name -contains 'exists' -and $criterionValue.exists -eq $false) }

                        if (-not $isExistsFalseCheck) {
                            $comparisonResult = @{ Passed = $false; Reason = "Ключ '$criterionKey' отсутствует в данных ('$Path') для применения операторного блока (и это не проверка на exists=false)." }
                        } else { # Это проверка exists=false и ключ отсутствует - это успех для exists=false, будет обработано в Compare-Values
                             $comparisonResult = Handle-OperatorBlockProcessing -DetailsValue $detailsValue -OperatorBlock $criterionValue -KeyName $criterionKey -BasePath $Path
                        }
                    } else {
                        $comparisonResult = Handle-OperatorBlockProcessing -DetailsValue $detailsValue -OperatorBlock $criterionValue -KeyName $criterionKey -BasePath $Path
                    }
                } else { # $criterionValue - это сложный объект, но не критерий для массива и не операторный блок
                    Write-Debug "    Тип критерия для '$criterionKey': Вложенный объект или Ошибка формата"
                    if (-not $keyExistsInDetails) {
                        $comparisonResult = @{ Passed = $false; Reason = "Ключ '$criterionKey' из вложенного критерия отсутствует в данных по пути '$Path'."}
                    } elseif ($null -eq $detailsValue -and ($criterionValue.PSObject.Properties.Count -gt 0)) { 
                         $comparisonResult = @{ Passed = $false; Reason = "Данные для '$currentEvaluationPath' равны `$null, но вложенный критерий ожидает объект."}
                    } elseif (($detailsValue -is [hashtable] -or $detailsValue -is [System.Management.Automation.PSCustomObject]) -or `
                              ($null -eq $detailsValue -and $criterionValue.PSObject.Properties.Count -eq 0) ) {
                        $comparisonResult = Test-SuccessCriteria -DetailsObject $detailsValue -CriteriaObject $criterionValue -Path $currentEvaluationPath
                    } else {
                        $comparisonResult = @{ Passed = $null; Reason = "Некорректный формат критерия для ключа '$criterionKey' по пути '$Path'. Ожидалось простое значение или операторный блок, но получен сложный объект: '$($criterionValue | ConvertTo-Json -Depth 1 -Compress -WarningAction SilentlyContinue)'." }
                    }
                }
            } 
        } else { # $isCriterionValueComplex -eq $false (критерий - простое значение)
            Write-Debug "    Тип критерия для '$criterionKey': Простое значение (сравнение '==')"
            if (-not $keyExistsInDetails) {
                $comparisonResult = @{ Passed = $false; Reason = "Ключ '$criterionKey' из критерия отсутствует в данных для простого сравнения по пути '$Path'."}
            } else {
                $comparisonResult = Compare-Values -Value $detailsValue -Operator '==' -Threshold $criterionValue
            }
        }

        if ($null -ne $comparisonResult -and $comparisonResult.Passed -ne $true) {
            $finalFailReasonDetail = $comparisonResult.Reason 
            if ([string]::IsNullOrEmpty($finalFailReasonDetail)) { # Если Reason пуст, даем запасной вариант
                if ($comparisonResult.Passed -eq $false) { $finalFailReasonDetail = "Условие не выполнено (без дополнительной причины от обработчика)." }
                elseif ($comparisonResult.Passed -eq $null) { $finalFailReasonDetail = "Ошибка оценки условия (без дополнительной причины от обработчика)." }
                else { $finalFailReasonDetail = "Неизвестная причина провала (обработчик не вернул Reason)." }
            }
            $finalFailReason = "Критерий для '$criterionKey' по пути '$Path' не пройден. Причина: $finalFailReasonDetail"
            Write-Debug "  [Провал TSC] Key=`"$criterionKey`", Path=`"$Path`", CriterionValue=`"$($criterionValue | Out-String -Width 100 | ForEach-Object {$_.Trim()})`", ComparisonPassed=`"$($comparisonResult.Passed)`", Reason=`"$finalFailReason`""
            return @{ Passed = $comparisonResult.Passed; FailReason = $finalFailReason }
        }
        Write-Debug "  [Успех TSC для ключа] Key=`"$criterionKey`", Path=`"$Path`""
    } 

    Write-Debug "--- Test-SuccessCriteria [Выход - Успех для всех ключей] --- Path: `"$Path`""
    return @{ Passed = $true; FailReason = $null } 
}
#endregion


#--------------------------------------------------------------------------
# Экспортируемые функции
#--------------------------------------------------------------------------

#region Функция New-CheckResultObject (Экспортируемая, v1.3.2 - Возвращает Hashtable)
function New-CheckResultObject {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)] [bool]$IsAvailable,
        [Parameter(Mandatory = $false)] [nullable[bool]]$CheckSuccess = $null, 
        [Parameter(Mandatory = $false)] $Details = $null,
        [Parameter(Mandatory = $false)] [string]$ErrorMessage = $null
    )
    $processedDetails = $null
    if ($null -ne $Details) {
        if ($Details -is [hashtable]) { 
            $processedDetails = $Details 
        } elseif ($Details -is [System.Management.Automation.PSCustomObject]) {
            $processedDetails = @{}
            $Details.PSObject.Properties | ForEach-Object { $processedDetails[$_.Name] = $_.Value }
        } else { 
            $processedDetails = @{ Value = $Details }
        }
    }

    $finalCheckSuccess = $CheckSuccess 
    if (-not $IsAvailable) {
        $finalCheckSuccess = $null
    }
    
    $finalErrorMessage = $ErrorMessage
    if ([string]::IsNullOrEmpty($finalErrorMessage)) {
        if (-not $IsAvailable) {
            $finalErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)."
        } elseif ($finalCheckSuccess -eq $false) {
            $finalErrorMessage = "Проверка не прошла по критериям (CheckSuccess=false)."
        } elseif ($finalCheckSuccess -eq $null -and $IsAvailable) {
             $finalErrorMessage = "Не удалось оценить критерии успеха (CheckSuccess=null), хотя проверка доступности прошла."
        }
    }
    
    $result = @{ # Возвращаем обычную Hashtable
        IsAvailable  = $IsAvailable
        CheckSuccess = $finalCheckSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $processedDetails 
        ErrorMessage = $finalErrorMessage
    }

    Write-Verbose ("New-CheckResultObject (v1.3.2 - Hashtable): Создан результат: IsAvailable=$($result.IsAvailable), CheckSuccess=$($result.CheckSuccess), ErrorMessage SET: $(!([string]::IsNullOrEmpty($result.ErrorMessage)))")
    return $result
}
#endregion

#region Функция Invoke-StatusMonitorCheck (Экспортируемая, v1.2.4 - Совместимость с PS 5.1)
function Invoke-StatusMonitorCheck {
    [CmdletBinding(SupportsShouldProcess = $false)]
    param(
        [Parameter(Mandatory = $true)]
        [PSObject]$Assignment 
    )

    if ($null -eq $Assignment -or `
        -not ($Assignment -is [System.Management.Automation.PSCustomObject]) -or `
        -not $Assignment.PSObject.Properties.Name.Contains('assignment_id') -or `
        -not $Assignment.PSObject.Properties.Name.Contains('method_name')) {
        Write-Warning "Invoke-StatusMonitorCheck: Передан некорректный или неполный объект задания (ожидался PSCustomObject с assignment_id и method_name)."
        return New-CheckResultObject -IsAvailable $false -ErrorMessage "Некорректный объект задания передан в Invoke-StatusMonitorCheck."
    }

    $assignmentId = $Assignment.assignment_id
    $methodName = $Assignment.method_name
    
    $targetIP = $null
    if ($Assignment.PSObject.Properties.Name -contains 'ip_address') {
        $targetIP = $Assignment.ip_address
    }

    $nodeName = "Задание ID $assignmentId" 
    if ($Assignment.PSObject.Properties.Name -contains 'node_name') {
        $tempNodeName = $Assignment.node_name
        if (-not [string]::IsNullOrWhiteSpace($tempNodeName)) {
            $nodeName = $tempNodeName
        }
    }
    
    $parameters = @{}
    $assignmentParameters = $null
    if ($Assignment.PSObject.Properties.Name -contains 'parameters') {
        $assignmentParameters = $Assignment.parameters
    }
    if ($null -ne $assignmentParameters) {
        if ($assignmentParameters -is [hashtable]) { $parameters = $assignmentParameters }
        elseif ($assignmentParameters -is [System.Management.Automation.PSCustomObject]) {
            try { $parameters = @{}; $assignmentParameters.PSObject.Properties | ForEach-Object { $parameters[$_.Name] = $_.Value } }
            catch { Write-Warning "[$($assignmentId) | $nodeName] Не удалось преобразовать 'parameters' (PSCustomObject) в Hashtable. Используется пустой объект." }
        } else { Write-Warning "[$($assignmentId) | $nodeName] Поле 'parameters' имеет неожиданный тип '$($assignmentParameters.GetType().FullName)'. Используется пустой объект."}
    }

    $successCriteria = $null 
    $assignmentSuccessCriteria = $null
    if ($Assignment.PSObject.Properties.Name -contains 'success_criteria') {
        $assignmentSuccessCriteria = $Assignment.success_criteria
    }
    if ($null -ne $assignmentSuccessCriteria) {
        if ($assignmentSuccessCriteria -is [hashtable]) { $successCriteria = $assignmentSuccessCriteria }
        elseif ($assignmentSuccessCriteria -is [System.Management.Automation.PSCustomObject]) {
            try { $successCriteria = @{}; $assignmentSuccessCriteria.PSObject.Properties | ForEach-Object { $successCriteria[$_.Name] = $_.Value } }
            catch { Write-Warning "[$($assignmentId) | $nodeName] Не удалось преобразовать 'success_criteria' (PSCustomObject) в Hashtable. Критерии не будут применены." }
        } else { Write-Warning "[$($assignmentId) | $nodeName] Поле 'success_criteria' имеет неожиданный тип '$($assignmentSuccessCriteria.GetType().FullName)'. Критерии не будут применены."}
    }
    
    $targetLogString = if ($targetIP) { $targetIP } else { '[Локально]' }
    Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Запуск метода '$methodName' для цели '$targetLogString'."

    $resultFromCheckScript = $null 
    try {
        $ModuleBase = $MyInvocation.MyCommand.Module.ModuleBase
        if (-not $ModuleBase) { 
            if ($PSScriptRoot) { $ModuleBase = $PSScriptRoot } 
            else { throw "Не удалось определить базовый путь модуля для поиска скриптов Checks/." }
        }
        $ChecksFolder = Join-Path -Path $ModuleBase -ChildPath "Checks"
        $CheckScriptFile = "Check-$($methodName).ps1"
        $CheckScriptPath = Join-Path -Path $ChecksFolder -ChildPath $CheckScriptFile
        Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Поиск скрипта проверки: '$CheckScriptPath'"

        if (-not (Test-Path $CheckScriptPath -PathType Leaf)) {
            $errMsg = "Скрипт проверки '$CheckScriptFile' не найден в '$ChecksFolder'."
            Write-Warning "[$($assignmentId) | $nodeName] $errMsg"
            return New-CheckResultObject -IsAvailable $false -ErrorMessage $errMsg -Details @{ CheckedScriptPath = $CheckScriptPath }
        }
        
        $paramsForCheckScript = @{
            TargetIP        = $targetIP         
            Parameters      = $parameters       
            SuccessCriteria = $successCriteria  
            NodeName        = $nodeName
        }
        Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Запуск скрипта '$CheckScriptFile'..."
        $resultFromCheckScript = & $checkScriptPath @paramsForCheckScript
        
        if ($null -eq $resultFromCheckScript -or -not ($resultFromCheckScript -is [hashtable]) -or -not $resultFromCheckScript.ContainsKey('IsAvailable')) {
            $errMsg = "Скрипт '$CheckScriptFile' вернул некорректный результат или `$null."
            $resultTypeInfo = if ($null -eq $resultFromCheckScript) { '$null' } else { $resultFromCheckScript.GetType().FullName }
            Write-Warning "[$($assignmentId) | $nodeName] $errMsg Тип результата: $resultTypeInfo. Ожидалась Hashtable от New-CheckResultObject."
            $resultFromCheckScript = New-CheckResultObject -IsAvailable $false -ErrorMessage $errMsg -Details @{ ScriptOutput = ($resultFromCheckScript | Out-String -Width 200) }
        } else {
            Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Скрипт '$CheckScriptFile' вернул корректный формат результата."
        }

    } catch {
        $critErrMsg = "Критическая ошибка при выполнении метода '$methodName' для '$nodeName': $($_.Exception.Message)"
        Write-Warning "[$($assignmentId) | $nodeName] $critErrMsg"
        $errorDetails = @{ ErrorRecord = $_.ToString(); StackTrace = $_.ScriptStackTrace }
        if ($CheckScriptPath) { $errorDetails.CheckedScriptPath = $CheckScriptPath }
        $resultFromCheckScript = New-CheckResultObject -IsAvailable $false -ErrorMessage $critErrMsg -Details $errorDetails
    }
    
    #Write-Host "DEBUG (Invoke-Check): --- Начало отладки Details в Invoke-StatusMonitorCheck (перед дополнением) ---" -ForegroundColor Cyan
    $detailsFromCheck = $null
    if ($resultFromCheckScript -is [hashtable] -and $resultFromCheckScript.ContainsKey('Details')) {
        $detailsFromCheck = $resultFromCheckScript['Details']
        #Write-Host "DEBUG (Invoke-Check): Получен Details из скрипта проверки. Тип: $($detailsFromCheck.GetType().FullName)" -ForegroundColor Cyan
        if ($detailsFromCheck -is [hashtable]) {
            #Write-Host "DEBUG (Invoke-Check): Ключи в Details от скрипта: $($detailsFromCheck.Keys -join ', ')" -ForegroundColor Cyan
            #Write-Host "DEBUG (Invoke-Check): Содержимое Details от скрипта (JSON): $($detailsFromCheck | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue)" -ForegroundColor DarkCyan
        } else {
            #Write-Host "DEBUG (Invoke-Check): Details от скрипта проверки НЕ является Hashtable (это НЕ ожидалось, т.к. New-CheckResultObject v1.3.2+ возвращает Hashtable)." -ForegroundColor Yellow
        }
    } else {
        #Write-Host "DEBUG (Invoke-Check): Ключ 'Details' в результате от скрипта проверки НЕ НАЙДЕН или результат не Hashtable (ЭТО ОШИБКА ЛОГИКИ в New-CheckResultObject или выше)." -ForegroundColor Red
    }

    if ($null -eq $detailsFromCheck -or -not ($detailsFromCheck -is [hashtable])) {
        #Write-Host "DEBUG (Invoke-Check): Инициализация resultFromCheckScript['Details'] новой пустой Hashtable (т.к. он был $null или не Hashtable)." -ForegroundColor Yellow
        if ($resultFromCheckScript -is [hashtable]) { # Убедимся, что сам $resultFromCheckScript - это Hashtable
            $resultFromCheckScript['Details'] = @{} 
        } else {
            # Это не должно происходить, если New-CheckResultObject всегда возвращает Hashtable
            Write-Warning "Invoke-StatusMonitorCheck: resultFromCheckScript не является Hashtable, не могу установить Details."
        }
    } 
    
    # Добавляем стандартные поля, только если 'Details' существует и является Hashtable
    if ($resultFromCheckScript -is [hashtable] -and $resultFromCheckScript.ContainsKey('Details') -and $resultFromCheckScript['Details'] -is [hashtable]) {
        $resultFromCheckScript['Details']['execution_target'] = $env:COMPUTERNAME
        $resultFromCheckScript['Details']['execution_mode'] = 'local_agent'
        $resultFromCheckScript['Details']['check_target_ip'] = $targetIP 
        #Write-Host "DEBUG (Invoke-Check): Содержимое resultFromCheckScript['Details'] ПОСЛЕ дополнения (JSON): $($resultFromCheckScript['Details'] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue)" -ForegroundColor DarkCyan
    } else {
        Write-Warning "Invoke-StatusMonitorCheck: Не удалось дополнить Details стандартной информацией, так как Details не является Hashtable."
    }
    #Write-Host "DEBUG (Invoke-Check): --- Конец отладки Details в Invoke-StatusMonitorCheck (после дополнения) ---" -ForegroundColor Cyan

    $isAvailableStr = $resultFromCheckScript['IsAvailable']
    $checkSuccessStrForLog = if ($null -eq $resultFromCheckScript['CheckSuccess']) { '[null]' } else { $resultFromCheckScript['CheckSuccess'] }
    Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Завершение. IsAvailable: $isAvailableStr, CheckSuccess: $checkSuccessStrForLog"
    
    return $resultFromCheckScript
}
#endregion

# --- Экспорт функций ---
Export-ModuleMember -Function Invoke-StatusMonitorCheck, New-CheckResultObject, Test-SuccessCriteria, Compare-Values
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Найти все SSL-сертификаты сервера в LocalMachine\My и проверить, что осталось > 14 дней
$certAssignment1 = @{
    assignment_id = 501; method_name = 'CERT_EXPIRY'; node_name = 'Local SSL Certs (>14d)'
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        eku_oid = @('1.3.6.1.5.5.7.3.1') # Server Authentication OID
        require_private_key = $true
        min_days_warning = 30 # Предупреждать за 30 дней
    }
    success_criteria = @{
        min_days_left = 14 # Должно оставаться > 14 дней
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment1) | ConvertTo-Json -Depth 4

# 2. Найти конкретный сертификат по отпечатку и проверить, что осталось > 60 дней
# ЗАМЕНИ 'YOUR_CERT_THUMBPRINT_HERE' на реальный отпечаток существующего сертификата
$thumbprintToTest = 'YOUR_CERT_THUMBPRINT_HERE'
$certAssignment2 = @{
    assignment_id = 502; method_name = 'CERT_EXPIRY'; node_name = "Cert by Thumbprint ($($thumbprintToTest.Substring(0,8))... >60d)"
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        thumbprint = $thumbprintToTest
    }
    success_criteria = @{
        min_days_left = 60
    }
}
if ($thumbprintToTest -ne 'YOUR_CERT_THUMBPRINT_HERE') {
    Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment2) | ConvertTo-Json -Depth 4
} else { Write-Warning "Тест 2 пропущен: Замените YOUR_CERT_THUMBPRINT_HERE на реальный отпечаток." }


# 3. Найти сертификаты, выданные определенным CA (например, внутренним)
$issuerPattern = "*MyInternalCA*" # Замените на часть имени вашего CA
$certAssignment3 = @{
    assignment_id = 503; method_name = 'CERT_EXPIRY'; node_name = "Certs from $issuerPattern (>3d)"
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        issuer_like = $issuerPattern
    }
    success_criteria = @{
        min_days_left = 3
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment3) | ConvertTo-Json -Depth 4

# 4. Тест с ошибкой: Неверное хранилище
$certAssignment4 = @{
    assignment_id = 504; method_name = 'CERT_EXPIRY'; node_name = 'Invalid Store'
    ip_address = $null
    parameters = @{ store_location = 'InvalidPlace'; store_name = 'My' }
    success_criteria = @{ min_days_left = 1 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment4) | ConvertTo-Json -Depth 4

# 5. Тест с ошибкой: Отсутствует обязательный критерий
$certAssignment5 = @{
    assignment_id = 505; method_name = 'CERT_EXPIRY'; node_name = 'Missing Criteria'
    ip_address = $null
    parameters = @{ thumbprint = $thumbprintToTest }
    success_criteria = @{ } # Пустой критерий
}
if ($thumbprintToTest -ne 'YOUR_CERT_THUMBPRINT_HERE') {
    Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment5) | ConvertTo-Json -Depth 4
} else { Write-Warning "Тест 5 пропущен: Замените YOUR_CERT_THUMBPRINT_HERE." }
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 ====
# Убедись, что модуль загружен
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Проверка всех локальных дисков без критериев
$diskAssignment1 = @{ assignment_id = 301; method_name = 'DISK_USAGE'; node_name = 'Local Disk Usage'; ip_address = $null; parameters = $null; success_criteria = $null }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment1) | ConvertTo-Json -Depth 5

# 2. Проверка только диска C: без критериев
$diskAssignment2 = @{ assignment_id = 302; method_name = 'DISK_USAGE'; node_name = 'Local Disk C Usage'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = $null }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment2) | ConvertTo-Json -Depth 5

# 3. Проверка диска C: с критерием > 5% свободно (скорее всего, пройдет)
$diskAssignment3 = @{ assignment_id = 303; method_name = 'DISK_USAGE'; node_name = 'Local Disk C OK'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 5 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment3) | ConvertTo-Json -Depth 5

# 4. Проверка диска C: с заведомо невыполнимым критерием (> 99% свободно)
$diskAssignment4 = @{ assignment_id = 304; method_name = 'DISK_USAGE'; node_name = 'Local Disk C Fail'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 99 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment4) | ConvertTo-Json -Depth 5

# 5. Проверка всех дисков с дефолтным критерием > 1%
$diskAssignment5 = @{ assignment_id = 305; method_name = 'DISK_USAGE'; node_name = 'Local All Disks Default OK'; ip_address = $null; parameters = $null; success_criteria = @{ _default_ = @{ min_percent_free = 1 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment5) | ConvertTo-Json -Depth 5

# 6. Проверка всех дисков, где для C: >99%, для остальных >1% (C: провалится)
$diskAssignment6 = @{ assignment_id = 306; method_name = 'DISK_USAGE'; node_name = 'Local All Disks C Fail Rest OK'; ip_address = $null; parameters = $null; success_criteria = @{ C = @{ min_percent_free = 99 }; _default_ = @{ min_percent_free = 1 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment6) | ConvertTo-Json -Depth 5

# 7. Тест с некорректным критерием
$diskAssignment7 = @{ assignment_id = 307; method_name = 'DISK_USAGE'; node_name = 'Invalid Criteria'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 'десять' } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment7) | ConvertTo-Json -Depth 5
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 ====
# Убедись, что модуль загружен
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Пинг существующего локального адреса (успех)
$pingAssignment1 = @{
    assignment_id = 201; method_name = 'PING'; node_name = 'Localhost Ping'
    ip_address = '127.0.0.1'; parameters = @{ count = 2 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment1) | ConvertTo-Json -Depth 3

# 2. Пинг несуществующего адреса (ошибка доступности)
$pingAssignment2 = @{
    assignment_id = 202; method_name = 'PING'; node_name = 'Non-existent Ping'
    ip_address = '192.168.254.254'; parameters = @{ timeout_ms = 500 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment2) | ConvertTo-Json -Depth 3

# 3. Пинг существующего адреса с критерием RTT (успех по критерию)
$pingAssignment3 = @{
    assignment_id = 203; method_name = 'PING'; node_name = 'Gateway Ping OK'
    ip_address = 'ya.ru'; parameters = @{ count = 1 } # Укажи IP своего шлюза
    success_criteria = @{ max_rtt_ms = 500 } # Критерий RTT < 500ms
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment3) | ConvertTo-Json -Depth 3

# 4. Пинг существующего адреса с критерием RTT (неуспех по критерию)
$pingAssignment4 = @{
    assignment_id = 204; method_name = 'PING'; node_name = 'Gateway Ping Fail RTT'
    ip_address = 'ya.ru'; parameters = @{ count = 1 }
    success_criteria = @{ max_rtt_ms = 1 } # Заведомо невыполнимый критерий
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment4) | ConvertTo-Json -Depth 3
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Все процессы, сортировка по памяти (убывание), топ 5
$procAssignment1 = @{
    assignment_id = 401; method_name = 'PROCESS_LIST'; node_name = 'Local Top 5 Mem Proc'
    ip_address = $null
    parameters = @{ sort_by = 'Memory'; sort_descending = $true; top_n = 5; include_username=$false; include_path=$false }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment1) | ConvertTo-Json -Depth 4

# 2. Процессы PowerShell с путем и пользователем
$procAssignment2 = @{
    assignment_id = 402; method_name = 'PROCESS_LIST'; node_name = 'Local PS Proc Details'
    ip_address = $null
    parameters = @{ process_names = @('*powershell*'); include_username = $true; include_path = $true }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment2) | ConvertTo-Json -Depth 4

# 3. Несуществующий процесс (должен вернуть IsAvailable=true, CheckSuccess=true, пустой список)
$procAssignment3 = @{
    assignment_id = 403; method_name = 'PROCESS_LIST'; node_name = 'Local NonExistent Proc'
    ip_address = $null
    parameters = @{ process_names = @('__NonExistentProcess__') }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment3) | ConvertTo-Json -Depth 4

# 4. Тест с некорректным полем сортировки
$procAssignment4 = @{
    assignment_id = 404; method_name = 'PROCESS_LIST'; node_name = 'Invalid Sort'
    ip_address = $null
    parameters = @{ sort_by = 'InvalidField' }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment4) | ConvertTo-Json -Depth 4

# 5. Удаленный тест (ожидаем ошибку WinRM -> IsAvailable=false)
$procAssignment5 = @{
    assignment_id = 405; method_name = 'PROCESS_LIST'; node_name = 'Remote Proc Fail'
    ip_address = 'REMOTE_HOST_NAME_NO_WINRM' # Замените на имя хоста без доступа по WinRM
    parameters = @{ top_n = 5 }
}
# Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment5) | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 ====
Remove-Module StatusMonitorAgentUtils -Force -ErrorAction SilentlyContinue
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -Verbose

$testAssignment = [PSCustomObject]@{
    assignment_id = 123; method_name = 'SERVICE_STATUS'; ip_address = $null
    node_name = 'Локальный Тест'; parameters = @{ service_name = 'Spooler' }
    success_criteria = @{ status = 'Running' }
}
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4

$testAssignment.parameters.service_name = 'NonExistentService'
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4

$testAssignment.parameters.service_name = 'Spooler'
$testAssignment.success_criteria = @{ status = 'Stopped' }
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# Замени на свои значения
$server = "YOUR_SERVER\YOUR_INSTANCE"
$db = "YourDatabaseName"
$tableName = "YourTableName" # Таблица с какими-нибудь данными

# 1. Получить первую строку
$sqlAssignment1 = @{
    assignment_id = 701; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL First Row Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT TOP 1 * FROM $tableName"
        return_format = 'first_row'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment1) | ConvertTo-Json -Depth 4

# 2. Получить все строки (ОСТОРОЖНО, если строк много!)
$sqlAssignment2 = @{
    assignment_id = 702; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL All Rows Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT Id, Name FROM $tableName WHERE Id < 10" # Пример с WHERE
        return_format = 'all_rows'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment2) | ConvertTo-Json -Depth 4

# 3. Получить количество строк
$sqlAssignment3 = @{
    assignment_id = 703; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Row Count Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT Id FROM $tableName" # Достаточно одного столбца для подсчета
        return_format = 'row_count'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment3) | ConvertTo-Json -Depth 4

# 4. Получить скалярное значение (имя первой записи)
$sqlAssignment4 = @{
    assignment_id = 704; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Scalar Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT TOP 1 Name FROM $tableName ORDER BY Id"
        return_format = 'scalar'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment4) | ConvertTo-Json -Depth 4

# 5. Выполнить Non-Query (например, создать временную таблицу) - ОСТОРОЖНО!
$sqlAssignment5 = @{
    assignment_id = 705; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Non-Query Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "IF OBJECT_ID('tempdb..#TestTempTable') IS NULL CREATE TABLE #TestTempTable (Id INT);" # Пример безопасного non-query
        return_format = 'non_query'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment5) | ConvertTo-Json -Depth 4

# 6. Ошибка - неверная БД
$sqlAssignment6 = $sqlAssignment1.PSObject.Copy()
$sqlAssignment6.assignment_id = 706
$sqlAssignment6.node_name = "SQL Error - Bad DB"
$sqlAssignment6.parameters.sql_database = "NonExistentDatabase"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment6) | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# Замени на свои значения
$server = "YOUR_SERVER\YOUR_INSTANCE" # Или просто "YOUR_SERVER"
$db = "YourDatabaseName"
$query = "SELECT TOP 1 CreationDate, Revise, id, UTCTime FROM YourTable WHERE id = 12345" # Пример запроса
$xmlCol = "Revise"
$keys = @("VersionStat", "ArrivalStationID", "TS_Version", "NonExistentKey")

$sqlAssignment = @{
    assignment_id = 601
    method_name   = 'SQL_XML_QUERY'
    node_name     = "SQL Query Test ($db)"
    ip_address    = $server # Передаем сервер как TargetIP
    parameters    = @{
        sql_database = $db
        sql_query = $query
        xml_column_name = $xmlCol
        keys_to_extract = $keys
        # sql_username = "your_sql_user" # Раскомментируй для SQL Auth
        # sql_password = "your_sql_password" # Раскомментируй для SQL Auth
    }
    success_criteria = $null # Пока не используем
}

Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment) | ConvertTo-Json -Depth 5

# --- Тест с ошибкой (неверное имя столбца) ---
$sqlAssignmentError = $sqlAssignment.PSObject.Copy()
$sqlAssignmentError.parameters.xml_column_name = 'InvalidColumnName'
$sqlAssignmentError.assignment_id = 602
$sqlAssignmentError.node_name = "SQL Error Test (Bad Column)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignmentError) | ConvertTo-Json -Depth 5

# --- Тест с ошибкой (неверный SQL) ---
$sqlAssignmentError2 = $sqlAssignment.PSObject.Copy()
$sqlAssignmentError2.parameters.sql_query = 'SELECT * FRO Arom InvalidTable'
$sqlAssignmentError2.assignment_id = 603
$sqlAssignmentError2.node_name = "SQL Error Test (Bad Query)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignmentError2) | ConvertTo-Json -Depth 5
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1
# --- Версия 2.1.0 --- Рефакторинг для читаемости, PS 5.1, улучшена обработка параметров и ошибок
<#
.SYNOPSIS
    Скрипт проверки сроков действия локально установленных сертификатов. (v2.1.0)
.DESCRIPTION
    Использует Get-ChildItem для поиска сертификатов в указанных или стандартных хранилищах.
    Позволяет фильтровать сертификаты по различным атрибутам (отпечаток, субъект, издатель, EKU, наличие приватного ключа).
    Рассчитывает количество дней до истечения и формирует статус для каждого сертификата.
    Формирует $Details с массивом 'certificates', содержащим подробную информацию.
    Вызывает Test-SuccessCriteria для определения CheckSuccess на основе собранных данных.
.PARAMETER TargetIP 
    [string] Опциональный. IP/Имя хоста (для логирования и контекста). Проверка сертификатов всегда выполняется локально.
.PARAMETER Parameters 
    [hashtable] Опциональный. Параметры для настройки поиска и фильтрации:
                - store_location ([string]): Расположение хранилища (например, 'LocalMachine', 'CurrentUser'). По умолчанию 'LocalMachine'.
                - store_name ([string]): Имя хранилища (например, 'My', 'WebHosting', 'Remote Desktop'). По умолчанию 'My'.
                                         Если store_location и store_name не указаны, используются стандартные хранилища.
                - subject_like ([string]): Фильтр по имени субъекта (CN). Wildcard '*' поддерживается.
                - issuer_like ([string]): Фильтр по имени издателя. Wildcard '*' поддерживается.
                - thumbprint ([string]): Точный отпечаток сертификата для поиска (приоритетный фильтр).
                - require_private_key ([bool]): Искать только сертификаты с приватным ключом. По умолчанию $false.
                - eku_oid ([string[]]): Массив OID'ов расширенного использования ключа.
                - min_days_warning ([int]): Дней до истечения для статуса 'ExpiringSoon'. По умолчанию 30.
.PARAMETER SuccessCriteria 
    [hashtable] Опциональный. Критерии успеха, применяемые к объекту $details.
                Часто используется для проверки массива 'certificates':
                @{ certificates = @{ _condition_='all'; _criteria_=@{days_left=@{'>'=14}; status=@{'!='='Expired'}} } }
.PARAMETER NodeName 
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS Hashtable - Стандартизированный результат.
.NOTES
    Версия: 2.1.0
    Зависит от New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.
#>
param(
    [Parameter(Mandatory = $false)] # Сделан не обязательным
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node (CERT_EXPIRY)"
)

# --- Инициализация ---
$isAvailable = $false 
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null
$details = @{
    certificates = [System.Collections.Generic.List[object]]::new()
    stores_checked = [System.Collections.Generic.List[string]]::new()
    filter_applied = $false
    parameters_used = @{ # Для отладки и информации в Details
        store_location = $null # Будут установлены из $Parameters или значения по умолчанию
        store_name = $null
        subject_like = $null
        issuer_like = $null
        thumbprint = $null
        require_private_key = $false # Значение по умолчанию
        eku_oid = $null
        min_days_warning = 30  # Значение по умолчанию
    }
    store_access_errors = [System.Collections.Generic.List[string]]::new()
}

$logTargetDisplay = if (-not [string]::IsNullOrWhiteSpace($TargetIP)) { $TargetIP } else { $env:COMPUTERNAME + " (локально)" }
Write-Verbose "[$NodeName] Check-CERT_EXPIRY (v2.1.0): Начало проверки сертификатов. Цель (контекст): $logTargetDisplay"

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Обработка входных параметров ($Parameters) ---
    # Сохраняем используемые параметры в $details для информации
    if ($Parameters.ContainsKey('store_location')) { $details.parameters_used.store_location = $Parameters.store_location }
    if ($Parameters.ContainsKey('store_name')) { $details.parameters_used.store_name = $Parameters.store_name }
    if ($Parameters.ContainsKey('subject_like')) { $details.parameters_used.subject_like = $Parameters.subject_like }
    if ($Parameters.ContainsKey('issuer_like')) { $details.parameters_used.issuer_like = $Parameters.issuer_like }
    if ($Parameters.ContainsKey('thumbprint')) { $details.parameters_used.thumbprint = $Parameters.thumbprint }

    if ($Parameters.ContainsKey('require_private_key')) {
        try { $details.parameters_used.require_private_key = [bool]$Parameters.require_private_key }
        catch { Write-Warning "[$NodeName] Некорректное значение для 'require_private_key': '$($Parameters.require_private_key)'. Используется $($details.parameters_used.require_private_key)." }
    }
    if ($Parameters.ContainsKey('eku_oid') -and $Parameters.eku_oid -is [array]) {
        $details.parameters_used.eku_oid = @($Parameters.eku_oid | Where-Object {-not [string]::IsNullOrWhiteSpace($_)})
        if ($details.parameters_used.eku_oid.Count -eq 0) { $details.parameters_used.eku_oid = $null } # Если массив пуст после фильтрации
    }
    if ($Parameters.ContainsKey('min_days_warning')) {
        $parsedWarnDays = 0
        if ([int]::TryParse($Parameters.min_days_warning.ToString(), [ref]$parsedWarnDays) -and $parsedWarnDays -ge 0) {
            $details.parameters_used.min_days_warning = $parsedWarnDays
        } else {
            Write-Warning "[$NodeName] Некорректное значение min_days_warning: '$($Parameters.min_days_warning)'. Используется $($details.parameters_used.min_days_warning)."
        }
    }
    # Извлекаем значения для использования в скрипте
    $pStoreLoc = $details.parameters_used.store_location
    $pStoreName = $details.parameters_used.store_name
    $pSubjectLike = $details.parameters_used.subject_like
    $pIssuerLike = $details.parameters_used.issuer_like
    $pThumbprint = $details.parameters_used.thumbprint
    $pRequirePK = $details.parameters_used.require_private_key
    $pEkuOids = $details.parameters_used.eku_oid
    $pMinDaysWarn = $details.parameters_used.min_days_warning
    
    # --- 2. Определение хранилищ для поиска и сам поиск ---
    $storesToSearchConfig = [System.Collections.Generic.List[object]]::new()
    $useSpecificStoreParam = (-not [string]::IsNullOrWhiteSpace($pStoreLoc)) -and (-not [string]::IsNullOrWhiteSpace($pStoreName))

    if ($useSpecificStoreParam) {
        $storesToSearchConfig.Add(@{ Path = "Cert:\$pStoreLoc\$pStoreName"; Location = $pStoreLoc; Name = $pStoreName })
        Write-Verbose "[$NodeName] Поиск будет произведен в указанном хранилище: Cert:\$pStoreLoc\$pStoreName"
    } else {
        Write-Verbose "[$NodeName] Поиск будет произведен в стандартных хранилищах."
        $storesToSearchConfig.Add(@{ Path = "Cert:\LocalMachine\My"; Location = "LocalMachine"; Name = "My" })
        $storesToSearchConfig.Add(@{ Path = "Cert:\LocalMachine\WebHosting"; Location = "LocalMachine"; Name = "WebHosting" })
        $storesToSearchConfig.Add(@{ Path = "Cert:\CurrentUser\My"; Location = "CurrentUser"; Name = "My" })
        # $storesToSearchConfig.Add(@{ Path = "Cert:\LocalMachine\Remote Desktop"; Location = "LocalMachine"; Name = "Remote Desktop" })
    }

    $allFoundCertificatesList = [System.Collections.Generic.List[PSObject]]::new() # Типизированный список

    foreach ($storeInfo in $storesToSearchConfig) {
        $currentStorePath = $storeInfo.Path
        $details.stores_checked.Add($currentStorePath)
        Write-Verbose "[$NodeName] Проверка хранилища: $currentStorePath"
        try {
            if (-not (Test-Path -Path $currentStorePath -PathType Container -ErrorAction SilentlyContinue)) {
                $storeErrorMsg = "Хранилище '$currentStorePath' не найдено или недоступно."
                Write-Warning "[$NodeName] $storeErrorMsg"
                $details.store_access_errors.Add($storeErrorMsg)
                continue # Переходим к следующему хранилищу
            }
            
            $certsInCurrentStore = Get-ChildItem -Path $currentStorePath -ErrorAction SilentlyContinue
            if ($Error.Count -gt 0) { # Ошибки при Get-ChildItem
                ($Error | ForEach-Object { 
                    $errMsg = "Ошибка доступа к '$currentStorePath': $($_.Exception.Message.Trim())"
                    Write-Warning "[$NodeName] $errMsg"; $details.store_access_errors.Add($errMsg)
                })
                $Error.Clear()
            }
            if ($null -ne $certsInCurrentStore) {
                # Get-ChildItem может вернуть один объект или массив, приводим к массиву
                $certsInCurrentStoreArray = @($certsInCurrentStore)
                $allFoundCertificatesList.AddRange($certsInCurrentStoreArray)
                Write-Verbose "[$NodeName] В '$currentStorePath' найдено сертификатов: $($certsInCurrentStoreArray.Count)"
            }
        } catch { # Критическая ошибка, не связанная с Get-ChildItem (например, Test-Path)
            $criticalErrorMsg = "Непредвиденная ошибка при работе с хранилищем '$currentStorePath': $($_.Exception.Message.Trim())"
            Write-Warning "[$NodeName] $criticalErrorMsg"
            $details.store_access_errors.Add($criticalErrorMsg)
        }
    }

    if ($details.stores_checked.Count -eq 0) { # Не было задано ни одного хранилища, или все указанные не существуют
        $isAvailable = $false
        $errorMessage = "Не указаны или не найдены хранилища для проверки сертификатов."
        throw $errorMessage 
    }
    # Если хотя бы одно хранилище было проверено (даже с ошибкой доступа, но путь был валиден), считаем проверку доступной
    $isAvailable = $true 
    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: IsAvailable=$isAvailable. Всего найдено сертификатов до фильтрации: $($allFoundCertificatesList.Count)."

    # --- 3. Фильтрация сертификатов ---
    $filteredCerts = $allFoundCertificatesList # Начинаем с полного списка
    
    if (-not [string]::IsNullOrWhiteSpace($pThumbprint)) {
        $details.filter_applied = $true
        $normalizedThumbprint = $pThumbprint.Trim().ToUpper() # Отпечатки обычно в верхнем регистре и без пробелов
        $filteredCerts = $filteredCerts | Where-Object { $_.Thumbprint -eq $normalizedThumbprint }
        Write-Verbose "[$NodeName] После фильтра по отпечатку ('$normalizedThumbprint'): $($filteredCerts.Count) серт."
    } else {
        # Фильтры по Subject и Issuer применяются, только если Thumbprint не указан
        if (-not [string]::IsNullOrWhiteSpace($pSubjectLike)) {
            $details.filter_applied = $true
            $filteredCerts = $filteredCerts | Where-Object { $_.Subject -like $pSubjectLike }
            Write-Verbose "[$NodeName] После фильтра по Subject ('$pSubjectLike'): $($filteredCerts.Count) серт."
        }
        if (-not [string]::IsNullOrWhiteSpace($pIssuerLike)) {
            $details.filter_applied = $true
            $filteredCerts = $filteredCerts | Where-Object { $_.Issuer -like $pIssuerLike }
            Write-Verbose "[$NodeName] После фильтра по Issuer ('$pIssuerLike'): $($filteredCerts.Count) серт."
        }
    }

    if ($pRequirePK) {
        $details.filter_applied = $true
        $filteredCerts = $filteredCerts | Where-Object { $_.HasPrivateKey }
        Write-Verbose "[$NodeName] После фильтра 'require_private_key=$true': $($filteredCerts.Count) серт."
    }

    if ($pEkuOids -is [array] -and $pEkuOids.Count -gt 0) {
        $details.filter_applied = $true
        $filteredCerts = $filteredCerts | Where-Object {
            $certToTestEku = $_
            $ekuExtension = $certToTestEku.Extensions | Where-Object { $_.Oid -and $_.Oid.FriendlyName -eq 'Enhanced Key Usage' }
            if ($ekuExtension -and $ekuExtension.EnhancedKeyUsages) {
                # Проверяем, содержит ли сертификат ХОТЯ БЫ ОДИН из указанных EKU OID
                foreach ($requiredOid in $pEkuOids) {
                    if ($ekuExtension.EnhancedKeyUsages.Oid -contains $requiredOid) {
                        return $true # Нашли совпадение
                    }
                }
            }
            return $false # Совпадений не найдено или нет EKU
        }
        Write-Verbose "[$NodeName] После фильтра по EKU OIDs ('$($pEkuOids -join ',')'): $($filteredCerts.Count) серт."
    }

    if (-not $details.filter_applied -and $allFoundCertificatesList.Count -gt 0) {
        Write-Verbose "[$NodeName] Фильтры не применялись. Обрабатываются все $($allFoundCertificatesList.Count) найденных сертификатов."
    } elseif ($details.filter_applied -and $filteredCerts.Count -eq 0 -and $allFoundCertificatesList.Count -gt 0) {
         Write-Verbose "[$NodeName] После применения фильтров не осталось сертификатов (было: $($allFoundCertificatesList.Count))."
    }

    # --- 4. Формирование $details.certificates из отфильтрованного списка ---
    $currentTimeUtc = (Get-Date).ToUniversalTime() # Получаем один раз для консистентности
    if ($filteredCerts.Count -eq 0) {
        $message = "Сертификаты"
        if ($details.filter_applied) { $message += ", соответствующие заданным фильтрам," }
        $message += " не найдены"
        if ($allFoundCertificatesList.Count -gt 0 -and $details.filter_applied) {
            $message += " (всего до фильтрации было $($allFoundCertificatesList.Count) в проверенных хранилищах)."
        } elseif ($allFoundCertificatesList.Count -eq 0) {
            $message += " (в проверенных хранилищах сертификатов не обнаружено)."
        }
        $details.message = $message
    } else {
        foreach ($certToProcess in $filteredCerts) {
            $daysLeftValue = -9999 # Значение по умолчанию при ошибке
            try { 
                # NotAfter это DateTime, Start тоже DateTime
                $timeSpanToExpire = New-TimeSpan -Start $currentTimeUtc -End $certToProcess.NotAfter.ToUniversalTime()
                $daysLeftValue = [math]::Floor($timeSpanToExpire.TotalDays) 
            } catch { 
                Write-Warning "[$NodeName] Не удалось рассчитать days_left для сертификата $($certToProcess.Thumbprint): $($_.Exception.Message)"
            }

            $certCurrentStatus = "OK"
            $certCurrentStatusDetails = ""

            if ($currentTimeUtc -gt $certToProcess.NotAfter.ToUniversalTime()) {
                $certCurrentStatus = "Expired"
                $certCurrentStatusDetails = "Сертификат истек $($certToProcess.NotAfter.ToLocalTime().ToString('yyyy-MM-dd HH:mm:ss')) ($daysLeftValue дней назад)."
            } elseif ($daysLeftValue -le $pMinDaysWarn) { 
                $certCurrentStatus = "ExpiringSoon"
                $certCurrentStatusDetails = "Сертификат истекает через $daysLeftValue дней (порог предупреждения: $pMinDaysWarn дней или менее)."
            }
            
            $certInfoObject = @{ 
                thumbprint        = $certToProcess.Thumbprint
                subject           = $certToProcess.Subject
                issuer            = $certToProcess.Issuer
                not_before_utc    = $certToProcess.NotBefore.ToUniversalTime().ToString("o")
                not_after_utc     = $certToProcess.NotAfter.ToUniversalTime().ToString("o")
                days_left         = $daysLeftValue
                has_private_key   = $certToProcess.HasPrivateKey
                status            = $certCurrentStatus
                status_details    = $certCurrentStatusDetails
                store_path        = $certToProcess.PSParentPath 
            }
            $details.certificates.Add([PSCustomObject]$certInfoObject) 
        }
        $details.certificates = $details.certificates | Sort-Object days_left # Сортируем по оставшимся дням
    }
    # Копируем использованные параметры в детали, чтобы они были видны
    $details.parameters_used = $details.parameters_used 

    # --- 5. Проверка критериев успеха ---
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Вызов Test-SuccessCriteria..."
            $criteriaProcessingResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria -Path '$details'
            
            $checkSuccess = $criteriaProcessingResult.Passed
            $failReasonFromCriteria = $criteriaProcessingResult.FailReason

            if ($checkSuccess -ne $true) {
                if (-not [string]::IsNullOrEmpty($failReasonFromCriteria)) {
                    $errorMessage = $failReasonFromCriteria
                } else {
                    $errorMessage = "Критерии успеха для сертификатов не пройдены (CheckSuccess: $($checkSuccess | ForEach-Object {if ($_ -eq $null) {'[null]'} else {$_}}))."
                }
                Write-Verbose "[$NodeName] Check-CERT_EXPIRY: SuccessCriteria НЕ пройдены или ошибка оценки. ErrorMessage: $errorMessage"
            } else {
                $errorMessage = $null 
                Write-Verbose "[$NodeName] Check-CERT_EXPIRY: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы. По умолчанию считаем успешным, если isAvailable.
            # Однако, если были ошибки доступа к хранилищам, это может быть неполный успех.
            $checkSuccess = $true 
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: SuccessCriteria не заданы, CheckSuccess установлен в true (т.к. IsAvailable=true)."
        }
        
        # Добавляем информацию об ошибках доступа к хранилищам в ErrorMessage, если проверка в остальном успешна
        if ($details.store_access_errors.Count -gt 0 -and $checkSuccess -eq $true) {
            $accessErrorString = "При проверке сертификатов были ошибки доступа к некоторым хранилищам: $($details.store_access_errors -join '; ')"
            $errorMessage = if ([string]::IsNullOrEmpty($errorMessage)) { $accessErrorString } else { "$errorMessage; $accessErrorString" }
            # Можно решить, должен ли $checkSuccess стать $null или $false в этом случае.
            # Например, если полный доступ ко всем хранилищам критичен:
            # $checkSuccess = $false 
            Write-Warning "[$NodeName] $accessErrorString. CheckSuccess остается $checkSuccess."
        }

    } else { 
        $checkSuccess = $null 
        if ([string]::IsNullOrEmpty($errorMessage)) { 
            $errorMessage = "Ошибка проверки сертификатов (IsAvailable=false), критерии не проверялись."
        }
    }

    # --- 6. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< ОСНОВНОЙ CATCH для критических ошибок скрипта >>>
    $isAvailable = $false 
    $checkSuccess = $null   
    
    $critErrorMessageFromCatch = "Критическая ошибка в Check-CERT_EXPIRY: $($_.Exception.Message)"
    Write-Error "[$NodeName] Check-CERT_EXPIRY: $critErrorMessageFromCatch ScriptStackTrace: $($_.ScriptStackTrace)"
    
    # Заполняем детали информацией об ошибке
    if ($null -eq $details) { $details = @{ certificates = [System.Collections.Generic.List[object]]::new() } } # Гарантируем, что $details - хэш
    $details.error = $critErrorMessageFromCatch
    $details.ErrorRecord = $_.ToString()
    if ($Parameters -and $Parameters.Count -gt 0) { $details.parameters_used_on_error = $Parameters }
    
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $critErrorMessageFromCatch
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Отладка перед возвратом ---
Write-Host "DEBUG (Check-CERT_EXPIRY): --- Начало отладки finalResult.Details ---" -ForegroundColor Green
# ... (ваш отладочный блок) ...
if ($finalResult -and $finalResult.Details) {
    Write-Host "DEBUG (Check-CERT_EXPIRY): Тип finalResult.Details: $($finalResult.Details.GetType().FullName)" -ForegroundColor Green
    if ($finalResult.Details -is [hashtable]) {
        Write-Host "DEBUG (Check-CERT_EXPIRY): Ключи в finalResult.Details: $($finalResult.Details.Keys -join ', ')" -ForegroundColor Green
        if ($finalResult.Details.ContainsKey('certificates')) {
             Write-Host "DEBUG (Check-CERT_EXPIRY): Количество сертификатов в Details: $($finalResult.Details.certificates.Count)" -ForegroundColor Green
        }
        if ($finalResult.Details.ContainsKey('parameters_used')) {
             Write-Host "DEBUG (Check-CERT_EXPIRY): Параметры использованные: $($finalResult.Details.parameters_used | ConvertTo-Json -Compress -Depth 2)" -ForegroundColor Green
        }
    }
} elseif ($finalResult) { Write-Host "DEBUG (Check-CERT_EXPIRY): finalResult.Details является $null или отсутствует." -ForegroundColor Yellow }
else { Write-Host "DEBUG (Check-CERT_EXPIRY): finalResult сам по себе $null." -ForegroundColor Red }
Write-Host "DEBUG (Check-CERT_EXPIRY): --- Конец отладки finalResult.Details ---" -ForegroundColor Green

# --- Возврат результата ---
$isAvailableStrForLog = if ($finalResult) { $finalResult.IsAvailable } else { '[finalResult is null]' }
$checkSuccessStrForLog = if ($finalResult) { if ($null -eq $finalResult.CheckSuccess) {'[null]'} else {$finalResult.CheckSuccess} } else { '[finalResult is null]' }
Write-Verbose "[$NodeName] Check-CERT_EXPIRY (v2.1.0): Завершение. IsAvailable=$isAvailableStrForLog, CheckSuccess=$checkSuccessStrForLog"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1
# --- Версия 2.0.2 --- Интеграция Test-SuccessCriteria
<#
.SYNOPSIS
    Скрипт проверки использования дискового пространства. (v2.0.2)
.DESCRIPTION
    Использует Get-Volume для получения информации о дисках.
    Формирует $Details с массивом 'disks'.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
    ...
#>
param(
    [Parameter(Mandatory = $false)] # <--- TargetIP обязательный
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ disks = [System.Collections.Generic.List[object]]::new() }

Write-Verbose "[$NodeName] Check-DISK_USAGE (v2.0.2): Начало проверки дисков на $TargetIP (локально)"

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Выполнение Get-Volume ---
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Вызов Get-Volume..."
    $volumes = Get-Volume -ErrorAction Stop # <--- Get-Volume выполняется локально
    $isAvailable = $true 
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Get-Volume выполнен. Найдено томов: $($volumes.Count)"

    # --- 2. Фильтрация томов ---
    $targetDriveLetters = @(); 
    if ($Parameters.ContainsKey('drives') -and $Parameters.drives -is [array]) { 
        $targetDriveLetters = $Parameters.drives | ForEach-Object { $_.ToString().Trim().ToUpper() } # Добавил ToString()
    }
    $filteredVolumes = $volumes | Where-Object { 
        $_.DriveType -eq 'Fixed' -and 
        $_.DriveLetter -ne $null -and 
        (($targetDriveLetters.Count -eq 0) -or ($targetDriveLetters -contains $_.DriveLetter.ToString().ToUpper())) 
    }
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Найдено Fixed дисков после фильтрации: $($filteredVolumes.Count)"

    # --- 3. Обработка томов и формирование $details.disks ---
    if ($filteredVolumes.Count -eq 0) {
        if ($targetDriveLetters.Count -gt 0) {
            $details.message = "Нет локальных Fixed дисков (фильтр: $($targetDriveLetters -join ','))."
        } else {
            $details.message = "Нет локальных Fixed дисков."
        }
    } else {
        foreach ($vol in $filteredVolumes) {
            $driveLetter = $vol.DriveLetter.ToString().ToUpper() # Уже ToUpper()
            $diskInfo = [ordered]@{ # Используется ordered
                drive_letter=$driveLetter; 
                label=$vol.FileSystemLabel; 
                filesystem=$vol.FileSystem; 
                size_bytes=$vol.Size; 
                free_bytes=$vol.SizeRemaining; 
                used_bytes=($vol.Size - $vol.SizeRemaining); 
                size_gb=$null; free_gb=$null; used_gb=$null; 
                percent_free=$null; percent_used=$null 
            }
            if ($diskInfo.size_bytes -gt 0) {
                $diskInfo.size_gb = [math]::Round($diskInfo.size_bytes / 1GB, 2); 
                $diskInfo.free_gb = [math]::Round($diskInfo.free_bytes / 1GB, 2); 
                $diskInfo.used_gb = [math]::Round($diskInfo.used_bytes / 1GB, 2)
                $diskInfo.percent_free = [math]::Round(($diskInfo.free_bytes / $diskInfo.size_bytes) * 100, 1); 
                $diskInfo.percent_used = [math]::Round(($diskInfo.used_bytes / $diskInfo.size_bytes) * 100, 1)
            } else { 
                $diskInfo.percent_free = 0.0; # Явно double
                $diskInfo.percent_used = 0.0  # Явно double, если размер 0, то занято 0%
                # Если размер 0 и свободно 0, то % использования тоже 0 (или 100, если считать, что нет свободного места)
                # Для диска 0 байт, percent_used скорее 0, чем 100.
                # Если free_bytes = 0 и size_bytes > 0, то percent_used = 100
                if ($diskInfo.size_bytes -eq 0) { $diskInfo.percent_used = 0.0 } 
                elseif ($diskInfo.free_bytes -eq 0) { $diskInfo.percent_used = 100.0} # Занято 100%
            }
            $details.disks.Add($diskInfo)
        }
    }

    # --- 4. Проверка критериев успеха ---
    $failReason = $null
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) { # Для Hashtable лучше .Keys.Count
            Write-Verbose "[$NodeName] Check-DISK_USAGE: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria -Path '$details' # Добавлен Path
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            if ($checkSuccess -ne $true) { 
                # Используем if/else вместо Get-OrElse
                if (-not [string]::IsNullOrEmpty($failReason)) { $errorMessage = $failReason }
                else { $errorMessage = "Критерии успеха для дисков не пройдены (CheckSuccess: $($checkSuccess | ForEach-Object {if ($_ -eq $null) {'[null]'} else {$_}}))." }
                Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены/ошибка: $errorMessage" 
            }
            else { $errorMessage = $null; Write-Verbose "[$NodeName] ... SuccessCriteria пройдены." }
        } else {
            $checkSuccess = $true; $errorMessage = $null
            Write-Verbose "[$NodeName] Check-DISK_USAGE: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка выполнения Get-Volume (IsAvailable=false)." }
    }

    # --- 5. Формирование результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< ОСНОВНОЙ CATCH >>>
    $isAvailable = $false; $checkSuccess = $null
    $critErrorMessage = "Критическая ошибка Check-DISK_USAGE: $($_.Exception.Message)"
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }
    # $finalResult создается через New-CheckResultObject для единообразия
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $detailsError ` # Передаем детали ошибки
                                         -ErrorMessage $critErrorMessage
    Write-Error "[$NodeName] Check-DISK_USAGE: Критическая ошибка: $critErrorMessage"
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Отладка перед возвратом ---
# (оставляем ваш отладочный блок без изменений, если он вам полезен)
Write-Host "DEBUG (Check-DISK_USAGE): --- Начало отладки finalResult.Details ---" -ForegroundColor Green
# ...

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStrForLog = if ($finalResult) { if ($null -eq $finalResult.CheckSuccess) {'[null]'} else {$finalResult.CheckSuccess} } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-DISK_USAGE (v2.1.0): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStrForLog"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1
# --- Версия 2.3.2 --- Удален Get-OrElse, добавлен Path в Test-SuccessCriteria, улучшено логирование
<#
.SYNOPSIS
    Скрипт проверки доступности узла с помощью .NET Ping. (v2.3.2)
.DESCRIPTION
    Использует System.Net.NetworkInformation.Ping.
    Формирует $Details с результатами (RTT, потери и т.д.).
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.PARAMETER TargetIP
    [string] Обязательный. IP-адрес или имя хоста.
.PARAMETER Parameters
    [hashtable] Опциональный. Параметры: timeout_ms, count, buffer_size, ttl.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для полей в $Details
                (напр., @{ rtt_ms = @{'<='=100}; packet_loss_percent = @{'=='=0} }).
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
.NOTES
    Версия: 2.3.2
    Зависит от New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false          # Флаг доступности по результатам PING
$checkSuccess = $null         # Результат проверки критериев (изначально null)
$errorMessage = $null         # Сообщение об ошибке
$finalResultFromPing = $null  # Итоговый объект, который вернет эта функция
# $details будет заполнен результатами пинга
$details = @{
    target_ip = $TargetIP # IP или имя, которое пингуем
    packets_sent = 0
    packets_received = 0
    packet_loss_percent = 100 # По умолчанию 100% потерь
    rtt_ms = $null            # Среднее время ответа
    ip_address = $null        # Фактический IP-адрес, ответивший на пинг
    status_string = '[Error]' # Общий статус пинга
}

Write-Host "[$NodeName] Check-PING (v2.3.2 - .NET): Инициализация для $TargetIP" -ForegroundColor Magenta # Используем Write-Host для ручных тестов

# --- Основной Try/Catch для всей логики скрипта ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY БЛОКА >>>

    # --- 1. Получение параметров пинга (без Get-OrElse) ---
    $TimeoutMs = 1000 # Значение по умолчанию
    if ($Parameters.ContainsKey('timeout_ms') -and $Parameters.timeout_ms -ne $null) {
        $parsedVal = 0
        if ([int]::TryParse($Parameters.timeout_ms, [ref]$parsedVal) -and $parsedVal -gt 0) { $TimeoutMs = $parsedVal }
        else { Write-Warning "[$NodeName] Check-PING: Некорректное значение timeout_ms ('$($Parameters.timeout_ms)'). Используется $TimeoutMs мс." }
    }

    $PingCount = 1 # Значение по умолчанию
    if ($Parameters.ContainsKey('count') -and $Parameters.count -ne $null) {
        $parsedVal = 0
        if ([int]::TryParse($Parameters.count, [ref]$parsedVal) -and $parsedVal -gt 0) { $PingCount = $parsedVal }
        else { Write-Warning "[$NodeName] Check-PING: Некорректное значение count ('$($Parameters.count)'). Используется $PingCount." }
    }
    $details.packets_sent = $PingCount # Сразу записываем в детали

    $BufferSize = 32 # Значение по умолчанию
    if ($Parameters.ContainsKey('buffer_size') -and $Parameters.buffer_size -ne $null) {
        $parsedVal = 0
        if ([int]::TryParse($Parameters.buffer_size, [ref]$parsedVal) -and $parsedVal -gt 0) { $BufferSize = $parsedVal }
        else { Write-Warning "[$NodeName] Check-PING: Некорректное значение buffer_size ('$($Parameters.buffer_size)'). Используется $BufferSize." }
    }

    $TtlValue = 128 # Значение по умолчанию
    if ($Parameters.ContainsKey('ttl') -and $Parameters.ttl -ne $null) {
        $parsedVal = 0
        if ([int]::TryParse($Parameters.ttl, [ref]$parsedVal) -and $parsedVal -gt 0) { $TtlValue = $parsedVal }
        else { Write-Warning "[$NodeName] Check-PING: Некорректное значение ttl ('$($Parameters.ttl)'). Используется $TtlValue." }
    }
    
    Write-Verbose "[$NodeName] Check-PING: Параметры: Count=$PingCount, Timeout=$TimeoutMs, Buffer=$BufferSize, TTL=$TtlValue"

    # --- 2. Выполнение пинга ---
    $pingSender = New-Object System.Net.NetworkInformation.Ping
    $pingOptions = New-Object System.Net.NetworkInformation.PingOptions($TtlValue, $true) # TTL, DontFragment
    $sendBuffer = [byte[]]::new($BufferSize) # Создаем буфер нужного размера
    
    $resultsList = [System.Collections.Generic.List[System.Net.NetworkInformation.PingReply]]::new()
    $successfulRepliesCount = 0
    $totalRoundtripTime = 0
    $firstSuccessfulReply = $null

    Write-Verbose "[$NodeName] Check-PING: Отправка $PingCount ICMP запросов к '$TargetIP' (Таймаут на каждый: $TimeoutMs мс)..."
    for ($i = 1; $i -le $PingCount; $i++) {
        $currentReply = $null
        try {
            $currentReply = $pingSender.Send($TargetIP, $TimeoutMs, $sendBuffer, $pingOptions)
            $resultsList.Add($currentReply) # Сохраняем все ответы для возможного анализа

            if ($currentReply.Status -eq [System.Net.NetworkInformation.IPStatus]::Success) {
                $successfulRepliesCount++
                $totalRoundtripTime += $currentReply.RoundtripTime
                if ($null -eq $firstSuccessfulReply) { $firstSuccessfulReply = $currentReply }
            }
            Write-Verbose "[$NodeName] Check-PING: Попытка $i/$PingCount - Статус: $($currentReply.Status), RTT: $(if($currentReply.Status -eq 'Success') {$currentReply.RoundtripTime} else {'N/A'})ms, Адрес: $($currentReply.Address)"
        
        } catch [System.Net.NetworkInformation.PingException] {
            # КРИТИЧЕСКАЯ ошибка - пинг невозможен (например, хост не найден DNS, нет маршрута)
            $errorMessage = "Критическая ошибка PingException для '$TargetIP': $($_.Exception.Message)"
            Write-Warning "[$NodeName] Check-PING: $errorMessage"
            # Заполняем детали ошибки
            $details.status_string = 'PingException'
            $details.error = $errorMessage
            $details.ErrorRecord = $_.ToString()
            # IsAvailable остается $false (установлено при инициализации)
            throw $errorMessage # Прерываем выполнение, чтобы попасть в основной catch и вернуть ошибку
        } catch {
             # Другая, менее критичная ошибка при отправке одного из пингов
             $otherSinglePingError = "Ошибка при отправке пинга ($i/$PingCount) для '$TargetIP': $($_.Exception.Message)"
             Write-Warning "[$NodeName] Check-PING: $otherSinglePingError"
             if (-not $details.ContainsKey('individual_ping_errors')) { $details.individual_ping_errors = [System.Collections.Generic.List[string]]::new() }
             $details.individual_ping_errors.Add($otherSinglePingError)
             # Не прерываем цикл, следующие пинги могут пройти
        }
        # Пауза между пингами, если их несколько
        if ($PingCount -gt 1 -and $i -lt $PingCount) { Start-Sleep -Milliseconds 100 } # Небольшая пауза
    } # Конец for

    # --- 3. Анализ результатов всех пингов и заполнение $details ---
    $details.packets_received = $successfulRepliesCount
    if ($PingCount -gt 0) {
        $details.packet_loss_percent = [math]::Round((($PingCount - $successfulRepliesCount) / $PingCount) * 100.0)
    } else { # На случай, если $PingCount был 0 (хотя валидация выше должна это предотвратить)
        $details.packet_loss_percent = 0 
    }

    if ($successfulRepliesCount -gt 0) {
        $isAvailable = $true # Пинг считается УСПЕШНЫМ, если получен хотя бы один ответ "Success"
        $errorMessage = $null # Сбрасываем общий errorMessage, если он был от неудачных предыдущих попыток
        
        $details.status_string = 'Success' # Общий статус
        $details.rtt_ms = [int][math]::Round($totalRoundtripTime / $successfulRepliesCount) # Среднее RTT
        if ($null -ne $firstSuccessfulReply) {
            $details.ip_address = $firstSuccessfulReply.Address.ToString() # IP ответившего хоста
        }
        Write-Verbose "[$NodeName] Check-PING: Пинг в целом успешен. IsAvailable=True. Успешных ответов: $successfulRepliesCount/$PingCount. Среднее RTT: $($details.rtt_ms)ms."
    } else {
        # IsAvailable остается $false (установлено при инициализации)
        $firstReplyStatusText = if ($resultsList.Count -gt 0) { $resultsList[0].Status.ToString() } else { "[Нет ответов после $PingCount попыток]" }
        $errorMessage = "Ошибка PING для '$TargetIP': Нет успешных ответов ($successfulRepliesCount/$PingCount). Статус первой попытки (если была): $firstReplyStatusText"
        $details.status_string = $firstReplyStatusText # Статус первой неудачной попытки или общее сообщение
        $details.error = $errorMessage # Добавляем основную причину неудачи в детали
        Write-Warning "[$NodeName] Check-PING: $errorMessage"
    }

    # --- 4. Проверка критериев успеха (вызов универсальной функции Test-SuccessCriteria) ---
    # Критерии проверяются только если пинг был доступен (IsAvailable = $true)
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) { # Проверяем, что SuccessCriteria не пустой хэш
            Write-Verbose "[$NodeName] Check-PING: Вызов Test-SuccessCriteria..."
            # Передаем полный объект $details и $SuccessCriteria в Test-SuccessCriteria
            # Также передаем путь '$details' для корректного формирования сообщений об ошибках в Test-SuccessCriteria
            $criteriaProcessingResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria -Path '$details'
            
            $checkSuccess = $criteriaProcessingResult.Passed # Результат: $true, $false, или $null (при ошибке в критерии)
            $failReasonFromCriteria = $criteriaProcessingResult.FailReason

            if ($checkSuccess -ne $true) { # Если критерий не пройден ($false) или была ошибка оценки ($null)
                # Формируем ErrorMessage на основе причины от Test-SuccessCriteria
                if (-not [string]::IsNullOrEmpty($failReasonFromCriteria)) {
                    $errorMessage = $failReasonFromCriteria
                } else {
                    # Fallback, если FailReason пуст, но CheckSuccess не true
                    $errorMessage = "Критерии успеха для пинга не пройдены (CheckSuccess: $($checkSuccess | ForEach-Object {if ($_ -eq $null) {'[null]'} else {$_}}))."
                }
                Write-Verbose "[$NodeName] Check-PING: SuccessCriteria НЕ пройдены или ошибка оценки. ErrorMessage: $errorMessage"
            } else {
                # Критерии пройдены
                Write-Verbose "[$NodeName] Check-PING: SuccessCriteria пройдены."
                # Убедимся, что ErrorMessage пуст, если критерии пройдены
                # (на случай, если были ошибки отдельных пингов, но общий результат прошел критерии)
                $errorMessage = $null
            }
        } else {
            # Критерии не заданы - считаем проверку успешной, если пинг прошел (IsAvailable = $true)
            $checkSuccess = $true
            $errorMessage = $null # Нет ошибок, связанных с критериями
            Write-Verbose "[$NodeName] Check-PING: SuccessCriteria не заданы, CheckSuccess установлен в true, т.к. IsAvailable=true."
        }
    } else {
        # Пинг не прошел ($isAvailable = $false) -> CheckSuccess должен остаться $null (неприменимо)
        $checkSuccess = $null
        # $errorMessage уже был установлен выше при анализе результатов пинга
        if ([string]::IsNullOrEmpty($errorMessage)) {
             $errorMessage = "Ошибка PING (IsAvailable=false), критерии не проверялись." # Запасной вариант
        }
    }

    # --- 5. Формирование итогового результата с помощью New-CheckResultObject ---
    $finalResultFromPing = New-CheckResultObject -IsAvailable $isAvailable `
                                                 -CheckSuccess $checkSuccess `
                                                 -Details $details `
                                                 -ErrorMessage $errorMessage

# <<< Закрываем основной try >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ошибок (например, PingException, выброшенная из цикла пингов, или другая непредвиденная ошибка) ---
    $isAvailable = $false # Гарантированно false при критической ошибке
    $checkSuccess = $null   # Критерии не могли быть оценены
    
    # Формируем сообщение об ошибке, если оно еще не установлено
    # $errorMessage может быть уже установлен, если исключение было поймано и переброшено из цикла for
    if ([string]::IsNullOrEmpty($errorMessage)) {
        $errorMessage = "Критическая непредвиденная ошибка в Check-PING для '$TargetIP': $($_.Exception.Message)"
    }
    
    Write-Error "[$NodeName] Check-PING: $errorMessage ScriptStackTrace: $($_.ScriptStackTrace)" # Логируем полную ошибку

    # Обновляем $details информацией об ошибке
    # $details мог быть частично заполнен до ошибки, или остаться инициализированным
    if ($null -eq $details) { $details = @{ target_ip = $TargetIP } } # На случай, если $details вообще не создался
    $details.error = $errorMessage       # Основное сообщение
    $details.ErrorRecord = $_.ToString() # Полная информация об ошибке PowerShell
    $details.status_string = if ($details.status_string -eq '[Error]' -or [string]::IsNullOrEmpty($details.status_string)) { 'CriticalError' } else { $details.status_string } # Обновляем статус, если он не был специфичен
    
    # Создаем финальный результат с ошибкой
    # Используем уже установленные $isAvailable, $checkSuccess, $errorMessage
    $finalResultFromPing = New-CheckResultObject -IsAvailable $isAvailable `
                                                 -CheckSuccess $checkSuccess `
                                                 -Details $details `
                                                 -ErrorMessage $errorMessage
} # <<< Закрываем основной catch >>>


# --- Отладка перед возвратом ---
Write-Host "DEBUG (Check-PING): --- Начало отладки finalResult.Details в Check-PING ---" -ForegroundColor Green
if ($finalResultFromPing -and $finalResultFromPing.Details) {
    Write-Host "DEBUG (Check-PING): Тип finalResult.Details: $($finalResultFromPing.Details.GetType().FullName)" -ForegroundColor Green
    if ($finalResultFromPing.Details -is [hashtable]) {
        Write-Host "DEBUG (Check-PING): Ключи в finalResult.Details (Hashtable): $($finalResultFromPing.Details.Keys -join ', ')" -ForegroundColor Green
    }
    Write-Host "DEBUG (Check-PING): Полное содержимое finalResult.Details (ConvertTo-Json -Depth 5):" -ForegroundColor Green
    Write-Host ($finalResultFromPing.Details | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue) -ForegroundColor DarkGreen
} elseif ($finalResultFromPing) {
    Write-Host "DEBUG (Check-PING): finalResult.Details является $null или отсутствует." -ForegroundColor Yellow
} else {
    Write-Host "DEBUG (Check-PING): finalResult сам по себе $null (ошибка до его формирования)." -ForegroundColor Red
}
Write-Host "DEBUG (Check-PING): --- Конец отладки finalResult.Details в Check-PING ---" -ForegroundColor Green

# --- Возврат результата ---
$isAvailableStr = if ($finalResultFromPing) { $finalResultFromPing.IsAvailable } else { '[finalResultFromPing is null]' }
$checkSuccessStrForLog = if ($finalResultFromPing) { if ($null -eq $finalResultFromPing.CheckSuccess) {'[null]'} else {$finalResultFromPing.CheckSuccess} } else { '[finalResultFromPing is null]' }
Write-Host "[$NodeName] Check-PING (v2.3.2): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStrForLog" -ForegroundColor Magenta

return $finalResultFromPing
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1
# --- Версия 2.1.0 --- Рефакторинг для читаемости, PS 5.1, удален Get-OrElse
<#
.SYNOPSIS
    Получает список запущенных процессов. (v2.1.0)
.DESCRIPTION
    Использует Get-Process. Позволяет фильтровать/сортировать по имени, ID, CPU, памяти, времени запуска.
    Может включать имя пользователя и путь к исполняемому файлу.
    Формирует $Details с массивом 'processes', содержащим стандартизированную информацию.
    Вызывает Test-SuccessCriteria для определения CheckSuccess на основе собранных данных.
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста (в текущей реализации Get-Process выполняется локально,
             поэтому TargetIP используется в основном для логирования и идентификации задания).
.PARAMETER Parameters
    [hashtable] Опциональный. Параметры для настройки выборки и вывода:
                - process_names ([string[]]): Массив имен процессов для фильтрации (поддерживаются wildcard).
                - include_username ([bool]): Включить ли имя пользователя процесса. По умолчанию $false.
                - include_path ([bool]): Включить ли путь к исполняемому файлу. По умолчанию $false.
                - sort_by ([string]): Поле для сортировки. Допустимые: 'id', 'name', 'cpu' (или 'cpu_seconds'),
                                      'memory' (или 'mem', 'ws', 'memory_ws_mb'), 'start_time'. По умолчанию 'name'.
                - sort_descending ([bool]): Сортировать по убыванию. По умолчанию $false.
                - top_n ([int]): Вернуть только указанное количество процессов после сортировки.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для оценки массива 'processes' в $Details.
                Примеры:
                - Наличие процесса: @{ processes = @{ _condition_='count'; _where_=@{name='notepad.exe'}; _count_=@{'>='=1}} }
                - Отсутствие процесса: @{ processes = @{ _condition_='none'; _where_=@{name='malware.exe'}} }
                - Проверка CPU/памяти: @{ processes = @{ _condition_='all'; _where_=@{name='sqlservr.exe'}; _criteria_=@{memory_ws_mb=@{'<'=2048}}} }
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки, созданный New-CheckResultObject.
.NOTES
    Версия: 2.1.0
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria из модуля StatusMonitorAgentUtils.
    Get-Process выполняется локально. Для удаленного выполнения потребуется обертка с Invoke-Command.
    Получение username и path может быть ресурсоемким и требовать повышенных прав.
#>
param(
    [Parameter(Mandatory = $false)] # <--- ИЗМЕНЕНО: Сделан не обязательным
    [string]$TargetIP,             # Тип [string] по умолчанию допускает $null, если Mandatory=$false
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node (PROCESS_LIST)"
)

# --- Инициализация основных переменных ---
$isAvailable = $false             # Смогли ли мы вообще выполнить Get-Process
$checkSuccess = $null            # Результат проверки SuccessCriteria
$errorMessage = $null            # Сообщение об ошибке
$finalResult = $null             # Итоговый объект для возврата
# $details будет содержать массив 'processes' и, возможно, 'message' или 'error'
$details = @{
    processes = [System.Collections.Generic.List[object]]::new() # Список для хранения обработанных процессов
}

# Используем NodeName для ясности, TargetIP теперь опционален и больше для контекста
$logTargetDisplay = if (-not [string]::IsNullOrWhiteSpace($TargetIP)) { $TargetIP } else { $env:COMPUTERNAME + " (локально)" }
Write-Verbose "[$NodeName] Check-PROCESS_LIST (v2.1.1): Начало получения списка процессов. Цель (контекст): $logTargetDisplay"

# --- Основной блок Try/Catch для всей логики скрипта ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Обработка входных параметров ($Parameters) ---
    $processNamesFilter = $null
    $filteringByName = $false
    if ($Parameters.ContainsKey('process_names') -and ($Parameters.process_names -is [array]) -and ($Parameters.process_names.Count -gt 0)) {
        $processNamesFilter = $Parameters.process_names
        $filteringByName = $true
        Write-Verbose "[$NodeName] Фильтрация по именам процессов: $($processNamesFilter -join ', ')"
    }

    $includeUsername = $false
    if ($Parameters.ContainsKey('include_username')) {
        try { $includeUsername = [bool]$Parameters.include_username }
        catch { Write-Warning "[$NodeName] Некорректное значение для 'include_username': '$($Parameters.include_username)'. Используется $false." }
    }
    Write-Verbose "[$NodeName] Включить имя пользователя: $includeUsername"

    $includePath = $false
    if ($Parameters.ContainsKey('include_path')) {
        try { $includePath = [bool]$Parameters.include_path }
        catch { Write-Warning "[$NodeName] Некорректное значение для 'include_path': '$($Parameters.include_path)'. Используется $false." }
    }
    Write-Verbose "[$NodeName] Включить путь к файлу: $includePath"

    # Определение поля для сортировки ($sortByActual)
    $sortByInputString = 'name' # По умолчанию
    if ($Parameters.ContainsKey('sort_by') -and (-not [string]::IsNullOrWhiteSpace($Parameters.sort_by))) {
        $sortByInputString = $Parameters.sort_by.ToString().Trim()
    }
    
    $validSortFieldsMap = @{ # Карта псевдонимов к реальным именам полей в $procInfo
        'id'           = 'id'
        'name'         = 'name'
        'cpu'          = 'cpu_seconds'
        'cpu_seconds'  = 'cpu_seconds'
        'memory'       = 'memory_ws_mb'
        'mem'          = 'memory_ws_mb'
        'ws'           = 'memory_ws_mb'
        'memory_ws_mb' = 'memory_ws_mb'
        'start_time'   = 'start_time'
    }
    $sortByActual = 'name' # Поле для сортировки по умолчанию
    if ($validSortFieldsMap.ContainsKey($sortByInputString.ToLower())) {
        $sortByActual = $validSortFieldsMap[$sortByInputString.ToLower()]
    } else {
        Write-Warning "[$NodeName] Некорректное значение для 'sort_by': '$sortByInputString'. Используется сортировка по 'name'."
    }
    Write-Verbose "[$NodeName] Поле для сортировки: $sortByActual"

    $sortDescending = $false
    if ($Parameters.ContainsKey('sort_descending')) {
        try { $sortDescending = [bool]$Parameters.sort_descending }
        catch { Write-Warning "[$NodeName] Некорректное значение для 'sort_descending': '$($Parameters.sort_descending)'. Используется $false." }
    }
    Write-Verbose "[$NodeName] Сортировать по убыванию: $sortDescending"

    $topN = 0 # 0 означает без ограничения
    if ($Parameters.ContainsKey('top_n') -and $Parameters.top_n -ne $null) {
        $parsedTopNValue = 0
        if ([int]::TryParse($Parameters.top_n.ToString(), [ref]$parsedTopNValue) -and $parsedTopNValue -ge 0) { # Разрешаем 0 (без ограничения)
            $topN = $parsedTopNValue
        } else {
            Write-Warning "[$NodeName] Некорректное значение для 'top_n': '$($Parameters.top_n)'. Ограничение не будет применяться."
        }
    }
    Write-Verbose "[$NodeName] Отобразить топ N процессов: $(if ($topN -gt 0) {$topN} else {'Все'})"

    # --- 2. Выполнение Get-Process ---
    $getProcessCmdParams = @{}
    # ErrorAction Stop для общего случая, SilentlyContinue если фильтруем по имени и процесс может быть не найден
    $getProcessCmdParams.ErrorAction = if ($filteringByName) { 'SilentlyContinue' } else { 'Stop' }
    
    if ($filteringByName) {
        $getProcessCmdParams.Name = $processNamesFilter
    }
    # Для PS 5.1, Get-Process -ComputerName требует соответствующей настройки и прав,
    # и не всегда работает надежно. Текущая реализация выполняет Get-Process локально.
    # Если TargetIP не localhost, это просто для информации/контекста.
    # if ($TargetIP -ne $env:COMPUTERNAME -and $TargetIP -ne 'localhost' -and $TargetIP -ne '127.0.0.1') {
    #    $getProcessCmdParams.ComputerName = $TargetIP # Потребует WinRM и прав
    # }

    Write-Verbose "[$NodeName] Check-PROCESS_LIST: Вызов Get-Process с параметрами: $($getProcessCmdParams | ConvertTo-Json -Compress -Depth 1)"
    $processesRaw = Get-Process @getProcessCmdParams
    
    # Проверяем специфичную ошибку "ProcessNotFoundException" при фильтрации по имени
    $processNotFoundErrorOccurred = $false
    if ($filteringByName -and $Error.Count -gt 0) {
        foreach ($errRec in $Error) {
            if ($errRec.CategoryInfo.Reason -eq 'ProcessNotFoundException') {
                $processNotFoundErrorOccurred = $true
                Write-Verbose "[$NodeName] Примечание: Один или несколько процессов из фильтра '$($processNamesFilter -join ', ')' не найдены."
                # Можно добавить $errRec.Exception.Message в $details.messages, если нужно
                break 
            }
        }
        $Error.Clear() # Очищаем ошибки, связанные с ненайденными процессами, чтобы они не считались критическими
    }

    $isAvailable = $true # Если мы дошли сюда без исключения из Get-Process (кроме ProcessNotFound), считаем, что команда отработала
    $rawProcessCount = if ($null -ne $processesRaw) { @($processesRaw).Count } else { 0 } # @() для гарантии массива, даже если 1 элемент
    Write-Verbose "[$NodeName] Check-PROCESS_LIST: Get-Process выполнен. Найдено процессов (до обработки): $rawProcessCount."

    # --- 3. Обработка результатов Get-Process и формирование $details.processes ---
    if ($rawProcessCount -gt 0) {
        $tempProcessedList = foreach ($proc in $processesRaw) {
            # Создаем хэш-таблицу для информации о процессе
            $procInfo = [ordered]@{ # Используем ordered для предсказуемого порядка в JSON
                id              = $proc.Id
                name            = $proc.ProcessName
                cpu_seconds     = $null # Будет заполнено ниже
                memory_ws_mb    = $null # Рабочий набор (Working Set)
                username        = $null # Будет заполнено, если $includeUsername
                path            = $null # Будет заполнено, если $includePath
                start_time      = $null # Время запуска
            }
            
            # Пытаемся получить дополнительные свойства, обрабатывая возможные ошибки
            try { $procInfo.cpu_seconds = [math]::Round($proc.CPU, 2) } catch { Write-Verbose "[$NodeName] Не удалось получить CPU для процесса $($proc.Id) ($($proc.ProcessName)): $($_.Exception.Message)" }
            try { $procInfo.memory_ws_mb = [math]::Round($proc.WS / 1MB, 1) } catch { Write-Verbose "[$NodeName] Не удалось получить WS для процесса $($proc.Id) ($($proc.ProcessName)): $($_.Exception.Message)" }
            try { if ($proc.StartTime) { $procInfo.start_time = $proc.StartTime.ToUniversalTime().ToString("o") } } catch { Write-Verbose "[$NodeName] Не удалось получить StartTime для процесса $($proc.Id) ($($proc.ProcessName)): $($_.Exception.Message)" }

            if ($includeUsername) {
                try {
                    # Get-CimInstance более надежен для получения владельца, чем $proc.UserName (которого нет)
                    $ownerDetails = Get-CimInstance -ClassName Win32_Process -Filter "ProcessId = $($proc.Id)" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Owner -ErrorAction SilentlyContinue
                    if ($ownerDetails -and $ownerDetails.User) {
                        $procInfo.username = if ($ownerDetails.Domain) { "$($ownerDetails.Domain)\$($ownerDetails.User)" } else { $ownerDetails.User }
                    } else {
                        $procInfo.username = '[N/A_User]' # Пользователь не определен или нет доступа
                    }
                } catch {
                    $procInfo.username = '[AccessError_User]' # Ошибка при попытке получить пользователя
                    Write-Verbose "[$NodeName] Ошибка получения пользователя для процесса $($proc.Id): $($_.Exception.Message)"
                }
            }

            if ($includePath) {
                try {
                    $executablePath = $proc.Path # Это свойство есть у объектов Get-Process
                    if (-not $executablePath -and $proc.MainModule) { # Fallback, если Path пуст, но есть MainModule
                        try { $executablePath = $proc.MainModule.FileName } catch {}
                    }
                    $procInfo.path = if ([string]::IsNullOrWhiteSpace($executablePath)) { '[N/A_Path]' } else { $executablePath }
                } catch {
                    $procInfo.path = '[AccessError_Path]' # Ошибка при попытке получить путь
                    Write-Verbose "[$NodeName] Ошибка получения пути для процесса $($proc.Id): $($_.Exception.Message)"
                }
            }
            # Возвращаем PSCustomObject для удобства сортировки и обработки далее
            [PSCustomObject]$procInfo 
        } # Конец foreach ($proc in $processesRaw)

        # Сортировка (если список не пустой)
        if ($tempProcessedList.Count -gt 0) {
            Write-Verbose "[$NodeName] Сортировка списка процессов по '$sortByActual' (убывание: $sortDescending)..."
            try {
                $tempProcessedList = $tempProcessedList | Sort-Object -Property $sortByActual -Descending:$sortDescending
            } catch {
                Write-Warning "[$NodeName] Ошибка при сортировке по '$sortByActual'. Применена сортировка по 'name'. Ошибка: $($_.Exception.Message)"
                $tempProcessedList = $tempProcessedList | Sort-Object -Property 'name' # Fallback сортировка
            }
        }
        
        # Ограничение Top N (если нужно и список не пустой)
        if ($topN -gt 0 -and $tempProcessedList.Count -gt $topN) {
            Write-Verbose "[$NodeName] Применение Top N: $topN"
            $tempProcessedList = $tempProcessedList | Select-Object -First $topN
        }
        
        # Добавляем обработанные процессы в $details
        $details.processes.AddRange($tempProcessedList)
        Write-Verbose "[$NodeName] В $details.processes добавлено $($tempProcessedList.Count) процессов."

    } elseif ($filteringByName -and $processNotFoundErrorOccurred) {
        # Если был фильтр по имени и процессы не найдены (это НЕ ошибка доступности проверки)
        $details.message = "Процессы, соответствующие фильтру '$($processNamesFilter -join ', ')', не найдены."
        Write-Verbose "[$NodeName] $($details.message)"
    } else {
        # Если процессов нет вообще (не из-за фильтра) или Get-Process вернул $null
        $details.message = "Список запущенных процессов пуст или не удалось получить данные."
        Write-Verbose "[$NodeName] $($details.message)"
    }

    # --- 4. Проверка критериев успеха ---
    # Критерии проверяются на основе $details.processes
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-PROCESS_LIST: Вызов Test-SuccessCriteria..."
            # $details передается целиком, Test-SuccessCriteria будет работать с $details.processes, если критерий нацелен на него
            $criteriaProcessingResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria -Path '$details'
            
            $checkSuccess = $criteriaProcessingResult.Passed
            $failReasonFromCriteria = $criteriaProcessingResult.FailReason

            if ($checkSuccess -ne $true) {
                if (-not [string]::IsNullOrEmpty($failReasonFromCriteria)) {
                    $errorMessage = $failReasonFromCriteria
                } else {
                    $errorMessage = "Критерии успеха для списка процессов не пройдены (CheckSuccess: $($checkSuccess | ForEach-Object {if ($_ -eq $null) {'[null]'} else {$_}}))."
                }
                Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены или ошибка оценки. ErrorMessage: $errorMessage"
            } else {
                $errorMessage = $null # Критерии пройдены
                Write-Verbose "[$NodeName] ... SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы - считаем успешным, если сама проверка прошла
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-PROCESS_LIST: SuccessCriteria не заданы, CheckSuccess установлен в true (т.к. IsAvailable=true)."
        }
    } else {
        # IsAvailable = $false (ошибка при Get-Process)
        $checkSuccess = $null # Критерии не оценивались
        # $errorMessage уже должен быть установлен в блоке catch ниже, если была критическая ошибка Get-Process
        if ([string]::IsNullOrEmpty($errorMessage)) {
            $errorMessage = "Ошибка получения списка процессов (IsAvailable=false), критерии не проверялись."
        }
    }

    # --- 5. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< ОСНОВНОЙ CATCH для критических ошибок (например, Stop ErrorAction из Get-Process) >>>
    $isAvailable = $false # Гарантированно false при критической ошибке
    $checkSuccess = $null   # Критерии не могли быть оценены
    
    $critErrorMessage = "Критическая ошибка в Check-PROCESS_LIST для '$TargetIP': $($_.Exception.Message)"
    Write-Error "[$NodeName] Check-PROCESS_LIST: $critErrorMessage ScriptStackTrace: $($_.ScriptStackTrace)"
    
    # $details может быть уже частично заполнен, добавляем информацию об ошибке
    if ($null -eq $details) { $details = @{} }
    $details.error = $critErrorMessage
    $details.ErrorRecord = $_.ToString()
    
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $critErrorMessage
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Отладка перед возвратом (можно закомментировать после отладки) ---
Write-Host "DEBUG (Check-PROCESS_LIST): --- Начало отладки finalResult.Details ---" -ForegroundColor Green
if ($finalResult -and $finalResult.Details) {
    Write-Host "DEBUG (Check-PROCESS_LIST): Тип finalResult.Details: $($finalResult.Details.GetType().FullName)" -ForegroundColor Green
    if ($finalResult.Details -is [hashtable]) {
        Write-Host "DEBUG (Check-PROCESS_LIST): Ключи в finalResult.Details: $($finalResult.Details.Keys -join ', ')" -ForegroundColor Green
        Write-Host "DEBUG (Check-PROCESS_LIST): Количество процессов в Details: $($finalResult.Details.processes.Count)" -ForegroundColor Green
    }
    # Write-Host "DEBUG (Check-PROCESS_LIST): Полное содержимое finalResult.Details (JSON): $($finalResult.Details | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue)" -ForegroundColor DarkGreen
} elseif ($finalResult) {
    Write-Host "DEBUG (Check-PROCESS_LIST): finalResult.Details является $null или отсутствует." -ForegroundColor Yellow
} else {
    Write-Host "DEBUG (Check-PROCESS_LIST): finalResult сам по себе $null (ошибка до его формирования)." -ForegroundColor Red
}
Write-Host "DEBUG (Check-PROCESS_LIST): --- Конец отладки finalResult.Details ---" -ForegroundColor Green

# --- Возврат результата ---
$isAvailableStrForLog = if ($finalResult) { $finalResult.IsAvailable } else { '[finalResult is null]' }
$checkSuccessStrForLog = if ($finalResult) { if ($null -eq $finalResult.CheckSuccess) {'[null]'} else {$finalResult.CheckSuccess} } else { '[finalResult is null]' }
Write-Verbose "[$NodeName] Check-PROCESS_LIST (v2.1.0): Завершение. IsAvailable=$isAvailableStrForLog, CheckSuccess=$checkSuccessStrForLog"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1
# --- Версия 2.0.2 (или 2.1.0, если следовать общей нумерации) --- Исправлен параметр TargetIP
<#
.SYNOPSIS
    Проверяет статус указанной системной службы. (v2.0.2)
.DESCRIPTION
    Использует Get-Service.
    Формирует $Details с информацией о службе.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.PARAMETER TargetIP
    [string] Опциональный. IP или имя хоста (для логирования и контекста). Get-Service выполняется локально.
.PARAMETER Parameters
    [hashtable] Обязательный. Должен содержать 'service_name'.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для полей в $Details
                (напр., @{ status = 'Running'; start_type = 'Automatic' }).
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
.NOTES
    Версия: 2.0.2
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
#>
param(
    [Parameter(Mandatory = $false)] # <--- ИЗМЕНЕНО: Сделан не обязательным
    [string]$TargetIP,             # Тип [string] по умолчанию допускает $null, если Mandatory=$false
    [Parameter(Mandatory = $false)] # Был Mandatory=$true, но service_name важнее, его проверяем ниже
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node (SERVICE_STATUS)"
)

# --- Инициализация ---
$isAvailable = $false
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null
$details = @{ service_name = $null } # Базовые детали

$logTargetDisplay = if (-not [string]::IsNullOrWhiteSpace($TargetIP)) { $TargetIP } else { $env:COMPUTERNAME + " (локально)" }
Write-Verbose "[$NodeName] Check-SERVICE_STATUS (v2.0.2): Начало проверки службы. Цель (контекст): $logTargetDisplay"

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>
    # 1. Валидация ОБЯЗАТЕЛЬНОГО параметра service_name из $Parameters
    if (-not $Parameters.ContainsKey('service_name') -or [string]::IsNullOrWhiteSpace($Parameters.service_name)) {
        throw "Параметр 'service_name' отсутствует, пуст или не указан в хэш-таблице Parameters."
    }
    $serviceName = $Parameters.service_name.Trim()
    $details.service_name = $serviceName
    Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Проверяемая служба '$serviceName'"

    # 2. Выполнение Get-Service (локально)
    # $TargetIP в Get-Service -ComputerName здесь не используется, т.к. проверка локальная.
    # Если бы была удаленная, то: $getServiceParams = @{ Name = $serviceName; ErrorAction = 'Stop' }
    # if ($TargetIP -and $TargetIP -ne $env:COMPUTERNAME) { $getServiceParams.ComputerName = $TargetIP }
    # $service = Get-Service @getServiceParams
    
    $service = $null
    try {
        Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Вызов Get-Service -Name '$serviceName'..."
        $service = Get-Service -Name $serviceName -ErrorAction Stop # Ошибка, если служба не найдена
        
        $isAvailable = $true # Если команда выполнилась без ошибки, проверка считается доступной
        $currentServiceStatus = $service.Status.ToString()
        Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Служба '$serviceName' найдена. Статус: $currentServiceStatus"
        
        # Заполняем $Details информацией о службе
        $details.status = $currentServiceStatus
        $details.display_name = $service.DisplayName
        $details.start_type = $service.StartType.ToString()
        $details.can_stop = $service.CanStop
        # Дополнительные полезные свойства (опционально)
        # $details.can_pause_and_continue = $service.CanPauseAndContinue
        # $details.dependent_services = @($service.DependentServices | ForEach-Object {$_.Name})
        # $details.services_depended_on = @($service.ServicesDependedOn | ForEach-Object {$_.Name})

    } catch [Microsoft.PowerShell.Commands.ServiceCommandException] {
        # ОШИБКА: Служба не найдена (это не ошибка доступности самой проверки, а результат)
        $isAvailable = $true # Сама проверка (попытка получить статус) была выполнена
        $checkSuccess = $false # Но результат - служба не найдена, что обычно провал, если критерий был на статус
        $errorMessage = "Служба '$serviceName' не найдена на хосте '$($env:COMPUTERNAME)'."
        $details.error = $errorMessage
        $details.status = "NotFound" # Добавляем специальный статус
        Write-Warning "[$NodeName] Check-SERVICE_STATUS: $errorMessage"
        # Не прерываем выполнение, Test-SuccessCriteria может это учесть, если критерий был на отсутствие
    } catch {
        # ОШИБКА: Другая, более серьезная ошибка Get-Service (например, служба RPC недоступна)
        $isAvailable = $false # Сама проверка не удалась
        $errorMessage = "Ошибка при вызове Get-Service для '$serviceName': $($_.Exception.Message)"
        $details.error = $errorMessage
        $details.ErrorRecord = $_.ToString()
        Write-Warning "[$NodeName] Check-SERVICE_STATUS: $errorMessage"
        # $checkSuccess остается $null, т.к. проверка не была полностью выполнена
        # Перебрасываем ошибку, чтобы она была поймана основным catch и корректно обработана как критическая для этой проверки
        throw 
    }

    # --- 3. Проверка критериев успеха ---
    if ($isAvailable -eq $true) { 
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Вызов Test-SuccessCriteria..."
            $criteriaProcessingResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria -Path '$details'
            
            $checkSuccess = $criteriaProcessingResult.Passed 
            $failReasonFromCriteria = $criteriaProcessingResult.FailReason

            if ($checkSuccess -ne $true) { 
                if (-not [string]::IsNullOrEmpty($failReasonFromCriteria)) {
                    $errorMessage = $failReasonFromCriteria # Перезаписываем errorMessage, если он был от "NotFound"
                } else {
                    $errorMessage = "Критерии успеха для службы '$serviceName' не пройдены (CheckSuccess: $($checkSuccess | ForEach-Object {if ($_ -eq $null) { '[null]' } else { $_ }}))."
                }
                Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria НЕ пройдены или ошибка оценки. ErrorMessage: $errorMessage"
            } else {
                # Если критерии пройдены, но ранее была ошибка "NotFound", она должна остаться в ErrorMessage
                if ($details.status -ne "NotFound") {
                    $errorMessage = $null 
                }
                Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы. Если служба найдена (status не "NotFound"), то успех.
            if ($details.status -ne "NotFound") {
                $checkSuccess = $true
                $errorMessage = $null
            } else {
                # Если критериев нет, а служба не найдена, то это $checkSuccess = $false
                # $errorMessage уже содержит "Служба ... не найдена"
                # $checkSuccess уже был установлен в $false выше
            }
            Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria не заданы. CheckSuccess: $checkSuccess."
        }
    } else {
        # $isAvailable = $false (была критическая ошибка Get-Service)
        $checkSuccess = $null # Критерии не оценивались
        if ([string]::IsNullOrEmpty($errorMessage)) { 
            $errorMessage = "Ошибка проверки статуса службы '$serviceName' (IsAvailable=false), критерии не проверялись."
        }
    }

    # --- 4. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< ОСНОВНОЙ CATCH для критических ошибок (например, валидация $Parameters или throw из блока Get-Service) >>>
    $isAvailable = $false 
    $checkSuccess = $null   
    
    $critErrorMessage = "Критическая ошибка в Check-SERVICE_STATUS для службы '$($Parameters.service_name | Get-OrElse "[неизвестно]")': $($_.Exception.Message)"
    Write-Error "[$NodeName] Check-SERVICE_STATUS: $critErrorMessage ScriptStackTrace: $($_.ScriptStackTrace)"
    
    if ($null -eq $details) { $details = @{} }
    if (-not $details.ContainsKey('service_name') -and $Parameters.ContainsKey('service_name')) { $details.service_name = $Parameters.service_name }
    $details.error = $critErrorMessage
    $details.ErrorRecord = $_.ToString()
    
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $critErrorMessage
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Отладка перед возвратом ---
Write-Host "DEBUG (Check-SERVICE_STATUS): --- Начало отладки finalResult.Details ---" -ForegroundColor Green
if ($finalResult -and $finalResult.Details) {
    Write-Host "DEBUG (Check-SERVICE_STATUS): Тип finalResult.Details: $($finalResult.Details.GetType().FullName)" -ForegroundColor Green
    if ($finalResult.Details -is [hashtable]) {
        Write-Host "DEBUG (Check-SERVICE_STATUS): Ключи в finalResult.Details: $($finalResult.Details.Keys -join ', ')" -ForegroundColor Green
    }
    Write-Host "DEBUG (Check-SERVICE_STATUS): Полное содержимое finalResult.Details (JSON): $($finalResult.Details | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue)" -ForegroundColor DarkGreen
} elseif ($finalResult) {
    Write-Host "DEBUG (Check-SERVICE_STATUS): finalResult.Details является $null или отсутствует." -ForegroundColor Yellow
} else {
    Write-Host "DEBUG (Check-SERVICE_STATUS): finalResult сам по себе $null (ошибка до его формирования)." -ForegroundColor Red
}
Write-Host "DEBUG (Check-SERVICE_STATUS): --- Конец отладки finalResult.Details ---" -ForegroundColor Green

# --- Возврат результата ---
$isAvailableStrForLog = if ($finalResult) { $finalResult.IsAvailable } else { '[finalResult is null]' }
$checkSuccessStrForLog = if ($finalResult) { if ($null -eq $finalResult.CheckSuccess) {'[null]'} else {$finalResult.CheckSuccess} } else { '[finalResult is null]' }
Write-Verbose "[$NodeName] Check-SERVICE_STATUS (v2.0.2): Завершение. IsAvailable=$isAvailableStrForLog, CheckSuccess=$checkSuccessStrForLog"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1
# --- Версия 2.1.1 --- Рефакторинг, PS 5.1 совместимость, улучшенная обработка ошибок и логов
<#
.SYNOPSIS
    Выполняет SQL-запрос к MS SQL Server и возвращает результат в указанном формате. (v2.1.1)
.DESCRIPTION
    Скрипт подключается к указанному экземпляру SQL Server и базе данных,
    выполняет предоставленный SQL-запрос и обрабатывает результат согласно
    параметру 'return_format'. 
    Поддерживаемые форматы вывода:
    - 'first_row': Возвращает первую строку результата как хэш-таблицу.
    - 'all_rows': Возвращает все строки результата как массив хэш-таблиц. (Осторожно с большими объемами!)
    - 'row_count': Возвращает количество строк, затронутых/возвращенных запросом.
    - 'scalar': Возвращает значение из первого столбца первой строки.
    - 'non_query': Для запросов, не возвращающих данные (например, INSERT, UPDATE, DDL). Сообщает об успехе выполнения.

    Скрипт формирует детальный объект $Details, содержащий как параметры запроса, так и его результат.
    Затем вызывает Test-SuccessCriteria (если критерии предоставлены) для определения CheckSuccess.
    Ошибки подключения к SQL, выполнения запроса или обработки результатов логируются и влияют на IsAvailable.
.PARAMETER TargetIP
    [string] Обязательный. Имя или IP-адрес SQL Server instance (например, 'SERVER\SQLEXPRESS' или 'localhost,1433').
.PARAMETER Parameters
    [hashtable] Обязательный. Хэш-таблица с параметрами для SQL-запроса:
                - sql_database ([string], Обязательный): Имя целевой базы данных.
                - sql_query ([string], Обязательный): Текст SQL-запроса для выполнения.
                - return_format ([string], Опциональный, по умолч. 'first_row'): Формат возвращаемого результата.
                                            Допустимые: 'first_row', 'all_rows', 'row_count', 'scalar', 'non_query'.
                - sql_username ([string], Опциональный): Имя пользователя для SQL Server аутентификации.
                                                         Если не указано, используется Windows-аутентификация.
                - sql_password ([string], Опциональный): Пароль для SQL Server аутентификации. 
                                                         Обязателен, если указан sql_username. (Использование не рекомендуется из соображений безопасности).
                - query_timeout_sec ([int], Опциональный, по умолч. 30): Таймаут выполнения SQL-запроса в секундах.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха, применяемые к объекту $details.
                Примеры:
                - Для 'row_count': @{ row_count = @{'>=' = 1} }
                - Для 'scalar': @{ scalar_value = "OK" } или @{ scalar_value = @{'matches' = '^Error.*'} }
                - Для 'first_row' (проверка поля 'Status'): @{ query_result = @{ Status = "Completed" } }
                - Для 'all_rows' (все строки должны иметь Value > 0): 
                  @{ query_result = @{ _condition_ = "all"; _criteria_ = @{ Value = @{">"=0} } } }
.PARAMETER NodeName
    [string] Опциональный. Имя узла (для логирования).
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки, созданный New-CheckResultObject.
.NOTES
    Версия: 2.1.1
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria из модуля StatusMonitorAgentUtils.
    Требует наличия модуля 'SqlServer' на машине, где выполняется скрипт.
    Рекомендуется использовать Windows-аутентификацию для подключения к SQL Server.
#>
param(
    [Parameter(Mandatory = $true)] # TargetIP здесь - это SQL Server Instance, он должен быть обязательным
    [string]$TargetIP, 
    [Parameter(Mandatory = $false)] # Проверяем наличие ключей внутри
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node (SQL_QUERY_EXECUTE)"
)

# --- Инициализация ---
$isAvailable = $false             # Смогли ли мы успешно выполнить запрос и получить данные/статус
$checkSuccess = $null            # Результат проверки SuccessCriteria
$errorMessage = $null            # Сообщение об ошибке
$finalResult = $null             # Итоговый объект для возврата
# $details инициализируется основными параметрами, затем дополняется результатами
$details = @{ 
    server_instance    = $TargetIP
    database_name      = $null 
    query_executed     = $null 
    return_format_used = 'first_row' # Значение по умолчанию, будет обновлено
    # Поля для результатов будут добавлены в зависимости от return_format:
    # query_result (для first_row, all_rows)
    # rows_returned (для first_row, all_rows)
    # row_count (для row_count)
    # scalar_value (для scalar)
    # non_query_success (для non_query)
}

$logTargetDisplay = if (-not [string]::IsNullOrWhiteSpace($TargetIP)) { $TargetIP } else { "[SQL Server не указан]" }
Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE (v2.1.1): Начало выполнения SQL. Сервер: $logTargetDisplay"

# --- Основной блок Try/Catch для всей логики скрипта ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Извлечение и валидация параметров из $Parameters ---
    $SqlServerInstance = $TargetIP # TargetIP является экземпляром SQL Server

    if (-not $Parameters.ContainsKey('sql_database') -or [string]::IsNullOrWhiteSpace($Parameters.sql_database)) {
        throw "Отсутствует или пуст обязательный параметр 'sql_database' в Parameters."
    }
    $DatabaseName = $Parameters.sql_database.Trim()
    $details.database_name = $DatabaseName

    if (-not $Parameters.ContainsKey('sql_query') -or [string]::IsNullOrWhiteSpace($Parameters.sql_query)) {
        throw "Отсутствует или пуст обязательный параметр 'sql_query' в Parameters."
    }
    $SqlQuery = $Parameters.sql_query.Trim()
    $details.query_executed = $SqlQuery
    
    $SqlUsername = $null
    if ($Parameters.ContainsKey('sql_username')) {
        $SqlUsername = $Parameters.sql_username # Может быть $null или пустой строкой
    }
    $SqlPassword = $null # Пароль нужен, только если есть имя пользователя
    if (-not [string]::IsNullOrWhiteSpace($SqlUsername)) {
        if (-not $Parameters.ContainsKey('sql_password') -or $Parameters.sql_password -eq $null) { # Пароль может быть пустой строкой, если SQL Server это позволяет
            throw "Параметр 'sql_password' обязателен и не должен быть `$null, если указан 'sql_username'."
        }
        $SqlPassword = $Parameters.sql_password
    }

    $ReturnFormat = 'first_row' # Значение по умолчанию
    if ($Parameters.ContainsKey('return_format') -and (-not [string]::IsNullOrWhiteSpace($Parameters.return_format))) {
        $tempFormat = $Parameters.return_format.ToString().ToLower().Trim()
        $validFormats = @('first_row', 'all_rows', 'row_count', 'scalar', 'non_query')
        if ($tempFormat -in $validFormats) {
            $ReturnFormat = $tempFormat
        } else {
            throw "Недопустимое значение для 'return_format': '$($Parameters.return_format)'. Допустимые: $($validFormats -join ', ')."
        }
    }
    $details.return_format_used = $ReturnFormat
    Write-Verbose "[$NodeName] SQL: Используется return_format: '$ReturnFormat'."

    $QueryTimeoutSec = 30 # Значение по умолчанию
    if ($Parameters.ContainsKey('query_timeout_sec') -and $Parameters.query_timeout_sec -ne $null) {
        $parsedTimeout = 0
        if ([int]::TryParse($Parameters.query_timeout_sec.ToString(), [ref]$parsedTimeout) -and $parsedTimeout -gt 0) {
            $QueryTimeoutSec = $parsedTimeout
        } else {
            Write-Warning "[$NodeName] SQL: Некорректное значение 'query_timeout_sec': '$($Parameters.query_timeout_sec)'. Используется $QueryTimeoutSec сек."
        }
    }
    Write-Verbose "[$NodeName] SQL: Используется query_timeout_sec: $QueryTimeoutSec сек."

    # --- 2. Подготовка параметров для Invoke-Sqlcmd ---
    $invokeSqlParams = @{
        ServerInstance       = $SqlServerInstance
        Database             = $DatabaseName
        Query                = $SqlQuery
        QueryTimeout         = $QueryTimeoutSec
        ErrorAction          = 'Stop' # Важно для перехвата ошибок SQL в блоке catch
        TrustServerCertificate = $true   # Часто необходимо для тестовых/внутренних сред
        OutputSqlErrors      = $true   # Выводить ошибки SQL в поток ошибок PowerShell
    }
    if (-not [string]::IsNullOrWhiteSpace($SqlUsername)) {
        $securePassword = ConvertTo-SecureString -String $SqlPassword -AsPlainText -Force
        $credential = New-Object System.Management.Automation.PSCredential($SqlUsername, $securePassword)
        $invokeSqlParams.Credential = $credential
        Write-Verbose "[$NodeName] SQL: Используется SQL аутентификация для пользователя '$SqlUsername'."
    } else {
        Write-Verbose "[$NodeName] SQL: Используется Windows аутентификация."
    }

    # --- 3. Проверка наличия модуля SqlServer ---
    if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
        Write-Warning "[$NodeName] SQL: Командлет Invoke-Sqlcmd не найден. Попытка импорта модуля 'SqlServer'..."
        try {
            Import-Module SqlServer -ErrorAction Stop -Scope Local # Импорт в локальную область видимости
            Write-Verbose "[$NodeName] SQL: Модуль 'SqlServer' успешно импортирован."
        } catch {
            throw "Модуль 'SqlServer' не установлен или не может быть импортирован. Установите его командой: Install-Module SqlServer -Scope CurrentUser. Ошибка импорта: $($_.Exception.Message)"
        }
    }

    # --- 4. Выполнение SQL-запроса ---
    Write-Verbose "[$NodeName] SQL: Выполнение запроса к '$SqlServerInstance/$DatabaseName' (формат: $ReturnFormat)..."
    $queryResultData = $null # Результат от Invoke-Sqlcmd
    
    if ($ReturnFormat -eq 'non_query') {
        Invoke-Sqlcmd @invokeSqlParams | Out-Null # Ошибки (включая SQL ошибки) будут пойманы в catch благодаря ErrorAction=Stop и OutputSqlErrors=$true
        $isAvailable = $true # Если дошли сюда без исключения, команда на сервере выполнена
        $details.non_query_success = $true
        Write-Verbose "[$NodeName] SQL: non-query запрос успешно выполнен."
    } else {
        $queryResultData = Invoke-Sqlcmd @invokeSqlParams
        $isAvailable = $true # Если нет исключения, значит, подключение к БД и выполнение запроса удалось
        Write-Verbose "[$NodeName] SQL: запрос, возвращающий данные, выполнен."
        
        # 5. Обработка результата ($queryResultData) в зависимости от $ReturnFormat
        # $details был инициализирован ранее, здесь мы добавляем/обновляем ключи с результатами
        switch ($ReturnFormat) {
            'first_row' { 
                $firstRowResult = $null
                $returnedRowCount = 0
                if ($null -ne $queryResultData) {
                    $queryResultArray = @($queryResultData) # Гарантируем, что это массив
                    $returnedRowCount = $queryResultArray.Count
                    if ($returnedRowCount -gt 0) {
                        $firstRowResult = @{} # Создаем Hashtable для первой строки
                        # Копируем все свойства из объекта DataRow (или PSCustomObject) в Hashtable
                        $queryResultArray[0].PSObject.Properties | ForEach-Object { $firstRowResult[$_.Name] = $_.Value }
                    }
                }
                $details.query_result = $firstRowResult # Будет $null, если запрос не вернул строк
                $details.rows_returned = $returnedRowCount
            }
            'all_rows' { 
                $allRowsResult = [System.Collections.Generic.List[object]]::new()
                $returnedRowCount = 0
                if ($null -ne $queryResultData) {
                    foreach($rowItem in @($queryResultData)) { # Гарантируем массив
                        $rowDataHashtable = @{}
                        $rowItem.PSObject.Properties | ForEach-Object { $rowDataHashtable[$_.Name] = $_.Value }
                        $allRowsResult.Add($rowDataHashtable)
                    }
                    $returnedRowCount = $allRowsResult.Count
                }
                $details.query_result = $allRowsResult # Будет пустым списком, если нет строк
                $details.rows_returned = $returnedRowCount
            }
            'row_count' { 
                $returnedRowCount = 0
                if ($null -ne $queryResultData) { $returnedRowCount = @($queryResultData).Count }
                $details.row_count = $returnedRowCount
            }
            'scalar' { 
                $scalarResultValue = $null
                if ($null -ne $queryResultData) {
                    $queryResultArray = @($queryResultData)
                    if ($queryResultArray.Count -gt 0) {
                        $firstRowObject = $queryResultArray[0]
                        # Получаем имя первого свойства первого объекта результата
                        if ($firstRowObject.PSObject.Properties.Count -gt 0) {
                            $firstPropertyName = $firstRowObject.PSObject.Properties[0].Name
                            $scalarResultValue = $firstRowObject.$firstPropertyName
                        }
                    }
                }
                $details.scalar_value = $scalarResultValue # Будет $null, если запрос не вернул строк/столбцов
            }
        }
        Write-Verbose "[$NodeName] SQL: Результат запроса обработан для формата '$ReturnFormat'."
    }

    # --- 6. Проверка критериев успеха ---
    # $isAvailable уже должен быть true, если не было исключений при выполнении SQL
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] SQL: Вызов Test-SuccessCriteria..."
            $criteriaProcessingResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria -Path '$details'
            
            $checkSuccess = $criteriaProcessingResult.Passed
            $failReasonFromCriteria = $criteriaProcessingResult.FailReason

            if ($checkSuccess -ne $true) { # Если $false или $null (ошибка критерия)
                if (-not [string]::IsNullOrEmpty($failReasonFromCriteria)) {
                    $errorMessage = $failReasonFromCriteria
                } else {
                    $errorMessage = "Критерии успеха для SQL-запроса не пройдены (CheckSuccess: $($checkSuccess | ForEach-Object {if ($_ -eq $null) {'[null]'} else {$_}}))."
                }
                Write-Verbose "[$NodeName] SQL: SuccessCriteria НЕ пройдены или ошибка оценки. ErrorMessage: $errorMessage"
            } else {
                $errorMessage = $null # Критерии пройдены
                Write-Verbose "[$NodeName] SQL: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы - считаем успешным, если сама SQL-проверка прошла (isAvailable=true)
            $checkSuccess = $true 
            $errorMessage = $null
            Write-Verbose "[$NodeName] SQL: SuccessCriteria не заданы, CheckSuccess установлен в true."
        }
    } else { # Этот блок не должен выполняться, если isAvailable=false из-за исключения выше, т.к. будет выполнен основной catch
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) { 
            $errorMessage = "Ошибка выполнения SQL-запроса (IsAvailable=false), критерии не проверялись."
        }
    }

    # --- 7. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< Основной CATCH для критических ошибок (подключение, выполнение SQL, валидация параметров, импорт модуля) >>>
    $isAvailable = $false 
    $checkSuccess = $null   
    
    # Формируем информативное сообщение об ошибке
    $exceptionMessage = $_.Exception.Message
    # Invoke-Sqlcmd при OutputSqlErrors=$true может помещать SQL ошибки в InnerException
    if ($_.Exception.InnerException) {
        $exceptionMessage += " Внутренняя ошибка SQL: $($_.Exception.InnerException.Message)"
    }
    $critErrorMessageFromCatch = "Критическая ошибка в Check-SQL_QUERY_EXECUTE для '$($TargetIP)/$($details.database_name)': $exceptionMessage"
    Write-Error "[$NodeName] Check-SQL_QUERY_EXECUTE: $critErrorMessageFromCatch ScriptStackTrace: $($_.ScriptStackTrace)"
    
    # $details может быть уже частично заполнен, добавляем информацию об ошибке
    if ($null -eq $details) { $details = @{} } 
    if (-not $details.ContainsKey('server_instance')) { $details.server_instance = $TargetIP }
    if (-not $details.ContainsKey('database_name') -and $DatabaseName) { $details.database_name = $DatabaseName } # $DatabaseName может быть не установлен, если ошибка до его парсинга
    if (-not $details.ContainsKey('query_executed') -and $SqlQuery) { $details.query_executed = $SqlQuery }     # Аналогично для $SqlQuery

    $details.error = $critErrorMessageFromCatch # Перезаписываем или добавляем поле error
    $details.ErrorRecord = $_.ToString()        # Сохраняем полный объект ошибки
    
    # Если это была ошибка non_query, помечаем ее неуспешной
    if ($ReturnFormat -eq 'non_query' -and $details.ContainsKey('non_query_success')) {
        $details.non_query_success = $false
    }
    
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $critErrorMessageFromCatch
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Отладка перед возвратом ---
Write-Host "DEBUG (Check-SQL_QUERY_EXECUTE): --- Начало отладки finalResult.Details ---" -ForegroundColor Green
if ($finalResult -and $finalResult.Details) {
    Write-Host "DEBUG (Check-SQL_QUERY_EXECUTE): Тип finalResult.Details: $($finalResult.Details.GetType().FullName)" -ForegroundColor Green
    Write-Host "DEBUG (Check-SQL_QUERY_EXECUTE): Ключи в finalResult.Details: $($finalResult.Details.Keys -join ', ')" -ForegroundColor Green
    # Закомментировано, чтобы не перегружать вывод, но полезно для детальной отладки
    # Write-Host "DEBUG (Check-SQL_QUERY_EXECUTE): Полное содержимое finalResult.Details (JSON): $($finalResult.Details | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue)" -ForegroundColor DarkGreen
} elseif ($finalResult) { Write-Host "DEBUG (Check-SQL_QUERY_EXECUTE): finalResult.Details является $null или отсутствует." -ForegroundColor Yellow}
else { Write-Host "DEBUG (Check-SQL_QUERY_EXECUTE): finalResult сам по себе $null." -ForegroundColor Red }
Write-Host "DEBUG (Check-SQL_QUERY_EXECUTE): --- Конец отладки finalResult.Details ---" -ForegroundColor Green

# --- Возврат результата ---
$isAvailableStrForLog = '[N/A]'
if ($finalResult) { $isAvailableStrForLog = $finalResult.IsAvailable.ToString() }

$checkSuccessStrForLog = '[N/A]'
if ($finalResult) {
    if ($null -eq $finalResult.CheckSuccess) { $checkSuccessStrForLog = '[null]' }
    else { $checkSuccessStrForLog = $finalResult.CheckSuccess.ToString() }
}
Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE (v2.1.1): Завершение. IsAvailable=$isAvailableStrForLog, CheckSuccess=$checkSuccessStrForLog"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1
# --- Версия 2.1.1 --- Рефакторинг, PS 5.1 совместимость, улучшенная обработка ошибок и XML
<#
.SYNOPSIS
    Выполняет SQL-запрос, извлекает XML из указанного столбца первой строки,
    парсит XML и извлекает значения по заданному списку ключей. (v2.1.1)
.DESCRIPTION
    Скрипт подключается к SQL Server, выполняет запрос, который должен вернуть
    хотя бы одну строку с XML-данными в указанном столбце. 
    XML парсится, и из него извлекаются значения элементов, имена которых 
    переданы в параметре 'keys_to_extract'.
    
    Формирует $Details с информацией о запросе, именем XML-столбца, 
    количеством возвращенных строк и хэш-таблицей 'extracted_data' с 
    извлеченными парами ключ-значение.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
    Обрабатывает ошибки подключения, выполнения SQL, отсутствия данных или ошибок парсинга XML.
.PARAMETER TargetIP
    [string] Обязательный. Имя или IP-адрес SQL Server instance.
.PARAMETER Parameters
    [hashtable] Обязательный. Хэш-таблица с параметрами:
                - sql_database ([string], Обязательный): Имя целевой базы данных.
                - sql_query ([string], Обязательный): SQL-запрос, возвращающий XML.
                - xml_column_name ([string], Обязательный): Имя столбца, содержащего XML.
                - keys_to_extract ([string[]], Обязательный): Массив имен XML-элементов для извлечения.
                - sql_username ([string], Опциональный): Имя пользователя для SQL Server аутентификации.
                - sql_password ([string], Опциональный): Пароль.
                - query_timeout_sec ([int], Опциональный, по умолч. 30): Таймаут SQL-запроса.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха, применяемые к $details, особенно к $details.extracted_data.
                Пример: @{ extracted_data = @{ Version = "1.2.3"; Status = @{'!=' = "Error"} } }
.PARAMETER NodeName
    [string] Опциональный. Имя узла (для логирования).
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
.NOTES
    Версия: 2.1.1
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
    Требует модуль 'SqlServer'.
    Предполагается, что извлекаемые ключи являются прямыми потомками корневого элемента XML.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,
    [Parameter(Mandatory = $false)] # Проверяем ключи внутри
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node (SQL_XML_QUERY)"
)

# --- Инициализация ---
$isAvailable = $false
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null
$details = @{
    server_instance   = $TargetIP
    database_name     = $null
    query_executed    = $null
    xml_source_column = $null
    rows_returned     = 0
    extracted_data    = @{} # Для извлеченных ключ-значение из XML
    xml_content_sample = $null # Для отладки при ошибках парсинга
}

$logTargetDisplay = if (-not [string]::IsNullOrWhiteSpace($TargetIP)) { $TargetIP } else { "[SQL Server не указан]" }
Write-Verbose "[$NodeName] Check-SQL_XML_QUERY (v2.1.1): Начало извлечения XML. Сервер: $logTargetDisplay"

# --- Основной блок Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Извлечение и валидация параметров из $Parameters ---
    $SqlServerInstance = $TargetIP

    if (-not $Parameters.ContainsKey('sql_database') -or [string]::IsNullOrWhiteSpace($Parameters.sql_database)) {
        throw "Отсутствует или пуст обязательный параметр 'sql_database'."
    }
    $DatabaseName = $Parameters.sql_database.Trim()
    $details.database_name = $DatabaseName

    if (-not $Parameters.ContainsKey('sql_query') -or [string]::IsNullOrWhiteSpace($Parameters.sql_query)) {
        throw "Отсутствует или пуст обязательный параметр 'sql_query'."
    }
    $SqlQuery = $Parameters.sql_query.Trim()
    $details.query_executed = $SqlQuery

    if (-not $Parameters.ContainsKey('xml_column_name') -or [string]::IsNullOrWhiteSpace($Parameters.xml_column_name)) {
        throw "Отсутствует или пуст обязательный параметр 'xml_column_name'."
    }
    $XmlColumnName = $Parameters.xml_column_name.Trim()
    $details.xml_source_column = $XmlColumnName

    if (-not $Parameters.ContainsKey('keys_to_extract') -or `
        -not ($Parameters.keys_to_extract -is [array]) -or `
        $Parameters.keys_to_extract.Count -eq 0 -or `
        ($Parameters.keys_to_extract | Where-Object {[string]::IsNullOrWhiteSpace($_)})) {
        throw "Параметр 'keys_to_extract' должен быть непустым массивом строк без пустых элементов."
    }
    $KeysToExtract = @($Parameters.keys_to_extract | Where-Object {-not [string]::IsNullOrWhiteSpace($_)})


    $SqlUsername = $null
    if ($Parameters.ContainsKey('sql_username')) { $SqlUsername = $Parameters.sql_username }
    $SqlPassword = $null
    if (-not [string]::IsNullOrWhiteSpace($SqlUsername)) {
        if (-not $Parameters.ContainsKey('sql_password') -or $Parameters.sql_password -eq $null) {
            throw "Параметр 'sql_password' обязателен, если указан 'sql_username'."
        }
        $SqlPassword = $Parameters.sql_password
    }

    $QueryTimeoutSec = 30
    if ($Parameters.ContainsKey('query_timeout_sec') -and $Parameters.query_timeout_sec -ne $null) {
        $parsedTimeout = 0
        if ([int]::TryParse($Parameters.query_timeout_sec.ToString(), [ref]$parsedTimeout) -and $parsedTimeout -gt 0) {
            $QueryTimeoutSec = $parsedTimeout
        } else {
            Write-Warning "[$NodeName] SQL-XML: Некорректное 'query_timeout_sec': '$($Parameters.query_timeout_sec)'. Используется $QueryTimeoutSec сек."
        }
    }
    Write-Verbose "[$NodeName] SQL-XML: Используется query_timeout_sec: $QueryTimeoutSec сек."

    # --- 2. Подготовка параметров для Invoke-Sqlcmd ---
    $invokeSqlParams = @{
        ServerInstance       = $SqlServerInstance
        Database             = $DatabaseName
        Query                = $SqlQuery
        QueryTimeout         = $QueryTimeoutSec
        ErrorAction          = 'Stop'
        TrustServerCertificate = $true
        OutputSqlErrors      = $true
    }
    if (-not [string]::IsNullOrWhiteSpace($SqlUsername)) {
        $invokeSqlParams.Credential = New-Object System.Management.Automation.PSCredential($SqlUsername, (ConvertTo-SecureString -String $SqlPassword -AsPlainText -Force))
        Write-Verbose "[$NodeName] SQL-XML: Используется SQL аутентификация для '$SqlUsername'."
    } else {
        Write-Verbose "[$NodeName] SQL-XML: Используется Windows аутентификация."
    }

    # --- 3. Проверка модуля SqlServer ---
    if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
        Write-Warning "[$NodeName] SQL-XML: Командлет Invoke-Sqlcmd не найден. Попытка импорта 'SqlServer'..."
        try { Import-Module SqlServer -ErrorAction Stop -Scope Local }
        catch { throw "Модуль 'SqlServer' не установлен или не импортируется. Ошибка: $($_.Exception.Message)" }
    }

    # --- 4. Выполнение SQL-запроса ---
    Write-Verbose "[$NodeName] SQL-XML: Выполнение запроса к '$SqlServerInstance/$DatabaseName'..."
    $queryResultData = Invoke-Sqlcmd @invokeSqlParams
    
    # Если Invoke-Sqlcmd не вызвал исключение, считаем, что SQL-часть доступна
    $isAvailable = $true 
    Write-Verbose "[$NodeName] SQL-XML: SQL-запрос выполнен."

    # --- 5. Обработка результата SQL и извлечение XML-строки ---
    $xmlStringContent = $null
    $sqlErrorMessage = $null # Локальная ошибка, если столбец не найден или пуст

    if ($null -ne $queryResultData) {
        $queryResultArray = @($queryResultData) # Гарантируем массив
        $details.rows_returned = $queryResultArray.Count
        Write-Verbose "[$NodeName] SQL-XML: Запрос вернул $($details.rows_returned) строк(у)."

        if ($details.rows_returned -gt 0) {
            $firstRow = $queryResultArray[0]
            if ($firstRow.PSObject.Properties.Name -contains $XmlColumnName) {
                $xmlValueFromDb = $firstRow.$XmlColumnName
                if ($null -ne $xmlValueFromDb -and $xmlValueFromDb -ne [System.DBNull]::Value) {
                    $xmlStringContent = $xmlValueFromDb.ToString()
                    if ([string]::IsNullOrWhiteSpace($xmlStringContent)) {
                        $sqlErrorMessage = "Столбец '$XmlColumnName' в первой строке результата SQL пуст."
                        $xmlStringContent = $null # Убедимся, что не пытаемся парсить пустую строку
                    } else {
                        Write-Verbose "[$NodeName] SQL-XML: Получена непустая XML-строка из столбца '$XmlColumnName'."
                    }
                } else {
                    $sqlErrorMessage = "Столбец '$XmlColumnName' в первой строке результата SQL содержит DBNull или PowerShell `$null."
                }
            } else {
                $sqlErrorMessage = "Столбец '$XmlColumnName' не найден в первой строке результата SQL-запроса. Доступные столбцы: $($firstRow.PSObject.Properties.Name -join ', ')."
            }
        } else { # Запрос не вернул строк
            $details.message = "SQL-запрос не вернул строк, XML для анализа отсутствует."
            Write-Verbose "[$NodeName] SQL-XML: $($details.message)"
            # $isAvailable остается true, но $checkSuccess будет зависеть от критериев (если есть)
            # Если критерии есть, они, вероятно, не пройдут, так как extracted_data будет пуст.
        }
    } else { # Invoke-Sqlcmd вернул $null (например, для некоторых типов запросов или если нет результатов)
        $details.message = "SQL-запрос не вернул данных (результат Invoke-Sqlcmd равен `$null)."
        Write-Verbose "[$NodeName] SQL-XML: $($details.message)"
    }

    if ($null -ne $sqlErrorMessage) {
        # Эта ошибка не критична для $isAvailable (SQL запрос выполнился), но важна для $checkSuccess и $errorMessage
        $errorMessage = $sqlErrorMessage
        $details.error = $sqlErrorMessage # Добавляем в детали
        Write-Warning "[$NodeName] SQL-XML: $sqlErrorMessage"
        # Дальнейший парсинг XML невозможен
    }

    # --- 6. Парсинг XML и извлечение ключей (только если есть $xmlStringContent) ---
    if ($isAvailable -and (-not [string]::IsNullOrWhiteSpace($xmlStringContent))) {
        Write-Verbose "[$NodeName] SQL-XML: Попытка парсинга XML из столбца '$XmlColumnName'..."
        $xmlDoc = $null
        try {
            # Удаляем BOM, если есть, и лишние пробелы
            $cleanXmlString = $xmlStringContent.Trim()
            if ($cleanXmlString.StartsWith($([char]0xFEFF))) { $cleanXmlString = $cleanXmlString.Substring(1) } # UTF-16 BOM
            if ($cleanXmlString.StartsWith($([char]0xEFBBBF))) { $cleanXmlString = $cleanXmlString.Substring(3) } # UTF-8 BOM

            if (-not $cleanXmlString.StartsWith("<")) {
                 throw "Содержимое столбца '$XmlColumnName' не является валидным XML (не начинается с '<')."
            }
            $details.xml_content_sample = if ($cleanXmlString.Length -gt 200) { $cleanXmlString.Substring(0,200) + "..." } else { $cleanXmlString }
            
            $xmlDoc = New-Object System.Xml.XmlDocument
            $xmlDoc.LoadXml($cleanXmlString) # Загружаем очищенную строку
            
            if ($null -eq $xmlDoc.DocumentElement) {
                throw "XML не содержит корневого элемента после парсинга."
            }
            Write-Verbose "[$NodeName] SQL-XML: XML успешно распарсен."

            # Извлечение значений по ключам
            $extractedKeyValues = @{}
            foreach ($keyToExtract in $KeysToExtract) {
                $nodeValue = $null
                # Ищем элемент как прямой потомок корневого элемента
                $xmlNode = $xmlDoc.DocumentElement.SelectSingleNode("./*[local-name()='$keyToExtract']") # local-name() для игнорирования namespace
                if ($null -ne $xmlNode) {
                    $nodeValue = $xmlNode.InnerText # Получаем текстовое содержимое
                }
                $extractedKeyValues[$keyToExtract] = $nodeValue # Добавляем ключ, даже если значение $null (ключ не найден)
                Write-Verbose "[$NodeName] SQL-XML: Извлечен ключ '$keyToExtract' = '$nodeValue'"
            }
            $details.extracted_data = $extractedKeyValues

        } catch {
            # Ошибка парсинга XML или извлечения ключей - это провал проверки, но $isAvailable может оставаться true, если SQL запрос прошел
            $parsingErrorMessage = "Ошибка парсинга/обработки XML из '$XmlColumnName': $($_.Exception.Message)"
            $errorMessage = if ([string]::IsNullOrEmpty($errorMessage)) { $parsingErrorMessage } else { "$errorMessage; $parsingErrorMessage" }
            $details.error = $errorMessage # Дополняем или устанавливаем ошибку
            $details.ErrorRecord = $_.ToString()
            Write-Warning "[$NodeName] SQL-XML: $parsingErrorMessage"
            $isAvailable = $false # Считаем, что если XML не распарсился, то проверка недоступна в полной мере
        }
    }

    # --- 7. Проверка критериев успеха ---
    # Критерии проверяются, даже если были некритические ошибки (например, ключ не найден в XML, но XML распарсился)
    # $isAvailable может быть $false из-за ошибки парсинга XML, тогда $checkSuccess будет $null
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] SQL-XML: Вызов Test-SuccessCriteria..."
            # Критерии обычно будут нацелены на $details.extracted_data
            $criteriaProcessingResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria -Path '$details'
            
            $checkSuccess = $criteriaProcessingResult.Passed
            $failReasonFromCriteria = $criteriaProcessingResult.FailReason

            if ($checkSuccess -ne $true) {
                $currentErrorMessage = if (-not [string]::IsNullOrEmpty($failReasonFromCriteria)) { $failReasonFromCriteria }
                                 else { "Критерии успеха для XML-данных не пройдены (CheckSuccess: $($checkSuccess | ForEach-Object {$_ -eq $null ? '[null]' : $_}))." }
                $errorMessage = if ([string]::IsNullOrEmpty($errorMessage)) { $currentErrorMessage } else { "$errorMessage; $currentErrorMessage" }
                Write-Verbose "[$NodeName] SQL-XML: SuccessCriteria НЕ пройдены или ошибка оценки. ErrorMessage: $errorMessage"
            } else {
                # Если критерии пройдены, но ранее была ошибка (например, ключ не найден, но это OK по критериям),
                # то $errorMessage может уже быть установлен. Не перезаписываем его на $null.
                if ($null -eq $details.error) { $errorMessage = $null } # Сбрасываем только если не было ошибок в $details
                Write-Verbose "[$NodeName] SQL-XML: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы. Успех, если $isAvailable и нет ошибок в $details.error
            $checkSuccess = if ($null -eq $details.error) { $true } else { $false }
            # $errorMessage уже должен содержать $details.error, если он есть
            Write-Verbose "[$NodeName] SQL-XML: SuccessCriteria не заданы. CheckSuccess установлен на $checkSuccess (на основе $details.error)."
        }
    } else { # $isAvailable = $false (критическая ошибка SQL или парсинга XML)
        $checkSuccess = $null # Критерии не оценивались
        if ([string]::IsNullOrEmpty($errorMessage)) { 
            $errorMessage = "Ошибка выполнения SQL XML запроса или парсинга XML (IsAvailable=false), критерии не проверялись."
        }
    }

    # --- 8. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< Основной CATCH для критических ошибок скрипта >>>
    $isAvailable = $false 
    $checkSuccess = $null   
    
    $exceptionMessage = $_.Exception.Message
    if ($_.Exception.InnerException) { $exceptionMessage += " Внутренняя ошибка: $($_.Exception.InnerException.Message)"}
    $critErrorMessageFromCatch = "Критическая ошибка в Check-SQL_XML_QUERY для '$($TargetIP)/$($details.database_name)': $exceptionMessage"
    Write-Error "[$NodeName] Check-SQL_XML_QUERY: $critErrorMessageFromCatch ScriptStackTrace: $($_.ScriptStackTrace)"
    
    if ($null -eq $details) { $details = @{} }
    if (-not $details.ContainsKey('server_instance')) { $details.server_instance = $TargetIP }
    # Заполняем поля из параметров, если они были установлены до ошибки
    if (-not $details.ContainsKey('database_name') -and $DatabaseName) { $details.database_name = $DatabaseName }
    if (-not $details.ContainsKey('query_executed') -and $SqlQuery) { $details.query_executed = $SqlQuery }
    if (-not $details.ContainsKey('xml_source_column') -and $XmlColumnName) { $details.xml_source_column = $XmlColumnName }

    $details.error = $critErrorMessageFromCatch
    $details.ErrorRecord = $_.ToString()
        
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $critErrorMessageFromCatch
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Отладка перед возвратом ---
Write-Host "DEBUG (Check-SQL_XML_QUERY): --- Начало отладки finalResult.Details ---" -ForegroundColor Green
# ... (ваш отладочный блок) ...
if ($finalResult -and $finalResult.Details) {
    Write-Host "DEBUG (Check-SQL_XML_QUERY): Тип finalResult.Details: $($finalResult.Details.GetType().FullName)" -ForegroundColor Green
    Write-Host "DEBUG (Check-SQL_XML_QUERY): Ключи в finalResult.Details: $($finalResult.Details.Keys -join ', ')" -ForegroundColor Green
    # Закомментировано, чтобы не перегружать вывод
    # Write-Host "DEBUG (Check-SQL_XML_QUERY): Полное содержимое finalResult.Details (JSON): $($finalResult.Details | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue)" -ForegroundColor DarkGreen
} elseif ($finalResult) { Write-Host "DEBUG (Check-SQL_XML_QUERY): finalResult.Details является $null или отсутствует." -ForegroundColor Yellow}
else { Write-Host "DEBUG (Check-SQL_XML_QUERY): finalResult сам по себе $null." -ForegroundColor Red }
Write-Host "DEBUG (Check-SQL_XML_QUERY): --- Конец отладки finalResult.Details ---" -ForegroundColor Green

# --- Возврат результата ---
$isAvailableStrForLog = '[N/A]'
if ($finalResult) { $isAvailableStrForLog = $finalResult.IsAvailable.ToString() }
$checkSuccessStrForLog = '[N/A]'
if ($finalResult) {
    if ($null -eq $finalResult.CheckSuccess) { $checkSuccessStrForLog = '[null]' }
    else { $checkSuccessStrForLog = $finalResult.CheckSuccess.ToString() }
}
Write-Verbose "[$NodeName] Check-SQL_XML_QUERY (v2.1.1): Завершение. IsAvailable=$isAvailableStrForLog, CheckSuccess=$checkSuccessStrForLog"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md ====

---
**5. `Checks\README-Check-CERT_EXPIRY.md` (Обновленный)**
---
```markdown
# Check-CERT_EXPIRY.ps1 (v2.1.0+)

**Назначение:**

Этот скрипт проверяет сроки действия локально установленных сертификатов Windows.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется только для логирования.
2.  Извлекает параметры из `$Parameters`: `store_location`, `store_name`, `subject_like`, `issuer_like`, `thumbprint`, `require_private_key`, `eku_oid`, `min_days_warning`. Устанавливает значения по умолчанию, если параметры не переданы.
3.  Определяет список хранилищ для поиска: либо указанное в параметрах, либо стандартный список (`LocalMachine\My`, `LocalMachine\WebHosting`, `CurrentUser\My`).
4.  Итерирует по списку хранилищ:
    *   Проверяет доступность хранилища через `Test-Path`.
    *   Вызывает `Get-ChildItem` для получения сертификатов. Обрабатывает ошибки доступа.
    *   Собирает все найденные сертификаты в список.
5.  Устанавливает `IsAvailable = $true`, если удалось проверить хотя бы одно хранилище. Если нет - `$IsAvailable = $false`. Ошибки доступа к отдельным хранилищам записываются в `Details.store_access_errors`.
6.  Фильтрует собранный список сертификатов согласно параметрам (`Thumbprint` имеет приоритет над `SubjectLike`/`IssuerLike`, затем применяются `RequirePrivateKey` и `EkuOids`). Устанавливает флаг `Details.filter_applied`.
7.  Для каждого отфильтрованного сертификата:
    *   Рассчитывает количество дней до истечения (`days_left`).
    *   Определяет статус сертификата (`OK`, `Expired`, `ExpiringSoon`) на основе `days_left` и `min_days_warning`.
    *   Собирает информацию (`thumbprint`, `subject`, `issuer`, даты, `days_left`, `has_private_key`, `status`, `status_details`, `store_path`) в хэш-таблицу.
    *   Добавляет хэш-таблицу в массив `$details.certificates`.
8.  Сортирует `$details.certificates` по `days_left`.
9.  Если после фильтрации сертификатов не осталось, добавляет сообщение в `$details.message`.
10. Если `$isAvailable` равен `$true` и `$SuccessCriteria` предоставлены, вызывает `Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria`.
    *   Критерии обычно применяются к массиву `$details.certificates`.
11. Устанавливает `CheckSuccess` в `$true`, `$false` или `$null`.
12. Формирует `ErrorMessage`, учитывая результат критериев и ошибки доступа к хранилищам.
13. Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Необязательный): IP/Имя хоста (для логирования).
*   `$Parameters` ([hashtable], Необязательный): Параметры поиска и фильтрации.
*   `$SuccessCriteria` ([hashtable], Необязательный): Критерии успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `store_location` ([string], Необязательный): 'LocalMachine' или 'CurrentUser'. Если указан вместе с `store_name`, ищет только там.
*   `store_name` ([string], Необязательный): Имя хранилища ('My', 'WebHosting', etc.). Если указан вместе с `store_location`, ищет только там.
*   `subject_like` ([string], Необязательный): Фильтр по Subject (CN). Wildcard `*`.
*   `issuer_like` ([string], Необязательный): Фильтр по Issuer. Wildcard `*`.
*   `thumbprint` ([string], Необязательный): Точный отпечаток (приоритетный фильтр).
*   `require_private_key` ([bool], Необязательный, по умолч. `$false`): Искать только с приватным ключом.
*   `eku_oid` ([string[]], Необязательный): Массив OID'ов Enhanced Key Usage. Сертификат должен содержать хотя бы один из них.
*   `min_days_warning` ([int], Необязательный, по умолч. 30): Порог в днях для статуса 'ExpiringSoon' (не влияет на CheckSuccess).

**Критерии успеха (`$SuccessCriteria`)**:

*   Применяются к объекту `$details`. Основное поле для проверки - массив `certificates`.
*   **Структура для проверки массива `certificates`:**
    ```json
    {
      "certificates": {
        "_condition_": "all" / "any" / "none" / "count",
        "_where_": { <поле_сертификата>: <критерий> }, // Опционально
        "_criteria_": { <поле_сертификата>: <критерий> }, // Для all/any/none
        "_count_": { <оператор>: <число> } // Для count
      }
    }
    ```
*   **Поля сертификата для проверки (`<поле_сертификата>`):** `thumbprint`, `subject`, `issuer`, `days_left`, `has_private_key`, `status`.
*   **Примеры:**
    *   Все найденные сертификаты должны иметь `days_left > 30`: `@{ certificates = @{ _condition_='all'; _criteria_=@{days_left=@{'>'=30}}} }`
    *   Ни один сертификат не должен быть 'Expired': `@{ certificates = @{ _condition_='none'; _where_=@{status='Expired'}} }`
    *   Хотя бы один SSL-сертификат истекает менее чем через 15 дней: `@{ certificates = @{ _condition_='any'; _where_=@{eku_oid=@{'contains'='1.3.6.1.5.5.7.3.1'}}; _criteria_=@{days_left=@{'<'=15}}} }` (Примечание: EKU проверяется при фильтрации в `$Parameters`, а не через `_where_` здесь). Условие для ANY будет проще: `@{ certificates = @{ _condition_='any'; _criteria_=@{days_left=@{'<'=15}}} }` (применится ко всем отфильтрованным сертификатам).

**Возвращаемый результат (`$Details`)**:

*   `certificates` (object[]): Массив хэш-таблиц для каждого найденного и отфильтрованного сертификата. Каждая содержит:
    *   `thumbprint`, `subject`, `issuer` (string)
    *   `not_before_utc`, `not_after_utc` (string ISO 8601)
    *   `days_left` (int)
    *   `has_private_key` (bool)
    *   `status` (string): 'OK', 'Expired', 'ExpiringSoon'
    *   `status_details` (string)
    *   `store_path` (string)
*   `stores_checked` (string[]): Список проверенных хранилищ.
*   `parameters_used` (hashtable): Параметры, фактически использованные для поиска/фильтрации.
*   `filter_applied` (bool): Применялись ли фильтры?
*   `message` (string, опционально): Сообщение, если сертификаты не найдены.
*   `store_access_errors` (string[], опционально): Список ошибок доступа к хранилищам.
*   `error` (string, опционально): Сообщение об основной ошибке проверки.
*   `ErrorRecord` (string, опционально): Полная информация об исключении.

**Пример конфигурации Задания (Assignment):**

```json
// Проверить все сертификаты в LocalMachine\My, 
// у которых есть приватный ключ, 
// и убедиться, что все они действительны еще > 30 дней
{
  "node_id": 50,
  "method_id": 7, // ID для CERT_EXPIRY
  "is_enabled": true,
  "parameters": {
    "store_location": "LocalMachine",
    "store_name": "My",
    "require_private_key": true,
    "min_days_warning": 60 
  },
  "success_criteria": {
    "certificates": { 
        "_condition_": "all",
        "_criteria_": { "days_left": { ">": 30 } }
    }
  },
  "description": "Проверка сертификатов в LM\\My (>30 дней, с ключом)"
}

IGNORE_WHEN_COPYING_END

Возможные ошибки и замечания:

    Права доступа: Доступ к LocalMachine требует прав администратора.

    Отсутствие хранилищ: Скрипт обрабатывает отсутствие стандартных хранилищ (например, WebHosting).

    EKU Фильтрация: Проверяет наличие хотя бы одного из указанных OID в расширении EKU сертификата.

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.

    Доступ к хранилищам сертификатов Windows.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md ====

---
**3. `Checks\README-Check-DISK_USAGE.md` (Обновленный)**
---
```markdown
# Check-DISK_USAGE.ps1 (v2.1.0+)

**Назначение:**

Этот скрипт проверяет использование дискового пространства на локальных дисках, используя командлет `Get-Volume`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется только для логирования.
2.  Вызывает `Get-Volume` для получения информации обо всех томах локально. Если команда не выполняется, устанавливает `IsAvailable = $false`.
3.  Фильтрует полученные тома:
    *   Оставляет только диски с `DriveType = 'Fixed'`.
    *   Оставляет только диски, имеющие букву (`DriveLetter`).
    *   Если в `$Parameters.drives` передан массив букв, оставляет только диски из этого списка.
4.  Для каждого отфильтрованного диска:
    *   Рассчитывает общий размер, свободное/занятое место в байтах и ГБ, процент свободного/занятого места.
    *   Собирает информацию в хэш-таблицу.
    *   Добавляет эту хэш-таблицу в массив `$details.disks`.
5.  Если после фильтрации дисков не осталось, добавляет сообщение в `$details.message`.
6.  Если `$isAvailable` равен `$true` и `$SuccessCriteria` предоставлены, вызывает `Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria`.
    *   Критерии обычно применяются к массиву `$details.disks` с использованием `_condition_`, `_where_`, `_criteria_`.
7.  Устанавливает `CheckSuccess` в `$true`, `$false` или `$null` (при ошибке критерия).
8.  Формирует `ErrorMessage`, если `$isAvailable` или `$checkSuccess` равны `$false`, или если `$checkSuccess` равен `$null` при `$IsAvailable = $true`.
9.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Необязательный): IP-адрес или имя хоста (для логирования).
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `drives` ([string[]], Необязательный): Массив строк с буквами дисков для проверки (например, `@('C', 'D')`). Регистр не важен. Если не указан, проверяются все локальные Fixed-диски.

**Критерии успеха (`$SuccessCriteria`)**:

*   Применяются к объекту `$details`. Основное поле для проверки - массив `disks`.
*   **Структура для проверки массива `disks`:**
    ```json
    {
      "disks": {
        "_condition_": "all" / "any" / "none" / "count",
        "_where_": { <поле_диска>: <простой_критерий_или_операторный_блок> }, // Опционально
        "_criteria_": { <поле_диска>: <простой_критерий_или_операторный_блок> }, // Обязательно для all/any/none с элементами
        "_count_": { <оператор>: <число> } // Обязательно для count
      }
    }
    ```
*   **Поля диска для проверки (`<поле_диска>`):** `drive_letter`, `label`, `filesystem`, `size_bytes`, `free_bytes`, `used_bytes`, `size_gb`, `free_gb`, `used_gb`, `percent_free`, `percent_used`.
*   **Примеры:**
    *   Все диски > 10% свободного места: `@{ disks = @{ _condition_='all'; _criteria_=@{percent_free=@{'>'=10.0}}} }`
    *   Хотя бы один диск с буквой C или D имеет < 5% свободного места: `@{ disks = @{ _condition_='any'; _where_=@{drive_letter=@{'matches'}='^(C|D)$'}}; _criteria_=@{percent_free=@{'<'=5.0}}} }`
    *   Количество дисков с размером > 1 ТБ (в байтах) ровно 1: `@{ disks = @{ _condition_='count'; _where_=@{size_bytes=@{'>'=(1TB)}}; _count_=@{'=='=1}} }`

**Возвращаемый результат (`$Details`)**:

*   `disks` (object[]): Массив хэш-таблиц, по одной для каждого проверенного диска. Каждая содержит:
    *   `drive_letter` (string)
    *   `label` (string)
    *   `filesystem` (string)
    *   `size_bytes` (long), `free_bytes` (long), `used_bytes` (long)
    *   `size_gb` (double), `free_gb` (double), `used_gb` (double)
    *   `percent_free` (double), `percent_used` (double)
*   `message` (string, опционально): Сообщение, если диски не найдены.
*   `error` (string, опционально): Сообщение об ошибке `Get-Volume`.
*   `ErrorRecord` (string, опционально): Полная информация об исключении.

**Пример конфигурации Задания (Assignment):**

```json
// Проверить диск C (>15%) и все остальные (>5%)
{
  "node_id": 10,
  "method_id": 5, // ID для DISK_USAGE
  "is_enabled": true,
  "parameters": null, // Проверяем все диски
  "success_criteria": {
    "disks": [ // Можно передать массив критериев, которые будут проверяться ПО ОЧЕРЕДИ
        // Критерий 1: Диск C должен иметь >= 15%
        { "_condition_": "all", "_where_": {"drive_letter": "C"}, "_criteria_": { "percent_free": { ">=": 15 } } },
        // Критерий 2: Все ОСТАЛЬНЫЕ диски (не C) должны иметь > 5%
        { "_condition_": "all", "_where_": {"drive_letter": {"!=":"C"}}, "_criteria_": { "percent_free": { ">": 5 } } }
    ]
    // АЛЬТЕРНАТИВНО (если Test-SuccessCriteria поддерживает массив критериев для одного ключа):
    // "disks": { 
    //     "_condition_": "all", // Применяется к обоим критериям ниже? Или как? УТОЧНИТЬ работу TSC с массивом критериев. 
    //                            // Вероятно, лучше передавать один сложный объект criteria.
    //     "_criteria_": [
    //        {"_where_": {"drive_letter": "C"}, "_check_": {"percent_free": {">=":15}}}, 
    //        {"_where_": {"drive_letter": {"!=":"C"}}, "_check_": {"percent_free": {">":5}}}
    //      ]
    // }
    // ПОКА ЧТО Test-SuccessCriteria НЕ поддерживает массив критериев. Используйте отдельные проверки или более сложные _where_.
  },
  "description": "Проверка места: C>=15%, остальные >5%"
}

Примечание по массиву критериев: Текущая реализация Test-SuccessCriteria не поддерживает массив критериев для одного ключа. Если нужны сложные условия "И" для разных подмножеств массива, их нужно либо объединять в один критерий с более сложным _where_ (если возможно), либо создавать отдельные Задания мониторинга.

Возможные ошибки и замечания:

    Версия ОС: Требуется Windows 8 / Windows Server 2012+.

    Права доступа: Обычно не требует повышенных прав.

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.

    Командлет Get-Volume (модуль Storage).
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md ====
# Check-PING.ps1 (v2.3.2+)

**Назначение:**

Этот скрипт выполняет проверку доступности сетевого узла с помощью ICMP эхо-запросов (пинг), используя класс `System.Net.NetworkInformation.Ping`.

**Принцип работы:**

1.  Получает целевой IP-адрес или имя хоста (`TargetIP`) и опциональные параметры (`Parameters`, `SuccessCriteria`) от диспетчера `Invoke-StatusMonitorCheck`.
2.  Извлекает параметры пинга из `$Parameters`:
    *   `count` (количество запросов, по умолчанию 1).
    *   `timeout_ms` (таймаут для каждого запроса в мс, по умолчанию 1000).
    *   `buffer_size` (размер буфера, по умолчанию 32).
    *   `ttl` (Time-To-Live, по умолчанию 128).
3.  Отправляет указанное количество ICMP-запросов к `$TargetIP` с помощью `System.Net.NetworkInformation.Ping.Send()`.
4.  Анализирует ответы:
    *   Подсчитывает количество успешных ответов (`packets_received`).
    *   Рассчитывает процент потерь (`packet_loss_percent`).
    *   Рассчитывает среднее время ответа (`rtt_ms`) для успешных запросов.
    *   Фиксирует IP-адрес ответившего хоста (`ip_address`) из первого успешного ответа.
    *   Записывает статус первого ответа или общее сообщение об ошибке (`status_string`, `error`).
5.  Устанавливает `IsAvailable = $true`, если был получен **хотя бы один** успешный ответ (`Status = Success`). Иначе `IsAvailable = $false`.
6.  Заполняет хэш-таблицу `$Details` собранными метриками.
7.  Если `$SuccessCriteria` предоставлены и `$isAvailable` равен `$true`, вызывает `Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria` для оценки критериев.
    *   Критерии обычно применяются к полям `rtt_ms` и `packet_loss_percent`.
8.  Устанавливает `CheckSuccess` в `$true`, `$false` или `$null` (если критерии не заданы, выполнены, не выполнены или была ошибка их оценки).
9.  Формирует `ErrorMessage`, если `$isAvailable` или `$checkSuccess` равны `$false`, или если `$checkSuccess` равен `$null` при `$isAvailable = $true`.
10. Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста для пинга.
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами пинга.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `count` ([int], Необязательный, по умолч. 1): Количество ICMP-запросов для отправки.
*   `timeout_ms` ([int], Необязательный, по умолч. 1000): Таймаут ожидания ответа на **каждый** ICMP-запрос в миллисекундах.
*   `buffer_size` ([int], Необязательный, по умолч. 32): Размер буфера ICMP в байтах (макс. 65500).
*   `ttl` ([int], Необязательный, по умолч. 128): Максимальное количество переходов (hops) для пакета.

**Критерии успеха (`$SuccessCriteria`)**:

*   Применяются к объекту `$details`. Чаще всего используются для проверки:
    *   `rtt_ms` ([int]): Среднее время ответа в мс. Пример: `@{ rtt_ms = @{ '<=' = 100 } }`
    *   `packet_loss_percent` ([double]): Процент потерянных пакетов. Пример: `@{ packet_loss_percent = @{ '==' = 0 } }`
*   Можно комбинировать несколько критериев: `@{ rtt_ms = @{ '<' = 50 }; packet_loss_percent = @{ '<' = 10 } }`

**Возвращаемый результат (`$Details`)**:

*   `target_ip` (string): IP-адрес или имя хоста, которое пинговали.
*   `packets_sent` (int): Количество отправленных пакетов.
*   `packets_received` (int): Количество полученных успешных ответов.
*   `packet_loss_percent` (double): Процент потерянных пакетов.
*   `rtt_ms` (int/null): Среднее время ответа в мс для успешных пакетов (null, если не было успешных).
*   `ip_address` (string/null): Фактический IP-адрес, ответивший на пинг (из первого успешного ответа, null если не было успешных).
*   `status_string` (string): Строковое представление статуса первой попытки пинга (например, 'Success', 'TimedOut', 'DestinationHostUnreachable') или общее сообщение об ошибке.
*   `error` (string, опционально): Сообщение об основной ошибке, если пинг не удался.
*   `individual_ping_errors` (string[], опционально): Список ошибок для отдельных попыток пинга (если `count > 1` и были неудачные попытки, но хотя бы одна удалась).
*   `ErrorRecord` (string, опционально): Полная информация об исключении PowerShell, если произошла критическая ошибка.

**Пример конфигурации Задания (Assignment):**

```json
// Пинг шлюза 4 раза, RTT < 50мс, потери < 10%
{
  "node_id": 25,
  "method_id": 1, // ID для PING
  "is_enabled": true,
  "parameters": {
    "count": 4,
    "timeout_ms": 500
  },
  "success_criteria": {
    "rtt_ms": { "<": 50 },
    "packet_loss_percent": { "<": 10 }
  },
  "description": "Пинг шлюза (4x, <50ms, <10% loss)"
}

IGNORE_WHEN_COPYING_END

Возможные ошибки и замечания:

    Брандмауэр: ICMP Echo Request/Reply (Тип 8/Тип 0) должны быть разрешены.

    Разрешение имен: Если используется имя хоста, оно должно разрешаться в IP.

    Права: Обычно не требуются повышенные права.

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.

    .NET Framework (для System.Net.NetworkInformation.Ping).
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md ====
Примечание по массиву критериев: Текущая реализация Test-SuccessCriteria не поддерживает массив критериев для одного ключа. Если нужны сложные условия "И" для разных подмножеств массива, их нужно либо объединять в один критерий с более сложным _where_ (если возможно), либо создавать отдельные Задания мониторинга.

Возможные ошибки и замечания:

    Версия ОС: Требуется Windows 8 / Windows Server 2012+.

    Права доступа: Обычно не требует повышенных прав.

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.

    Командлет Get-Volume (модуль Storage).

    IGNORE_WHEN_COPYING_END

Возможные ошибки и замечания:

    Права доступа: Для username и path часто нужны права администратора.

    Производительность: Включение username и path может замедлить проверку.

    Критерии и top_n: Критерии успеха (SuccessCriteria) применяются к полному списку процессов (после фильтрации по process_names, но до применения top_n). Если вам нужно проверить только топ N процессов, это потребует более сложного критерия или отдельной проверки.

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.

    Командлет Get-Process, Get-CimInstance (стандартные).
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md ====

---
**2. `Checks\README-Check-SERVICE_STATUS.md` (Обновленный)**
---
```markdown
# Check-SERVICE_STATUS.ps1 (v2.0.2+)

**Назначение:**

Этот скрипт проверяет статус указанной системной службы Windows с помощью командлета `Get-Service`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется только для логирования, так как `Get-Service` выполняется локально.
2.  Извлекает **обязательное** имя службы из `$Parameters.service_name`. Если параметр отсутствует или пуст, генерирует ошибку.
3.  Вызывает `Get-Service -Name $serviceName`.
4.  **Если `Get-Service` вернул объект службы:**
    *   Устанавливает `IsAvailable = $true`.
    *   Извлекает текущий статус (`Running`, `Stopped`, `Paused`, etc.), отображаемое имя (`display_name`), тип запуска (`start_type`), возможность остановки (`can_stop`).
    *   Заполняет `$Details` этой информацией.
5.  **Если `Get-Service` выдал ошибку `ServiceCommandException` (служба не найдена):**
    *   Устанавливает `IsAvailable = $true` (так как проверка была выполнена).
    *   Устанавливает `CheckSuccess = $false` (по умолчанию ненайденная служба - это провал).
    *   Записывает сообщение "Служба не найдена" в `ErrorMessage` и `Details.error`.
    *   Устанавливает `Details.status = "NotFound"`.
6.  **Если `Get-Service` выдал другую ошибку (нет доступа, RPC недоступен и т.д.):**
    *   Выбрасывается исключение, которое ловится основным `catch`.
    *   Устанавливается `IsAvailable = $false`.
    *   `CheckSuccess` остается `$null`.
    *   Формируется `ErrorMessage` с деталями исключения.
7.  **Проверка критериев успеха:**
    *   Если `$isAvailable` равен `$true` и `$SuccessCriteria` предоставлены, вызывает `Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria`.
    *   Критерии обычно применяются к полям `status`, `start_type`, `can_stop` и т.д.
    *   Устанавливает `CheckSuccess` в `$true`, `$false` или `$null` (при ошибке критерия).
    *   Если критерии не заданы: `CheckSuccess` устанавливается в `$true`, если статус службы не "NotFound", иначе в `$false`.
8.  Формирует итоговый `ErrorMessage`, учитывая как ошибки выполнения, так и результаты проверки критериев.
9.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Необязательный): IP-адрес или имя хоста (для логирования).
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `service_name` ([string], **Обязательный**): Системное имя службы Windows (например, 'Spooler', 'wuauserv').

**Критерии успеха (`$SuccessCriteria`)**:

*   Применяются к объекту `$details`. Часто проверяются поля:
    *   `status` (string): Ожидаемый статус ('Running', 'Stopped', 'Paused'). Пример: `@{ status = 'Running' }` или `@{ status = @{ '!=' = 'Stopped' } }`
    *   `start_type` (string): Ожидаемый тип запуска ('Automatic', 'Manual', 'Disabled'). Пример: `@{ start_type = 'Automatic' }`
    *   `can_stop` (bool): Ожидаемая возможность остановки. Пример: `@{ can_stop = $true }`
    *   Можно проверять на отсутствие службы, используя статус 'NotFound': `@{ status = 'NotFound' }` (ожидаем, что служба не найдена).

**Возвращаемый результат (`$Details`)**:

*   `service_name` (string): Имя проверенной службы.
*   `status` (string): Текущий статус службы ('Running', 'Stopped', 'Paused', 'NotFound', etc.).
*   `display_name` (string/null): Отображаемое имя службы (если найдена).
*   `start_type` (string/null): Тип запуска службы (если найдена).
*   `can_stop` (bool/null): Может ли служба быть остановлена (если найдена).
*   `error` (string, опционально): Сообщение об ошибке, если служба не найдена или произошла другая ошибка.
*   `ErrorRecord` (string, опционально): Полная информация об исключении PowerShell, если произошла критическая ошибка.

**Пример конфигурации Задания (Assignment):**

```json
// Проверить, что служба 'Spooler' запущена И тип запуска 'Automatic'
{
  "node_id": 55,
  "method_id": 4, // ID для SERVICE_STATUS
  "is_enabled": true,
  "parameters": {
    "service_name": "Spooler"
  },
  "success_criteria": {
    "status": "Running", 
    "start_type": "Automatic"
  },
  "description": "Проверка службы печати (Spooler)"
}

IGNORE_WHEN_COPYING_END

Возможные ошибки и замечания:

    Права доступа: Обычно не требует повышенных прав для локальной проверки. Для удаленной (если бы была реализована через -ComputerName) потребуются права и WinRM.

    Имя службы: Убедитесь, что service_name указано правильно (системное имя).

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md ====

---
**6. `Checks\README-Check-SQL_QUERY_EXECUTE.md` (Обновленный)**
---
```markdown
# Check-SQL_QUERY_EXECUTE.ps1 (v2.1.1+)

**Назначение:**

Этот скрипт выполняет произвольный SQL-запрос к Microsoft SQL Server и возвращает результат в заданном формате.

**Принцип работы:**

1.  Получает параметры (`TargetIP` как имя SQL Server Instance, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера.
2.  Извлекает и валидирует обязательные параметры из `$Parameters`: `sql_database`, `sql_query`.
3.  Извлекает опциональные параметры: `return_format` (по умолч. 'first_row'), `sql_username`, `sql_password`, `query_timeout_sec` (по умолч. 30). Проверяет их корректность.
4.  Проверяет наличие модуля `SqlServer`. Если отсутствует или не импортируется, генерирует ошибку (`IsAvailable = $false`).
5.  Формирует параметры для `Invoke-Sqlcmd`, включая учетные данные и `OutputSqlErrors = $true`.
6.  Вызывает `Invoke-Sqlcmd`. Если возникает ошибка (подключения или выполнения SQL), устанавливает `IsAvailable = $false` и записывает ошибку.
7.  Если запрос выполнен успешно:
    *   Устанавливает `IsAvailable = $true`.
    *   Обрабатывает результат `$queryResultData` в соответствии с `return_format`:
        *   `first_row`: Записывает первую строку (как `Hashtable`) в `Details.query_result` и количество строк в `Details.rows_returned`.
        *   `all_rows`: Записывает все строки (как `List<object>` из `Hashtable`) в `Details.query_result` и количество в `Details.rows_returned`.
        *   `row_count`: Записывает количество строк в `Details.row_count`.
        *   `scalar`: Записывает значение первого столбца первой строки в `Details.scalar_value`.
        *   `non_query`: Записывает `$true` в `Details.non_query_success`.
    *   Заполняет другие поля `$Details` (server_instance, database_name и т.д.).
8.  Если `$isAvailable = $true` и `$SuccessCriteria` предоставлены, вызывает `Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria`.
    *   Критерии могут применяться к полям `row_count`, `scalar_value`, `non_query_success`, `query_result` (если это хэш) или к массиву `query_result` (если `all_rows`).
9.  Устанавливает `CheckSuccess` в `$true`, `$false` или `$null`.
10. Формирует `ErrorMessage`.
11. Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], **Обязательный**): Имя или IP-адрес SQL Server instance.
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами SQL.
*   `$SuccessCriteria` ([hashtable], Необязательный): Критерии успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `sql_database` ([string], **Обязательный**): Имя базы данных.
*   `sql_query` ([string], **Обязательный**): SQL-запрос для выполнения.
*   `return_format` ([string], Необязательный, по умолч. `'first_row'`): Формат результата (`first_row`, `all_rows`, `row_count`, `scalar`, `non_query`).
*   `sql_username` ([string], Необязательный): Имя пользователя SQL Auth.
*   `sql_password` ([string], Необязательный): Пароль SQL Auth (обязателен при `sql_username`). **Небезопасно.**
*   `query_timeout_sec` ([int], Необязательный, по умолч. 30): Таймаут запроса.

**Критерии успеха (`$SuccessCriteria`)**:

*   Применяются к объекту `$details`. Примеры:
    *   `@{ row_count = @{'>='=1} }`
    *   `@{ scalar_value = "OK" }`
    *   `@{ non_query_success = $true }`
    *   `@{ query_result = @{ Status = "Completed" } }` (для `first_row`)
    *   `@{ query_result = @{ _condition_="all"; _criteria_=@{ Value = @{">"=0} } } }` (для `all_rows`)

**Возвращаемый результат (`$Details`)**:

*   `server_instance` (string)
*   `database_name` (string)
*   `query_executed` (string)
*   `return_format_used` (string)
*   *В зависимости от `return_format`*:
    *   `query_result` (hashtable или List<object>)
    *   `rows_returned` (int)
    *   `row_count` (int)
    *   `scalar_value` (any)
    *   `non_query_success` (bool)
*   `error` (string, опционально)
*   `ErrorRecord` (string, опционально)

**Пример конфигурации Задания (Assignment):**

```json
// Получить количество строк в таблице Logs за последний час
{
  "node_id": 61,
  "method_id": 9, // ID для SQL_QUERY_EXECUTE
  "is_enabled": true,
  "parameters": {
    "sql_database": "AppLogs",
    "sql_query": "SELECT COUNT(*) FROM dbo.Logs WHERE LogTime >= DATEADD(hour, -1, GETUTCDATE())",
    "return_format": "scalar" 
  },
  "success_criteria": {
    // Провал, если за час было > 1000 логов (аномалия)
    "scalar_value": { "<": 1000 } 
  },
  "description": "Количество логов за последний час < 1000"
}

Возможные ошибки и замечания:

    Модуль SqlServer: Требуется Install-Module SqlServer.

    Права доступа к SQL: Необходимы права на подключение и выполнение запроса.

    Безопасность пароля: Избегайте использования SQL Auth с паролем в параметрах.

    all_rows: Используйте с осторожностью для больших таблиц.

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.

    Модуль PowerShell SqlServer.

    Доступ к MS SQL Server.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md ====

---
**7. `Checks\README-Check-SQL_XML_QUERY.md` (Обновленный)**
---
```markdown
# Check-SQL_XML_QUERY.ps1 (v2.1.1+)

**Назначение:**

Этот скрипт выполняет SQL-запрос к Microsoft SQL Server, извлекает XML-данные из указанного столбца первой строки результата, парсит этот XML и извлекает значения по заданному списку ключей (имен элементов).

**Принцип работы:**

1.  Получает параметры (`TargetIP` как имя SQL Server Instance, `Parameters`, `SuccessCriteria`, `NodeName`).
2.  Извлекает и валидирует обязательные параметры из `$Parameters`: `sql_database`, `sql_query`, `xml_column_name`, `keys_to_extract`.
3.  Извлекает опциональные параметры: `sql_username`, `sql_password`, `query_timeout_sec`.
4.  Проверяет наличие и импортирует модуль `SqlServer`.
5.  Формирует параметры для `Invoke-Sqlcmd`.
6.  Выполняет SQL-запрос. Ошибки подключения/выполнения устанавливают `IsAvailable = $false`.
7.  Если SQL-запрос успешен (`$isAvailable = $true`):
    *   Проверяет результат: наличие строк, наличие столбца `xml_column_name`, непустое ли значение в нем. Если данные для XML не найдены или некорректны, устанавливает `$errorMessage`, но `$isAvailable` может остаться `$true`.
    *   Если XML-строка получена:
        *   Пытается распарсить XML (удаляя BOM).
        *   Если парсинг неудачен, устанавливает `$isAvailable = $false` и `$errorMessage`.
        *   Если XML распарсен успешно:
            *   Итерирует по `$keys_to_extract`.
            *   Извлекает текстовое содержимое элементов (используя `SelectSingleNode` и `local-name()` для игнорирования namespace).
            *   Записывает извлеченные пары ключ-значение в `$details.extracted_data`.
8.  Если `$isAvailable` равен `$true` и `$SuccessCriteria` предоставлены, вызывает `Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria`.
    *   Критерии обычно применяются к хэш-таблице `$details.extracted_data`.
9.  Устанавливает `CheckSuccess` в `$true`, `$false` или `$null`.
10. Формирует `ErrorMessage`.
11. Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], **Обязательный**): Имя SQL Server instance.
*   `$Parameters` ([hashtable], Обязательный): Параметры SQL и XML.
*   `$SuccessCriteria` ([hashtable], Необязательный): Критерии успеха.
*   `$NodeName` ([string], Необязательный): Имя узла.

**Параметры задания (`$Parameters`)**:

*   `sql_database` ([string], **Обязательный**): Имя базы данных.
*   `sql_query` ([string], **Обязательный**): SQL-запрос, возвращающий XML.
*   `xml_column_name` ([string], **Обязательный**): Имя столбца с XML.
*   `keys_to_extract` ([string[]], **Обязательный**): Массив имен XML-элементов для извлечения (прямые потомки корневого элемента).
*   `sql_username` ([string], Необязательный): Имя пользователя SQL Auth.
*   `sql_password` ([string], Необязательный): Пароль SQL Auth. **Небезопасно.**
*   `query_timeout_sec` ([int], Необязательный, по умолч. 30): Таймаут SQL.

**Критерии успеха (`$SuccessCriteria`)**:

*   Применяются к объекту `$details`. Чаще всего используется для проверки `$details.extracted_data`:
    ```json
    {
      "extracted_data": {
        "KeyName1": "ExpectedValue", // Простое равенство
        "KeyName2": { ">": 100 },     // С оператором
        "OptionalKey": { "exists": false } // Проверка отсутствия
      }
    }
    ```

**Возвращаемый результат (`$Details`)**:

*   `server_instance` (string)
*   `database_name` (string)
*   `query_executed` (string)
*   `xml_source_column` (string)
*   `rows_returned` (int)
*   `extracted_data` (hashtable): Извлеченные данные {ключ=значение}. Значение `$null`, если ключ не найден.
*   `xml_content_sample` (string, опционально): Начало XML при ошибке парсинга.
*   `message` (string, опционально): Сообщение (например, если нет строк).
*   `error` (string, опционально): Сообщение об ошибке SQL, поиска столбца или парсинга XML.
*   `ErrorRecord` (string, опционально): Полная информация об исключении.

**Пример конфигурации Задания (Assignment):**

```json
// Получить статус и версию из XML в таблице Config
{
  "node_id": 65, 
  "method_id": 8, // ID для SQL_XML_QUERY
  "is_enabled": true,
  "parameters": {
    "sql_database": "Configuration",
    "sql_query": "SELECT ConfigXml FROM dbo.SystemConfig WHERE ConfigKey = 'Processing'",
    "xml_column_name": "ConfigXml",
    "keys_to_extract": ["IsEnabled", "Version", "LastCheckUTC"]
  },
  "success_criteria": {
    "extracted_data": { 
        "IsEnabled": "true", // Сравнение строк
        "Version": { "matches": "^\\d+\\.\\d+$" } // Проверка формата версии regex
    }
  },
  "description": "Проверка конфигурации обработки из XML"
}

IGNORE_WHEN_COPYING_END

Возможные ошибки и замечания:

    Модуль SqlServer: Требуется.

    Права доступа к SQL: Необходимы.

    Безопасность пароля: Используйте Windows Auth.

    Структура XML: Скрипт ожидает плоскую структуру (ключи - прямые потомки корня).

    Пространства имен XML: Игнорируются благодаря local-name().

Зависимости:

    Функции New-CheckResultObject, Test-SuccessCriteria из модуля StatusMonitorAgentUtils.psm1.

    Модуль PowerShell SqlServer.

    Доступ к MS SQL Server.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1
# --- Версия с попыткой импорта Microsoft.PowerShell.Security ---

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' } # Pester 5+

# Локальное определение New-CheckResultObject для изоляции от мока основной функции
# Убедитесь, что эта версия соответствует той, что используется в вашем StatusMonitorAgentUtils.psm1 (возвращает Hashtable)
function New-CheckResultObjectLocalPester { 
    [CmdletBinding()] 
    param(
        [Parameter(Mandatory = $true)] [bool]$IsAvailable,
        [Parameter(Mandatory = $false)] [nullable[bool]]$CheckSuccess = $null, 
        [Parameter(Mandatory = $false)] $Details = $null,
        [Parameter(Mandatory = $false)] [string]$ErrorMessage = $null
    )
    $processedDetails = $null
    if ($null -ne $Details) {
        if ($Details -is [hashtable]) { $processedDetails = $Details }
        elseif ($Details -is [System.Management.Automation.PSCustomObject]) {
            $processedDetails = @{}
            $Details.PSObject.Properties | ForEach-Object { $processedDetails[$_.Name] = $_.Value }
        } else { $processedDetails = @{ Value = $Details } }
    }
    $finalCheckSuccess = $CheckSuccess 
    if (-not $IsAvailable) { $finalCheckSuccess = $null }
    # Важно: если $IsAvailable = $true и $CheckSuccess пришел как $null (ошибка критерия), он должен остаться $null.
    # Если $IsAvailable = $true и $CheckSuccess не был передан (подразумевается, что критерии не применялись или прошли),
    # то Check-*.ps1 сам должен был установить $checkSuccess в $true перед вызовом New-CheckResultObject.
    # Таким образом, здесь мы не меняем $finalCheckSuccess на $true по умолчанию, если $IsAvailable.
    
    $finalErrorMessage = $ErrorMessage
    if ([string]::IsNullOrEmpty($finalErrorMessage)) {
        if (-not $IsAvailable) { $finalErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)." }
        elseif ($finalCheckSuccess -eq $false) { $finalErrorMessage = "Проверка не прошла по критериям (CheckSuccess=false)." }
        elseif ($finalCheckSuccess -eq $null -and $IsAvailable) { $finalErrorMessage = "Не удалось оценить критерии успеха (CheckSuccess=null), хотя проверка доступности прошла."}
    }
    return @{ # Возвращаем Hashtable
        IsAvailable  = $IsAvailable
        CheckSuccess = $finalCheckSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $processedDetails 
        ErrorMessage = $finalErrorMessage
    }
}

Describe 'Check-CERT_EXPIRY.ps1 (текущая версия после рефакторинга)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils' # Имя вашего модуля

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-CERT_EXPIRY.ps1') -ErrorAction Stop
        if (-not $script:scriptPath) { throw "Не удалось найти скрипт Check-CERT_EXPIRY.ps1" }

        # Загружаем основной модуль StatusMonitorAgentUtils, чтобы мокать его функции
        try {
            Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -ErrorAction Stop
        } catch {
            throw "Критическая ошибка: Не удалось загрузить основной модуль '$($script:utilsModuleName)' для тестов. Ошибка: $($_.Exception.Message)"
        }

        # --- ПОПЫТКА ИСПРАВЛЕНИЯ: Явный импорт модуля Microsoft.PowerShell.Security ---
        try {
            Import-Module Microsoft.PowerShell.Security -ErrorAction Stop
            Write-Host "INFO (Pester BeforeAll): Модуль Microsoft.PowerShell.Security успешно импортирован." -ForegroundColor Cyan
        } catch {
            Write-Warning "ПРЕДУПРЕЖДЕНИЕ (Pester BeforeAll): Не удалось импортировать модуль Microsoft.PowerShell.Security. Моки для Get-ChildItem могут не работать корректно. Ошибка: $($_.Exception.Message)"
        }
        # --- КОНЕЦ ПОПЫТКИ ИСПРАВЛЕНИЯ ---
    }

    # Базовый объект задания для тестов
    $baseAssignment = @{ 
        method_name = 'CERT_EXPIRY'
        node_name   = 'TestNode-CertExpiry'
        ip_address  = $null # Для Check-CERT_EXPIRY TargetIP не используется для выполнения
        parameters  = @{}
        success_criteria = $null 
    }

    # Общие моки для большинства тестов
    BeforeEach {
        # Мокируем функции из НАШЕГО модуля StatusMonitorAgentUtils
        Mock New-CheckResultObject -ModuleName $script:utilsModuleName {
            # Используем локальную копию функции, чтобы не мокать саму себя в бесконечном цикле,
            # если бы мы мокали ее для проверки вызова с параметрами.
            # В данном случае, мы просто хотим, чтобы скрипт Check-*.ps1 ее использовал.
            # А проверять будем уже возвращенный результат.
            # Поэтому важно, чтобы New-CheckResultObjectLocalPester вела себя так же, как реальная.
            param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
            return New-CheckResultObjectLocalPester -IsAvailable $IsAvailable -CheckSuccess $CheckSuccess -Details $Details -ErrorMessage $ErrorMessage
        }

        Mock Test-SuccessCriteria -ModuleName $script:utilsModuleName {
            # По умолчанию считаем, что критерии пройдены, если они вызываются
            param($DetailsObject, $CriteriaObject, $Path) # Добавляем Path для соответствия сигнатуре
            Write-Verbose "Mock Test-SuccessCriteria CALLED with Path: $Path, Criteria: $($CriteriaObject | ConvertTo-Json -Depth 1 -Compress)"
            return @{ Passed = $true; FailReason = $null } 
        }

        # --- Мок для Get-ChildItem из Microsoft.PowerShell.Security ---
        # Имитируем набор сертификатов
        $commonTestDate = Get-Date
        $script:mockCertificates = @(
            [PSCustomObject]@{ Thumbprint='CERT_OK_LONG'; Subject='CN=ok-long.example.com'; Issuer='CN=Test CA'; NotAfter=$commonTestDate.AddDays(200); HasPrivateKey=$true;  PSParentPath='Cert:\LocalMachine\My'; Extensions=@([PSCustomObject]@{Oid=[PSCustomObject]@{FriendlyName='Enhanced Key Usage'; Value='1.3.6.1.5.5.7.3.1'}; EnhancedKeyUsages=@([PSCustomObject]@{Oid='1.3.6.1.5.5.7.3.1'})}) } # SSL
            [PSCustomObject]@{ Thumbprint='CERT_OK_SHORT'; Subject='CN=ok-short.example.com'; Issuer='CN=Test CA'; NotAfter=$commonTestDate.AddDays(45);  HasPrivateKey=$true;  PSParentPath='Cert:\LocalMachine\My'; Extensions=@() }
            [PSCustomObject]@{ Thumbprint='CERT_WARN_SOON'; Subject='CN=warn.example.com';   Issuer='CN=Test CA'; NotAfter=$commonTestDate.AddDays(15);  HasPrivateKey=$true;  PSParentPath='Cert:\CurrentUser\My'; Extensions=@() } # Истекает через 15 дней
            [PSCustomObject]@{ Thumbprint='CERT_EXPIRED'; Subject='CN=expired.example.com'; Issuer='CN=Test CA'; NotAfter=$commonTestDate.AddDays(-5); HasPrivateKey=$false; PSParentPath='Cert:\LocalMachine\My'; Extensions=@() } # Истек
            [PSCustomObject]@{ Thumbprint='CERT_NO_PK'; Subject='CN=no-pk.example.com';   Issuer='CN=Test CA'; NotAfter=$commonTestDate.AddDays(100); HasPrivateKey=$false; PSParentPath='Cert:\LocalMachine\WebHosting'; Extensions=@() }
            [PSCustomObject]@{ Thumbprint='CERT_OTHER_EKU'; Subject='CN=other-eku.example.com'; Issuer='CN=Test CA'; NotAfter=$commonTestDate.AddDays(180); HasPrivateKey=$true;  PSParentPath='Cert:\LocalMachine\My'; Extensions=@([PSCustomObject]@{Oid=[PSCustomObject]@{FriendlyName='Enhanced Key Usage'; Value='1.3.6.1.5.5.7.3.2'}; EnhancedKeyUsages=@([PSCustomObject]@{Oid='1.3.6.1.5.5.7.3.2'})}) } # Client Auth
        )
        
        # Мокируем Get-ChildItem. Pester должен найти команду, если модуль загружен.
        Mock Get-ChildItem -ModuleName Microsoft.PowerShell.Security {
            param($Path)
            Write-Verbose "Mock Get-ChildItem called for Path: $Path"
            $storeName = ($Path -split '\\')[-1]
            $storeLocation = ($Path -split '\\')[-2]
            # Возвращаем сертификаты в зависимости от пути
            # Важно, чтобы PSParentPath в мок-сертификатах соответствовал этим путям
            return $script:mockCertificates | Where-Object {$_.PSParentPath -eq $Path}
        }
        
        # Мокируем Test-Path, чтобы он всегда возвращал true для путей к хранилищам из нашего мока
        Mock Test-Path {
            param($Path)
            if ($Path -like "Cert:\*") {
                # Проверяем, есть ли такое хранилище в наших мок-сертификатах
                if (($script:mockCertificates.PSParentPath | Select-Object -Unique) -contains $Path) {
                    Write-Verbose "Mock Test-Path for '$Path' returning True (store exists in mock)"
                    return $true
                } else {
                     Write-Verbose "Mock Test-Path for '$Path' returning False (store does not exist in mock or specified by test)"
                    return $false # Для хранилищ, которых нет в моке, возвращаем false
                }
            }
            # Для других путей вызываем реальный Test-Path
            return Test-Path @using:PSBoundParameters 
        } -ModuleName Microsoft.PowerShell.Management
    }

    Context 'Получение данных о сертификатах (с новой обработкой параметров и хранилищ)' {
        It 'Должен вернуть IsAvailable=true и все 6 мок-сертификатов, если параметры фильтрации и хранилища не указаны (стандартные хранилища)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # Параметры не указаны, скрипт должен использовать стандартный список хранилищ
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue
            $result.Details.certificates | Should -HaveCount 6
            ($result.Details.stores_checked -contains 'Cert:\LocalMachine\My') | Should -BeTrue
            ($result.Details.stores_checked -contains 'Cert:\LocalMachine\WebHosting') | Should -BeTrue
            ($result.Details.stores_checked -contains 'Cert:\CurrentUser\My') | Should -BeTrue
            $result.Details.parameters_used.min_days_warning | Should -Be 30 # Дефолтное значение
            $result.ErrorMessage | Should -BeNullOrEmpty
        }

        It 'Должен искать только в указанном хранилище LocalMachine\My' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ store_location = 'LocalMachine'; store_name = 'My' }
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue
            # В LocalMachine\My у нас 3 сертификата по моку (OK_LONG, OK_SHORT, EXPIRED, OTHER_EKU) - всего 4
            $result.Details.certificates | Should -HaveCount 4 
            $result.Details.stores_checked | Should -HaveCount 1
            ($result.Details.stores_checked[0] -eq 'Cert:\LocalMachine\My') | Should -BeTrue
        }

        It 'Должен корректно фильтровать по отпечатку' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ thumbprint = 'CERT_WARN_SOON' } # Этот в CurrentUser\My
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue
            $result.Details.certificates | Should -HaveCount 1
            $result.Details.certificates[0].thumbprint | Should -Be 'CERT_WARN_SOON'
            $result.Details.filter_applied | Should -BeTrue
        }

        It 'Должен корректно фильтровать по EKU (SSL Server Auth)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ eku_oid = @('1.3.6.1.5.5.7.3.1') } # SSL Server Auth
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue
            $result.Details.certificates | Should -HaveCount 1
            $result.Details.certificates[0].thumbprint | Should -Be 'CERT_OK_LONG'
            $result.Details.filter_applied | Should -BeTrue
        }

        It 'Должен корректно рассчитывать статус ExpiringSoon с учетом min_days_warning' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ min_days_warning = 20 } # Устанавливаем порог
            
            $result = & $script:scriptPath @assignment
            
            $certWarnSoon = $result.Details.certificates | Where-Object {$_.thumbprint -eq 'CERT_WARN_SOON'}
            $certWarnSoon.status | Should -Be 'ExpiringSoon' # days_left = 15, min_days_warning = 20
            $certOkShort = $result.Details.certificates | Where-Object {$_.thumbprint -eq 'CERT_OK_SHORT'}
            $certOkShort.status | Should -Be 'OK' # days_left = 45, min_days_warning = 20
        }
    }

    Context 'Проверка Критериев Успеха' {
        It 'Критерий "все > 30 дней": должен пройти, если все отфильтрованные сертификаты > 30 дней' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # Фильтруем, чтобы остались только 'CERT_OK_LONG' (200 дней) и 'CERT_OK_SHORT' (45 дней)
            $assignment.parameters = @{ subject_like = 'ok-*.example.com' }
            $assignment.success_criteria = @{ 
                certificates = @{ _condition_ = 'all'; _criteria_ = @{ days_left = @{'>'=30} } } 
            }
            # Мок Test-SuccessCriteria по умолчанию возвращает Passed = $true, что подходит
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue
            $result.Details.certificates | Should -HaveCount 2 # Убедимся, что фильтр сработал
            $result.CheckSuccess | Should -BeTrue
            $result.ErrorMessage | Should -BeNullOrEmpty
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
        }

        It 'Критерий "все > 50 дней": должен НЕ пройти, если CERT_OK_SHORT (45 дней) найден' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ subject_like = 'ok-*.example.com' } # Найдет CERT_OK_LONG и CERT_OK_SHORT
            $assignment.success_criteria = @{ 
                certificates = @{ _condition_ = 'all'; _criteria_ = @{ days_left = @{'>'=50} } } 
            }
            # Переопределяем мок Test-SuccessCriteria, чтобы имитировать провал
            $failReason = "Сертификат CERT_OK_SHORT имеет 45 дней, что не > 50"
            Mock Test-SuccessCriteria -ModuleName $script:utilsModuleName -MockWith { 
                return @{ Passed = $false; FailReason = $using:failReason } 
            } -Scope It
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue
            $result.CheckSuccess | Should -BeFalse
            $result.ErrorMessage | Should -Be $failReason
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
        }

        It 'Критерий "ни один не Expired": должен пройти, если нет просроченных среди отфильтрованных' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # Фильтруем все, КРОМЕ CERT_EXPIRED (у него hasPrivateKey = $false)
            $assignment.parameters = @{ require_private_key = $true } 
            $assignment.success_criteria = @{ 
                certificates = @{ _condition_ = 'none'; _where_ = @{ status = 'Expired' } } 
            }
            # Мок Test-SuccessCriteria (Passed=$true) подходит
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue
            # Ожидаем 3 сертификата с приватным ключом из мока
            $result.Details.certificates | Should -HaveCount 3 
            ($result.Details.certificates.status -contains 'Expired') | Should -BeFalse
            $result.CheckSuccess | Should -BeTrue
            $result.ErrorMessage | Should -BeNullOrEmpty
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
        }
    }

    Context 'Обработка ошибок хранилищ и параметров' {
        It 'Должен вернуть IsAvailable=false, если указано несуществующее хранилище' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ store_location = 'InvalidStore'; store_name = 'NonExistent' }
            
            # Test-Path вернет false для этого пути
            Mock Test-Path { param($Path) if ($Path -eq 'Cert:\InvalidStore\NonExistent') { return $false } else { return $true } } -ModuleName Microsoft.PowerShell.Management -Scope It
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeFalse
            $result.CheckSuccess | Should -BeNull
            $result.ErrorMessage | Should -Contain "Не удалось получить доступ ни к одному из указанных/стандартных хранилищ"
        }

        It 'Должен вернуть IsAvailable=true и ошибку в ErrorMessage/Details, если одно из стандартных хранилищ недоступно' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # Параметры не указаны, используются стандартные
            
            # Мокируем Test-Path, чтобы WebHosting был недоступен
            Mock Test-Path { 
                param($Path) 
                if ($Path -eq 'Cert:\LocalMachine\WebHosting') { return $false } 
                return $true # Остальные доступны
            } -ModuleName Microsoft.PowerShell.Management -Scope It
            
            $result = & $script:scriptPath @assignment
            
            $result.IsAvailable | Should -BeTrue # Доступ к другим хранилищам был
            $result.Details.store_access_errors | Should -HaveCount 1
            $result.Details.store_access_errors[0] | Should -Contain 'Cert:\LocalMachine\WebHosting'
            $result.ErrorMessage | Should -Contain 'ошибки доступа к некоторым хранилищам'
            # CheckSuccess должен быть true, если критериев нет и другие хранилища отработали
            $result.CheckSuccess | Should -BeTrue 
        }
    }
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 ====
# Check-DISK_USAGE.Tests.ps1
# Тесты для Check-DISK_USAGE.ps1 v2.1.0+ с моками

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

Describe 'Check-DISK_USAGE.ps1 (v2.1.0+)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-DISK_USAGE.ps1') -EA Stop
        try {
            Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop
            Import-Module Storage -ErrorAction SilentlyContinue # Попытка загрузить Storage для Pester
        } catch {
            throw "Не удалось загрузить модуль $($script:utilsModuleName) или Storage. Ошибка: $($_.Exception.Message)"
        }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'DISK_USAGE'; node_name = 'TestNode-Disk'; ip_address = $null; parameters = $null; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        
        Mock Get-Volume {
             Write-Verbose "Mock Get-Volume called"
             return @(
                 [PSCustomObject]@{ DriveLetter = 'C'; FileSystemLabel = 'System'; FileSystem = 'NTFS'; DriveType = 'Fixed'; Size = 500GB; SizeRemaining = 100GB }
                 [PSCustomObject]@{ DriveLetter = 'D'; FileSystemLabel = 'Data'; FileSystem = 'NTFS'; DriveType = 'Fixed'; Size = 1000GB; SizeRemaining = 50GB }
                 [PSCustomObject]@{ DriveLetter = 'E'; FileSystemLabel = ''; FileSystem = 'CDFS'; DriveType = 'CD-ROM'; Size = 0; SizeRemaining = 0 }
                 [PSCustomObject]@{ DriveLetter = $null; FileSystemLabel = 'Recovery'; FileSystem = 'NTFS'; DriveType = 'Fixed'; Size = 1GB; SizeRemaining = 0.5GB }
             )
        } -ModuleName Storage # Указываем модуль для Get-Volume
    }

    Context 'Получение данных о дисках' {
        It 'Должен вернуть IsAvailable=true и данные для дисков C и D без фильтров' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Volume -Times 1 -Exactly -ModuleName Storage
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details -is [hashtable] -and $Details.disks -is [System.Collections.Generic.List[object]] -and $Details.disks.Count -eq 2) -and
                ($Details.disks[0].drive_letter -eq 'C' -and $Details.disks[0].percent_free -eq 20.0) -and
                ($Details.disks[1].drive_letter -eq 'D' -and $Details.disks[1].percent_free -eq 5.0) -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
             Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
        }

        It 'Должен вернуть только диск C при фильтре parameters.drives = @("C")' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ drives = @('C', 'c') } 
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.disks.Count -eq 1 -and $Details.disks[0].drive_letter -eq 'C')
            }
        }

        It 'Должен вернуть пустой список и сообщение, если фильтр не находит дисков' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ drives = @('Z') } 
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.disks.Count -eq 0) -and ($Details.message -match 'Нет локальных Fixed дисков' -or $Details.message -match 'не найдены') # Уточнено сообщение
            }
        }
    } # Конец Context 'Получение данных'

    Context 'Проверка Критериев Успеха' {
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true, если критерии пройдены (mock=true)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ disks=@{_condition_='all';_criteria_=@{percent_free=@{'>'=1}}} }
            Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject -ne $null }
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true -and [string]::IsNullOrEmpty($ErrorMessage) }
        }

        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false, если критерии НЕ пройдены (mock=false)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ disks=@{_condition_='all';_where_=@{drive_letter='D'};_criteria_=@{percent_free=@{'>'=10}}} }
            $failReasonMock = "Диск D: процент свободного места 5.0 меньше или равен порогу 10"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
        }
    } # Конец Context 'Проверка Критериев'

    Context 'Ошибка Get-Volume' {
        BeforeEach {
            Mock Get-Volume { throw "Ошибка доступа к WMI (Mock Error)" } -ModuleName Storage
        }
        It 'Должен вернуть IsAvailable=false и сообщение об ошибке' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment
            
            # Проверяем РЕАЛЬНЫЙ результат, так как New-CheckResultObject вызывается из блока catch скрипта
            $result | Should -Not -BeNull
            ($result.PSObject.Properties.Name -notcontains 'Mocked' -or (-not $result.Mocked)) | Should -BeTrue
            $result.IsAvailable | Should -BeFalse
            $result.CheckSuccess | Should -BeNull
            $result.ErrorMessage | Should -Match 'Критическая ошибка'
            $result.ErrorMessage | Should -Match 'Check-DISK_USAGE' # Уточнено, что ошибка из самого скрипта
            $result.Details.error | Should -Match 'Критическая ошибка'

            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
        }
    } # Конец Context 'Ошибка Get-Volume'
} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 ====
# Check-PING.Tests.ps1 (v2.2.1 - Исправлены ошибки парсинга)
# --- Версия 2.2.1 ---
# Изменения:
# - Исправлены синтаксические ошибки в моках Ping.Send (комментарии внутри PSCustomObject).

# Требуется Pester v5+
# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

function New-CheckResultObject {
    [CmdletBinding()] param([Parameter(Mandatory=$true)][bool]$IsAvailable, [Parameter(Mandatory=$false)][nullable[bool]]$CheckSuccess=$null, [Parameter(Mandatory=$false)][hashtable]$Details=$null, [Parameter(Mandatory=$false)][string]$ErrorMessage=$null)
    $result = [ordered]@{ IsAvailable=$IsAvailable; CheckSuccess=$CheckSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$Details; ErrorMessage=$ErrorMessage }; if ($result.IsAvailable) { if ($result.CheckSuccess -eq $null) { $result.CheckSuccess = $true } } else { $result.CheckSuccess = $null }; if ([string]::IsNullOrEmpty($result.ErrorMessage)) { if (-not $result.IsAvailable) { $result.ErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)." } }; return $result
}

Describe 'Check-PING.ps1 (v2.3.2 .NET Ping Refactored Tests)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'
    $script:pingSendMockBehavior = $null

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-PING.ps1') -EA Stop
        Write-Host "INFO: Тестируемый скрипт: $($script:scriptPath)" -FC Cyan
        try {
            Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop
            Write-Host "INFO: Модуль '$($script:utilsModuleName)' успешно загружен для тестов." -FC Green
        } catch {
            throw "КРИТИЧЕСКАЯ ОШИБКА: Не удалось загрузить модуль '$($script:utilsModuleName)'. Тесты не могут быть выполнены. Ошибка: $($_.Exception.Message)"
        }
    }

    $baseAssignment = @{
        method_name      = 'PING'
        node_name        = 'TestNode-PING'
        ip_address       = '8.8.8.8'
        parameters       = @{}
        success_criteria = $null
    }

    BeforeEach {
        Mock New-CheckResultObject {
            param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
            Write-Verbose "MOCK New-CheckResultObject CALLED with: IsAvailable=$IsAvailable, CheckSuccess=$CheckSuccess, ErrorMessage='$ErrorMessage'"
            return @{ Mocked = $true; M_IsAvailable = $IsAvailable; M_CheckSuccess = $CheckSuccess; M_Details = $Details; M_ErrorMessage = $ErrorMessage }
        } -ModuleName $script:utilsModuleName

        Mock Test-SuccessCriteria {
            param($DetailsObject, $CriteriaObject, $Path)
            Write-Verbose "MOCK Test-SuccessCriteria CALLED. CriteriaObject: $($CriteriaObject | ConvertTo-Json -Depth 2 -Compress). Path: $Path"
            return @{ Passed = $true; FailReason = $null }
        } -ModuleName $script:utilsModuleName

        $script:pingSendMockBehavior = {
            param($hostnameOrAddress, $timeout, $buffer, $options)
            Write-Verbose "MOCK Ping.Send (default behavior): Simulating SUCCESS Ping to '$hostnameOrAddress' with timeout $timeout"
            # Исправлено: Безопасный fallback и комментарий ВНЕ объекта
            $parsedAddress = try { [System.Net.IPAddress]::Parse($hostnameOrAddress) } catch { [System.Net.IPAddress]::Parse('127.0.0.1') }
            return [PSCustomObject]@{
                Status        = [System.Net.NetworkInformation.IPStatus]::Success
                Address       = $parsedAddress
                RoundtripTime = (Get-Random -Minimum 10 -Maximum 50) # long
            }
        }

        Mock New-Object {
            param ($TypeName)
            if ($TypeName -eq 'System.Net.NetworkInformation.Ping') {
                Write-Verbose "MOCK New-Object: Intercepted 'System.Net.NetworkInformation.Ping'. Returning custom mock object."
                return [PSCustomObject]@{
                    Send    = $script:pingSendMockBehavior
                    Dispose = { Write-Verbose "MOCK Ping.Dispose() called." }
                }
            }
            Write-Verbose "MOCK New-Object: Passing call for '$TypeName' to original."
            Microsoft.PowerShell.Utility\New-Object @PSBoundParameters
        }
    }

    Context 'Успешный Пинг (.NET Send возвращает Success)' {
        BeforeEach {
            $script:pingSendMockBehavior = {
                param($hostnameOrAddress, $timeout, $buffer, $options)
                Write-Verbose "MOCK Ping.Send (Success Context): Host='$hostnameOrAddress', Timeout=$timeout"
                $parsedAddress = try { [System.Net.IPAddress]::Parse($hostnameOrAddress) } catch { [System.Net.IPAddress]::Parse('8.8.8.8') }
                return [PSCustomObject]@{
                    Status        = [System.Net.NetworkInformation.IPStatus]::Success
                    Address       = $parsedAddress
                    RoundtripTime = 15L # Конкретное значение для теста
                }
            }
        }

        It 'Должен вернуть IsAvailable=true, CheckSuccess=true без критериев' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment

            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and
                $CheckSuccess -eq $true -and
                ($Details -is [hashtable] -and $Details.rtt_ms -eq 15 -and $Details.packet_loss_percent -eq 0) -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
        }

        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true, если критерии переданы и мок Test-SuccessCriteria возвращает true' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = 100 } }

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 ($DetailsObject.rtt_ms -eq 15) -and ($CriteriaObject.rtt_ms.'<=' -eq 100)
            }
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and [string]::IsNullOrEmpty($ErrorMessage)
            }
        }

        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false, если критерии переданы и мок Test-SuccessCriteria возвращает false' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ packet_loss_percent = @{ '==' = 0 } }
            $failReasonMock = "Потери не 0% (мок)"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock
            }
        }
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=null, если критерии переданы и мок Test-SuccessCriteria возвращает Passed=$null (ошибка критерия)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.success_criteria = @{ rtt_ms = @{ '==' = "not a number" } }
             $failReasonMock = "Ошибка сравнения в Test-SuccessCriteria (мок)"
             Mock Test-SuccessCriteria { return @{ Passed = $null; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It

             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $IsAvailable -eq $true -and $CheckSuccess -eq $null -and $ErrorMessage -eq $using:failReasonMock
             }
        }
    }

    Context 'Неуспешный Пинг (.NET Send НЕ возвращает Success)' {
        BeforeEach {
             $script:pingSendMockBehavior = {
                param($hostnameOrAddress, $timeout, $buffer, $options)
                Write-Verbose "MOCK Ping.Send (Failure Context): Simulating TIMEOUT Ping to '$hostnameOrAddress'"
                return [PSCustomObject]@{
                    Status        = [System.Net.NetworkInformation.IPStatus]::TimedOut
                    Address       = $null
                    RoundtripTime = 0L
                }
            }
        }
        It 'Должен вернуть IsAvailable=false, CheckSuccess=$null и НЕ вызывать Test-SuccessCriteria' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = 100 } }

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $false -and
                $CheckSuccess -eq $null -and
                ($Details -is [hashtable] -and $Details.status_string -eq 'TimedOut' -and $Details.packet_loss_percent -eq 100) -and
                $ErrorMessage -match 'Нет успешных ответов' -and $ErrorMessage -match 'TimedOut'
            }
        }
    }

    Context 'Критическая ошибка PingException' {
         BeforeEach {
             $script:pingSendMockBehavior = {
                param($hostnameOrAddress, $timeout, $buffer, $options)
                Write-Verbose "MOCK Ping.Send (Exception Context): Simulating PingException for '$hostnameOrAddress'"
                throw [System.Net.NetworkInformation.PingException]::new("Мок: Хост не найден (PingException).")
            }
         }
         It 'Должен вернуть IsAvailable=false, CheckSuccess=$null и содержать ошибку в Details/ErrorMessage' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.ip_address = 'invalid-host-for-exception'

            $result = & $script:scriptPath @assignment

            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $M_IsAvailable -eq $false -and
                $M_CheckSuccess -eq $null -and
                $M_ErrorMessage -match 'Критическая ошибка PingException' -and $M_ErrorMessage -match 'invalid-host-for-exception' -and
                ($M_Details -is [hashtable] -and $M_Details.error -match 'PingException' -and $M_Details.ErrorRecord -match 'PingException')
            }
         }
    }
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 ====
# Check-PROCESS_LIST.Tests.ps1 (v2.1.0+ Refactored for PS 5.1)

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' } # Pester 5 должен работать и с PS 5.1

function New-CheckResultObject {
    [CmdletBinding()] param([Parameter(Mandatory = $true)][bool]$IsAvailable, [Parameter(Mandatory = $false)][nullable[bool]]$CheckSuccess = $null, [Parameter(Mandatory = $false)][hashtable]$Details = $null, [Parameter(Mandatory = $false)][string]$ErrorMessage = $null)
    $result = [ordered]@{ IsAvailable = $IsAvailable; CheckSuccess = $CheckSuccess; Timestamp = (Get-Date).ToUniversalTime().ToString("o"); Details = $Details; ErrorMessage = $ErrorMessage };
    if ($result.IsAvailable) { if ($result.CheckSuccess -eq $null) { $result.CheckSuccess = $true } } else { $result.CheckSuccess = $null };
    if ([string]::IsNullOrEmpty($result.ErrorMessage)) { if (-not $result.IsAvailable) { $result.ErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)." } };
    return $result
}

Describe 'Check-PROCESS_LIST.ps1 (v2.1.0+ PS 5.1 Tests)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'
    $script:mockProcesses = @() # Инициализируем здесь

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-PROCESS_LIST.ps1') -EA Stop
        Write-Host "INFO: Тестируемый скрипт: $($script:scriptPath)" -FC Cyan
        try {
            Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop
            Write-Host "INFO: Модуль '$($script:utilsModuleName)' успешно загружен для тестов." -FC Green
        } catch {
            throw "КРИТИЧЕСКАЯ ОШИБКА: Не удалось загрузить модуль '$($script:utilsModuleName)'. Тесты не могут быть выполнены. Ошибка: $($_.Exception.Message)"
        }

        # Определяем $script:mockProcesses один раз
        $script:mockProcesses = @(
            [PSCustomObject]@{ Id = 101; ProcessName = 'powershell'; CPU = 10.5; WS = 200MB; StartTime = (Get-Date).AddHours(-1); Path = 'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe' }
            [PSCustomObject]@{ Id = 102; ProcessName = 'explorer'; CPU = 5.2; WS = 150MB; StartTime = (Get-Date).AddHours(-5); Path = 'C:\Windows\explorer.exe' }
            [PSCustomObject]@{ Id = 103; ProcessName = 'svchost'; CPU = 0.1; WS = 10MB; StartTime = (Get-Date).AddDays(-1); Path = 'C:\Windows\System32\svchost.exe' }
            [PSCustomObject]@{ Id = 104; ProcessName = 'svchost'; CPU = 0.5; WS = 15MB; StartTime = (Get-Date).AddDays(-1).AddHours(1); Path = 'C:\Windows\System32\svchost.exe' }
            [PSCustomObject]@{ Id = 201; ProcessName = 'notepad'; CPU = 1.0; WS = 20MB; StartTime = (Get-Date).AddMinutes(-30); Path = 'C:\Windows\System32\notepad.exe' }
        )
    }

    $baseAssignment = @{
        method_name      = 'PROCESS_LIST'
        node_name        = 'TestNode-Proc'
        ip_address       = $null # Проверка всегда локальная
        parameters       = @{}
        success_criteria = $null
    }

    BeforeEach {
        Mock New-CheckResultObject {
            param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
            Write-Verbose "MOCK New-CheckResultObject CALLED with: IsAvailable=$IsAvailable, CheckSuccess=$CheckSuccess, ErrorMessage='$ErrorMessage'"
            return @{ Mocked = $true; M_IsAvailable = $IsAvailable; M_CheckSuccess = $CheckSuccess; M_Details = $Details; M_ErrorMessage = $ErrorMessage }
        } -ModuleName $script:utilsModuleName

        Mock Test-SuccessCriteria {
            param($DetailsObject, $CriteriaObject, $Path)
            Write-Verbose "MOCK Test-SuccessCriteria CALLED. CriteriaObject: $($CriteriaObject | ConvertTo-Json -Depth 2 -Compress). Path: $Path"
            return @{ Passed = $true; FailReason = $null }
        } -ModuleName $script:utilsModuleName

        # --- Мок Get-Process ---
        Mock Get-Process {
            param(
                [string[]]$Name,
                [string]$ComputerName, # Хотя мы его не используем, он может быть передан
                [switch]$IncludeUserName, # Get-Process не имеет этого, но SUT может передавать
                [string]$ErrorAction = 'Continue' # Значение по умолчанию для Get-Process
            )
            Write-Verbose "MOCK Get-Process CALLED. Name Filter: '$($Name -join ', ')', ErrorAction: $ErrorAction"
            $processesToReturn = $script:mockProcesses # Используем общую переменную

            if ($Name) {
                $filteredByName = [System.Collections.Generic.List[object]]::new()
                foreach ($pattern in $Name) {
                    $processesToReturn | Where-Object { $_.ProcessName -like $pattern } | ForEach-Object { $filteredByName.Add($_) }
                }
                $processesToReturn = $filteredByName.ToArray() | Select-Object -Unique # Убираем дубликаты, если паттерны пересекаются
            }

            if ($processesToReturn.Count -eq 0 -and $Name -and $ErrorAction -ne 'Stop') {
                # Имитируем ошибку, если процесс не найден и ErrorAction не Stop
                # Для ProcessNotFoundException нужно больше информации, которую сложно корректно мокнуть
                # Проще вернуть пустой массив и проверить логику SUT (System Under Test)
                Write-Warning "MOCK Get-Process: Process(es) matching '$($Name -join ', ')' not found."
                # Эта ошибка будет очищена в SUT, если это ProcessNotFoundException
                $exceptionMessage = "Cannot find a process with the name ""$($Name -join ', ')"". Verify the process name and call the cmdlet again."
                $exception = [System.Management.Automation.ProcessCommandException]::new($exceptionMessage)
                $errorRecord = [System.Management.Automation.ErrorRecord]::new($exception, "ProcessNotFound", [System.Management.Automation.ErrorCategory]::ObjectNotFound, $Name)
                $PSCmdlet.WriteError($errorRecord) # Это правильно для генерации ошибки, которую SUT может поймать
                return @() # Возвращаем пустой массив, т.к. ошибка была обработана (не Stop)
            }
            return $processesToReturn
        } -ModuleName Microsoft.PowerShell.Management # Модуль, где живет Get-Process

        # --- Мок Get-CimInstance для Win32_Process (получение Username) ---
        Mock Get-CimInstance {
            param(
                [string]$ClassName,
                [string]$Filter,
                [string]$ComputerName,
                [string]$ErrorAction = 'Continue'
            )
            Write-Verbose "MOCK Get-CimInstance CALLED. ClassName: $ClassName, Filter: $Filter"
            if ($ClassName -ne 'Win32_Process' -or -not $Filter -match 'ProcessId = (\d+)') {
                if ($ErrorAction -eq 'Stop') { throw "MOCK Get-CimInstance: Invalid ClassName or Filter for Win32_Process mock." }
                return $null
            }
            $procId = [int]$Matches[1]
            switch ($procId) {
                101 { return [PSCustomObject]@{Domain = 'MOCKDOMAIN'; User = 'UserPS'} } # Для powershell
                102 { return [PSCustomObject]@{Domain = $env:USERDOMAIN; User = $env:USERNAME} } # Для explorer
                103 { return [PSCustomObject]@{User = 'SYSTEM'} } # Для svchost 1
                201 { return $null } # Имитация отсутствия данных для notepad
                default {
                    # Для других ProcessId возвращаем $null или имитируем ошибку, если ErrorAction='Stop'
                    if ($ErrorAction -eq 'Stop') { throw "MOCK Get-CimInstance: No CIM data for ProcessId $procId" }
                    return $null
                }
            }
        } -ModuleName CimCmdlets # Модуль, где живет Get-CimInstance
    }

    Context 'Получение списка процессов' {
        It 'Должен вернуть все 5 процессов без фильтров и с базовыми полями (username/path null)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # Параметры по умолчанию: include_username=$false, include_path=$false
            $result = & $script:scriptPath @assignment

            Should -Invoke Get-Process -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management -ParameterFilter { $Name -eq $null }
            Should -Invoke Get-CimInstance -Times 0 -ModuleName CimCmdlets # Не должен вызываться, т.к. include_username=false

            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $M_IsAvailable -eq $true -and $M_CheckSuccess -eq $true -and
                ($M_Details.processes.Count -eq 5) -and # В моке 5 процессов
                ($M_Details.processes | Where-Object { $_.name -eq 'powershell' } | ForEach-Object { $_.username -eq $null -and $_.path -eq $null }) -and
                ($M_Details.processes | Where-Object { $_.name -eq 'notepad' } | ForEach-Object { $_.username -eq $null -and $_.path -eq $null })
            }
        }

        It 'Должен вернуть процессы PowerShell (1 шт) с Username и Path при include_username/path=true' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ process_names = @('powershell'); include_username = $true; include_path = $true }
            $result = & $script:scriptPath @assignment

            Should -Invoke Get-Process -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management -ParameterFilter { $Name -contains 'powershell' }
            Should -Invoke Get-CimInstance -Times 1 -Exactly -ModuleName CimCmdlets -ParameterFilter { $Filter -match '101' } # Вызов для powershell (ID 101)

            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $M_Details.processes.Count -eq 1 -and
                $M_Details.processes[0].name -eq 'powershell' -and
                $M_Details.processes[0].username -eq 'MOCKDOMAIN\UserPS' -and
                $M_Details.processes[0].path -eq 'C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe' # Path из мока $script:mockProcesses
            }
        }

        It 'Должен вернуть отсортированный список по CPU (убывание)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ sort_by = 'cpu'; sort_descending = $true }
            $result = & $script:scriptPath @assignment

            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $M_Details.processes.Count -eq 5 -and
                $M_Details.processes[0].name -eq 'powershell' -and # 10.5 CPU
                $M_Details.processes[1].name -eq 'explorer' -and   # 5.2 CPU
                $M_Details.processes[2].name -eq 'notepad' -and    # 1.0 CPU
                $M_Details.processes[3].name -eq 'svchost' -and    # 0.5 CPU (ID 104)
                $M_Details.processes[4].name -eq 'svchost'         # 0.1 CPU (ID 103)
            }
        }

        It 'Должен вернуть топ 2 процесса по памяти (убывание)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ sort_by = 'memory'; sort_descending = $true; top_n = 2 }
            $result = & $script:scriptPath @assignment

            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $M_Details.processes.Count -eq 2 -and
                 $M_Details.processes[0].name -eq 'powershell' -and # 200MB
                 $M_Details.processes[1].name -eq 'explorer'        # 150MB
            }
        }

        It 'Должен вернуть пустой список и сообщение, если процесс по фильтру "nonexistent" не найден' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ process_names = @('nonexistent') }
            # Мок Get-Process вернет ошибку ProcessNotFound, которая будет обработана в SUT
            $result = & $script:scriptPath @assignment

            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $M_IsAvailable -eq $true -and # Сама проверка отработала
                 $M_CheckSuccess -eq $true -and # Критериев нет, ProcessNotFound - не ошибка доступности SUT
                 ($M_Details.processes.Count -eq 0) -and
                 ($M_Details.message -match 'не найдены') -and ($M_Details.message -match 'nonexistent')
            }
        }
    }

    Context 'Проверка Критериев Успеха' {
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true, если критерий пройден (мок Test-SuccessCriteria = true)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ processes = @{ _condition_ = 'count'; _where_ = @{ name = 'svchost' }; _count_ = @{ '>=' = 1 } } } # Ожидаем хотя бы один svchost
            # Мок Test-SuccessCriteria по умолчанию возвращает true
            $result = & $script:scriptPath @assignment

            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $M_CheckSuccess -eq $true }
        }

        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false, если критерий НЕ пройден (мок Test-SuccessCriteria = false)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ processes = @{ _condition_ = 'none'; _where_ = @{ name = 'explorer.exe' } } } # Не должно быть explorer.exe
            $failReasonMock = "Найден запрещенный процесс explorer.exe (мок)"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
            $result = & $script:scriptPath @assignment

            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $M_CheckSuccess -eq $false -and $M_ErrorMessage -eq $using:failReasonMock }
        }
    }

    Context 'Ошибка Get-Process (кроме ProcessNotFound)' {
        BeforeEach {
            # Мокируем Get-Process так, чтобы он выбрасывал критическую ошибку
            Mock Get-Process {
                param($Name, $ErrorAction='Continue')
                Write-Verbose "MOCK Get-Process (CRITICAL ERROR CONTEXT)"
                if ($ErrorAction -eq 'Stop') {
                    throw "Критическая ошибка доступа к Get-Process (мок)"
                } else {
                    # Для ErrorAction='SilentlyContinue' или 'Continue'
                    $exception = [System.Management.Automation.RuntimeException]::new("Критическая ошибка доступа к Get-Process (мок)")
                    $errorRecord = [System.Management.Automation.ErrorRecord]::new($exception, "GetProcessCriticalError", [System.Management.Automation.ErrorCategory]::InvalidOperation, $null)
                    $PSCmdlet.WriteError($errorRecord)
                    return $null # или @()
                }
            } -ModuleName Microsoft.PowerShell.Management
        }
        It 'Должен вернуть IsAvailable=false и сообщение об ошибке, если Get-Process выбрасывает критическую ошибку' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # SUT Check-PROCESS_LIST.ps1 вызывает Get-Process с ErrorAction = SilentlyContinue или Stop
            # Если SUT ставит ErrorAction='Stop' в своем вызове, наш мок это обработает и кинет throw
            # Если SUT ставит ErrorAction='SilentlyContinue', то наш мок вернет $null и запишет ошибку, SUT должен это обработать.
            # В Check-PROCESS_LIST.ps1 (v2.1.0) ErrorAction устанавливается в Stop, если нет фильтра по имени.
            $result = & $script:scriptPath @assignment # Без фильтра по имени, SUT поставит ErrorAction='Stop'

            # Ожидаем, что SUT поймает исключение и вернет результат через New-CheckResultObject
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $M_IsAvailable -eq $false -and
                $M_CheckSuccess -eq $null -and
                $M_ErrorMessage -match 'Критическая ошибка в Check-PROCESS_LIST' -and $M_ErrorMessage -match 'Критическая ошибка доступа к Get-Process \(мок\)'
            }
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
        }
    }
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 ====
# Check-SERVICE_STATUS.Tests.ps1
# Тесты для Check-SERVICE_STATUS.ps1 v2.0.2+ с моками

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

Describe 'Check-SERVICE_STATUS.ps1 (v2.0.2+)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-SERVICE_STATUS.ps1') -EA Stop
        try {
            Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop
            Import-Module Microsoft.PowerShell.Management -ErrorAction SilentlyContinue # For Get-Service
        } catch {
            throw "Не удалось загрузить модуль $($script:utilsModuleName) или Microsoft.PowerShell.Management. Ошибка: $($_.Exception.Message)"
        }
    }

    $baseAssignment = @{ method_name = 'SERVICE_STATUS'; node_name = 'TestNode-Service'; ip_address = $null; parameters = @{}; success_criteria = $null }

    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { param($DetailsObject, $CriteriaObject, $Path) return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        
        Mock Get-Service {
            param($Name)
            # Write-Verbose "Mock Get-Service called for $Name"
            if ($Name -eq 'NonExistentSvcMock') {
                # Имитируем ServiceCommandException для ненайденной службы
                $exception = [Microsoft.PowerShell.Commands.ServiceCommandException]::new("Cannot find any service with service name '$Name'.")
                $errorRecord = [System.Management.Automation.ErrorRecord]::new($exception, "ServiceNotFound", [System.Management.Automation.ErrorCategory]::ObjectNotFound, $Name)
                # В Pester мок не может напрямую вызвать $PSCmdlet.WriteError так, чтобы это было поймано как обычная ошибка командлета.
                # Вместо этого мы должны *throw* исключение, чтобы SUT его поймал.
                throw $errorRecord # Используем $errorRecord, т.к. SUT ловит ServiceCommandException
            }
            # По умолчанию возвращаем работающую службу
            return [PSCustomObject]@{Name=$Name; Status='Running'; DisplayName="Mock $Name"; StartType='Automatic'; CanStop=$true}
        } -ModuleName Microsoft.PowerShell.Management
    }

    Context 'Служба Найдена (Get-Service успешен)' {
        It 'Должен вернуть IsAvailable=true, CheckSuccess=true, если статус Running и нет критериев' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'Spooler' }
            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Service -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management -ParameterFilter { $Name -eq 'Spooler' }
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details -is [hashtable] -and $Details.status -eq 'Running') -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
        }

        It 'Должен вернуть CheckSuccess=true, если статус Running и критерий status=Running' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'Spooler' }
            $assignment.success_criteria = @{ status = 'Running' }
            Mock Test-SuccessCriteria { param($DetailsObject,$CriteriaObject,$Path) return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.status -eq 'Running' }
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true -and [string]::IsNullOrEmpty($ErrorMessage) }
        }
        # ... (остальные тесты из этого контекста)
    }

    Context 'Служба Не Найдена (Get-Service выбрасывает ServiceCommandException)' {
        It 'Должен вернуть IsAvailable=true, CheckSuccess=false и сообщение об ошибке (служба не найдена)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'NonExistentSvcMock' }
            # Нет SuccessCriteria, поэтому CheckSuccess должен быть false из-за NotFound
            
            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Service -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName # Критериев нет, но и не должны вызываться т.к. есть ошибка "NotFound"
            
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and # Проверка была выполнена, хоть и с результатом "не найдено"
                $CheckSuccess -eq $false -and # Ненайденная служба - это провал, если нет критериев, ожидающих NotFound
                ($Details -is [hashtable] -and $Details.status -eq 'NotFound' -and $Details.error -match 'не найдена') -and
                ($ErrorMessage -match 'не найдена')
            }
        }

        It 'Должен вернуть CheckSuccess=true, если критерий ожидает status=NotFound' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'NonExistentSvcMock' }
            $assignment.success_criteria = @{ status = 'NotFound' } # Ожидаем, что служба не найдена
            Mock Test-SuccessCriteria { param($DetailsObject,$CriteriaObject,$Path)
                # Имитируем, что Test-SuccessCriteria прошел, т.к. $Details.status будет 'NotFound'
                if ($DetailsObject.status -eq 'NotFound' -and $CriteriaObject.status -eq 'NotFound') {
                    return @{ Passed = $true; FailReason = $null }
                }
                return @{ Passed = $false; FailReason = "Ожидался NotFound" }
            } -ModuleName $script:utilsModuleName -Scope It

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.status -eq 'NotFound') -and
                ($ErrorMessage -match 'не найдена') # ErrorMessage все равно будет, т.к. служба не найдена, но критерий это учел
            }
        }
    }

    Context 'Ошибка Валидации Параметра service_name' {
         It 'Должен вернуть IsAvailable=false, если service_name не передан' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             # $assignment.parameters не содержит service_name
             $result = & $script:scriptPath @assignment
             
             $result | Should -Not -BeNull
             ($result.PSObject.Properties.Name -notcontains 'Mocked' -or (-not $result.Mocked)) | Should -BeTrue
             $result.IsAvailable | Should -BeFalse
             $result.CheckSuccess | Should -BeNull
             $result.ErrorMessage | Should -Match 'service_name отсутствует'
         }
    }
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 ====
# Check-SQL_QUERY_EXECUTE.Tests.ps1
# Тесты для Check-SQL_QUERY_EXECUTE.ps1 v2.0.1 с моками Invoke-Sqlcmd

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Локальная New-CheckResultObject
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-SQL_QUERY_EXECUTE.ps1 (v2.0.1)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-SQL_QUERY_EXECUTE.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "..." }
        # Мок Get-Command, чтобы скрипт думал, что модуль SqlServer есть
        Mock Get-Command { param($Name) if($Name -eq 'Invoke-Sqlcmd'){ return $true } else { Get-Command @PSBoundParameters } }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'SQL_QUERY_EXECUTE'; node_name = 'TestNode-SQL'; ip_address = 'TestSQLServer'; parameters = @{sql_database='TestDB'}; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        # --- Мок Invoke-Sqlcmd ---
        # По умолчанию возвращает одну строку
        $mockSqlData = @( [PSCustomObject]@{ ID = 1; Name = 'Row1'; Value = 100 } )
        Mock Invoke-Sqlcmd { param($Query) Write-Verbose "Mock Invoke-Sqlcmd: Query=$Query"; return $using:mockSqlData }
    }

    Context 'Обработка разных return_format' {
        It 'first_row: Должен вернуть первую строку как хэш-таблицу' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT *"; $assignment.parameters.return_format = 'first_row'
            $result = & $script:scriptPath @assignment
            Should -Invoke Invoke-Sqlcmd -Times 1 -Exactly
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.return_format_used -eq 'first_row') -and
                ($Details.query_result -is [hashtable]) -and $Details.query_result.ID -eq 1 -and $Details.query_result.Name -eq 'Row1' -and
                ($Details.rows_returned -eq 1)
            }
        }
        It 'all_rows: Должен вернуть массив хэш-таблиц' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT *"; $assignment.parameters.return_format = 'all_rows'
            # Мок вернет тот же массив из 1 элемента
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                 ($Details.return_format_used -eq 'all_rows') -and
                 ($Details.query_result -is [System.Collections.Generic.List[object]]) -and $Details.query_result.Count -eq 1 -and
                 ($Details.query_result[0] -is [hashtable]) -and $Details.query_result[0].Value -eq 100 -and
                 ($Details.rows_returned -eq 1)
            }
        }
         It 'row_count: Должен вернуть количество строк' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT ID"; $assignment.parameters.return_format = 'row_count'
             # Мок вернет 1 строку
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                  $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                  ($Details.return_format_used -eq 'row_count') -and ($Details.row_count -eq 1)
             }
         }
          It 'scalar: Должен вернуть значение первого столбца первой строки' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "SELECT Value"; $assignment.parameters.return_format = 'scalar'
              # Мок вернет объект с Value=100
              $result = & $script:scriptPath @assignment
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                   $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                   ($Details.return_format_used -eq 'scalar') -and ($Details.scalar_value -eq 100)
              }
          }
          It 'non_query: Должен вернуть non_query_success = true' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "UPDATE T"; $assignment.parameters.return_format = 'non_query'
              Mock Invoke-Sqlcmd { return $null } -Scope It # Non-query обычно ничего не возвращает
              $result = & $script:scriptPath @assignment
              Should -Invoke Invoke-Sqlcmd -Times 1 -Exactly
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                   $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                   ($Details.return_format_used -eq 'non_query') -and ($Details.non_query_success -eq $true)
              }
          }
          It 'Должен обработать пустой результат от Invoke-Sqlcmd для first_row' {
               $assignment = $script:baseAssignment.PSObject.Copy()
               $assignment.parameters.sql_query = "SELECT * WHERE 1=0"; $assignment.parameters.return_format = 'first_row'
               Mock Invoke-Sqlcmd { return $null } -Scope It
               $result = & $script:scriptPath @assignment
               Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                    $IsAvailable -eq $true -and $CheckSuccess -eq $true -and # Пустой результат - не ошибка
                    ($Details.return_format_used -eq 'first_row') -and ($Details.query_result -eq $null) -and ($Details.rows_returned -eq 0)
               }
          }
    } # Конец Context 'Обработка return_format'

    Context 'Проверка Критериев Успеха' {
         It 'Должен вызвать Test-SuccessCriteria для row_count и вернуть CheckSuccess=false (mock=false)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT ID"; $assignment.parameters.return_format = 'row_count'
             $assignment.success_criteria = @{ row_count = @{ '==' = 0 } } # Критерий: строк должно быть 0
             $failReasonMock = "Количество строк (1) не равно 0"
             Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
             # Мок Invoke-Sqlcmd возвращает 1 строку
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.row_count -ne $null }
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
         }
         It 'Должен вызвать Test-SuccessCriteria для scalar и вернуть CheckSuccess=true (mock=true)' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "SELECT Value"; $assignment.parameters.return_format = 'scalar'
              $assignment.success_criteria = @{ scalar_value = @{ '<' = 200 } } # Критерий: значение < 200
              Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
              # Мок Invoke-Sqlcmd возвращает 100
              $result = & $script:scriptPath @assignment
              Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.scalar_value -ne $null }
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true }
         }
    } # Конец Context 'Проверка Критериев'

    Context 'Ошибки Invoke-Sqlcmd' {
         BeforeEach { Mock Invoke-Sqlcmd { throw "Ошибка подключения к SQL (Mock)" } }
         It 'Должен вернуть IsAvailable=false и сообщение об ошибке SQL' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT 1"; $assignment.parameters.return_format = 'scalar'
             $result = & $script:scriptPath @assignment
             $result.Mocked | Should -BeNullOr $false # Реальный результат из catch
             $result.IsAvailable | Should -BeFalse
             $result.CheckSuccess | Should -BeNull
             $result.ErrorMessage | Should -Match 'Критическая ошибка'
             $result.ErrorMessage | Should -Match 'SQL'
             Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
         }
          It 'non_query: Должен вернуть IsAvailable=false и non_query_success=false' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "UPDATE T"; $assignment.parameters.return_format = 'non_query'
              $result = & $script:scriptPath @assignment
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                   $IsAvailable -eq $false -and $CheckSuccess -eq $null -and
                   ($Details.non_query_success -eq $false) -and
                   $ErrorMessage -match 'Ошибка non-query SQL'
              }
          }
    } # Конец Context 'Ошибки Invoke-Sqlcmd'
} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 ====
# Check-SQL_XML_QUERY.Tests.ps1
# Тесты для Check-SQL_XML_QUERY.ps1 v2.0.1 с моками Invoke-Sqlcmd

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Локальная New-CheckResultObject
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-SQL_XML_QUERY.ps1 (v2.0.1)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-SQL_XML_QUERY.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "..." }
        Mock Get-Command { param($Name) if($Name -eq 'Invoke-Sqlcmd'){ return $true } else { Get-Command @PSBoundParameters } }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'SQL_XML_QUERY'; node_name = 'TestNode-SQLXML'; ip_address = 'TestSQLServer'; parameters = @{sql_database='TestDB'}; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        # --- Мок Invoke-Sqlcmd ---
        # По умолчанию возвращает строку с валидным XML
        $mockXmlString = '<Root><KeyA>ValueA</KeyA><KeyB>123</KeyB></Root>'
        $mockSqlData = @( [PSCustomObject]@{ XmlColumn = $mockXmlString; OtherColumn = 'data' } )
        Mock Invoke-Sqlcmd { param($Query) Write-Verbose "Mock Invoke-Sqlcmd: Query=$Query"; return $using:mockSqlData }
    }

    Context 'Успешное выполнение и парсинг XML' {
        It 'Должен извлечь значения для существующих ключей' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'
            $assignment.parameters.keys_to_extract = @('KeyA', 'KeyB')
            $result = & $script:scriptPath @assignment
            Should -Invoke Invoke-Sqlcmd -Times 1 -Exactly
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.extracted_data -is [hashtable]) -and
                $Details.extracted_data.KeyA -eq 'ValueA' -and
                $Details.extracted_data.KeyB -eq '123'
            }
             Should -Invoke Test-SuccessCriteria -Times 0 # Критериев нет
        }

        It 'Должен вернуть null для несуществующих ключей' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'
             $assignment.parameters.keys_to_extract = @('KeyA', 'NonExistentKey')
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                  $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                  $Details.extracted_data.KeyA -eq 'ValueA' -and
                  $Details.extracted_data.ContainsKey('NonExistentKey') -and $Details.extracted_data.NonExistentKey -eq $null
             }
        }
    } # Конец Context 'Успешное выполнение'

    Context 'Проверка Критериев Успеха' {
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true (mock=true)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'; $assignment.parameters.keys_to_extract = @('KeyA', 'KeyB')
             $assignment.success_criteria = @{ extracted_data = @{ KeyA = 'ValueA'; KeyB = @{'>'=100} } }
             Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.extracted_data -ne $null }
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true }
        }
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false (mock=false)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'; $assignment.parameters.keys_to_extract = @('KeyB')
            $assignment.success_criteria = @{ extracted_data = @{ KeyB = @{'<'=100} } } # Критерий KeyB < 100 (не пройдет, т.к. он 123)
            $failReasonMock = "KeyB (123) не меньше 100"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
        }
    } # Конец Context 'Проверка Критериев'

    Context 'Ошибки SQL или Парсинга' {
        It 'Должен вернуть IsAvailable=false, если Invoke-Sqlcmd выдает ошибку' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "ERROR"; $assignment.parameters.xml_column_name = 'C'; $assignment.parameters.keys_to_extract = @('K')
            Mock Invoke-Sqlcmd { throw "SQL Error (Mock)" } -Scope It
            $result = & $script:scriptPath @assignment
            $result.Mocked | Should -BeNullOr $false
            $result.IsAvailable | Should -BeFalse; $result.CheckSuccess | Should -BeNull; $result.ErrorMessage | Should -Match 'Критическая ошибка'; $result.ErrorMessage | Should -Match 'SQL Error'
            Should -Invoke Test-SuccessCriteria -Times 0
        }
        It 'Должен вернуть IsAvailable=false, если столбец XML не найден' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT OtherColumn"; $assignment.parameters.xml_column_name = 'WrongColumnName'; $assignment.parameters.keys_to_extract = @('K')
            # Мок Invoke-Sqlcmd возвращает OtherColumn='data'
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $IsAvailable -eq $false -and $ErrorMessage -match 'не найден' }
            Should -Invoke Test-SuccessCriteria -Times 0
        }
        It 'Должен вернуть IsAvailable=false, если XML невалиден' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT BadXml"; $assignment.parameters.xml_column_name = 'BadXml'; $assignment.parameters.keys_to_extract = @('K')
            Mock Invoke-Sqlcmd { return @([PSCustomObject]@{ BadXml = '<Root><KeyA>ValueA</Root' }) } -Scope It # Незакрытый тег
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $IsAvailable -eq $false -and $ErrorMessage -match 'Ошибка парсинга' }
            Should -Invoke Test-SuccessCriteria -Times 0
        }
         It 'Должен вернуть IsAvailable=true, если SQL не вернул строк' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT XmlCol WHERE 1=0"; $assignment.parameters.xml_column_name = 'XmlCol'; $assignment.parameters.keys_to_extract = @('K')
             Mock Invoke-Sqlcmd { return $null } -Scope It # Имитируем пустой результат
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $IsAvailable -eq $true -and $CheckSuccess -eq $true -and $Details.message -match 'не вернул строк' }
             Should -Invoke Test-SuccessCriteria -Times 0
         }
    } # Конец Context 'Ошибки SQL или Парсинга'

} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 ====
# Invoke-StatusMonitorCheck.Tests.ps1 (v8 - ���������� $PSScriptRoot � BeforeAll)

# --- ���� ���������� ---
# BeforeAll ����������� ���� ��� ����� ����� ������� � ���� Describe �����.
BeforeAll {
    # ���������� $PSScriptRoot, ������� ��������� �� ���������� �������� ����� ����� (.Tests.ps1)
    Write-Host "INFO: PSScriptRoot ��������� ���: $PSScriptRoot" # ��� ��� �������
    if (-not $PSScriptRoot) {
        throw "�� ������� ���������� ���������� ����� (\$PSScriptRoot). ���������� ����� ������."
    }

    # ������ ���� � ��������� ������������ ����� tests
    $moduleManifestRelativePath = '..\StatusMonitorAgentUtils.psd1'
    $moduleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath $moduleManifestRelativePath

    # ���������� Resolve-Path ��� ��������� ������� ���� � �������� �������������
    try {
        $resolvedModulePath = Resolve-Path -Path $moduleManifestPath -ErrorAction Stop
        Write-Host "INFO: ������ ���� � ��������� ������: $resolvedModulePath"
    } catch {
        # ��������� ����� ��������� ��������� �� ������
        Write-Error "�� ������� �����/���������� ���� � ��������� ������ '$moduleManifestPath'. ���������, ��� ��������� ����� �����: tests/ ��������� ������ StatusMonitorAgentUtils/. ������ Resolve-Path: $($_.Exception.Message)"
        throw "�� ������� ����� ������ ��� ������������." # ��������� ����������
    }

    # ����������� ������ �� ������� ����
    Write-Host "INFO: �������� ������ �� $resolvedModulePath ��� ������..."
    Remove-Module StatusMonitorAgentUtils -Force -ErrorAction SilentlyContinue
    Import-Module $resolvedModulePath -Force
    Write-Host "INFO: ������ StatusMonitorAgentUtils ��������."
}

# --- ����� ---
Describe 'Invoke-StatusMonitorCheck (��������� ��������)' {

    # --- Mocking (��� ���������) ---
    Mock New-CheckResultObject { Param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
        return @{ Mocked = $true; IsAvailable = $IsAvailable; CheckSuccess = $CheckSuccess; ErrorMessage = $ErrorMessage; Details = $Details }
    } -ModuleName StatusMonitorAgentUtils

    Mock Test-Path { Param($Path)
        if ($Path -like "*Checks\Check-*.ps1") { return $true }
        return Test-Path @using:PSBoundParameters
    } -ModuleName Microsoft.PowerShell.Management

    Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
        Write-Verbose "��� Invoke-CheckScript: ���������� ����� '$ScriptPath'"
        return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp = (Get-Date).ToUniversalTime().ToString("o"); Details = @{ CalledScript = $ScriptPath; ParamsPassed = $ParametersForScript }; ErrorMessage = $null }
    } -ModuleName StatusMonitorAgentUtils

    # --- �������� ������ (��� ���������) ---
    $baseAssignment = @{
        assignment_id = 101; node_id = 1; node_name = 'TestNode'; ip_address = '127.0.0.1'
        parameters = @{ timeout = 500 }; success_criteria = @{ max_rtt_ms = 100 }
    }

    # --- ����� (��� ���������) ---

    It '������ �������� Invoke-CheckScript ��� ������ PING � ����������� �����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'PING'
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            $ScriptPath | Should -EndWith '\Checks\Check-PING.ps1'
            $ParametersForScript | Should -Not -BeNull
            $ParametersForScript.TargetIP | Should -Be $using:assignment.ip_address
            $ParametersForScript.Parameters | Should -Be $using:assignment.parameters
            $ParametersForScript.SuccessCriteria | Should -Be $using:assignment.success_criteria
            $ParametersForScript.NodeName | Should -Be $using:assignment.node_name
            return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=@{mocked_call_for='PING'}; ErrorMessage=$null }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        $result.IsAvailable | Should -BeTrue
        $result.Details.mocked_call_for | Should -Be 'PING'
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
    }

    It '������ �������� Invoke-CheckScript ��� SERVICE_STATUS � ����������� �����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'SERVICE_STATUS'
        $assignment.parameters = @{ service_name = 'Spooler' }
        $assignment.success_criteria = @{ status = 'Running' }
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            $ScriptPath | Should -EndWith '\Checks\Check-SERVICE_STATUS.ps1'
            $ParametersForScript.TargetIP | Should -Be $using:assignment.ip_address
            $ParametersForScript.Parameters.service_name | Should -Be 'Spooler'
            $ParametersForScript.SuccessCriteria.status | Should -Be 'Running'
            return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=@{mocked_call_for='SERVICE'}; ErrorMessage=$null }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        $result.IsAvailable | Should -BeTrue
        $result.Details.mocked_call_for | Should -Be 'SERVICE'
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
    }

    It '������ ���������� ������, ���� ������ �������� �� ������ (Test-Path ������ false)' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'NON_EXISTENT_METHOD'
        Mock Test-Path { Param($Path)
            if ($Path -like "*Check-NON_EXISTENT_METHOD.ps1") { return $false }
            return $true
        } -ModuleName Microsoft.PowerShell.Management -Verifiable
        Mock Invoke-CheckScript { throw "Invoke-CheckScript �� ������ ��� ���������!" } -ModuleName StatusMonitorAgentUtils -Verifiable -Scope It
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Test-Path -Times 1 -ModuleName Microsoft.PowerShell.Management
        Should -Invoke Invoke-CheckScript -Times 0 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '�� ������'
        $result.ErrorMessage | Should -Contain 'Check-NON_EXISTENT_METHOD.ps1'
    }

    It '������ ���������� ������, ���� ����� �� ������ � �������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.PSObject.Properties.Remove('method_name')
        Mock Invoke-CheckScript { throw "�� ������ ���� ����� �� ������ �������" } -ModuleName StatusMonitorAgentUtils -Verifiable -Scope It
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 0 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '������������ ������ �������'
    }

     It '������ ���������� ������, ���� Invoke-CheckScript ����������� ����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'SCRIPT_WITH_ERROR'
        $errorMessageFromInvoke = "����������� ������ ��� ������ �������"
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            if ($ScriptPath -like "*Check-SCRIPT_WITH_ERROR.ps1") {
                throw $errorMessageFromInvoke
            }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        Mock Test-Path { return $true } -ModuleName Microsoft.PowerShell.Management
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain $errorMessageFromInvoke
        $result.ErrorMessage | Should -Contain '������ ���������� ������� ��������'
    }

     It '������ ���������� ������, ���� Invoke-CheckScript ������ ������������ ������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'BAD_FORMAT_SCRIPT'
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            if ($ScriptPath -like "*Check-BAD_FORMAT_SCRIPT.ps1") {
                return "��� ������ ������, � �� ���-�������"
            }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        Mock Test-Path { return $true } -ModuleName Microsoft.PowerShell.Management
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '������ ������������ ������'
    }
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 ====

