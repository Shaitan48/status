=== СПИСОК ФАЙЛОВ ===
Файл: F:\status\source\powershell\Dockerfile.tests (Кодировка: UTF8)
Файл: F:\status\source\powershell\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\configurator\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\configurator\README.txt (Кодировка: UTF8)
Файл: F:\status\source\powershell\hybrid-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\hybrid-agent\hybrid-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\hybrid-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\offline-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\offline-agent\offline-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\offline-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\online-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\online-agent\online-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\online-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\result_loader.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)


=== ДЕРЕВО КАТАЛОГОВ ===
F:\status\source\powershell
  |-- Dockerfile.tests (Кодировка: UTF8)
  |-- README.md (Кодировка: UTF8)
  |-- configurator\config.json (Кодировка: UTF8)
  |-- configurator\generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
  |-- configurator\README.txt (Кодировка: UTF8)
  |-- hybrid-agent\config.json (Кодировка: UTF8)
  |-- hybrid-agent\hybrid-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- hybrid-agent\README.md (Кодировка: UTF8)
  |-- offline-agent\config.json (Кодировка: UTF8)
  |-- offline-agent\offline-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- offline-agent\README.md (Кодировка: UTF8)
  |-- online-agent\config.json (Кодировка: UTF8)
  |-- online-agent\online-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- online-agent\README.md (Кодировка: UTF8)
  |-- result_loader\config.json (Кодировка: UTF8)
  |-- result_loader\README.md (Кодировка: UTF8)
  |-- result_loader\result_loader.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\README.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-PING.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\configurator
  |-- config.json (Кодировка: UTF8)
  |-- generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
  |-- README.txt (Кодировка: UTF8)
F:\status\source\powershell\hybrid-agent
  |-- config.json (Кодировка: UTF8)
  |-- hybrid-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\offline-agent
  |-- config.json (Кодировка: UTF8)
  |-- offline-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\online-agent
  |-- config.json (Кодировка: UTF8)
  |-- online-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\result_loader
  |-- config.json (Кодировка: UTF8)
  |-- README.md (Кодировка: UTF8)
  |-- result_loader.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\StatusMonitorAgentUtils
  |-- ManualTest-Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
  |-- TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_PING.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- Checks\README-Check-PING.md (Кодировка: UTF8)
  |-- Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
  |-- tests\Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\StatusMonitorAgentUtils\Checks
  |-- Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- README-Check-PING.md (Кодировка: UTF8)
  |-- README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
F:\status\source\powershell\StatusMonitorAgentUtils\tests
  |-- Check-CERT_EXPIRY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-DISK_USAGE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PROCESS_LIST.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SERVICE_STATUS.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_QUERY_EXECUTE.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_XML_QUERY.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)


==== BEGIN FILE: F:\status\source\powershell\Dockerfile.tests ====
# powershell/Dockerfile.tests
# Dockerfile для запуска Pester тестов для PowerShell модулей проекта Status Monitor

# Используем официальный образ PowerShell (например, на базе Linux Alpine для легковесности)
# Выберите версию PowerShell, наиболее близкую к вашей целевой среде (5.1),
# но учтите, что официальные образы в основном идут с PowerShell 7+.
# Для PS 5.1 может потребоваться образ Windows Server Core, что усложнит сборку.
# Давайте пока остановимся на последней версии PowerShell Core, т.к. Pester 5 лучше работает с ней.
# Если возникнут проблемы совместимости с 5.1, нужно будет пересмотреть базовый образ.
FROM mcr.microsoft.com/powershell:latest

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app/tests

# Копируем ВСЮ папку powershell из хоста ВНУТРЬ /app/powershell в контейнере
# Это включает сам модуль StatusMonitorAgentUtils и папку tests
COPY ./ /app/powershell/

# Устанавливаем Pester последней версии
# Используем pwsh для выполнения команд PowerShell внутри контейнера
# Set-PSRepository -Name PSGallery -InstallationPolicy Trusted # Доверенный репозиторий
# Install-Module Pester -Force -SkipPublisherCheck # Установка Pester
# Убрал Scope CurrentUser, т.к. в контейнере это не так важно и может вызвать проблемы
# <<< УЛУЧШЕННАЯ УСТАНОВКА PESTER (обходит возможные проблемы с репозиторием) >>>
RUN pwsh -Command " \
    Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force; \
    Set-PSRepository -Name PSGallery -InstallationPolicy Trusted; \
    Install-Module -Name Pester -Repository PSGallery -Force -SkipPublisherCheck; \
    Write-Host 'Pester установлен.'"

# Установка других зависимостей, если они нужны для тестов
# Например, если бы тесты SQL требовали модуль SqlServer ВНУТРИ контейнера
# RUN pwsh -Command "Install-Module -Name SqlServer -Repository PSGallery -Force -SkipPublisherCheck"

# Устанавливаем рабочую директорию ВНУТРИ папки с тестами модуля Utils
# Это нужно, чтобы Invoke-Pester корректно находил тесты
WORKDIR /app/powershell/StatusMonitorAgentUtils/tests

# Команда по умолчанию для запуска всех *.Tests.ps1 файлов Pester в текущей директории
# -Output Detailed : Подробный вывод
# -CI : Режим для CI/CD систем (меняет exit code при ошибках)
# -PassThru : Возвращает объект с результатами (может быть полезно для CI)
# Можно добавить -Path для указания конкретных файлов/папок
CMD ["pwsh", "-Command", "Invoke-Pester -Output Detailed -CI -PassThru"]

# Альтернативная команда для запуска конкретного файла:
# CMD ["pwsh", "-Command", "Invoke-Pester -Path ./Check-PING.Tests.ps1 -Output Detailed -CI"]
==== END FILE: F:\status\source\powershell\Dockerfile.tests ====

==== BEGIN FILE: F:\status\source\powershell\README.md ====
# PowerShell Скрипты для Status Monitor

Эта папка содержит PowerShell скрипты и модули, которые выполняют роль агентов мониторинга и вспомогательных утилит для системы Status Monitor.

## Структура

*   **`online-agent/`**: Содержит скрипт и конфигурацию для **Онлайн-агента**, работающего на машинах с прямым доступом к API сервера мониторинга.
    *   [`online-agent/README.md`](online-agent/README.md)
*   **`offline-agent/`**: Содержит скрипт и конфигурацию для **Оффлайн-агента**, работающего в изолированных сетях без доступа к API.
    *   [`offline-agent/README.md`](offline-agent/README.md)
*   **`result_loader/`**: Скрипт и конфигурация **Загрузчика Результатов**, который обрабатывает файлы (`*.zrpu`) от оффлайн-агентов и отправляет данные в API.
    *   [`result_loader/README.md`](result_loader/README.md)
*   **`configurator/`**: Скрипт и конфигурация **Конфигуратора**, который генерирует файлы с заданиями для оффлайн-агентов, запрашивая данные у API.
    *   [`configurator/README.md`](configurator/README.md)
*   **`StatusMonitorAgentUtils/`**: **ОБЩИЙ МОДУЛЬ PowerShell**, содержащий основную логику выполнения проверок. Используется как онлайн, так и оффлайн агентами.
    *   [`StatusMonitorAgentUtils/README.md`](StatusMonitorAgentUtils/README.md)

## Ключевой компонент: `StatusMonitorAgentUtils`

Этот модуль является сердцем выполнения проверок на стороне PowerShell.

*   **Диспетчер (`Invoke-StatusMonitorCheck`)**: Основная экспортируемая функция модуля. Агенты вызывают именно ее, передавая объект задания. Функция определяет, какой метод проверки нужно выполнить (`method_name` из задания), находит соответствующий скрипт `Checks/Check-*.ps1` и **запускает его локально** на машине агента, передавая нужные параметры.
*   **Скрипты проверок (`Checks/Check-*.ps1`)**: Папка `Checks` внутри `StatusMonitorAgentUtils` содержит отдельные `.ps1` файлы для каждого метода проверки (например, `Check-PING.ps1`, `Check-SERVICE_STATUS.ps1`). Каждый такой скрипт выполняет **только свою конкретную проверку**, используя переданные ему параметры (например, IP-адрес цели, имя службы), и возвращает стандартизированный результат.
*   **Вспомогательные функции**: Модуль также содержит функции для стандартизации формата результата (`New-CheckResultObject`) и, в будущем, может содержать другие общие утилиты.

**Важно:** Для добавления поддержки нового метода мониторинга необходимо создать соответствующий `Check-METHOD_NAME.ps1` файл в папке `Checks/` и реализовать в нем логику проверки и возврата стандартизированного результата.

## Принцип работы с Заданиями (Assignments)

Система использует модель "Заданий" (`Assignments`), хранящихся в центральной БД. Каждый результат проверки должен быть связан с конкретным заданием через `assignment_id`.

*   **Online-агент:** Получает задания (с `assignment_id`) от API. Вызывает `Invoke-StatusMonitorCheck`. Получает результат. Отправляет результат **вместе с `assignment_id`** в API `/api/v1/checks`.
*   **Offline-агент:** Получает задания (с `assignment_id`) из файла `.json.status.КОД_ТС`. Вызывает `Invoke-StatusMonitorCheck`. Получает результат. **Добавляет `assignment_id`** к полученному результату. Сохраняет массив дополненных результатов в файл `*.zrpu`.
*   **Загрузчик (`result_loader`):** Читает файл `*.zrpu`. Для каждой записи результата извлекает `assignment_id` и остальные данные, формирует запрос и отправляет его в API `/api/v1/checks`.

Это позволяет серверу точно сопоставить каждый полученный результат с конкретным заданием, настроенным администратором.
==== END FILE: F:\status\source\powershell\README.md ====

==== BEGIN FILE: F:\status\source\powershell\configurator\config.json ====
{
  "api_base_url": "http://localhost:48030/api",
  "api_key": "eWfRuIrdREe_Bt8jaOzUmZ23JYIwk6Keeu9dQZnywwI",
  "output_path_base": "F:\\status\\builds\\configs\\Generated",
  "delivery_path_base": "F:\\status\\builds\\delivery_conf",
  "log_file": "F:\\status\\builds\\Logs\\configurator.log",
  "log_level": "Info", 
  "subdivision_ids_to_process": [1516, 1060],
  "output_filename_template": "{version_tag}_assignments.json.status.{transport_code}",
  "delivery_subdir_template": "{transport_code}",
  "api_timeout_sec": 60
}
==== END FILE: F:\status\source\powershell\configurator\config.json ====

==== BEGIN FILE: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 ====
# powershell/configurator/generate_and_deliver_config.ps1
# --- Версия 4.1 ---
# Изменения:
# - Добавлена атомарность при сохранении и доставке файлов.
<#
.SYNOPSIS
    Генерирует и доставляет конфигурационные файлы для оффлайн-режима
    гибридного агента Status Monitor (v4.1).
.DESCRIPTION
    Запрашивает конфигурацию у API и АТОМАРНО сохраняет/доставляет JSON файлы.
    1. Читает `config.json`.
    2. Определяет список ObjectId для обработки.
    3. Для каждого ObjectId:
       - Запрашивает `GET /api/v1/objects/{ObjectId}/offline_config`.
       - Проверяет ответ.
       - Формирует имя файла.
       - **Сохраняет JSON во временный файл в `output_path_base`.**
       - **Переименовывает временный файл в основной.**
       - Если задан `delivery_path_base`:
         - **Копирует основной файл во временный файл в папке доставки.**
         - **Переименовывает временный файл доставки в основной.**
.NOTES
    Версия: 4.1
    Дата: [Актуальная Дата]
#>
param(
    [string]$ConfigFile = "$PSScriptRoot\config.json",
    [string]$ParamLogFile = $null,
    [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
    [string]$ParamLogLevel = $null
)

# --- Вспомогательные функции (без изменений от предыдущей версии) ---
filter Get-OrElse_Internal { param([object]$DefaultValue); if ($_) { $_ } else { $DefaultValue } }
function Write-Log { param ([Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)][string]$Level = "Info"); if (-not $script:Config -or -not $script:Config.log_file) { Write-Host "[$Level] $Message"; return }; $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }; $currentLevelValue = $logLevels[$script:EffectiveLogLevel]; if ($null -eq $currentLevelValue) { $currentLevelValue = $logLevels["Info"] }; $messageLevelValue = $logLevels[$Level]; if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] }; if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] - $Message"; Write-Host $logMessage -ForegroundColor $(switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}); try { $logDir = Split-Path $script:Config.log_file -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки для лога: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }; $logMessage | Out-File -FilePath $script:Config.log_file -Append -Encoding UTF8 -ErrorAction Stop } catch { Write-Host "[Error] Невозможно записать в лог '$($script:Config.log_file)': $($_.Exception.Message)" -ForegroundColor Red } } }

# --- Начало скрипта ---
$ScriptVersion = "4.1"
$script:Config = $null
$script:EffectiveLogLevel = "Info"
$script:ApiKey = $null

# --- Шаг 1: Чтение и валидация конфигурации ---
# (Код без изменений, проверяет все поля, включая delivery_path_base)
Write-Host "Загрузка конфигурации из файла: $ConfigFile"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Error "Критическая ошибка: Файл конфигурации '$ConfigFile' не найден."; exit 1 }
try { $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error "Критическая ошибка: Ошибка чтения/парсинга JSON '$ConfigFile'. Ошибка: $($_.Exception.Message)"; exit 1 }
$requiredConfigFields = @("api_base_url", "api_key", "output_path_base", "delivery_path_base", "log_file", "log_level", "subdivision_ids_to_process", "output_filename_template", "delivery_subdir_template", "api_timeout_sec")
$missingFields = $requiredConfigFields | Where-Object { -not $script:Config.PSObject.Properties.Name.Contains($_) -or (-not ($script:Config.PSObject.Properties.$_ -ne $null) -and $_ -ne 'delivery_path_base') } # delivery_path_base может быть null
if ($missingFields) { Write-Error "Критическая ошибка: В '$ConfigFile' отсутствуют поля: $($missingFields -join ', ')"; exit 1 }
if ($script:Config.subdivision_ids_to_process -isnot [array]) { Write-Error "..."; exit 1 }
if ($ParamLogFile) { $script:Config.log_file = $ParamLogFile }
if ($ParamLogLevel) { $script:Config.log_level = $ParamLogLevel }
$validLogLevelsMap = @{ "Debug" = 0; "Verbose" = 1; "Info" = 2; "Warn" = 3; "Error" = 4 }
if (-not $validLogLevelsMap.ContainsKey($script:Config.log_level)) { $script:Config.log_level = "Info" }
$script:EffectiveLogLevel = $script:Config.log_level
$script:ApiKey = $script:Config.api_key

# --- Шаг 2: Инициализация и логирование ---
# (Код без изменений)
$logDir = Split-Path $script:Config.log_file -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { try { New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null } catch { Write-Error "..."; exit 1 } }
Write-Log "Скрипт конфигуратора (v$ScriptVersion) запущен." "Info"
# ... (логирование параметров конфига) ...

# --- Шаг 3: Определение списка ObjectId для обработки ---
# (Код без изменений, использует Invoke-RestMethod)
$objectIdsToProcess = @()
if ($script:Config.subdivision_ids_to_process.Count -gt 0) { $objectIdsToProcess = $script:Config.subdivision_ids_to_process | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ } }
else {
    Write-Log "Запрос всех подразделений с кодом ТС из API..." "Info"
    $apiUrlSubdivisions = "$($script:Config.api_base_url.TrimEnd('/'))/v1/subdivisions?limit=1000"
    $headers = @{ 'X-API-Key' = $script:ApiKey }
    try {
        $response = Invoke-RestMethod -Uri $apiUrlSubdivisions -Method Get -Headers $headers -TimeoutSec ($script:Config.api_timeout_sec | Get-OrElse_Internal 60) -ErrorAction Stop
        if ($response -and $response.items -is [array]) { $objectIdsToProcess = $response.items | Where-Object { $_.transport_system_code -and $_.object_id } | Select-Object -ExpandProperty object_id; Write-Log "Найдено для обработки: $($objectIdsToProcess.Count)" "Info" }
    } catch {
        $rawErrorMessage = $_.Exception.Message; $responseBody="[N/A]"; $statusCode=$null; if($_.Exception.Response){try{$statusCode=$_.Exception.Response.StatusCode}catch{}; try{$stream=[System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream());$responseBody=$stream.ReadToEnd();$stream.Close()}catch{}};
        Write-Log "Критическая ошибка получения списка подразделений: $rawErrorMessage - Code: $statusCode - Resp: $responseBody" "Error"; exit 1
    }
}
if ($objectIdsToProcess.Count -eq 0) { Write-Log "Нет ObjectId для обработки. Завершение." "Info"; exit 0 }

# --- Шаг 4: Цикл обработки каждого ObjectId ---
Write-Log "Начало цикла обработки для $($objectIdsToProcess.Count) подразделений." "Info"
foreach ($currentObjectId in $objectIdsToProcess) {
    Write-Log "--- Обработка ObjectId: $currentObjectId ---" "Info"
    $apiResponse = $null
    $versionTag = "[error]" # Значение по умолчанию
    $transportCode = "[error]" # Значение по умолчанию

    # 1. Запрос конфигурации
    $apiUrlConfig = "$($script:Config.api_base_url.TrimEnd('/'))/v1/objects/${currentObjectId}/offline_config"
    $headersConfig = @{ 'X-API-Key' = $script:ApiKey }
    Write-Log "Запрос конфигурации: GET $apiUrlConfig" "Verbose"
    try {
        $apiResponse = Invoke-RestMethod -Uri $apiUrlConfig -Method Get -Headers $headersConfig -TimeoutSec ($script:Config.api_timeout_sec | Get-OrElse_Internal 60) -ErrorAction Stop
        # Валидация ответа API
        if (-not ($apiResponse -is [PSCustomObject]) -or (-not $apiResponse.PSObject.Properties.Name.Contains('assignment_config_version')) -or (-not $apiResponse.PSObject.Properties.Name.Contains('transport_system_code')) -or (-not $apiResponse.PSObject.Properties.Name.Contains('assignments'))) {
             if($apiResponse -is [PSCustomObject] -and $apiResponse.error){ throw "API вернул ошибку: $($apiResponse.error)" }
             else { throw "Некорректная структура ответа API /offline_config." }
        }
        $versionTag = $apiResponse.assignment_config_version
        $transportCode = $apiResponse.transport_system_code
        $assignmentCount = $apiResponse.assignments.Count
        Write-Log "Конфигурация получена. Версия: ${versionTag}. Заданий: ${assignmentCount}. Код ТС: ${transportCode}." "Info"

    } catch {
        # Обработка ошибок API
        $exceptionMessage = $_.Exception.Message; $statusCode = $null; if ($_.Exception.Response) { try {$statusCode = $_.Exception.Response.StatusCode} catch {} };
        Write-Log "Ошибка получения конфигурации от API для ObjectId ${currentObjectId}: $exceptionMessage (Код: $statusCode)" "Error";
        continue # Пропускаем этот ID
    }

    # 2. Формирование имен файлов
    $outputFileNameBase = $script:Config.output_filename_template -replace "{version_tag}", $versionTag -replace "{transport_code}", $transportCode
    $outputFileName = $outputFileNameBase -replace '[\\/:*?"<>|]', '_' # Убираем недопустимые символы
    # Полные пути
    $outputFilePath = Join-Path -Path $script:Config.output_path_base -ChildPath $outputFileName
    $tempOutputFilePath = $outputFilePath + ".tmp" # Временный файл рядом
    $outputDir = Split-Path $outputFilePath -Parent

    # 3. Создание папки вывода
    if (-not (Test-Path $outputDir -PathType Container)) {
        Write-Log "Создание папки вывода '$outputDir'" "Verbose"
        try { New-Item -Path $outputDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }
        catch { Write-Log "Ошибка создания папки вывода '$outputDir'. Пропуск ${currentObjectId}. Error: $($_.Exception.Message)" "Error"; continue }
    }

    # --- 4. Атомарное сохранение JSON в output_path_base ---
    Write-Log "Сохранение конфигурации во временный файл: $tempOutputFilePath" "Verbose"
    $saveSuccess = $false
    try {
        $jsonToSave = $apiResponse | ConvertTo-Json -Depth 10 -WarningAction SilentlyContinue
        $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false)
        [System.IO.File]::WriteAllText($tempOutputFilePath, $jsonToSave, $Utf8NoBomEncoding)
        Write-Log "Данные записаны во временный файл." "Debug"
        # Переименование во временный файл
        Move-Item -Path $tempOutputFilePath -Destination $outputFilePath -Force -ErrorAction Stop
        Write-Log "Файл '$outputFileName' успешно сохранен (атомарно) в '$outputDir'." "Info"
        $saveSuccess = $true
    } catch {
        Write-Log "Ошибка сохранения/переименования файла '$outputFilePath'. Пропуск ${currentObjectId}. Error: $($_.Exception.Message)" "Error"
        # Пытаемся удалить временный файл, если он остался
        if (Test-Path $tempOutputFilePath -PathType Leaf) { try { Remove-Item -Path $tempOutputFilePath -Force -ErrorAction SilentlyContinue } catch {} }
        continue # Пропускаем доставку, если сохранение не удалось
    }

    # --- 5. Атомарная доставка файла (если нужно) ---
    if ($saveSuccess -and $script:Config.delivery_path_base) {
        $deliverySubDir = $script:Config.delivery_subdir_template -replace "{transport_code}", $transportCode
        $deliveryPath = Join-Path -Path $script:Config.delivery_path_base -ChildPath $deliverySubDir
        $deliveryFileName = $outputFileName # Имя файла то же
        $deliveryFilePath = Join-Path -Path $deliveryPath -ChildPath $deliveryFileName
        $tempDeliveryFilePath = $deliveryFilePath + ".tmp" # Временный файл доставки
        Write-Log "Проверка пути доставки: $deliveryFilePath" "Info"

        # Создаем папку доставки, если ее нет
        if (-not (Test-Path $deliveryPath -PathType Container)) {
            Write-Log "Папка доставки '$deliveryPath' не найдена. Создание..." "Warn"
            try { New-Item -Path $deliveryPath -ItemType Directory -Force -ErrorAction Stop | Out-Null; Write-Log "Папка '$deliveryPath' создана." "Verbose" }
            catch { Write-Log "Ошибка создания папки доставки '$deliveryPath'. Пропуск доставки. Error: $($_.Exception.Message)" "Error"; continue } # Пропускаем, если не удалось создать
        }

        # Атомарное копирование (Copy -> Rename)
        Write-Log "Копирование '$outputFilePath' -> '$tempDeliveryFilePath'" "Verbose"
        try {
             # 1. Копируем во временный файл
             Copy-Item -Path $outputFilePath -Destination $tempDeliveryFilePath -Force -ErrorAction Stop
             Write-Log "Временный файл доставки создан." "Debug"
             # 2. Переименовываем временный в основной
             Move-Item -Path $tempDeliveryFilePath -Destination $deliveryFilePath -Force -ErrorAction Stop
             Write-Log "Файл '$outputFileName' успешно доставлен (атомарно) в '$deliveryPath'." "Info"
        } catch {
             Write-Log "Ошибка копирования/переименования при доставке в '$deliveryFilePath'. Error: $($_.Exception.Message)" "Error"
             # Пытаемся удалить временный файл доставки, если он остался
             if (Test-Path $tempDeliveryFilePath -PathType Leaf) { try { Remove-Item -Path $tempDeliveryFilePath -Force -ErrorAction SilentlyContinue } catch {} }
        }
    } elseif ($saveSuccess) {
         Write-Log "delivery_path_base не задан. Пропуск доставки." "Info"
    }

    Write-Log "--- Обработка ObjectId: $currentObjectId завершена ---" "Info"
} # --- Конец цикла foreach ---

Write-Log "Работа скрипта конфигуратора успешно завершена." "Info"
==== END FILE: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\configurator\README.txt ====

---

### 3. README для Конфигуратора Оффлайн Агентов

**Файл:** `powershell/configurator/README.md` (Обновленный)

```markdown
# PowerShell Конфигуратор Оффлайн Агентов (configurator) v4.1

Этот скрипт (`generate_and_deliver_config.ps1`) предназначен для автоматической генерации и (опционально) **атомарной** доставки файлов конфигурации с заданиями для **Гибридного Агента** в **Offline режиме**.

## Назначение

*   Подключаться к центральному API системы мониторинга.
*   Запрашивать актуальную конфигурацию заданий для одного или нескольких подразделений (объектов), идентифицируемых по их `ObjectId`.
*   **Атомарно** сохранять полученную конфигурацию (включая метаданные и список заданий) в JSON файлы специального формата (`{version_tag}_assignments.json.status.{transport_code}`).
*   Опционально **атомарно** доставлять (копировать) сгенерированные файлы в указанные папки.

## Принцип Работы

1.  Скрипт запускается (вручную или по расписанию).
2.  Читает параметры из файла `config.json`.
3.  Определяет список `ObjectId` для обработки (из конфига или через API).
4.  Для каждого `ObjectId`:
    *   Выполняет GET-запрос к `/api/v1/objects/{ObjectId}/offline_config`.
    *   API возвращает JSON-объект конфигурации.
    *   Скрипт проверяет корректность ответа.
    *   Формирует имя файла на основе шаблона и данных из ответа.
    *   **Сохраняет JSON во временный файл (`.tmp`) в `output_path_base`.**
    *   **При успехе сохранения, переименовывает временный файл в основной (`.json.status.*`).**
    *   Если задан `delivery_path_base`:
        *   Формирует путь к целевой папке.
        *   **Копирует основной файл во временный файл (`.tmp`) в папке доставки.**
        *   **При успехе копирования, переименовывает временный файл доставки в основной.**
5.  Логирует свою работу.

**Атомарность:** Использование временных файлов и операции переименования (которая обычно атомарна в пределах одного тома файловой системы) гарантирует, что Гибридный Агент не прочитает частично записанный или скопированный файл конфигурации.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке:

```json
{
  "api_base_url": "http://localhost:48030/api", // ОБЯЗАТЕЛЬНО
  "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_CONFIGURATOR", // ОБЯЗАТЕЛЬНО
  "output_path_base": "F:\\status\\builds\\configs\\Generated", // ОБЯЗАТЕЛЬНО
  "delivery_path_base": "F:\\status\\builds\\delivery_conf", // ОБЯЗАТЕЛЬНО (или null, если доставка не нужна)
  "log_file": "F:\\status\\builds\\Logs\\configurator.log", // ОБЯЗАТЕЛЬНО
  "log_level": "Info", // Опционально (default: Info)
  "subdivision_ids_to_process": [], // ОБЯЗАТЕЛЬНО: [] для авто, [1060, ...] для конкретных
  "output_filename_template": "{version_tag}_assignments.json.status.{transport_code}", // ОБЯЗАТЕЛЬНО
  "delivery_subdir_template": "{transport_code}", // ОБЯЗАТЕЛЬНО
  "api_timeout_sec": 60 // Опционально (default: 60)
}

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Сеть: Доступ к api_base_url.

    Права: Права на запись/переименование в output_path_base и delivery_path_base. Права на запись в log_file.

    API Ключ: Действительный ключ с ролью configurator.

    Запуск: Вручную или через Планировщик Задач.

Замечания

    Скрипт генерирует файлы для Гибридного Агента в Offline режиме.

    Убедитесь, что транспортная система (или сам агент) настроена на чтение файлов из папки доставки (delivery_path_base/{transport_code}/).
==== END FILE: F:\status\source\powershell\configurator\README.txt ====

==== BEGIN FILE: F:\status\source\powershell\hybrid-agent\config.json ====
{
    "mode": "Online",
    "object_id": 1516,
    "log_file": "C:/StatusMonitor/Logs/hybrid-agent.log",
    "log_level": "Info",
    "agent_script_version": "hybrid_agent_v7.0",
    "api_base_url": "http://localhost:48030/api",
    "api_key": "ЗАМЕНИТЕ_НА_ВАШ_AGENT_КЛЮЧ",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 300,
    "assignments_file_path_pattern": "C:/StatusMonitor/OfflineConfig/*.json.status.*",
    "output_path": "C:/StatusMonitor/OfflineResults",
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_HybridOffline.zrpu",
    "offline_cycle_interval_seconds": 0
}
==== END FILE: F:\status\source\powershell\hybrid-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\hybrid-agent\hybrid-agent.ps1 ====
# powershell/hybrid-agent/hybrid-agent.ps1
# --- Гибридный Агент Мониторинга v7.0 ---
<#
.SYNOPSIS
    Гибридный агент системы мониторинга Status Monitor v7.0.
    Работает в режимах Online или Offline в зависимости от конфигурации.
.DESCRIPTION
    Этот агент выполняет мониторинг узлов и отправляет результаты.
    Режим работы определяется параметром 'mode' в файле config.json.

    Online режим:
    - Получает задания от API сервера (/api/v1/assignments).
    - Выполняет задания по расписанию.
    - Отправляет результат КАЖДОЙ проверки массивом из одного элемента на API (/api/v1/checks).

    Offline режим:
    - Читает задания из локального файла конфигурации (*.json.status.*).
    - Выполняет ВСЕ задания за один цикл.
    - Собирает результаты и сохраняет их в файл *.zrpu для последующей загрузки.
.NOTES
    Версия: 7.0
    Дата: [Актуальная Дата]
    Объединяет функциональность Online и Offline агентов.
    Использует модуль StatusMonitorAgentUtils.
    Требует PowerShell 5.1+.
    Совместим с API Status Monitor v5.2+.
#>
param (
    # Путь к единому файлу конфигурации агента.
    [string]$ConfigFile = "$PSScriptRoot\config.json"
)

# --- 1. Загрузка общего модуля утилит ---
$ErrorActionPreference = "Stop" # Строгий режим на время импорта
try {
    # Путь к манифесту Utils относительно папки hybrid-agent
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils успешно загружен."
} catch {
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "[CRITICAL] Агент не может работать без модуля Utils. Завершение." -ForegroundColor Red
    exit 1 # Критическая ошибка - выходим
} finally {
    $ErrorActionPreference = "Continue" # Возвращаем стандартный режим
}
# --- Конец загрузки модуля ---

# --- 2. Глобальные переменные ---
$script:ComputerName = $env:COMPUTERNAME
$script:Config = $null         # Конфигурация из config.json
$script:LogLevel = "Info"      # Уровень логирования
$script:LogFilePath = $null    # Полный путь к лог-файлу
$script:AgentVersion = "hybrid_agent_v7.0" # Версия скрипта для логов/результатов

# Переменные для Online режима
$script:ActiveAssignmentsOnline = @{} # Активные задания (ID -> Объект)
$script:LastExecutedTimesOnline = @{} # Время последнего выполнения (ID -> DateTimeOffset UTC)
$script:LastApiPollTimeOnline = [DateTimeOffset]::MinValue # Время последнего опроса API

# Переменные для Offline режима
$script:CurrentAssignmentsOffline = $null # Текущие задания из файла (массив)
$script:CurrentConfigVersionOffline = $null # Текущая версия файла конфига
$script:LastProcessedConfigFileOffline = $null # Путь к последнему обработанному файлу

# --- 3. Вспомогательные функции ---

#region Функции

<#
.SYNOPSIS Записывает сообщение в лог и/или консоль.
#>
function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
        [string]$Level = "Info"
    )
    # Уровни логирования (числовое представление)
    $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }
    $effectiveLogLevelValue = $logLevels[$script:LogLevel] # Текущий установленный уровень
    if ($null -eq $effectiveLogLevelValue) { $effectiveLogLevelValue = $logLevels["Info"] } # Fallback
    $messageLevelValue = $logLevels[$Level] # Уровень текущего сообщения
    if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] } # Fallback

    # Проверяем, нужно ли писать сообщение
    if ($messageLevelValue -le $effectiveLogLevelValue) {
        $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        $logMessage = "[$timestamp] [$Level] [$script:ComputerName] - $Message"
        # Определение цвета для консоли
        $consoleColor = switch($Level) {
            "Error"   { "Red" }
            "Warn"    { "Yellow" }
            "Info"    { "White" }
            "Verbose" { "Gray" }
            "Debug"   { "DarkGray" }
            Default   { "Gray" }
        }
        # Вывод в консоль
        Write-Host $logMessage -ForegroundColor $consoleColor

        # Запись в файл, если путь задан
        if ($script:LogFilePath) {
            try {
                # Проверяем/создаем папку для лога
                $logDir = Split-Path $script:LogFilePath -Parent
                if ($logDir -and (-not (Test-Path $logDir -PathType Container))) {
                    Write-Host "[INFO] Создание папки для лога: '$logDir'"
                    New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                }
                # Добавляем сообщение в файл
                Add-Content -Path $script:LogFilePath -Value $logMessage -Encoding UTF8 -Force -ErrorAction Stop
            } catch {
                # Ошибка записи в основной лог
                Write-Host ("[CRITICAL] Ошибка записи в лог '{0}': {1}" -f $script:LogFilePath, $_.Exception.Message) -ForegroundColor Red
                # Попытка записи в запасной лог в папке скрипта
                try {
                    $fallbackLog = "$PSScriptRoot\hybrid_agent_fallback.log"
                    $fallbackMessage = "[$timestamp] [$Level] [$script:ComputerName] - $Message"
                    $errorMessageLine = "[CRITICAL] FAILED TO WRITE TO '$($script:LogFilePath)': $($_.Exception.Message)"
                    Add-Content -Path $fallbackLog -Value $fallbackMessage -Encoding UTF8 -Force -ErrorAction SilentlyContinue
                    Add-Content -Path $fallbackLog -Value $errorMessageLine -Encoding UTF8 -Force -ErrorAction SilentlyContinue
                } catch {
                    # Игнорируем ошибки записи в запасной лог
                }
            }
        }
    }
}

<#
.SYNOPSIS Возвращает значение по умолчанию, если входное значение $null или пустое.
#>
filter Get-OrElse {
    param([object]$DefaultValue)
    if ($null -ne $_ -and (($_ -isnot [string]) -or (-not [string]::IsNullOrWhiteSpace($_)))) {
        $_
    } else {
        $DefaultValue
    }
}

<#
.SYNOPSIS Выполняет HTTP-запрос к API с логикой повторных попыток.
#>
function Invoke-ApiRequestWithRetry {
    param(
        [Parameter(Mandatory=$true)][string]$Uri,
        [Parameter(Mandatory=$true)][string]$Method,
        [Parameter(Mandatory=$false)]$BodyObject = $null, # Принимаем объект PS
        [Parameter(Mandatory=$true)][hashtable]$Headers, # Включая X-API-Key
        [Parameter(Mandatory=$true)][string]$Description # Описание для логов
    )

    $retryCount = 0
    $responseObject = $null # Результат (распарсенный JSON)
    $maxRetries = $script:Config.max_api_retries | Get-OrElse 3
    $timeoutSec = $script:Config.api_timeout_sec | Get-OrElse 60
    $retryDelaySec = $script:Config.retry_delay_seconds | Get-OrElse 5

    # Параметры для Invoke-RestMethod
    $invokeParams = @{
        Uri         = $Uri
        Method      = $Method
        Headers     = $Headers
        TimeoutSec  = $timeoutSec
        ErrorAction = 'Stop' # Ловим ошибки через try/catch
    }
    # Добавляем тело, если это не GET/DELETE и тело передано
    if ($BodyObject -ne $null -and $Method.ToUpper() -notin @('GET', 'DELETE')) {
        try {
            # Преобразуем объект в JSON строку
            $jsonBody = $BodyObject | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
            # Устанавливаем ContentType и тело запроса (байты UTF-8)
            $invokeParams.ContentType = 'application/json; charset=utf-8'
            $invokeParams.Body = [System.Text.Encoding]::UTF8.GetBytes($jsonBody)
             Write-Log "Тело запроса для ($Description): $jsonBody" -Level Debug
        } catch {
            Write-Log "Критическая ошибка ConvertTo-Json для ($Description): $($_.Exception.Message)" -Level Error
            # Write-Log "Проблемный объект: $($BodyObject | Out-String -Width 500)" -Level Debug # Может быть очень большим
            throw "Ошибка преобразования тела запроса в JSON." # Прерываем
        }
    }

    # Цикл повторных попыток
    while ($retryCount -lt $maxRetries -and $responseObject -eq $null) {
        try {
            Write-Log ("Выполнение запроса ({0}) (Попытка {1}/{2}): {3} {4}" -f $Description, ($retryCount + 1), $maxRetries, $Method, $Uri) -Level Verbose
            # Выполняем запрос
            $responseObject = Invoke-RestMethod @invokeParams
            # Успех!
            Write-Log ("Успешный ответ API ({0})." -f $Description) -Level Verbose
            return $responseObject # Возвращаем результат (распарсенный JSON)

        } catch [System.Net.WebException] { # Ловим специфичные ошибки веб-запросов
            $retryCount++
            $exception = $_.Exception
            $statusCode = $null
            $errorResponseBody = "[Не удалось прочитать тело ошибки]"
            if ($exception.Response -ne $null) {
                try { $statusCode = [int]$exception.Response.StatusCode } catch { }
                try {
                    $errorStream = $exception.Response.GetResponseStream()
                    $reader = New-Object System.IO.StreamReader($errorStream)
                    $errorResponseBody = $reader.ReadToEnd()
                    $reader.Close()
                    $errorStream.Dispose()
                     # Попытка распарсить тело ошибки как JSON
                     try { $errorJson = $errorResponseBody | ConvertFrom-Json; $errorResponseBody = $errorJson } catch {}
                } catch { }
            }
            # Формируем сообщение об ошибке
            $errorMessage = $exception.Message.Replace('{','{{').Replace('}','}}') # Экранируем фигурные скобки для -f
            $errorDetails = $errorResponseBody
            Write-Log ("Ошибка API ({0}) (Попытка {1}/{2}). Код: {3}. Error: {4}. Ответ: {5}" -f `
                        $Description, $retryCount, $maxRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage, ($errorDetails | Out-String -Width 300)) -Level Error

            # Критические ошибки, после которых нет смысла повторять
            if ($statusCode -in @(400, 401, 403, 404, 409, 422)) { # Bad Request, Unauthorized, Forbidden, Not Found, Conflict, Validation
                Write-Log ("Критическая ошибка API ({0} - Код {1}), повторные попытки отменены." -f $Description, $statusCode) -Level Error
                throw $exception # Пробрасываем исключение, чтобы основной код мог его обработать
            }
            # Если не критическая ошибка и попытки не кончились - пауза и повтор
            if ($retryCount -ge $maxRetries) {
                 Write-Log ("Превышено кол-во попыток ({0}) для ({1})." -f $maxRetries, $Description) -Level Error
                 throw $exception # Пробрасываем последнюю ошибку
            }
            Write-Log ("Пауза $retryDelaySec сек перед повторной попыткой...") -Level Warn
            Start-Sleep -Seconds $retryDelaySec

        } catch { # Ловим другие возможные ошибки (например, ConvertTo-Json выше или ошибки PS)
             $retryCount++ # Считаем попытку
             $errorMessage = $_.Exception.Message.Replace('{','{{').Replace('}','}}')
             Write-Log ("Неожиданная ошибка ({0}) (Попытка {1}/{2}): {3}" -f $Description, $retryCount, $maxRetries, $errorMessage) -Level Error
             # Сразу пробрасываем другие ошибки
             throw $_.Exception
        }
    } # Конец while
    # Сюда не должны попасть, если все работает как надо
    return $null
}

#endregion Функции

# --- 4. Основная логика ---

# 4.1 Чтение и валидация конфигурации
Write-Host "Запуск Гибридного Агента Мониторинга v$($script:AgentVersion)..."
Write-Log "Чтение конфигурации из '$ConfigFile'..." -Level Info
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Log "Критическая ошибка: Файл конфигурации '$ConfigFile' не найден." -Level Error; exit 1 }
try {
    $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop
} catch {
    Write-Log "Критическая ошибка: Ошибка чтения/парсинга JSON из '$ConfigFile': $($_.Exception.Message)" -Level Error
    exit 1
}

# --- Валидация ОБЩИХ обязательных полей ---
$requiredCommonFields = @("mode", "object_id", "log_file", "log_level", "agent_script_version")
$missingCommon = $requiredCommonFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or ($script:Config.$_ -is [string] -and [string]::IsNullOrWhiteSpace($script:Config.$_)) }
if ($missingCommon) { Write-Log ("Критическая ошибка: В '$ConfigFile' отсутствуют или пусты обязательные общие поля: $($missingCommon -join ', ')") -Level Error; exit 1 }

# Установка пути к лог-файлу и уровня логирования
$script:LogFilePath = $script:Config.log_file
$script:LogLevel = $script:Config.log_level
$validLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")
if ($script:LogLevel -notin $validLogLevels) { Write-Log ("Некорректный LogLevel '$($script:LogLevel)'. Используется 'Info'.") -Level Warn; $script:LogLevel = "Info" }

# Логирование базовой информации
Write-Log "Гибридный агент v$($script:AgentVersion) запущен. Имя хоста: $script:ComputerName" -Level Info
Write-Log "Режим работы: $($script:Config.mode)" -Level Info
Write-Log "ObjectID: $($script:Config.object_id)" -Level Info
Write-Log "Логирование в '$script:LogFilePath' с уровнем '$script:LogLevel'" -Level Info

# --- 4.2 Запуск логики для выбранного режима ---
$agentMode = $script:Config.mode.Trim().ToLower()

# --- ========================== ---
# ---      ONLINE РЕЖИМ        ---
# --- ========================== ---
if ($agentMode -eq 'online') {

    # --- Валидация параметров Online режима ---
    Write-Log "Проверка конфигурации для Online режима..." -Level Verbose
    $requiredOnlineFields = @("api_base_url", "api_key", "api_poll_interval_seconds", "default_check_interval_seconds")
    $missingOnline = $requiredOnlineFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or ($script:Config.$_ -is [string] -and [string]::IsNullOrWhiteSpace($script:Config.$_)) }
    if ($missingOnline) { Write-Log ("Критическая ошибка: Для Online режима в '$ConfigFile' отсутствуют поля: $($missingOnline -join ', ')") -Level Error; exit 1 }

    # Получаем интервалы (с проверкой)
    $apiPollInterval = 60; if ($script:Config.api_poll_interval_seconds -and [int]::TryParse($script:Config.api_poll_interval_seconds,[ref]$null) -and $script:Config.api_poll_interval_seconds -ge 10) { $apiPollInterval = $script:Config.api_poll_interval_seconds } else { Write-Log "..." "Warn" }
    $defaultCheckInterval = 300; if ($script:Config.default_check_interval_seconds -and [int]::TryParse($script:Config.default_check_interval_seconds,[ref]$null) -and $script:Config.default_check_interval_seconds -ge 5) { $defaultCheckInterval = $script:Config.default_check_interval_seconds } else { Write-Log "..." "Warn" }
    $apiPollTimeSpan = [TimeSpan]::FromSeconds($apiPollInterval)
    $defaultCheckTimeSpan = [TimeSpan]::FromSeconds($defaultCheckInterval)
    Write-Log ("Online режим: Опрос API каждые {0} сек, стандартный интервал {1} сек." -f $apiPollInterval, $defaultCheckInterval) -Level Info

    # --- Основной цикл Online режима ---
    Write-Log "Запуск основного цикла Online режима..." -Level Info
    while ($true) {
        $loopStartTime = [DateTimeOffset]::UtcNow # Используем UTC для сравнений
        Write-Log "Начало итерации цикла Online." -Level Verbose

        # --- Обновление списка заданий по расписанию ---
        if (($loopStartTime - $script:LastApiPollTimeOnline) -ge $apiPollTimeSpan) {
            Write-Log "Время обновить список заданий с API." -Level Info
            $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/assignments?object_id=$($script:Config.object_id)"
            $headers = @{ 'X-API-Key' = $script:Config.api_key }
            try {
                # Запрашиваем задания с помощью обертки с retry
                $fetchedAssignmentsRaw = Invoke-ApiRequestWithRetry `
                                            -Uri $apiUrl `
                                            -Method Get `
                                            -Headers $headers `
                                            -Description "Получение заданий (ObjectID $($script:Config.object_id))"

                if ($fetchedAssignmentsRaw -ne $null -and $fetchedAssignmentsRaw -is [array]) {
                     Write-Log "Получено $($fetchedAssignmentsRaw.Count) активных заданий от API." -Level Info
                    $newAssignmentMap = @{} # ID -> Объект
                    $fetchedIds = [System.Collections.Generic.List[int]]::new()
                    foreach ($assignmentRaw in $fetchedAssignmentsRaw) {
                        # Валидация полученного задания
                        if ($assignmentRaw -ne $null -and $assignmentRaw.PSObject -ne $null `
                            -and $assignmentRaw.PSObject.Properties.Name -contains 'assignment_id' `
                            -and $assignmentRaw.assignment_id -ne $null)
                        {
                            $id = $null
                            if([int]::TryParse($assignmentRaw.assignment_id, [ref]$id)) {
                                $newAssignmentMap[$id] = [PSCustomObject]$assignmentRaw # Сохраняем как PSCustomObject
                                $fetchedIds.Add($id)
                            } else { Write-Log "Нечисловой assignment_id получен от API: '$($assignmentRaw.assignment_id)'" -Level Warn }
                        } else { Write-Log "Получено некорректное задание от API: $($assignmentRaw | Out-String)" -Level Warn }
                    }

                    # Синхронизация с текущим списком
                    $currentIds = $script:ActiveAssignmentsOnline.Keys | ForEach-Object { [int]$_ }
                    $removedIds = $currentIds | Where-Object { $fetchedIds -notcontains $_ }
                    $addedCount = 0; $updatedCount = 0
                    # Удаляем устаревшие
                    if ($removedIds) {
                        foreach ($removedId in $removedIds) {
                            Write-Log "Удалено задание ID $removedId из активного списка." -Level Info
                            $script:ActiveAssignmentsOnline.Remove($removedId)
                            $script:LastExecutedTimesOnline.Remove($removedId)
                        }
                    }
                    # Добавляем/обновляем
                    foreach ($id in $fetchedIds) {
                        if (-not $script:ActiveAssignmentsOnline.ContainsKey($id)) {
                            $script:ActiveAssignmentsOnline[$id] = $newAssignmentMap[$id]
                            # Устанавливаем время последнего выполнения в далекое прошлое, чтобы выполнилось сразу
                            $script:LastExecutedTimesOnline[$id] = [DateTimeOffset]::UtcNow.AddDays(-1)
                            $addedCount++
                            Write-Log "Добавлено новое задание ID $id." -Level Info
                        } else {
                            # Проверка на изменения (сравниваем JSON представления)
                            $oldJson = $script:ActiveAssignmentsOnline[$id] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                            $newJson = $newAssignmentMap[$id] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                            if ($oldJson -ne $newJson) {
                                $script:ActiveAssignmentsOnline[$id] = $newAssignmentMap[$id]
                                # Не сбрасываем время выполнения при обновлении, чтобы не было всплеска
                                $updatedCount++
                                Write-Log "Обновлено задание ID $id." -Level Verbose
                            }
                        }
                    }
                    Write-Log ("Синхронизация заданий завершена. Добавлено:{0}. Обновлено:{1}. Удалено:{2}." `
                                -f $addedCount, $updatedCount, $removedIds.Count) -Level Info
                    $script:LastApiPollTimeOnline = $loopStartTime # Обновляем время последней успешной синхронизации

                } elseif ($fetchedAssignmentsRaw -eq $null) {
                    Write-Log "API вернул пустой ответ (возможно, нет активных заданий или ошибка)." -Level Warn
                    # Обработка случая, когда ВСЕ задания были удалены
                    if ($script:ActiveAssignmentsOnline.Count -gt 0) {
                         Write-Log "Очистка активных заданий, так как API вернул пустой список." -Level Info
                         $script:ActiveAssignmentsOnline.Clear()
                         $script:LastExecutedTimesOnline.Clear()
                    }
                    $script:LastApiPollTimeOnline = $loopStartTime # Считаем опрос успешным, хоть и пустым
                } else { # Не массив
                     Write-Log "API вернул некорректные данные заданий (не массив). Текущий список не изменен." -Level Error
                     # Не обновляем $script:LastApiPollTimeOnline, попробуем в след. раз
                }
            } catch { # Ошибка при вызове Invoke-ApiRequestWithRetry
                 Write-Log "Ошибка при получении заданий от API: $($_.Exception.Message). Используется текущий список заданий." -Level Error
                 # Не обновляем $script:LastApiPollTimeOnline
            }
        } else {
            Write-Log "Опрос API еще не требуется..." -Level Verbose
        }

        # --- Выполнение запланированных проверок ---
        $currentTime = [DateTimeOffset]::UtcNow # Текущее время UTC
        if ($script:ActiveAssignmentsOnline.Count -gt 0) {
            Write-Log "Проверка запланированных заданий ($($script:ActiveAssignmentsOnline.Count) активно)..." -Level Verbose
            # Копируем ключи, чтобы избежать проблем при изменении коллекции во время итерации
            $assignmentIdsToCheck = @($script:ActiveAssignmentsOnline.Keys)

            foreach ($id in $assignmentIdsToCheck) {
                # Проверяем, не удалили ли задание во время синхронизации
                if (-not $script:ActiveAssignmentsOnline.ContainsKey($id)) { continue }

                $assignment = $script:ActiveAssignmentsOnline[$id]
                # Определяем интервал для этого задания
                $checkIntervalSec = $assignment.check_interval_seconds | Get-OrElse $defaultCheckInterval
                if ($checkIntervalSec -le 0) { $checkIntervalSec = $defaultCheckInterval }
                $checkIntervalTimeSpan = [TimeSpan]::FromSeconds($checkIntervalSec)

                # Получаем время последнего выполнения
                $lastRunTime = [DateTimeOffset]::MinValue # Если не выполнялось, то давно пора
                if ($script:LastExecutedTimesOnline.ContainsKey($id)) {
                    $lastRunTime = $script:LastExecutedTimesOnline[$id]
                }

                # Вычисляем время следующего запуска
                $nextRunTime = $lastRunTime + $checkIntervalTimeSpan

                # Если пора выполнять
                if ($currentTime -ge $nextRunTime) {
                     Write-Log ("НАЧАЛО ВЫПОЛНЕНИЯ задания ID {0} ({1} для '{2}')." -f `
                                 $id, $assignment.method_name, $assignment.node_name) -Level Info
                    $checkResult = $null
                    try {
                        # --- Вызов основной функции проверки ---
                        $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment `
                                                                  -Verbose:$false ` # Передаем текущие настройки Verbose/Debug
                                                                  -Debug:$false   # или можно жестко задать $false

                        if ($checkResult -eq $null -or $checkResult.IsAvailable -eq $null) { throw "Invoke-StatusMonitorCheck вернул некорректный результат." }

                        Write-Log ("Результат проверки ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f `
                                   $id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) -Level Verbose

                        # --- Формирование payload для API ---
                        # API /checks теперь ожидает МАССИВ результатов
                        $payloadItem = @{
                            assignment_id        = $id
                            is_available         = $checkResult.IsAvailable
                            # CheckSuccess и ErrorMessage ИДУТ ВНУТРЬ details!
                            check_timestamp      = $checkResult.Timestamp # Уже в UTC ISO 8601
                            executor_object_id   = $script:Config.object_id # ID объекта, где работает агент
                            executor_host        = $script:ComputerName
                            resolution_method    = $assignment.method_name
                            detail_type          = $null # Тип будет определен по методу или внутри details
                            detail_data          = $checkResult.Details # Передаем объект Details как есть
                            agent_script_version = $script:AgentVersion
                            # assignment_config_version не актуально для Online
                        }
                        # Добавляем CheckSuccess и ErrorMessage в details, если они есть
                         if ($checkResult.PSObject.Properties.Name -contains 'CheckSuccess' -and $checkResult.CheckSuccess -ne $null) {
                             if ($payloadItem.detail_data -eq $null) { $payloadItem.detail_data = @{} }
                             $payloadItem.detail_data.CheckSuccess = $checkResult.CheckSuccess
                         }
                         if (-not [string]::IsNullOrEmpty($checkResult.ErrorMessage)) {
                              if ($payloadItem.detail_data -eq $null) { $payloadItem.detail_data = @{} }
                             $payloadItem.detail_data.ErrorMessageFromCheck = $checkResult.ErrorMessage
                             # Устанавливаем тип детализации ERROR, если он еще не установлен
                             if ($payloadItem.detail_type -eq $null) { $payloadItem.detail_type = "ERROR" }
                         }
                         # Если тип детализации все еще не установлен, используем имя метода
                         if ($payloadItem.detail_type -eq $null) {
                             $payloadItem.detail_type = $assignment.method_name.ToUpper() -replace '[^A-Z0-9_]','_'
                         }


                        # Создаем МАССИВ из одного элемента
                        $payloadArray = @( $payloadItem )

                        # --- Отправка результата в API ---
                        $apiUrlChecks = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/checks"
                        $sendSuccess = $false
                        try {
                             # Вызов API с retry (передаем МАССИВ в BodyObject)
                             $apiResponse = Invoke-ApiRequestWithRetry `
                                                -Uri $apiUrlChecks `
                                                -Method Post `
                                                -BodyObject $payloadArray `
                                                -Headers $headers `
                                                -Description "Отправка результата ID $id"

                             # Анализируем ответ (200 OK или 207 Multi-Status)
                             # Для массива из 1 элемента ожидаем 200 OK или 207 с 1 обработанным и 0 ошибок
                             if ($apiResponse -ne $null -and $apiResponse.status -eq 'success' `
                                 -and $apiResponse.processed -eq 1 -and $apiResponse.failed -eq 0) {
                                 $sendSuccess = $true
                                 Write-Log "Результат ID $id успешно отправлен в API." -Level Info
                             } elseif ($apiResponse -ne $null) { # Ответ есть, но не success или не 1/0
                                Write-Log ("Ответ API при отправке ID {0} не был 'success' или счетчики неверны. Статус: {1}, Обработано: {2}, Ошибки: {3}" -f `
                                            $id, $apiResponse.status, $apiResponse.processed, $apiResponse.failed) -Level Error
                                if($apiResponse.errors) { Write-Log "Ошибки от API: $($apiResponse.errors | ConvertTo-Json -Depth 3 -Compress)" -Level Error }
                            } else { # apiResponse = $null (Invoke-ApiRequestWithRetry не смог)
                                Write-Log "Не удалось отправить результат ID $id в API после всех попыток." -Level Error
                            }
                        } catch { # Ошибка в Invoke-ApiRequestWithRetry
                            Write-Log "Критическая ошибка при отправке результата ID $id в API: $($_.Exception.Message)" -Level Error
                        }

                        # Обновляем время выполнения только при УСПЕШНОЙ отправке
                        if ($sendSuccess) {
                            $script:LastExecutedTimesOnline[$id] = $currentTime
                            Write-Log "Время последнего выполнения ID $id обновлено." -Level Verbose
                        } else {
                             Write-Log "Время последнего выполнения ID $id НЕ обновлено из-за ошибки отправки." -Level Warn
                        }

                    } catch { # Ошибка при ВЫПОЛНЕНИИ Invoke-StatusMonitorCheck
                        Write-Log "Критическая ошибка при ВЫПОЛНЕНИИ задания ID ${id}: $($_.Exception.Message)" -Level Error
                        # Время выполнения НЕ обновляем
                    } finally {
                         Write-Log "ЗАВЕРШЕНИЕ ВЫПОЛНЕНИЯ задания ID $id." -Level Info
                    }
                } # Конец if ($currentTime -ge $nextRunTime)
            } # Конец foreach ($id in $assignmentIdsToCheck)
        } else {
            Write-Log "Нет активных заданий для выполнения." -Level Verbose
        }

        # --- Пауза перед следующей итерацией основного цикла ---
        # Короткая пауза, чтобы не загружать процессор на 100%
        Start-Sleep -Seconds 1

    } # --- Конец while ($true) Online ---

# --- =========================== ---
# ---      OFFLINE РЕЖИМ        ---
# --- =========================== ---
} elseif ($agentMode -eq 'offline') {

    # --- Валидация параметров Offline режима ---
    Write-Log "Проверка конфигурации для Offline режима..." -Level Verbose
    $requiredOfflineFields = @("assignments_file_path_pattern", "output_path", "output_name_template", "offline_cycle_interval_seconds")
    $missingOffline = $requiredOfflineFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or (($script:Config.$_ -is [string]) -and ([string]::IsNullOrWhiteSpace($script:Config.$_))) } # Позволяем 0 для offline_cycle_interval_seconds
    if ($missingOffline) { Write-Log ("Критическая ошибка: Для Offline режима в '$ConfigFile' отсутствуют поля: $($missingOffline -join ', ')") -Level Error; exit 1 }

    # Проверка путей
    $assignmentsFolderPath = $script:Config.assignments_file_path_pattern.TrimEnd('\*') # Убираем маску для проверки папки
    $outputPath = $script:Config.output_path
    $outputNameTemplate = $script:Config.output_name_template
    if(-not(Test-Path $assignmentsFolderPath -PathType Container)){ Write-Log "Критическая ошибка: Папка для файлов заданий '$assignmentsFolderPath' не найдена." -Level Error; exit 1 }
    if(-not(Test-Path $outputPath -PathType Container)){ Write-Log "Папка для результатов '$outputPath' не найдена. Попытка создать..." -Level Warn; try { New-Item -Path $outputPath -ItemType Directory -Force -EA Stop | Out-Null; Write-Log "Папка '$outputPath' успешно создана." -Level Info } catch { Write-Log "Критическая ошибка: Не удалось создать папку '$outputPath': $($_.Exception.Message)" -Level Error; exit 1 } };

    # Интервал цикла
    $offlineInterval = 0; if($script:Config.offline_cycle_interval_seconds -and [int]::TryParse($script:Config.offline_cycle_interval_seconds,[ref]$null) -and $script:Config.offline_cycle_interval_seconds -gt 0){ $offlineInterval = $script:Config.offline_cycle_interval_seconds }
    $runContinuously = ($offlineInterval -gt 0)
    if ($runContinuously) { Write-Log ("Offline режим: Запуск в циклическом режиме с интервалом {0} сек." -f $offlineInterval) -Level Info }
    else { Write-Log "Offline режим: Запуск в однократном режиме." -Level Info }

    # --- Основной цикл/запуск Offline режима ---
    do { # Используем do-while для гарантии хотя бы одного выполнения
        $cycleStartTime = [DateTimeOffset]::UtcNow
        Write-Log "Начало цикла/запуска Offline ($($cycleStartTime.ToString('s')))." -Level Info

        # --- Поиск и чтение файла конфигурации заданий ---
        $latestConfigFile = $null; $configError = $null; $configData = $null
        try {
            $assignmentsFilePattern = $script:Config.assignments_file_path_pattern
            Write-Log ("Поиск файла конфигурации в '$assignmentsFolderPath' по шаблону '$assignmentsFilePattern'...") -Level Debug
            # Ищем самый новый файл по LastWriteTime
            $foundFiles = Get-ChildItem -Path $assignmentsFilePattern -File -ErrorAction SilentlyContinue
            if ($Error.Count -gt 0 -and $Error[0].CategoryInfo.Category -eq 'ReadError') { throw ("Ошибка доступа при поиске файла: " + $Error[0].Exception.Message); $Error.Clear() }

            if ($foundFiles) {
                $latestConfigFile = $foundFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                Write-Log "Найден последний файл конфигурации: $($latestConfigFile.FullName)" -Level Verbose
            } else { Write-Log "Файлы конфигурации по шаблону '$assignmentsFilePattern' не найдены." -Level Warn }
        } catch { $configError = "Ошибка поиска файла конфигурации: $($_.Exception.Message)"; Write-Log $configError -Level Error }

        # Обрабатываем файл, только если он новый или еще не обрабатывался
        if ($latestConfigFile -ne $null -and $configError -eq $null) {
            if ($latestConfigFile.FullName -ne $script:lastProcessedConfigFileOffline) {
                Write-Log "Обнаружен новый/обновленный файл конфигурации: $($latestConfigFile.Name). Чтение..." -Level Info
                $tempAssignments = $null; $tempVersionTag = $null
                try {
                    $fileContent = Get-Content -Path $latestConfigFile.FullName -Raw -Encoding UTF8 -ErrorAction Stop
                    $fileContentClean = $fileContent.TrimStart([char]0xFEFF); # Убираем BOM, если есть
                    $configData = $fileContentClean | ConvertFrom-Json -ErrorAction Stop
                    # Валидация структуры конфига
                    if ($null -eq $configData -or (-not $configData.PSObject.Properties.Name.Contains('assignments')) -or ($configData.assignments -isnot [array]) -or (-not $configData.PSObject.Properties.Name.Contains('assignment_config_version')) -or (-not $configData.assignment_config_version) ) { throw ("Файл '$($latestConfigFile.Name)' имеет некорректную структуру JSON (отсутствуют 'assignments' или 'assignment_config_version').") };

                    $tempVersionTag = $configData.assignment_config_version
                    $tempAssignments = $configData.assignments
                    Write-Log ("Файл '{0}' успешно прочитан. Заданий: {1}, Версия конфига: '{2}'." -f $latestConfigFile.Name, $tempAssignments.Count, $tempVersionTag) -Level Info
                    # Обновляем глобальные переменные Offline режима
                    $script:CurrentAssignmentsOffline = $tempAssignments
                    $script:CurrentConfigVersionOffline = $tempVersionTag
                    $script:LastProcessedConfigFileOffline = $latestConfigFile.FullName
                } catch {
                    $errorMsg = "Критическая ошибка обработки файла '$($latestConfigFile.Name)': $($_.Exception.Message)"; Write-Log $errorMsg -Level Error
                    Write-Log ("Продолжаем использовать предыдущий список заданий (версия: {0})." -f ($script:currentConfigVersionOffline | Get-OrElse '[неизвестно]')) -Level Warn
                    # Не обновляем $script:lastProcessedConfigFileOffline
                }
            } else { Write-Log "Файл конфигурации '$($latestConfigFile.Name)' не изменился." -Level Verbose }
        } elseif ($configError -ne $null) { Write-Log "Продолжаем использовать предыдущий список заданий из-за ошибки поиска файла." -Level Warn }
        elseif ($script:lastProcessedConfigFileOffline -ne $null) { Write-Log "Файлы конфигурации не найдены. Продолжаем использовать предыдущий список." -Level Warn }
        else { Write-Log "Файлы конфигурации не найдены и нет предыдущего списка. Задания не будут выполнены." -Level Info }

        # --- Выполнение текущего списка заданий ---
        $cycleCheckResultsList = [System.Collections.Generic.List[object]]::new()
        if ($script:CurrentAssignmentsOffline -ne $null -and $script:CurrentAssignmentsOffline.Count -gt 0) {
            $assignmentsCount = $script:CurrentAssignmentsOffline.Count
            Write-Log ("Начало выполнения {0} заданий (Версия конфига: {1})..." -f $assignmentsCount, ($script:CurrentConfigVersionOffline | Get-OrElse 'N/A')) -Level Info
            $completedCount = 0

            foreach ($assignmentRaw in $script:CurrentAssignmentsOffline) {
                $completedCount++
                $assignment = $null # Сбрасываем перед каждой итерацией
                $currentAssignmentId = $null
                $currentMethodName = "[unknown method]"
                $currentNodeName = "[unknown node]"

                try {
                     # Преобразуем в PSCustomObject и валидируем базовую структуру
                     $assignment = [PSCustomObject]$assignmentRaw
                     $currentAssignmentId = $assignment.assignment_id
                     $currentMethodName = $assignment.method_name
                     $currentNodeName = $assignment.node_name | Get-OrElse "Assignment $currentAssignmentId"

                     if ($null -eq $assignment -or $null -eq $currentAssignmentId -or -not $currentMethodName) { throw "Некорректная структура задания в файле конфигурации." }

                     Write-Log ("Выполнение {0}/{1} (ID: {2}, Метод: {3}, Узел: '{4}')..." -f $completedCount, $assignmentsCount, $currentAssignmentId, $currentMethodName, $currentNodeName) -Level Verbose

                     # --- Вызов основной функции проверки ---
                     $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment `
                                                               -Verbose:$false `
                                                               -Debug:$false

                     if ($checkResult -eq $null -or $checkResult.IsAvailable -eq $null) { throw "Invoke-StatusMonitorCheck вернул некорректный результат." }

                     Write-Log ("Результат ID {0}: IsAvail={1}, ChkSucc={2}, Err='{3}'" -f `
                                $currentAssignmentId, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) -Level Verbose

                    # --- СОЗДАЕМ НОВЫЙ ОБЪЕКТ С ДОБАВЛЕННЫМ assignment_id ---
                     $resultToSave = @{ assignment_id = $currentAssignmentId } + $checkResult
                    # --- КОНЕЦ СОЗДАНИЯ ---

                     # Добавляем результат в список для файла
                     $cycleCheckResultsList.Add($resultToSave)

                } catch { # Ловим ошибки ВАЛИДАЦИИ или ВЫПОЛНЕНИЯ КОНКРЕТНОГО ЗАДАНИЯ
                     $errorMessage = "Ошибка обработки/выполнения задания ID {0} ({1} для '{2}'): {3}" -f `
                                     ($currentAssignmentId | Get-OrElse '[N/A]'), $currentMethodName, $currentNodeName, $_.Exception.Message
                     Write-Log $errorMessage -Level Error
                     # Формируем результат с ошибкой и добавляем его в список
                     $errorDetails = @{ ErrorRecord = $_.ToString(); OriginalAssignment = ($assignmentRaw | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue) }
                     $errorResultBase = New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details $errorDetails
                     # Добавляем ID, если он был
                     $errorResultToSave = @{ assignment_id = $currentAssignmentId } + $errorResultBase
                     $cycleCheckResultsList.Add($errorResultToSave)
                 }
            } # Конец foreach assignment
            Write-Log "Выполнение $assignmentsCount заданий завершено. Собрано результатов: $($cycleCheckResultsList.Count)." -Level Info
        } else { Write-Log "Нет активных заданий для выполнения." -Level Verbose }

        # --- Формирование и АТОМАРНОЕ сохранение файла *.zrpu ---
        if ($cycleCheckResultsList.Count -gt 0) {
             $timestampForFile = Get-Date -Format "ddMMyy_HHmmss"
             $outputFileName = $outputNameTemplate -replace "{object_id}", $script:Config.object_id -replace "{ddMMyy_HHmmss}", $timestampForFile
             $outputFileName = $outputFileName -replace '[\\/:*?"<>|]', '_' # Убираем недопустимые символы
             $outputFileFullPath = Join-Path $outputPath $outputFileName
             # Путь к временному файлу
             $tempOutputFileFullPath = $outputFileFullPath + ".tmp"

             Write-Log ("Сохранение {0} результатов в файл: '{1}'" -f $cycleCheckResultsList.Count, $outputFileFullPath) -Level Info
             Write-Log ("Версия агента: {0}, Версия конфига заданий: {1}" -f $script:AgentVersion, ($script:CurrentConfigVersionOffline | Get-OrElse 'N/A')) -Level Verbose

             # Формируем итоговый объект
             $finalPayload = @{
                 agent_script_version      = $script:AgentVersion
                 assignment_config_version = $script:CurrentConfigVersionOffline
                 object_id                 = $script:Config.object_id # Для идентификации источника Загрузчиком
                 execution_timestamp_utc   = $cycleStartTime.ToString("o") # Время начала цикла
                 results                   = $cycleCheckResultsList
             }

             # Атомарное сохранение
             try {
                 # 1. Сохраняем во временный файл
                 $jsonToSave = $finalPayload | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
                 $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false)
                 [System.IO.File]::WriteAllText($tempOutputFileFullPath, $jsonToSave, $Utf8NoBomEncoding)
                 Write-Log "Данные успешно записаны во временный файл: '$tempOutputFileFullPath'" -Level Debug

                 # 2. Переименовываем временный файл в основной (атомарно в NTFS)
                 Move-Item -Path $tempOutputFileFullPath -Destination $outputFileFullPath -Force -ErrorAction Stop
                 Write-Log "Файл результатов '$outputFileName' успешно сохранен (атомарно)." -Level Info

             } catch {
                 Write-Log ("Критическая ошибка сохранения/переименования файла результатов '{0}': {1}" `
                            -f $outputFileFullPath, $_.Exception.Message) -Level Error
                 # Пытаемся удалить временный файл, если он остался
                 if (Test-Path $tempOutputFileFullPath -PathType Leaf) {
                     try { Remove-Item -Path $tempOutputFileFullPath -Force -ErrorAction SilentlyContinue } catch {}
                 }
             }
        } else {
             Write-Log "Нет результатов для сохранения в файл." -Level Verbose
        }

        # --- Пауза (если в циклическом режиме) ---
        if ($runContinuously) {
            $cycleEndTime = [DateTimeOffset]::UtcNow
            $elapsedSeconds = ($cycleEndTime - $cycleStartTime).TotalSeconds
            $sleepSeconds = $offlineInterval - $elapsedSeconds
            if ($sleepSeconds -lt 1) { $sleepSeconds = 1 }
            Write-Log ("Итерация Offline заняла {0:N2} сек. Пауза {1:N2} сек..." -f $elapsedSeconds, $sleepSeconds) -Level Verbose
            Start-Sleep -Seconds $sleepSeconds
        }

    } while ($runContinuously) # --- Конец do-while Offline ---

    Write-Log ("Offline режим завершен ({0})." -f ($runContinuously ? 'цикл прерван?' : 'однократный запуск')) -Level Info
    exit 0 # Успешный выход (особенно для однократного режима)

# --- ============================= ---
# --- НЕИЗВЕСТНЫЙ РЕЖИМ / ОШИБКА  ---
# --- ============================= ---
} else {
     Write-Log "Критическая ошибка: Неизвестный или некорректный режим работы '$($script:Config.mode)' в файле конфигурации." -Level Error
     Write-Log "Допустимые режимы: 'Online' или 'Offline'." -Level Error
     exit 1
}

# Код сюда не должен доходить при нормальной работе
Write-Log "Агент завершает работу непредвиденно." -Level Error
exit 1
==== END FILE: F:\status\source\powershell\hybrid-agent\hybrid-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\hybrid-agent\README.md ====
# PowerShell Гибридный Агент Мониторинга (hybrid-agent) v7.0

Этот скрипт (`hybrid-agent.ps1`) выполняет роль универсального агента мониторинга для системы Status Monitor, способного работать в двух режимах: **Online** и **Offline**.

## Назначение

*   Выполнять мониторинг узлов как с прямым сетевым доступом к API сервера (**Online режим**), так и в изолированных сетевых сегментах без доступа к API (**Offline режим**).
*   Режим работы определяется параметром `"mode"` в файле конфигурации `config.json`.
*   Использовать общий модуль `StatusMonitorAgentUtils` для выполнения конкретных проверок, обеспечивая единообразие логики.
*   Взаимодействовать с API сервера или файловой системой в зависимости от выбранного режима.
*   Вести детальный лог своей работы.

## Режимы Работы

### Online Режим (`"mode": "Online"`)

*   **Получение заданий:** Периодически (раз в `api_poll_interval_seconds`) запрашивает актуальный список активных заданий для своего `object_id` у API сервера (`GET /api/v1/assignments`).
*   **Выполнение:** Планирует и выполняет каждое полученное задание согласно его индивидуальному интервалу (`check_interval_seconds` из задания или `default_check_interval_seconds` из конфига).
*   **Отправка результатов:** Немедленно после выполнения КАЖДОЙ проверки отправляет результат на API сервер (`POST /api/v1/checks`). Результат отправляется в виде **массива из одного элемента**.
*   **Требования:** Прямой сетевой доступ к `api_base_url`, валидный `api_key` с ролью `agent`.

### Offline Режим (`"mode": "Offline"`)

*   **Получение заданий:** Ищет и читает самый новый файл конфигурации (`*.json.status.*`, соответствующий `object_id`) из папки, указанной в `assignments_file_path_pattern`. Задания выполняются только при обнаружении нового/обновленного файла конфигурации или при первом запуске.
*   **Выполнение:** Запускает ВСЕ задания из файла конфигурации за один проход (цикл). Цикличность выполнения всего набора проверок определяется параметром `offline_cycle_interval_seconds`. Если он равен 0, скрипт выполнит проверки один раз и завершится (подходит для запуска по расписанию).
*   **Отправка результатов:** Собирает результаты ВСЕХ проверок за цикл в один массив. **Атомарно** сохраняет этот массив вместе с метаданными (версии, ID объекта) в JSON-файл с расширением `.zrpu` в папку `output_path`. Этот файл затем должен быть передан и обработан **Загрузчиком Результатов**.
*   **Требования:** Доступ к папке с файлами конфигурации, доступ на запись в `output_path`. Сетевой доступ к API не требуется.

## Принцип работы

1.  Скрипт `hybrid-agent.ps1` запускается.
2.  Читает `config.json`.
3.  Определяет режим работы (`mode`).
4.  Валидирует необходимые параметры конфигурации для выбранного режима.
5.  Импортирует модуль `StatusMonitorAgentUtils`.
6.  Запускает логику для выбранного режима (либо бесконечный цикл для Online, либо цикл/однократный запуск для Offline).
7.  **В обоих режимах:** Для выполнения конкретной проверки вызывается `Invoke-StatusMonitorCheck` из модуля `StatusMonitorAgentUtils`.
8.  Логирует свою работу.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `hybrid-agent.ps1`.

```json
{
    "mode": "Online", // "Online" или "Offline" - ОБЯЗАТЕЛЬНО
    "object_id": 1516, // ID объекта (подразделения/узла) - ОБЯЗАТЕЛЬНО
    "log_file": "C:/StatusMonitor/Logs/hybrid-agent.log", // ОБЯЗАТЕЛЬНО
    "log_level": "Info", // "Debug", "Verbose", "Info", "Warn", "Error" - ОБЯЗАТЕЛЬНО
    "agent_script_version": "hybrid_agent_v7.0", // Версия скрипта агента - ОБЯЗАТЕЛЬНО

    // --- Параметры для режима "Online" ---
    "api_base_url": "http://your-server-address:5000/api/v1", // ОБЯЗАТЕЛЬНО для Online
    "api_key": "your_agent_api_key",                     // ОБЯЗАТЕЛЬНО для Online (роль 'agent')
    "api_poll_interval_seconds": 60,                      // ОБЯЗАТЕЛЬНО для Online
    "default_check_interval_seconds": 300,               // ОБЯЗАТЕЛЬНО для Online
    "max_api_retries": 3,                                // Опционально для Online (default: 3)
    "retry_delay_seconds": 5,                            // Опционально для Online (default: 5)
    "api_timeout_sec": 60,                               // Опционально для Online (default: 60)

    // --- Параметры для режима "Offline" ---
    "assignments_file_path_pattern": "C:/StatusMonitor/OfflineConfig/*.json.status.*", // ОБЯЗАТЕЛЬНО для Offline
    "output_path": "C:/StatusMonitor/OfflineResults",          // ОБЯЗАТЕЛЬНО для Offline
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_HybridOffline.zrpu", // ОБЯЗАТЕЛЬНО для Offline
    "offline_cycle_interval_seconds": 3600                   // ОБЯЗАТЕЛЬНО для Offline (0 для однократного запуска)
}

Важно: Убедитесь, что для выбранного режима (mode) заданы все обязательные параметры.
Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль Utils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой hybrid-agent (т.е. ..\StatusMonitorAgentUtils) или в путях $env:PSModulePath.

    Online режим: Требуется сетевой доступ к api_base_url и к целевым узлам для проверок. Нужен действительный API ключ с ролью agent.

    Offline режим: Требуется доступ на чтение к папке с файлами конфигурации (assignments_file_path_pattern) и на запись в output_path. Необходим механизм доставки файлов конфигурации и отправки файлов результатов (.zrpu).

    Права: Права на запись в log_file. Права, необходимые для выполнения конкретных проверок (зависят от метода проверки).

    Запуск:

        Online: Рекомендуется запускать как Службу Windows для непрерывной работы.

        Offline (циклический): Рекомендуется запускать как Службу Windows.

        Offline (однократный, offline_cycle_interval_seconds = 0): Рекомендуется запускать через Планировщик Задач Windows с нужным интервалом.

Замечания

    Логика конкретных проверок находится в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.

    Атомарная запись .zrpu в Offline режиме обеспечивается через создание временного файла и его переименование.
==== END FILE: F:\status\source\powershell\hybrid-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\config.json ====
{
    "object_id": 1060, 
    "config_type": "offline_multi_check_agent_v2.3", 
    "check_interval_seconds": 60,
    "output_path": "F:\\status\\builds\\results_offline", 
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_OfflineChecks.json.status.zrpu", 
    "logFile": "F:\\status\\builds\\Logs\\offline_agent.log",
    "LogLevel": "Debug", 
    "assignments_file_path": "F:\\status\\builds\\delivery_conf\\TSP"
}
==== END FILE: F:\status\source\powershell\offline-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\offline-agent.ps1 ====
# powershell\offline-agent\offline-agent.ps1
# Оффлайн-агент мониторинга v3.1.
# Исправлено добавление assignment_id к результатам.
<#
.SYNOPSIS
    Оффлайн-агент системы мониторинга Status Monitor v3.1.
.DESCRIPTION
    Предназначен для работы в изолированных сетях без доступа к API.
    1. Читает локальную конфигурацию агента ('config.json').
    2. Периодически проверяет наличие файла с заданиями
       в папке 'assignments_file_path'.
    3. При обнаружении нового файла заданий:
       - Читает JSON-содержимое.
       - Извлекает список 'assignments' и 'assignment_config_version'.
       - Сохраняет их для выполнения.
    4. В цикле выполняет ВСЕ активные задания с помощью
       Invoke-StatusMonitorCheck из модуля StatusMonitorAgentUtils.
    5. Собирает стандартизированные результаты всех проверок.
    6. **Создает новый объект для каждого результата, объединяя
       стандартный результат и 'assignment_id'.**
    7. Формирует итоговый JSON-файл (*.zrpu) в папке 'output_path',
       включая метаданные (версии агента и конфига) и массив 'results'.
    8. Этот *.zrpu файл затем передается и загружается на сервер.
.NOTES
    Версия: 3.1
    Дата: 2024-05-20
    Изменения v3.1:
        - Исправлен способ добавления 'assignment_id' к результатам. Вместо
          Add-Member теперь создается новый объект путем слияния хэш-таблиц.
    Изменения v3.0:
        - Попытка добавить поле 'assignment_id' к каждому элементу в массиве 'results'.
    Зависимости: PowerShell 5.1+, модуль StatusMonitorAgentUtils, наличие файла конфигурации заданий.
#>

param (
    # Путь к файлу конфигурации агента.
    [string]$configFile = "$PSScriptRoot\config.json",

    # Параметры для переопределения лог-файла и уровня логирования из командной строки.
    [string]$paramLogFile = $null,
    [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
    [string]$paramLogLevel = $null
)

# --- Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try {
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils загружен."
} catch {
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    exit 1
} finally {
    $ErrorActionPreference = "Continue"
}
# --- Конец загрузки модуля ---

# --- Глобальные переменные ---
# Версия текущего скрипта оффлайн-агента
$AgentScriptVersion = "agent_script_v3.1" # Обновили версию

# Имя компьютера
$script:ComputerName = $env:COMPUTERNAME
# Текущий список заданий (массив объектов PSCustomObject из файла конфигурации)
$script:currentAssignments = $null
# Текущая версия файла конфигурации заданий (строка из файла)
$script:currentAssignmentVersion = $null
# Путь к последнему обработанному файлу конфигурации заданий
$script:lastProcessedConfigFile = $null
# Объект с конфигурацией самого агента (из config.json)
$script:localConfig = $null
# Путь к лог-файлу агента
$script:logFile = $null
# Установленный уровень логирования
$script:LogLevel = "Info"
# Допустимые уровни логирования
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")


# --- Функции ---

#region Функции

<#
.SYNOPSIS Записывает сообщение в лог.
#>
function Write-Log{
    param( [Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug","Verbose","Info","Warn","Error",IgnoreCase=$true)] [string]$Level="Info" ); if (-not $script:localConfig -or -not $script:logFile) { Write-Host "[$Level] $Message"; return }; $logLevels=@{"Debug"=4;"Verbose"=3;"Info"=2;"Warn"=1;"Error"=0}; $effectiveLogLevel = $script:LogLevel; if(-not $logLevels.ContainsKey($effectiveLogLevel)){ $effectiveLogLevel="Info" }; $currentLevelValue = $logLevels[$effectiveLogLevel]; $messageLevelValue = $logLevels[$Level]; if($null -eq $messageLevelValue){ $messageLevelValue=$logLevels["Info"] }; if($messageLevelValue -le $currentLevelValue){ $timestamp=Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage="[$timestamp] [$Level] [$script:ComputerName] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; if($script:logFile){ try { $logDir = Split-Path $script:logFile -Parent; if($logDir -and (-not(Test-Path $logDir -PathType Container))){ Write-Host "[INFO] Создание папки логов: '$logDir'."; New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null }; Add-Content -Path $script:logFile -Value $logMessage -Encoding UTF8 -Force -EA Stop } catch { Write-Host "[CRITICAL] Ошибка записи в лог '$script:logFile': $($_.Exception.Message)" -ForegroundColor Red; try { $fallbackLog = "$PSScriptRoot\offline_agent_fallback.log"; Add-Content -Path $fallbackLog -Value $logMessage -Encoding UTF8 -Force -EA SilentlyContinue; Add-Content -Path $fallbackLog -Value "[CRITICAL] Ошибка записи в '$script:logFile': $($_.Exception.Message)" -Encoding UTF8 -Force -EA SilentlyContinue } catch {} } } }
}

<#
.SYNOPSIS Возвращает значение по умолчанию, если входное значение ложно.
#>
filter Get-OrElse_Internal{ param([object]$DefaultValue); if ($_) { $_ } else { $DefaultValue } }

#endregion Функции

# --- Основной код агента ---

# 1. Чтение и валидация конфигурации агента
# ... (код чтения и валидации конфига без изменений) ...
Write-Host "Оффлайн-агент мониторинга v$AgentScriptVersion"; Write-Host "Чтение конфигурации агента: $configFile"
if(-not(Test-Path $configFile -PathType Leaf)){ Write-Error "Критическая ошибка: Файл конфигурации '$configFile' не найден."; exit 1 }
try { $script:localConfig = Get-Content -Path $configFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error "Критическая ошибка: Ошибка чтения/парсинга JSON из '$configFile': $($_.Exception.Message)"; exit 1 }
$requiredLocalConfigFields = @("object_id","output_path","output_name_template","assignments_file_path","logFile","LogLevel","check_interval_seconds"); $missingFields = $requiredLocalConfigFields | Where-Object { -not ($script:localConfig.PSObject.Properties.Name.Contains($_)) -or $null -eq $script:localConfig.$_ -or ($script:localConfig.$_ -is [string] -and [string]::IsNullOrWhiteSpace($script:localConfig.$_))}; if($missingFields){ Write-Error "Критическая ошибка: Отсутствуют/пусты обязательные поля в '$configFile': $($missingFields -join ', ')"; exit 1 }
$script:logFile = if($PSBoundParameters.ContainsKey('paramLogFile') -and $paramLogFile){ $paramLogFile } else { $script:localConfig.logFile }; $script:LogLevel = if($PSBoundParameters.ContainsKey('paramLogLevel') -and $paramLogLevel){ $paramLogLevel } else { $script:localConfig.LogLevel }; if(-not $ValidLogLevels.Contains($script:LogLevel)){ Write-Host "[WARN] Некорректный LogLevel '$($script:LogLevel)'. Используется 'Info'." -ForegroundColor Yellow; $script:LogLevel = "Info" }; $checkInterval = 60; if($script:localConfig.check_interval_seconds -and [int]::TryParse($script:localConfig.check_interval_seconds,[ref]$null) -and $script:localConfig.check_interval_seconds -ge 5){ $checkInterval = $script:localConfig.check_interval_seconds } else { Write-Log "Некорректное значение check_interval_seconds ('$($script:localConfig.check_interval_seconds)'). Используется $checkInterval сек." "Warn" }
$objectId = $script:localConfig.object_id; $outputPath = $script:localConfig.output_path; $outputNameTemplate = $script:localConfig.output_name_template; $assignmentsFolderPath = $script:localConfig.assignments_file_path


# 2. Инициализация и проверка путей
# ... (код инициализации и проверки путей без изменений) ...
Write-Log "Оффлайн-агент запущен. Версия: $AgentScriptVersion. Имя хоста: $script:ComputerName" "Info"; Write-Log ("Параметры: ObjectID={0}, Интервал={1} сек, Папка заданий='{2}', Папка результатов='{3}'" -f $objectId, $checkInterval, $assignmentsFolderPath, $outputPath) "Info"; Write-Log "Логирование в '$script:logFile' с уровнем '$script:LogLevel'" "Info"; if(-not(Test-Path $outputPath -PathType Container)){ Write-Log "Папка для результатов '$outputPath' не найдена. Попытка создать..." "Warn"; try { New-Item -Path $outputPath -ItemType Directory -Force -ErrorAction Stop | Out-Null; Write-Log "Папка '$outputPath' успешно создана." "Info" } catch { Write-Log "Критическая ошибка: Не удалось создать папку для результатов '$outputPath': $($_.Exception.Message)" "Error"; exit 1 } }; if(-not(Test-Path $assignmentsFolderPath -PathType Container)){ Write-Log "Критическая ошибка: Папка для файлов заданий '$assignmentsFolderPath' не найдена." "Error"; exit 1 }


# --- 3. Основной цикл работы агента ---
Write-Log "Запуск основного цикла агента..." "Info"
while ($true) {
    $cycleStartTime = Get-Date
    Write-Log "Начало итерации цикла ($($cycleStartTime.ToString('s')))." "Verbose"

    # --- 3.1 Поиск и чтение файла конфигурации заданий ---
    # ... (код поиска и чтения файла конфига без изменений) ...
    $latestConfigFile = $null; $configError = $null; $configData = $null
    try { $configFileNamePattern = "*_${objectId}_*_assignments.json.status.*"; Write-Log "Поиск файла конфигурации в '$assignmentsFolderPath' по шаблону '$configFileNamePattern'..." "Debug"; $foundFiles = Get-ChildItem -Path $assignmentsFolderPath -Filter $configFileNamePattern -File -ErrorAction SilentlyContinue; if ($Error.Count -gt 0 -and $Error[0].CategoryInfo.Category -eq 'ReadError') { throw ("Ошибка доступа при поиске файла конфигурации в '$assignmentsFolderPath': " + $Error[0].Exception.Message); $Error.Clear() }; if ($foundFiles) { $latestConfigFile = $foundFiles | Sort-Object Name -Descending | Select-Object -First 1; Write-Log "Найден последний файл конфигурации: $($latestConfigFile.FullName)" "Verbose" } else { Write-Log "Файлы конфигурации для ObjectID $objectId в '$assignmentsFolderPath' не найдены." "Warn" } } catch { $configError = "Ошибка поиска файла конфигурации: $($_.Exception.Message)"; Write-Log $configError "Error" }
    if ($latestConfigFile -ne $null -and $configError -eq $null) { if ($latestConfigFile.FullName -ne $script:lastProcessedConfigFile) { Write-Log "Обнаружен новый/обновленный файл конфигурации: $($latestConfigFile.Name). Чтение..." "Info"; $tempAssignments = $null; $tempVersionTag = $null; try { $fileContent = Get-Content -Path $latestConfigFile.FullName -Raw -Encoding UTF8 -ErrorAction Stop; $fileContentClean = $fileContent.TrimStart([char]0xFEFF); $configData = $fileContentClean | ConvertFrom-Json -ErrorAction Stop; if ($null -eq $configData -or (-not $configData.PSObject.Properties.Name.Contains('assignments')) -or ($configData.assignments -isnot [array]) -or (-not $configData.PSObject.Properties.Name.Contains('assignment_config_version')) -or (-not $configData.assignment_config_version) ) { throw ("Файл '$($latestConfigFile.Name)' имеет некорректную структуру JSON...") }; $tempVersionTag = $configData.assignment_config_version; $tempAssignments = $configData.assignments; Write-Log ("Файл '{0}' успешно прочитан..." -f $latestConfigFile.Name, $tempAssignments.Count, $tempVersionTag) "Info"; $script:currentAssignments = $tempAssignments; $script:currentAssignmentVersion = $tempVersionTag; $script:lastProcessedConfigFile = $latestConfigFile.FullName; Write-Log "Список заданий обновлен (версия: $tempVersionTag)..." "Info" } catch { $errorMsg = "Критическая ошибка обработки файла '$($latestConfigFile.Name)': $($_.Exception.Message)"; Write-Log $errorMsg "Error"; Write-Log ("Продолжаем использовать предыдущий список заданий (версия: {0})." -f ($script:currentAssignmentVersion | Get-OrElse_Internal '[неизвестно]')) "Warn" } } else { Write-Log "Файл конфигурации '$($latestConfigFile.Name)' не изменился." "Verbose" } } elseif ($configError -ne $null) { Write-Log "Продолжаем использовать предыдущий список заданий..." "Warn" } elseif ($script:lastProcessedConfigFile -ne $null) { Write-Log "Файлы конфигурации не найдены. Продолжаем использовать предыдущий список..." "Warn" } else { Write-Log "Файлы конфигурации не найдены..." "Info" }

    # --- 3.2 Выполнение текущего списка заданий ---
    $cycleCheckResultsList = [System.Collections.Generic.List[object]]::new()

    if ($script:currentAssignments -ne $null -and $script:currentAssignments.Count -gt 0) {
        $assignmentsCount = $script:currentAssignments.Count
        Write-Log "Начало выполнения $assignmentsCount заданий (Версия конфига: $($script:currentAssignmentVersion | Get-OrElse_Internal 'N/A'))..." "Info"
        $completedCount = 0

        foreach ($assignmentRaw in $script:currentAssignments) {
            $completedCount++
            $assignment = [PSCustomObject]$assignmentRaw
            Write-Log "Выполнение $completedCount/$assignmentsCount (ID: $($assignment.assignment_id))..." "Verbose"

            if ($null -eq $assignment -or $null -eq $assignment.assignment_id -or -not $assignment.method_name) {
                Write-Log "Пропущено некорректное задание в списке: $($assignment | Out-String)" "Warn"
                # --- ИЗМЕНЕНО: Создаем объект ошибки через слияние ---
                $errorDetails = @{ assignment_object = ($assignment | Out-String) }
                $errorResultBase = New-CheckResultObject -IsAvailable $false `
                                      -ErrorMessage "Некорректная структура задания в файле конфигурации." `
                                      -Details $errorDetails
                $idPart = @{ assignment_id = ($assignment.assignment_id | Get-OrElse_Internal $null) }
                $errorResultToSave = $idPart + $errorResultBase
                $cycleCheckResultsList.Add($errorResultToSave)
                # --- КОНЕЦ ИЗМЕНЕНИЯ ---
                continue
            }

            $checkResult = $null
            try {
                # Вызываем диспетчер проверок
                $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment `
                                                        -Verbose:$VerbosePreference `
                                                        -Debug:$DebugPreference

                Write-Log ("Результат ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f `
                           $assignment.assignment_id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) "Verbose"

                # --- ИЗМЕНЕНО: Создаем НОВЫЙ объект результата с ID через слияние ---
                $idPart = @{ assignment_id = $assignment.assignment_id }
                $resultToSave = $idPart + $checkResult
                # --- КОНЕЦ ИЗМЕНЕНИЯ ---

                # Отладочный вывод (если включен Debug)
                Write-Debug ("Объект ДО добавления в список (ID: {0}): {1}" -f `
                             $assignment.assignment_id, ($resultToSave | ConvertTo-Json -Depth 4 -Compress))

                # Добавляем результат в список для файла
                $cycleCheckResultsList.Add($resultToSave)

            } catch {
                 # Обработка критической ошибки выполнения Invoke-StatusMonitorCheck
                 $errorMessage = "Критическая ошибка при выполнении задания ID $($assignment.assignment_id): $($_.Exception.Message)"
                 Write-Log $errorMessage "Error"
                 # Создаем запись об ошибке
                 $errorDetails = @{ ErrorRecord = $_.ToString() }
                 $errorResultBase = New-CheckResultObject -IsAvailable $false `
                                      -ErrorMessage $errorMessage `
                                      -Details $errorDetails
                 # --- ИЗМЕНЕНО: Создаем НОВЫЙ объект ошибки с ID через слияние ---
                 $idPart = @{ assignment_id = $assignment.assignment_id }
                 $errorResultToSave = $idPart + $errorResultBase
                 # --- КОНЕЦ ИЗМЕНЕНИЯ ---

                 # Отладочный вывод для ошибки
                 Write-Debug ("ОБЪЕКТ ОШИБКИ ДО добавления в список (ID: {0}): {1}" -f `
                              $assignment.assignment_id, ($errorResultToSave | ConvertTo-Json -Depth 4 -Compress))

                 # Добавляем результат с ошибкой в общий список
                 $cycleCheckResultsList.Add($errorResultToSave)
            }
        } # Конец foreach assignment

        Write-Log "Выполнение $assignmentsCount заданий завершено. Собрано результатов: $($cycleCheckResultsList.Count)." "Info"

    } else {
        Write-Log "Нет активных заданий для выполнения в этой итерации." "Verbose"
    }

    # --- 3.3 Формирование и сохранение файла результатов (*.zrpu) ---
    if ($cycleCheckResultsList.Count -gt 0) {
        # ... (код формирования $finalPayload и сохранения файла без изменений) ...
        $finalPayload = @{ agent_script_version = $AgentScriptVersion; assignment_config_version = $script:currentAssignmentVersion; results = $cycleCheckResultsList }
        $timestampForFile = Get-Date -Format "ddMMyy_HHmmss"; $outputFileName = $outputNameTemplate -replace "{object_id}", $objectId -replace "{ddMMyy_HHmmss}", $timestampForFile; $outputFileName = $outputFileName -replace '[\\/:*?"<>|]', '_'; $outputFileFullPath = Join-Path $outputPath $outputFileName
        Write-Log "Сохранение $($cycleCheckResultsList.Count) результатов в файл: '$outputFileFullPath'" "Info"; Write-Log ("Версия агента: {0}, Версия конфига заданий: {1}" -f $AgentScriptVersion, ($script:currentAssignmentVersion | Get-OrElse_Internal 'N/A')) "Verbose"
        try { $jsonToSave = $finalPayload | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue; $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false); [System.IO.File]::WriteAllText($outputFileFullPath, $jsonToSave, $Utf8NoBomEncoding); Write-Log "Файл результатов '$outputFileName' успешно сохранен." "Info" }
        catch { Write-Log "Критическая ошибка сохранения файла результатов '$outputFileFullPath': $($_.Exception.Message)" "Error" }
    } else {
        Write-Log "Нет результатов для сохранения в файл в этой итерации." "Verbose"
    }

    # --- 3.4 Пауза перед следующей итерацией ---
    # ... (код расчета паузы и Start-Sleep без изменений) ...
    $cycleEndTime = Get-Date; $elapsedSeconds = ($cycleEndTime - $cycleStartTime).TotalSeconds; $sleepSeconds = $checkInterval - $elapsedSeconds; if ($sleepSeconds -lt 1) { $sleepSeconds = 1 }
    Write-Log ("Итерация заняла {0:N2} сек. Пауза {1:N2} сек до следующего цикла..." -f $elapsedSeconds, $sleepSeconds) "Verbose"; Start-Sleep -Seconds $sleepSeconds

} # --- Конец while ($true) ---

Write-Log "Оффлайн-агент завершает работу (неожиданный выход из основного цикла)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\offline-agent\offline-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\README.md ====

---

**6. `powershell/offline-agent/README.md` (Обновление)**

```markdown
# PowerShell Offline Агент (offline-agent) v3.1

Этот скрипт (`offline-agent.ps1`) выполняет роль агента мониторинга для узлов, работающих в **изолированных сетевых сегментах** без прямого доступа к центральному API системы Status Monitor.

## Назначение

*   Периодически проверять наличие/обновление локального файла с заданиями мониторинга (`*.json.status.*`).
*   Читать и выполнять задания из этого файла с помощью `Invoke-StatusMonitorCheck` из модуля `StatusMonitorAgentUtils`.
*   Собирать **стандартизированные результаты** каждой проверки (включая `IsAvailable`, `CheckSuccess`, `Details`, `ErrorMessage`, `Timestamp`).
*   **Добавлять `assignment_id`** к каждому полученному результату.
*   Сохранять массив этих дополненных результатов в единый JSON-файл (`*.zrpu`) вместе с метаданными (версии скрипта и конфига) в указанную папку для последующей передачи и загрузки в центральную систему.

## Принцип работы

1.  Администратор с помощью скрипта **Конфигуратора** генерирует файл конфигурации заданий (`{version_tag}_assignments.json.status.{transport_code}`) для данного объекта.
2.  Этот файл доставляется на машину агента (например, с помощью Транспортной Системы) в папку, указанную в параметре `assignments_file_path` в локальном `config.json` оффлайн-агента.
3.  Скрипт `offline-agent.ps1` запускается (например, через Планировщик Задач Windows).
4.  Читает параметры из своего локального файла `config.json`.
5.  Импортирует модуль `StatusMonitorAgentUtils`.
6.  В бесконечном цикле (с интервалом `check_interval_seconds`):
    *   Ищет самый новый файл конфигурации заданий в папке `assignments_file_path`.
    *   Если найден новый или измененный файл:
        *   Читает JSON, извлекает массив `assignments` и `assignment_config_version`.
        *   Сохраняет их в памяти (`$script:currentAssignments`, `$script:currentAssignmentVersion`).
    *   Если список `$script:currentAssignments` не пуст:
        *   Для **каждого** задания:
            *   Вызывает **локально** `Invoke-StatusMonitorCheck`, передавая объект задания.
            *   Получает стандартизированный результат (`$checkResult`).
            *   **Создает новый объект**, объединяя `$checkResult` и `assignment_id`.
            *   Добавляет этот новый объект в массив `$cycleCheckResultsList`.
            *   Обрабатывает ошибки выполнения, также добавляя `assignment_id` к записи об ошибке.
    *   Если `$cycleCheckResultsList` не пуст:
        *   Формирует итоговый JSON (`$finalPayload`), включающий `agent_script_version`, `assignment_config_version` и массив `results` (содержащий дополненные результаты).
        *   Сохраняет `$finalPayload` в файл `.zrpu` в папку `output_path`.
    *   Ожидает интервал `check_interval_seconds` перед следующим циклом.
    *   Логирует свою работу.
7.  Файлы `*.zrpu` из папки `output_path` затем забираются и доставляются для обработки Загрузчиком Результатов.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `offline-agent.ps1`:

```json
{
    "object_id": 1060,
    "config_type": "offline_multi_check_agent_v3.1",
    "check_interval_seconds": 60,
    "output_path": "C:\\StatusMonitor\\Results",
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_OfflineChecks.json.status.zrpu",
    "logFile": "C:\\Logs\\StatusMonitor\\offline_agent.log",
    "LogLevel": "Info",
    "assignments_file_path": "C:\\StatusMonitor\\Config"
}

Поля конфигурации:

    object_id: (Число, Обязательно) Внешний ID подразделения (subdivisions.object_id), которому соответствует этот агент. Используется для поиска файла конфигурации.

    config_type: (Строка, Информационно) Тип и версия агента.

    check_interval_seconds: (Число, Опционально, По умолчанию 60) Как часто (в секундах) агент будет выполнять весь цикл проверок и генерировать файл результатов.

    output_path: (Строка, Обязательно) Папка, куда будут сохраняться файлы с результатами (*.zrpu). Папка должна существовать и быть доступна для записи.

    output_name_template: (Строка, Обязательно) Шаблон имени файла результатов. Плейсхолдеры: {ddMMyy_HHmmss}, {object_id}. Расширение должно быть .zrpu.

    logFile: (Строка, Обязательно) Полный путь к лог-файлу агента.

    LogLevel: (Строка, Опционально, По умолчанию "Info") Уровень детализации логов (Debug, Verbose, Info, Warn, Error).

    assignments_file_path: (Строка, Обязательно) Папка, где агент ищет самый новый файл конфигурации, соответствующий его object_id и шаблону (*_<object_id>_*_assignments.json.status.*).

Формат файла результатов (*.zrpu)

Файл представляет собой JSON-объект со следующей структурой:

{
  "agent_script_version": "agent_script_v3.1", // Версия скрипта offline-agent.ps1
  "assignment_config_version": "20240520120000_1060_abc...", // Версия файла с заданиями
  "results": [ // Массив результатов проверок
    {
      // Стандартизированный результат от Invoke-StatusMonitorCheck
      "IsAvailable": true,
      "CheckSuccess": true,
      "Timestamp": "2024-05-20T12:05:30.1234567Z",
      "Details": {
        "disk_letter": "C",
        "percent_free": 25.5,
        "execution_mode": "local_agent",
        // ... другие детали ...
      },
      "ErrorMessage": null,
      // Добавленное поле:
      "assignment_id": 101
    },
    {
      "IsAvailable": false,
      "CheckSuccess": null,
      "Timestamp": "2024-05-20T12:05:35.9876543Z",
      "Details": {
        "error": "Служба 'MyService' не найдена.",
        // ... другие детали ...
      },
      "ErrorMessage": "Служба 'MyService' не найдена.",
      "assignment_id": 102
    }
    // ... другие результаты ...
  ]
}

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль StatusMonitorAgentUtils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой offline-agent или в путях $env:PSModulePath.

    Конфиг Заданий: Необходим файл конфигурации заданий (*.json.status.*), сгенерированный Конфигуратором и доставленный в assignments_file_path.

    Права: Права на чтение из assignments_file_path, запись в output_path и logFile. Права для выполнения конкретных проверок.

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows.

Замечания

    Агент не требует прямого доступа к API.

    Логика конкретных проверок находится в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.

    Убедитесь, что Транспортная Система корректно доставляет файлы конфигурации и забирает файлы результатов (*.zrpu).
==== END FILE: F:\status\source\powershell\offline-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\config.json ====
{
    "object_id": 1516,
    "config_type": "online_multi_check_agent_v3",
    "apiBaseUrl": "http://localhost:48030/api",
    "api_key": "HC_ig1ko5JM8mPs1pNM-mE2aDoUJDrtruD_6zpOp1aw",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 120,
    "logFile": "online_check.log",
    "LogLevel": "Debug"
}
==== END FILE: F:\status\source\powershell\online-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\online-agent.ps1 ====
# powershell\online-agent\online-agent.ps1
# Версия с поддержкой нового диспетчера, формата результата,
# улучшенным форматированием, комментариями и исправленными ошибками.
<#
.SYNOPSIS
    Онлайн-агент для системы мониторинга Status Monitor v5.5.
.DESCRIPTION
    Этот агент предназначен для работы на машинах, имеющих прямой сетевой
    доступ к API сервера мониторинга. Он выполняет следующие действия:
    1. Читает локальную конфигурацию из файла 'config.json'.
    2. Импортирует необходимый модуль StatusMonitorAgentUtils.
    3. Периодически (раз в api_poll_interval_seconds) обращается к API
       сервера (/api/v1/assignments) для получения списка активных заданий
       мониторинга, предназначенных для его object_id.
    4. Хранит список заданий в памяти и самостоятельно планирует их выполнение
       согласно интервалам, указанным в заданиях или в конфиге по умолчанию.
    5. Для выполнения каждой проверки вызывает функцию Invoke-StatusMonitorCheck
       из импортированного модуля.
    6. Получает стандартизированный результат от Invoke-StatusMonitorCheck.
    7. Преобразует результат в формат, ожидаемый API /checks (v1).
    8. Немедленно отправляет результат каждой проверки на сервер через
       POST-запрос к API /api/v1/checks, используя API-ключ для аутентификации.
    9. Ведет лог своей работы в указанный файл.
.NOTES
    Версия: 5.5
    Дата: 2024-05-20
    Изменения v5.5:
        - Исправлена ошибка CommandNotFoundException из-за заглушек "..." в ConvertTo-Json при сравнении заданий.
    Изменения v5.4:
        - Исправлена ошибка ParameterBindingException при вызове Write-Verbose с уровнем Debug. Заменено на Write-Debug.
    Изменения v5.3:
        - Исправлена ошибка парсинга строки в блоке catch функции Send-CheckResultToApi.
    Изменения v5.2:
        - Исправлена ошибка CommandNotFoundException из-за заглушек "...".
        - Реализовано корректное частичное отображение API ключа в логах.
        - Разбиты длинные строки кода на несколько для читаемости.
        - Добавлены подробные комментарии.
        - Улучшено форматирование.
        - Функция Get-ActiveAssignments вынесена и исправлена.
    Изменения v5.1:
        - Адаптация под новый формат результата Invoke-StatusMonitorCheck.
        - Использование полей IsAvailable и CheckSuccess из результата проверки.
        - Формирование detail_type и detail_data для API на основе результата.
        - Использование IsAvailable для определения доступности узла при отправке.
    Зависимости: PowerShell 5.1+, модуль StatusMonitorAgentUtils, доступ к API.
#>
param(
    # Путь к файлу конфигурации агента.
    [string]$ConfigFile = "$PSScriptRoot\config.json"
)

# --- Загрузка необходимого модуля утилит ---
# Устанавливаем строгий режим обработки ошибок на время импорта
$ErrorActionPreference = "Stop"
try {
    # Определяем путь к манифесту модуля относительно текущего скрипта
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot `
                                    -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    # Принудительно импортируем модуль
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils загружен."
} catch {
    # Критическая ошибка - агент не может работать без модуля
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    # Завершаем работу скрипта с кодом ошибки
    exit 1
} finally {
    # Возвращаем стандартное поведение обработки ошибок
    $ErrorActionPreference = "Continue"
}
# --- Конец загрузки модуля ---

# --- Глобальные переменные и константы ---

# Версия текущего скрипта агента
$ScriptVersion = "5.5" # Обновили версию

# Хэш-таблица для хранения активных заданий (ключ - assignment_id, значение - объект задания)
$script:ActiveAssignments = @{}
# Хэш-таблица для хранения времени последнего выполнения каждого задания (ключ - assignment_id, значение - строка ISO 8601 UTC)
$script:LastExecutedTimes = @{}
# Объект для хранения конфигурации из файла config.json
$script:Config = $null
# API ключ для аутентификации на сервере
$script:ApiKey = $null
# Имя текущего компьютера для идентификации в логах и результатах
$script:ComputerName = $env:COMPUTERNAME

# --- Значения по умолчанию для параметров конфигурации ---
# Как часто опрашивать API на предмет новых/измененных заданий (секунды)
$DefaultApiPollIntervalSeconds = 60
# Интервал выполнения проверки по умолчанию (если не указан в задании, секунды)
$DefaultCheckIntervalSeconds = 120
# Уровень логирования по умолчанию
$DefaultLogLevel = "Info"
# Путь к лог-файлу по умолчанию (в папке со скриптом)
$DefaultLogFile = "$PSScriptRoot\online_agent.log"
# Таймаут ожидания ответа от API (секунды)
$ApiTimeoutSeconds = 30
# Максимальное количество попыток запроса к API при ошибке
$MaxApiRetries = 3
# Задержка между повторными попытками запроса к API (секунды)
$RetryDelaySeconds = 5
# Допустимые уровни логирования
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")
# Эффективный уровень логирования (будет установлен после чтения конфига)
$script:EffectiveLogLevel = $DefaultLogLevel

# --- Функции ---

#region Функции

<#
.SYNOPSIS
    Записывает сообщение в лог-файл и/или выводит в консоль.
# ... (документация Write-Log без изменений) ...
#>
function Write-Log {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
        [string]$Level = "Info"
    )
    # ... (код функции Write-Log без изменений) ...
    $logFilePath = $script:Config.logFile | Get-OrElse $DefaultLogFile; $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }; $currentLevelValue = $logLevels[$script:EffectiveLogLevel]; if ($null -eq $currentLevelValue) { $currentLevelValue = $logLevels["Info"] }; $messageLevelValue = $logLevels[$Level]; if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] }; if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] [$script:ComputerName] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; try { $logDir = Split-Path $logFilePath -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки логов: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }; $logMessage | Out-File -FilePath $logFilePath -Append -Encoding UTF8 -ErrorAction Stop } catch { Write-Host "[Error] Не удалось записать в лог '$($logFilePath)': $($_.Exception.Message)" -ForegroundColor Red } }
}

<#
.SYNOPSIS
    Возвращает значение по умолчанию, если входное значение ложно.
# ... (документация Get-OrElse без изменений) ...
#>
filter Get-OrElse {
    param([object]$DefaultValue)
    if ($_) { $_ } else { $DefaultValue }
}

<#
.SYNOPSIS
    Отправляет результат ОДНОЙ проверки в API /checks.
# ... (документация Send-CheckResultToApi без изменений) ...
#>
function Send-CheckResultToApi {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$CheckResult,
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Assignment
    )

    $assignmentId = $Assignment.assignment_id
    Write-Log "Отправка результата для задания ID $assignmentId..." "Verbose"

    # --- Формируем тело запроса для API /checks ---
    $isAvailableApi = [bool]$CheckResult.IsAvailable
    $checkTimestampApi = $CheckResult.Timestamp
    $detailTypeApi = $null
    $detailDataApi = $null

    if ($CheckResult.Details -ne $null -and $CheckResult.Details -is [hashtable]) {
        $detailTypeApi = $Assignment.method_name
        $detailDataApi = $CheckResult.Details
        if ($CheckResult.ContainsKey('CheckSuccess')) {
            $detailDataApi.check_success = $CheckResult.CheckSuccess
        }
        if (-not [string]::IsNullOrEmpty($CheckResult.ErrorMessage)) {
             $detailDataApi.error_message_from_check = $CheckResult.ErrorMessage
        }
    }
    elseif (-not [string]::IsNullOrEmpty($CheckResult.ErrorMessage)) {
        $detailTypeApi = "ERROR"
        $detailDataApi = @{ message = $CheckResult.ErrorMessage }
    }

    $body = @{
        assignment_id        = $assignmentId
        is_available         = $isAvailableApi
        check_timestamp      = $checkTimestampApi
        executor_object_id   = $script:Config.object_id
        executor_host        = $script:ComputerName
        resolution_method    = $Assignment.method_name
        detail_type          = $detailTypeApi
        detail_data          = $detailDataApi
        agent_script_version = $ScriptVersion
    }
    # --- Конец формирования тела запроса ---

    # Преобразуем тело в JSON строку
    try {
        $jsonBody = $body | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
    } catch {
         # Используем -f для форматирования строки
         Write-Log ("Критическая ошибка ConvertTo-Json для ID {0}: {1}" -f $assignmentId, $_.Exception.Message) "Error"
         Write-Log "Проблемный объект: $($body | Out-String)" "Error"
         return $false
    }

    # Заголовки и URL
    $headers = @{
        'Content-Type' = 'application/json; charset=utf-8'
        'X-API-Key'    = $script:ApiKey
    }
    $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/checks"
    Write-Log "URL отправки: $apiUrl" "Debug"
    Write-Log "Тело JSON: $jsonBody" "Debug"

    # --- Отправка запроса с логикой повторных попыток (retry) ---
    $retryCount = 0; $success = $false
    while ($retryCount -lt $MaxApiRetries -and (-not $success)) {
        try {
            $response = Invoke-RestMethod -Uri $apiUrl `
                                          -Method Post `
                                          -Body ([System.Text.Encoding]::UTF8.GetBytes($jsonBody)) `
                                          -Headers $headers `
                                          -TimeoutSec $ApiTimeoutSeconds `
                                          -ErrorAction Stop

            Write-Log ("Результат ID {0} отправлен. Ответ API: {1}" -f `
                        $assignmentId, ($response | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue)) "Info"
            $success = $true

        } catch {
            $retryCount++; $statusCode = $null; if ($_.Exception.Response) { try { $statusCode = [int]$_.Exception.Response.StatusCode } catch {} }; $errorMessage = $_.Exception.Message;
            $errorResponseBody = "[не удалось прочитать тело ответа]"; if ($_.Exception.Response) { try { $errorStream = $_.Exception.Response.GetResponseStream(); $reader = New-Object System.IO.StreamReader($errorStream); $errorResponseBody = $reader.ReadToEnd(); $reader.Close(); $errorStream.Dispose() } catch {} };
            Write-Log ("Ошибка отправки ID {0} (попытка {1}/{2}). Код: {3}. Error: {4}. Ответ: {5}" -f $assignmentId, $retryCount, $MaxApiRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage, $errorResponseBody) "Error"
            if ($statusCode -eq 401 -or $statusCode -eq 403) { Write-Log "Критическая ошибка: Неверный API ключ или права (Код: $statusCode). Завершение работы." "Error"; exit 1 }
            if ($retryCount -ge $MaxApiRetries) { Write-Log "Превышено кол-во попыток ($MaxApiRetries) для ID $assignmentId." "Error"; break }
            Write-Log "Пауза $RetryDelaySeconds сек..." "Warn"; Start-Sleep -Seconds $RetryDelaySeconds
        }
    } # Конец while retry
    return $success
}

<#
.SYNOPSIS
    Запрашивает активные задания у API сервера.
# ... (документация Get-ActiveAssignments без изменений) ...
#>
function Get-ActiveAssignments {
    Write-Log "Запрос активных заданий у API..." "Info"
    $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/assignments?object_id=$($script:Config.object_id)"
    Write-Log "URL: $apiUrl" "Verbose"

    # Отображение части API ключа
    $apiKeyPartial = "[Не задан]"
    if ($script:ApiKey) {
        $len = $script:ApiKey.Length; $prefix = $script:ApiKey.Substring(0, [math]::Min(4, $len)); $suffix = if ($len -gt 8) { $script:ApiKey.Substring($len - 4, 4) } else { "" }; $apiKeyPartial = "$prefix....$suffix"
    }
    Write-Log "Исп. API ключ (частично): $apiKeyPartial" "Debug"

    $headers = @{ 'X-API-Key' = $script:ApiKey }
    $newAssignments = $null; $retryCount = 0
    while ($retryCount -lt $MaxApiRetries -and $newAssignments -eq $null) {
        try {
            $newAssignments = Invoke-RestMethod -Uri $apiUrl `
                                                -Method Get `
                                                -Headers $headers `
                                                -TimeoutSec $ApiTimeoutSeconds `
                                                -ErrorAction Stop
            if ($newAssignments -isnot [array]) { throw ("API ответ не является массивом: $($newAssignments | Out-String)") }
            Write-Log "Получено $($newAssignments.Count) активных заданий." "Info"
            return $newAssignments
        } catch {
            $retryCount++; $statusCode = $null; if ($_.Exception.Response) { try { $statusCode = [int]$_.Exception.Response.StatusCode } catch {} }; $errorMessage = $_.Exception.Message;
            Write-Log ("Ошибка API при получении заданий (попытка {0}/{1}). Код: {2}. Error: {3}" -f $retryCount, $MaxApiRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage) "Error"
            if ($statusCode -eq 401 -or $statusCode -eq 403) { Write-Log "Критическая ошибка: Неверный API ключ или права (Код: $statusCode). Завершение работы." "Error"; exit 1 }
            if ($retryCount -ge $MaxApiRetries) { Write-Log "Превышено кол-во попыток ($MaxApiRetries) получения заданий." "Error"; return $null }
            Write-Log "Пауза $RetryDelaySeconds сек..." "Warn"; Start-Sleep -Seconds $RetryDelaySeconds
        }
    } # Конец while retry
    return $null
}

#endregion Функции

# --- Основной код агента ---

# 1. Чтение конфигурации из файла
Write-Host "Чтение конфигурации из: $ConfigFile"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Error ...; exit 1 }
try { $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error ...; exit 1 }
$requiredCfg=@("object_id","apiBaseUrl","api_key","logFile","LogLevel","api_poll_interval_seconds","default_check_interval_seconds"); $missingCfg=$requiredCfg|?{-not $script:Config.PSObject.Properties.Name.Contains($_) -or !$script:Config.$_}; if($missingCfg){ Write-Error ...; exit 1 }
$script:EffectiveLogLevel = $script:Config.LogLevel | Get-OrElse $DefaultLogLevel
if ($script:EffectiveLogLevel -notin $ValidLogLevels) { Write-Host ...; $script:EffectiveLogLevel = $DefaultLogLevel }
$script:ApiKey = $script:Config.api_key

# 2. Инициализация и логирование старта агента
Write-Log "Онлайн-агент v$ScriptVersion запущен." "Info"
Write-Log "Конфигурация: ObjectID=$($script:Config.object_id), API URL=$($script:Config.apiBaseUrl)" "Info"
Write-Log ("Интервал опроса API: {0} сек, Стандартный интервал проверки: {1} сек." -f `
    $script:Config.api_poll_interval_seconds, $script:Config.default_check_interval_seconds) "Verbose"
Write-Log "Логирование в '$($script:Config.logFile)' с уровнем '$($script:EffectiveLogLevel)'" "Info"

# 3. Основной цикл работы агента
$lastApiPollTime = [DateTime]::MinValue
$apiPollInterval = [TimeSpan]::FromSeconds($script:Config.api_poll_interval_seconds)
$DefaultCheckInterval = [TimeSpan]::FromSeconds($script:Config.default_check_interval_seconds)

Write-Log "Запуск основного цикла обработки заданий..." "Info"
while ($true) {
    $loopStartTime = Get-Date
    Write-Log "Начало итерации цикла." "Verbose"

    # 3.1 Запрос/обновление списка активных заданий у API
    if (($loopStartTime - $lastApiPollTime) -ge $apiPollInterval) {
        Write-Log "Время обновить список заданий с API." "Info"; $fetchedAssignments = Get-ActiveAssignments
        if ($fetchedAssignments -ne $null) {
            Write-Log "Обработка полученных заданий..." "Info"; $newAssignmentMap = @{}; $fetchedIds = [System.Collections.Generic.List[int]]::new()
            foreach ($assignment in $fetchedAssignments) { if ($assignment.assignment_id -ne $null) { $id = $assignment.assignment_id; $newAssignmentMap[$id] = $assignment; $fetchedIds.Add($id) } else { Write-Log "..." "Warn" } }
            $currentIds = $script:ActiveAssignments.Keys | ForEach-Object { [int]$_ }; $removedIds = $currentIds | Where-Object { $fetchedIds -notcontains $_ }
            if ($removedIds) { foreach ($removedId in $removedIds) { Write-Log "... $removedId" "Info"; $script:ActiveAssignments.Remove($removedId); $script:LastExecutedTimes.Remove($removedId) } }
            $addedCount = 0; $updatedCount = 0
            foreach ($assignmentId in $fetchedIds) {
                if (-not $script:ActiveAssignments.ContainsKey($assignmentId)) {
                    # Добавление нового задания
                    Write-Log "Добавлено новое задание ID $assignmentId" "Info"
                    $script:ActiveAssignments[$assignmentId] = $newAssignmentMap[$assignmentId]
                    $script:LastExecutedTimes[$assignmentId] = (Get-Date).AddDays(-1).ToUniversalTime().ToString("o")
                    $addedCount++
                } else {
                    # Проверка, изменилось ли существующее задание
                    # --- ИСПРАВЛЕНО: Убраны заглушки "..." ---
                    $oldJson = $script:ActiveAssignments[$assignmentId] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                    $newJson = $newAssignmentMap[$assignmentId] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                    # --- КОНЕЦ ИСПРАВЛЕНИЯ ---
                    if ($oldJson -ne $newJson) {
                         Write-Log "Обновлено задание ID $assignmentId" "Verbose"
                         $script:ActiveAssignments[$assignmentId] = $newAssignmentMap[$assignmentId]
                         # Сбрасывать ли LastExecutedTimes при обновлении?
                         # Пока не будем, чтобы не вызвать выполнение сразу после обновления.
                         $updatedCount++
                    }
                }
            } # Конец foreach ($assignmentId in $fetchedIds)
            Write-Log ("Синхронизация заданий завершена. Добавлено:{0}. Обновлено:{1}. Удалено:{2}." -f $addedCount, $updatedCount, $removedIds.Count) "Info"
            $lastApiPollTime = $loopStartTime
        } else { Write-Log "Не удалось получить задания от API..." "Error" }
    } else { Write-Log "Опрос API еще не требуется..." "Verbose" }

    # 3.2 Выполнение запланированных проверок
    # ... (код выполнения проверок, вызова Invoke-StatusMonitorCheck и Send-CheckResultToApi без изменений) ...
    $currentTime = Get-Date
    if ($script:ActiveAssignments.Count -gt 0) {
        Write-Log "Проверка запланированных заданий ($($script:ActiveAssignments.Count) активно)..." "Verbose"
        $assignmentIdsToCheck = $script:ActiveAssignments.Keys | ForEach-Object { $_ }
        foreach ($id in $assignmentIdsToCheck) {
            if (-not $script:ActiveAssignments.ContainsKey($id)) { continue }
            $assignment = $script:ActiveAssignments[$id]; $checkIntervalSeconds = $assignment.check_interval_seconds | Get-OrElse $script:Config.default_check_interval_seconds; if ($checkIntervalSeconds -le 0) { $checkIntervalSeconds = $script:Config.default_check_interval_seconds }; $checkInterval = [TimeSpan]::FromSeconds($checkIntervalSeconds); $lastRunString = $script:LastExecutedTimes[$id]; $lastRunTime = [DateTime]::MinValue; if ($lastRunString) { try { $lastRunTime = [DateTime]::ParseExact($lastRunString,"o",$null).ToLocalTime() } catch { Write-Log "... ID ${id}: '$lastRunString'" "Error"; $lastRunTime = [DateTime]::MinValue } }; $nextRunTime = $lastRunTime + $checkInterval
            Write-Debug ("Задание ID {0}: Интервал={1} сек, Посл.={2}, След.={3}" -f $id, $checkInterval.TotalSeconds, $lastRunTime.ToString('s'), $nextRunTime.ToString('s'))
            if ($currentTime -ge $nextRunTime) {
                Write-Log ("ВЫПОЛНЕНИЕ ЗАДАНИЯ ID {0} ({1} для {2})." -f $id, $assignment.method_name, $assignment.node_name) "Info"; $checkResult = $null
                try { $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment -Verbose:$VerbosePreference -Debug:$DebugPreference; Write-Log ("Результат проверки ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f $id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) "Verbose"; Write-Log ("Детали результата ID {0}: {1}" -f $id, ($checkResult.Details | ConvertTo-Json -Depth 3 -Compress -WarningAction SilentlyContinue)) "Debug"; $sendSuccess = Send-CheckResultToApi -CheckResult $checkResult -Assignment $assignment; if ($sendSuccess) { $script:LastExecutedTimes[$id] = $currentTime.ToUniversalTime().ToString("o"); Write-Log "Время последнего выполнения ID $id обновлено." "Verbose" } else { Write-Log "Результат для ID $id НЕ был успешно отправлен в API." "Error" } } catch { Write-Log "Критическая ошибка при ВЫПОЛНЕНИИ задания ID ${id}: $($_.Exception.Message)" "Error" }
            }
        }
    } else { Write-Log "Нет активных заданий для выполнения." "Verbose" }

    # 3.3 Пауза перед следующей итерацией
    Start-Sleep -Seconds 1

} # --- Конец while ($true) ---

Write-Log "Онлайн-агент завершает работу (неожиданный выход из основного цикла)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\online-agent\online-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\README.md ====
# PowerShell Online Агент (online-agent) v5.5

Этот скрипт (`online-agent.ps1`) выполняет роль агента мониторинга для узлов, имеющих **прямой сетевой доступ** к центральному API системы Status Monitor.

## Назначение

*   Периодически подключаться к API и запрашивать актуальный список заданий мониторинга (`Assignments`), предназначенных для подразделения, в котором он работает (определяется по `object_id` в конфигурации).
*   Самостоятельно планировать и выполнять полученные задания с заданными интервалами.
*   Для выполнения каждой проверки использовать **локально** модуль `StatusMonitorAgentUtils` и его функцию-диспетчер `Invoke-StatusMonitorCheck`.
*   Немедленно отправлять стандартизированный результат **каждой** выполненной проверки обратно в API (`POST /api/v1/checks`), используя API-ключ для аутентификации.

## Принцип работы

1.  Скрипт `online-agent.ps1` запускается (например, через Планировщик Задач или как Служба Windows).
2.  Читает параметры из локального файла `config.json`.
3.  Импортирует модуль `StatusMonitorAgentUtils` (он должен находиться рядом или в путях PowerShell).
4.  Периодически (с интервалом `api_poll_interval_seconds`) выполняет GET-запрос к API (`/api/v1/assignments?object_id=...`), используя `object_id` и `api_key`.
5.  Хранит полученный список активных заданий в памяти (`$script:ActiveAssignments`). Сравнивает с предыдущим списком, добавляет новые, удаляет неактуальные.
6.  В бесконечном цикле проверяет, не пришло ли время выполнить какое-либо из активных заданий (с учетом `check_interval_seconds` из задания или `default_check_interval_seconds` из конфига).
7.  При наступлении времени выполнения для задания:
    *   Вызывает **локально** `Invoke-StatusMonitorCheck`, передавая ему объект задания.
    *   `Invoke-StatusMonitorCheck` находит и **локально** запускает соответствующий скрипт `Checks/Check-*.ps1`.
    *   Скрипт `Check-*.ps1` выполняет проверку (например, `Test-Connection` к целевому IP, `Get-Service` и т.д.).
    *   Агент получает стандартизированный результат (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
    *   Агент формирует тело запроса для `POST /api/v1/checks`, включая `assignment_id`, статус `is_available` (из результата), `timestamp` (из результата), `details` (включая `CheckSuccess` и `ErrorMessage`), `agent_script_version`.
    *   Отправляет POST-запрос в API с помощью функции `Send-CheckResultToApi`, используя API-ключ.
    *   Обновляет время последнего выполнения для этого задания локально (только при успешной отправке).
8.  Логирует свою работу в файл, указанный в `config.json`.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `online-agent.ps1`:

```json
{
    "object_id": 1516,
    "config_type": "online_multi_check_agent_v5.5",
    "apiBaseUrl": "http://localhost:48030/api",
    "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_AGENT",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 120,
    "logFile": "C:\\Logs\\StatusMonitor\\online_agent.log",
    "LogLevel": "Info"
}

Поля конфигурации:

    object_id: (Число, Обязательно) Уникальный внешний ID подразделения (subdivisions.object_id) из центральной БД. Агент будет получать задания только для узлов этого подразделения.

    config_type: (Строка, Информационно) Тип и версия агента.

    apiBaseUrl: (Строка, Обязательно) Базовый URL API сервера Status Monitor (например, http://status.example.com/api). Без /v1/ в конце.

    api_key: (Строка, Обязательно) API ключ, сгенерированный в системе Status Monitor с ролью agent. Используется для аутентификации при запросах к API.

    api_poll_interval_seconds: (Число, Опционально, По умолчанию 60) Как часто (в секундах) агент будет опрашивать API для обновления списка своих заданий.

    default_check_interval_seconds: (Число, Опционально, По умолчанию 120) Интервал выполнения проверки (в секундах), который будет использоваться, если интервал не указан в самом задании, полученном от API.

    logFile: (Строка, Обязательно) Полный путь к файлу, куда агент будет писать логи. Папка должна существовать и быть доступна для записи.

    LogLevel: (Строка, Опционально, По умолчанию "Info") Уровень детализации логов (Debug, Verbose, Info, Warn, Error).

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль StatusMonitorAgentUtils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой online-agent (т.е. ..\StatusMonitorAgentUtils) или в одном из путей, перечисленных в $env:PSModulePath.

    Сеть: Требуется сетевой доступ с машины агента к apiBaseUrl И к целевым узлам, которые он будет проверять (например, для PING, Get-Service).

    Права:

        Права на запись в logFile.

        Права, необходимые для выполнения конкретных проверок (например, для Get-Service на удаленной машине могут потребоваться права администратора и настроенный WinRM).

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows для обеспечения непрерывной работы и автоматического перезапуска.

Замечания

    Убедитесь, что API ключ, указанный в config.json, действителен и имеет роль agent.

    Для методов проверки, отличных от PING, необходимо реализовать соответствующую логику в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.
==== END FILE: F:\status\source\powershell\online-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\config.json ====
{
  "api_base_url": "http://localhost:48030/api",
  "api_key": "ЗАМЕНИТЕ_НА_ВАШ_LOADER_КЛЮЧ",
  "check_folder": "F:\\status\\builds\\results_offline",
  "processed_folder": "F:\\status\\builds\\results_offline\\Processed",
  "error_folder": "F:\\status\\builds\\results_offline\\Error",
  "unrecoverable_error_folder": "F:\\status\\builds\\results_offline\\Unrecoverable",
  "log_file": "F:\\status\\builds\\Logs\\result_loader.log",
  "log_level": "Info",
  "scan_interval_seconds": 30,
  "max_api_retries": 3,
  "retry_delay_seconds": 5,
  "api_timeout_sec": 60
}
==== END FILE: F:\status\source\powershell\result_loader\config.json ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\README.md ====

---

### 2. README для Загрузчика Результатов

**Файл:** `powershell/result_loader/README.md` (Обновленный)

```markdown
# PowerShell Загрузчик Результатов (result_loader) v4.2

Этот скрипт (`result_loader.ps1`) предназначен для обработки файлов с результатами мониторинга (`*.zrpu`), сгенерированных **Гибридным Агентом** в **Offline режиме**, и загрузки этих данных в центральное API системы Status Monitor v5.2+.

## Назначение

*   Периодически сканировать указанную папку (`check_folder`) на наличие файлов результатов (`*.zrpu`).
*   Читать содержимое каждого файла `.zrpu`.
*   Извлекать метаданные (`agent_script_version`, `assignment_config_version`, `object_id`) и массив `results`.
*   Для **каждой** записи результата проверки из массива `results` формировать объект для API, **добавляя метаданные файла**.
*   Отправлять **весь пакет** результатов из одного файла **одним POST-запросом** на унифицированный эндпоинт `/api/v1/checks` центрального API.
*   После обработки файла API, отправить событие `FILE_PROCESSED` на эндпоинт `/api/v1/events` для логирования факта и статуса обработки файла.
*   **Атомарно** перемещать обработанный файл в соответствующую подпапку (`Processed`, `Error`, `Unrecoverable`).

## Принцип работы

1.  Транспортная Система доставляет файлы результатов (`*.zrpu`) от Гибридных Агентов (Offline режим) в папку, указанную как `check_folder` в `config.json` загрузчика.
2.  Скрипт `result_loader.ps1` запускается (например, через Планировщик Задач) на машине, имеющей доступ к `check_folder` и центральному API.
3.  Читает параметры из своего файла `config.json`.
4.  В бесконечном цикле (с интервалом `scan_interval_seconds`):
    *   Сканирует папку `check_folder` на наличие файлов `*.zrpu`.
    *   Для каждого найденного файла:
        *   Пытается прочитать и распарсить его как JSON. **При ошибке** - логирует и перемещает файл в **`error_folder`**.
        *   Извлекает метаданные и массив `results`. Валидирует базовую структуру. **При ошибке** - логирует и перемещает файл в **`error_folder`**.
        *   Формирует **массив** объектов (`$payloadArray`) для отправки на `POST /checks`, добавляя метаданные файла в каждый элемент.
        *   Если `$payloadArray` не пуст, отправляет его **одним POST-запросом** на `/api/v1/checks`, используя функцию `Invoke-ApiRequestWithRetry`.
        *   Анализирует ответ API (ожидается 200 OK или 207 Multi-Status). Определяет статус обработки (`success`, `error_api`).
        *   Формирует тело события `FILE_PROCESSED` с информацией об обработке (включая количество ошибок API, если были).
        *   Отправляет событие в API `/api/v1/events`. Обрабатывает возможные ошибки отправки события.
        *   **Атомарно перемещает файл:**
            *   В `processed_folder` - если API вернул 200 OK (или 207 без ошибок *для этого файла*) И событие успешно отправлено.
            *   В **`unrecoverable_error_folder` (DLQ)** - если API вернул ошибку (любой статус, кроме 200/207) ИЛИ вернул 207 с ошибками ИЛИ не удалось отправить событие `FILE_PROCESSED`. Эти файлы требуют ручного анализа.
            *   В `error_folder` - если произошла ошибка чтения/парсинга файла (до отправки в API).
        *   Логирует результат обработки файла.
    *   Ожидает интервал `scan_interval_seconds` перед следующим сканированием.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `result_loader.ps1`.

```json
{
    "api_base_url": "http://localhost:48030/api", // ОБЯЗАТЕЛЬНО
    "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_LOADER",     // ОБЯЗАТЕЛЬНО
    "check_folder": "C:/StatusMonitor/IncomingResults", // ОБЯЗАТЕЛЬНО - Откуда брать .zrpu
    "processed_folder": "C:/StatusMonitor/Processed",    // ОБЯЗАТЕЛЬНО - Куда перемещать успешно обработанные
    "error_folder": "C:/StatusMonitor/Error",            // ОБЯЗАТЕЛЬНО - Куда перемещать при ошибках чтения/парсинга
    "unrecoverable_error_folder": "C:/StatusMonitor/Unrecoverable", // ОБЯЗАТЕЛЬНО - Куда перемещать при ошибках API/событий (DLQ)
    "log_file": "C:/Logs/StatusMonitor/result_loader.log", // ОБЯЗАТЕЛЬНО
    "log_level": "Info", // "Debug", "Verbose", "Info", "Warn", "Error" - ОБЯЗАТЕЛЬНО
    "scan_interval_seconds": 30, // Опционально (default: 30)
    "api_timeout_sec": 60,       // Опционально (default: 60)
    "max_api_retries": 3,        // Опционально (default: 3)
    "retry_delay_seconds": 5     // Опционально (default: 5)
}


Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Сеть: Требуется сетевой доступ с машины загрузчика к api_base_url.

    Доступ к Файлам: Требуются права на чтение, запись и удаление файлов в check_folder и ее подпапках Processed, Error, Unrecoverable.

    Права: Скрипту нужны права на запись в log_file.

    API Ключ: Убедитесь, что API ключ имеет роль loader.

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows для обеспечения непрерывной работы.

Замечания

    Скрипт ожидает, что файлы *.zrpu имеют корректную JSON-структуру, созданную hybrid-agent.ps1 (v7.0+).

    Файлы, вызвавшие ошибки при взаимодействии с API (например, из-за невалидных assignment_id внутри), будут перемещены в папку unrecoverable_error_folder для последующего анализа.
==== END FILE: F:\status\source\powershell\result_loader\README.md ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\result_loader.ps1 ====
# powershell/result_loader/result_loader.ps1
# --- Загрузчик Результатов v4.2 ---
# Изменения:
# - Удалена опция и логика use_bulk_api.
# - Всегда отправляет массив результатов на POST /api/v1/checks.
# - Добавлена папка unrecoverable_error_folder (DLQ) для ошибок API.
# - Улучшено атомарное перемещение файлов.
# - Убрана зависимость от PowerShell v5.1 (он и так был совместим).

<#
.SYNOPSIS
    Обрабатывает файлы *.zrpu от оффлайн-агентов и отправляет данные
    массивом на унифицированный API эндпоинт /api/v1/checks (v4.2).
.DESCRIPTION
    Скрипт-загрузчик результатов оффлайн мониторинга.
    1. Читает конфигурацию из 'config.json'.
    2. Циклически сканирует `check_folder` на наличие *.zrpu файлов.
    3. Для каждого файла:
       - Читает и парсит JSON. При ошибке - перемещает в `error_folder`.
       - Извлекает метаданные и массив 'results'.
       - Формирует payload (массив объектов для API), добавляя метаданные
         из файла в КАЖДЫЙ элемент массива.
       - Отправляет ВЕСЬ payload ОДНИМ запросом на `POST /api/v1/checks`.
       - Обрабатывает ответ API (200/207).
       - Отправляет событие `FILE_PROCESSED` в API.
       - Атомарно перемещает файл:
         - В `processed_folder` при полном успехе.
         - В `unrecoverable_error_folder` при ошибках API (включая 207)
           или ошибке отправки события.
         - В `error_folder` при локальных ошибках (парсинг).
.PARAMETER ConfigFile
    [string] Путь к файлу конфигурации загрузчика (JSON).
    По умолчанию: "$PSScriptRoot\config.json".
.NOTES
    Версия: 4.2
    Дата: [Актуальная Дата]
    Зависимости: PowerShell 5.1+, Сетевой доступ к API, Права доступа к папкам.
#>
param(
    [string]$ConfigFile = "$PSScriptRoot\config.json",
    # Параметры для переопределения конфига (можно убрать, если не нужны)
    [string]$apiBaseUrlOverride = $null,
    [string]$apiKeyOverride = $null,
    [string]$checkFolderOverride = $null,
    [string]$logFileOverride = $null,
    [string]$logLevelOverride = $null
)

# --- 1. Глобальные переменные и константы ---
$ScriptVersion = "4.2" # Обновляем версию
$script:Config = $null
$script:EffectiveLogLevel = "Info"
$script:LogFilePath = $null
$script:ComputerName = $env:COMPUTERNAME
$DefaultLogLevel = "Info"; $DefaultScanInterval = 30; $DefaultApiTimeout = 30; $DefaultMaxRetries = 3; $DefaultRetryDelay = 5;
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error");
$script:EffectiveApiKey = $null

# --- 2. Функции ---

#region Функции

<#
.SYNOPSIS Пишет сообщение в лог и/или консоль. (Код без изменений от Hybrid)
#>
function Write-Log {
    param( [Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)][string]$Level = "Info" )
    $logLevels=@{"Debug"=4;"Verbose"=3;"Info"=2;"Warn"=1;"Error"=0}; $currentLevelValue=$logLevels[$script:EffectiveLogLevel]; if($null -eq $currentLevelValue){ $currentLevelValue = $logLevels["Info"] }; $messageLevelValue=$logLevels[$Level]; if($null -eq $messageLevelValue){ $messageLevelValue = $logLevels["Info"] };
    if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] [$($script:ComputerName)] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; if ($script:LogFilePath) { try { $logDir = Split-Path $script:LogFilePath -Parent; if ($logDir -and (-not(Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки логов: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null }; Add-Content -Path $script:LogFilePath -Value $logMessage -Encoding UTF8 -Force -EA Stop } catch { Write-Host ("[Error] Не удалось записать в лог '{0}': {1}" -f $script:LogFilePath, $_.Exception.Message) -ForegroundColor Red } } }
}

<#
.SYNOPSIS Возвращает значение по умолчанию, если исходное пустое. (Код без изменений от Hybrid)
#>
filter Get-OrElse {
    param([object]$DefaultValue)
    if ($null -ne $_ -and (($_ -isnot [string]) -or (-not [string]::IsNullOrWhiteSpace($_)))) { $_ } else { $DefaultValue }
}

<#
.SYNOPSIS Выполняет HTTP-запрос к API с логикой повторных попыток. (Код без изменений от Hybrid)
#>
function Invoke-ApiRequestWithRetry {
    param(
        [Parameter(Mandatory=$true)][string]$Uri,
        [Parameter(Mandatory=$true)][string]$Method,
        [Parameter(Mandatory=$false)]$BodyObject = $null,
        [Parameter(Mandatory=$true)][hashtable]$Headers,
        [Parameter(Mandatory=$true)][string]$Description
    )
    $retryCount=0; $responseObject=$null; $maxRetries=$script:Config.max_api_retries | Get-OrElse 3; $timeoutSec=$script:Config.api_timeout_sec | Get-OrElse 60; $retryDelaySec=$script:Config.retry_delay_seconds | Get-OrElse 5;
    $invokeParams=@{Uri=$Uri; Method=$Method; Headers=$Headers; TimeoutSec=$timeoutSec; ErrorAction='Stop'}; if($BodyObject -ne $null -and $Method.ToUpper() -notin @('GET','DELETE')){ try{ $jsonBody = $BodyObject | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue; $invokeParams.ContentType = 'application/json; charset=utf-8'; $invokeParams.Body = [System.Text.Encoding]::UTF8.GetBytes($jsonBody); Write-Log "Тело запроса для ($Description): $jsonBody" -Level Debug } catch { Write-Log "Критическая ошибка ConvertTo-Json для ($Description): $($_.Exception.Message)" -Level Error; throw "Ошибка преобразования тела запроса в JSON." } }
    while($retryCount -lt $maxRetries -and $responseObject -eq $null){ try{ Write-Log ("Выполнение запроса ({0}) (Попытка {1}/{2}): {3} {4}" -f $Description,($retryCount+1),$maxRetries,$Method,$Uri) -Level Verbose; $responseObject = Invoke-RestMethod @invokeParams; Write-Log ("Успешный ответ API ({0})." -f $Description) -Level Verbose; return $responseObject } catch [System.Net.WebException]{ $retryCount++; $exception=$_.Exception; $statusCode=$null; $errorResponseBody="[Не удалось прочитать тело ошибки]"; if($exception.Response -ne $null){ try{ $statusCode = [int]$exception.Response.StatusCode } catch {}; try{ $errorStream = $exception.Response.GetResponseStream(); $reader=New-Object System.IO.StreamReader($errorStream); $errorResponseBody = $reader.ReadToEnd(); $reader.Close(); $errorStream.Dispose(); try{ $errorJson=$errorResponseBody|ConvertFrom-Json; $errorResponseBody=$errorJson }catch{} }catch{} }; $errorMessage=$exception.Message.Replace('{','{{').Replace('}','}}'); $errorDetails=$errorResponseBody; Write-Log ("Ошибка API ({0}) (Попытка {1}/{2}). Код: {3}. Error: {4}. Ответ: {5}" -f $Description,$retryCount,$maxRetries,($statusCode|Get-OrElse 'N/A'),$errorMessage,($errorDetails|Out-String -Width 300)) -Level Error; if($statusCode -in @(400,401,403,404,409,422)){ Write-Log ("Критическая ошибка API ({0} - Код {1}), повторные попытки отменены." -f $Description,$statusCode) -Level Error; throw $exception }; if($retryCount -ge $maxRetries){ Write-Log ("Превышено кол-во попыток ({0}) для ({1})." -f $maxRetries,$Description) -Level Error; throw $exception }; Write-Log ("Пауза $retryDelaySec сек перед повторной попыткой...") -Level Warn; Start-Sleep -Seconds $retryDelaySec } catch { $retryCount++; $errorMessage=$_.Exception.Message.Replace('{','{{').Replace('}','}}'); Write-Log ("Неожиданная ошибка ({0}) (Попытка {1}/{2}): {3}" -f $Description,$retryCount,$maxRetries,$errorMessage) -Level Error; throw $_.Exception } }; return $null
}

#endregion Функции

# --- 3. Основная логика ---

# 3.1 Чтение и валидация конфигурации
Write-Host "Запуск Загрузчика Результатов PowerShell v$ScriptVersion"
Write-Log "Чтение конфигурации..." "Info"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Log "Критическая ошибка: Файл конфигурации '$ConfigFile' не найден." -Level Error; exit 1 }
try { $script:Config = Get-Content $ConfigFile -Raw -Enc UTF8 | ConvertFrom-Json -EA Stop } catch { Write-Log "Критическая ошибка: Ошибка чтения/парсинга JSON из '$ConfigFile': $($_.Exception.Message)" -Level Error; exit 1 }

# Переопределение из параметров командной строки (если нужно)
$effectiveConfig = $script:Config.PSObject.Copy() # Копируем для изменений
if ($apiBaseUrlOverride) { $effectiveConfig.api_base_url = $apiBaseUrlOverride }
if ($apiKeyOverride) { $effectiveConfig.api_key = $apiKeyOverride }
if ($checkFolderOverride) { $effectiveConfig.check_folder = $checkFolderOverride }
if ($logFileOverride) { $effectiveConfig.log_file = $logFileOverride }
if ($logLevelOverride) { $effectiveConfig.log_level = $logLevelOverride }
$script:Config = [PSCustomObject]$effectiveConfig # Обновляем глобальный конфиг

# Валидация ОБЯЗАТЕЛЬНЫХ полей (убрали use_bulk_api)
$requiredFields = @(
    "api_base_url", "api_key", "check_folder", "log_file", "log_level",
    "processed_folder", "error_folder", "unrecoverable_error_folder", # Добавили папки
    "scan_interval_seconds", "max_api_retries", "retry_delay_seconds"
)
$missingFields = $requiredFields | Where-Object { -not ($script:Config.PSObject.Properties.Name -contains $_) -or $null -eq $script:Config.$_ -or (($script:Config.$_ -is [string]) -and ([string]::IsNullOrWhiteSpace($script:Config.$_))) }
if ($missingFields) { Write-Log ("Критическая ошибка: В конфигурации отсутствуют или пусты обязательные поля: $($missingFields -join ', ')") -Level Error; exit 1 }

# Установка лог-файла и уровня
$script:LogFilePath = $script:Config.log_file
$script:EffectiveLogLevel = $script:Config.log_level
if ($script:EffectiveLogLevel -notin $ValidLogLevels) { Write-Log "..." "Warn"; $script:EffectiveLogLevel = $DefaultLogLevel }
$script:EffectiveApiKey = $script:Config.api_key

# Проверка и создание папок
$checkFolder = $script:Config.check_folder
$processedFolder = $script:Config.processed_folder
$errorFolder = $script:Config.error_folder
$unrecoverableFolder = $script:Config.unrecoverable_error_folder # DLQ
$foldersToCheck = @($checkFolder, $processedFolder, $errorFolder, $unrecoverableFolder)
foreach ($folder in $foldersToCheck) {
     if (-not (Test-Path $folder -PathType Container)) {
         Write-Log "Папка '$folder' не найдена. Попытка создать..." -Level Warn
         try { New-Item -Path $folder -ItemType Directory -Force -EA Stop | Out-Null; Write-Log "Папка '$folder' создана." -Level Info }
         catch { Write-Log "Критическая ошибка: Не удалось создать папку '$folder': $($_.Exception.Message)" -Level Error; exit 1 }
     }
}

# Получение интервалов/попыток
$scanInterval = 30; if($script:Config.scan_interval_seconds -and [int]::TryParse($script:Config.scan_interval_seconds,[ref]$null) -and $script:Config.scan_interval_seconds -ge 5){ $scanInterval = $script:Config.scan_interval_seconds } else { Write-Log "..." "Warn" }

Write-Log "Инициализация загрузчика v$ScriptVersion завершена." -Level Info
Write-Log ("Параметры: API='{0}', Папка='{1}', Интервал={2} сек, Лог='{3}', Уровень='{4}'" `
    -f $script:Config.api_base_url, $checkFolder, $scanInterval, $script:LogFilePath, $script:EffectiveLogLevel) -Level Info

# --- 4. Основной цикл сканирования и обработки ---
Write-Log "Начало цикла сканирования папки '$checkFolder'..." -Level Info
while ($true) {
    Write-Log "Сканирование папки..." -Level Verbose
    $filesToProcess = @()
    try {
        # Маска файла теперь может быть разной, используем *.zrpu
        $resultsFileFilter = "*.zrpu"
        $filesToProcess = Get-ChildItem -Path $checkFolder -Filter $resultsFileFilter -File -ErrorAction Stop
    } catch {
        # Ошибка доступа к папке - критично, но пробуем дальше
        Write-Log ("Критическая ошибка доступа к папке '$checkFolder': $($_.Exception.Message). Пропуск итерации.") -Level Error
        Start-Sleep -Seconds $scanInterval; continue # Ждем и повторяем
    }

    if ($filesToProcess.Count -eq 0) {
        Write-Log "Нет файлов *.zrpu для обработки." -Level Verbose
    } else {
        Write-Log "Найдено файлов для обработки: $($filesToProcess.Count)." -Level Info

        # --- Обработка каждого файла ---
        foreach ($file in $filesToProcess) {
            $fileStartTime = [DateTimeOffset]::UtcNow
            Write-Log "--- Начало обработки файла: '$($file.FullName)' ---" -Level Info
            $fileProcessingStatus = "unknown" # Статусы: unknown, success, partial_error, error_local, error_api, error_event
            $fileProcessingMessage = ""
            $fileEventDetails = @{} # Детали для события FILE_PROCESSED
            $apiResponse = $null # Ответ от API /checks
            $payloadArray = $null # Массив результатов для отправки
            $totalRecordsInFile = 0 # Общее кол-во записей в файле
            $fileAgentVersion = "[неизвестно]"; $fileAssignmentVersion = "[неизвестно]"

            # Блок try/catch для ЛОКАЛЬНЫХ ошибок (чтение, парсинг)
            try {
                # --- Чтение и парсинг файла ---
                Write-Log "Чтение файла '$($file.Name)'..." -Level Debug
                $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
                $fileContentClean = $fileContent.TrimStart([char]0xFEFF)
                $payloadFromFile = $fileContentClean | ConvertFrom-Json -ErrorAction Stop
                Write-Log "Файл '$($file.Name)' успешно прочитан и распарсен." -Level Debug

                # --- Валидация структуры файла ---
                if ($null -eq $payloadFromFile `
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('results')) `
                    -or ($payloadFromFile.results -isnot [array]) `
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('agent_script_version')) `
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('assignment_config_version'))
                    -or (-not $payloadFromFile.PSObject.Properties.Name.Contains('object_id')) ) {
                    throw "Некорректная структура JSON файла '$($file.Name)'. Отсутствуют обязательные поля (results, agent_script_version, assignment_config_version, object_id)."
                }

                # Извлекаем метаданные
                $resultsArray = $payloadFromFile.results
                $fileAgentVersion = $payloadFromFile.agent_script_version | Get-OrElse "[не указана]"
                $fileAssignmentVersion = $payloadFromFile.assignment_config_version | Get-OrElse "[не указана]"
                $fileObjectId = $payloadFromFile.object_id # ID объекта, СГЕНЕРИРОВАВШЕГО файл

                $totalRecordsInFile = $resultsArray.Count
                Write-Log ("Файл '{0}' содержит записей: {1}. AgentVer: '{2}', ConfigVer: '{3}', SourceOID: {4}" `
                    -f $file.Name, $totalRecordsInFile, $fileAgentVersion, $fileAssignmentVersion, $fileObjectId) -Level Info

                # --- Формирование payload для API /checks ---
                if ($totalRecordsInFile -gt 0) {
                    $payloadArray = [System.Collections.Generic.List[object]]::new()
                    $skippedCount = 0
                    foreach ($res in $resultsArray) {
                         # Базовая валидация элемента result
                         if ($res -ne $null -and $res -is [hashtable] `
                             -and $res.ContainsKey('assignment_id') -and $res.assignment_id -ne $null `
                             -and $res.ContainsKey('IsAvailable') -and $res.IsAvailable -ne $null `
                             -and $res.ContainsKey('Timestamp') -and $res.Timestamp -ne $null)
                         {
                             # Формируем объект для API
                             $payloadItem = @{
                                 assignment_id        = $res.assignment_id
                                 is_available         = $res.IsAvailable
                                 check_timestamp      = $res.Timestamp
                                 details              = $res.Details # Передаем как есть
                                 # Добавляем метаданные из файла В КАЖДЫЙ результат
                                 agent_script_version = $fileAgentVersion
                                 assignment_config_version = $fileAssignmentVersion
                                 executor_object_id   = $fileObjectId # OID агента, сделавшего проверку
                                 executor_host        = $null # Оффлайн агент не пишет имя хоста в zrpu
                                 resolution_method    = 'offline_loader'
                             }
                             # Включаем CheckSuccess и ErrorMessage в details, если они есть
                             if ($res.ContainsKey('CheckSuccess') -and $res.CheckSuccess -ne $null) {
                                if ($payloadItem.details -eq $null) { $payloadItem.details = @{} }
                                $payloadItem.details.CheckSuccess = $res.CheckSuccess
                             }
                             if (-not [string]::IsNullOrEmpty($res.ErrorMessage)) {
                                if ($payloadItem.details -eq $null) { $payloadItem.details = @{} }
                                $payloadItem.details.ErrorMessageFromCheck = $res.ErrorMessage
                             }
                             $payloadArray.Add($payloadItem)
                         } else {
                            $skippedCount++
                             Write-Log ("Пропущен некорректный элемент в файле '{0}': отсутствует assignment_id, IsAvailable или Timestamp. Данные: {1}" `
                                         -f $file.Name, ($res | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue)) -Level Warn
                         }
                    } # End foreach ($res in $resultsArray)

                    if ($skippedCount -gt 0) {
                        $fileProcessingMessage = " Записей в файле: $totalRecordsInFile. Пропущено из-за ошибок формата: $skippedCount."
                        # Устанавливаем статус как частичная ошибка, т.к. не все данные будут отправлены
                        $fileProcessingStatus = "partial_error"
                        $fileEventDetails.skipped_format_error = $skippedCount
                    }
                    if ($payloadArray.Count -eq 0 -and $totalRecordsInFile -gt 0) {
                        # Все записи были пропущены
                         throw "Все записи в файле '$($file.Name)' некорректны."
                    } elseif ($payloadArray.Count -eq 0 -and $totalRecordsInFile -eq 0) {
                         # Изначально не было записей
                         $fileProcessingStatus = "success_empty"
                         $fileProcessingMessage = "Обработка файла завершена (пустой массив results)."
                         $fileEventDetails = @{ total_records_in_file = 0; agent_version_in_file = $fileAgentVersion; assignment_version_in_file = $fileAssignmentVersion }
                    }
                } else { # totalRecordsInFile == 0
                    $fileProcessingStatus = "success_empty"
                    $fileProcessingMessage = "Обработка файла завершена (пустой массив results)."
                    $fileEventDetails = @{ total_records_in_file = 0; agent_version_in_file = $fileAgentVersion; assignment_version_in_file = $fileAssignmentVersion }
                }

                # --- Отправка запроса в API (если есть что отправлять) ---
                if ($payloadArray -ne $null -and $payloadArray.Count -gt 0) {
                    $apiUrlChecks = "$($script:Config.api_base_url.TrimEnd('/'))/v1/checks"
                    $headersForChecks = @{ 'X-API-Key' = $script:EffectiveApiKey } # Content-Type добавится в Invoke-ApiRequestWithRetry
                    $apiParams = @{
                        Uri = $apiUrlChecks
                        Method = 'Post'
                        BodyObject = $payloadArray # Передаем массив объектов
                        Headers = $headersForChecks
                        Description = "Отправка {0} результатов из файла '{1}'" -f $payloadArray.Count, $file.Name
                    }
                    Write-Log ("Отправка {0} результатов из файла '{1}' на {2}..." -f $payloadArray.Count, $file.Name, $apiUrlChecks) -Level Info

                    # Вызов API с логикой retry
                    $apiResponse = Invoke-ApiRequestWithRetry @apiParams # Может выбросить исключение

                    # Анализ ответа API (если не было исключения)
                    if ($apiResponse -ne $null) {
                        $processedApi = $apiResponse.processed | Get-OrElse 0
                        $failedApi = $apiResponse.failed | Get-OrElse 0
                        $statusApi = $apiResponse.status | Get-OrElse "unknown"
                        $apiErrors = $apiResponse.errors # Может быть $null или массив

                         Write-Log ("Ответ API для файла '{0}': Статус='{1}', Обработано={2}, Ошибки API={3}" `
                                    -f $file.Name, $statusApi, $processedApi, $failedApi) -Level Info
                         if ($apiErrors) { Write-Log "Детали ошибок API: $($apiErrors | ConvertTo-Json -Depth 3 -Compress -WarningAction SilentlyContinue)" -Level Warn }

                        # Определяем итоговый статус файла на основе ответа API
                        if ($statusApi -eq "success" -and $failedApi -eq 0) {
                            $fileProcessingStatus = "success"
                            $fileProcessingMessage += " Успешно обработано API: $processedApi."
                        } else { # partial_error или error от API
                            $fileProcessingStatus = "error_api" # Любая ошибка от API - файл в DLQ
                            $fileProcessingMessage += " Обработано API: $processedApi, Ошибки API: $failedApi."
                            $fileEventDetails.api_status = $statusApi
                            $fileEventDetails.api_processed = $processedApi
                            $fileEventDetails.api_failed = $failedApi
                            if ($apiErrors) { $fileEventDetails.api_errors = $apiErrors }
                        }
                    } else {
                        # Если Invoke-ApiRequestWithRetry вернул $null (все попытки неудачны)
                         $fileProcessingStatus = "error_api" # Ошибка API, файл в DLQ
                         $fileProcessingMessage += " Ошибка отправки в API после всех попыток."
                         $fileEventDetails.error = "API request failed after retries."
                    }
                } # Конец if ($payloadArray -ne $null -and $payloadArray.Count -gt 0)

            # <<< Закрываем локальный try >>>
            } catch {
                # Ошибка чтения/парсинга файла ИЛИ ошибка валидации структуры
                $errorMessage = "Критическая локальная ошибка обработки файла '$($file.FullName)': $($_.Exception.Message)"
                Write-Log $errorMessage -Level Error
                $fileProcessingStatus = "error_local"
                $fileProcessingMessage = "Ошибка чтения, парсинга JSON или валидации структуры файла."
                $fileEventDetails = @{ error = $errorMessage; ErrorRecord = $_.ToString() }
            }
            # --- Конец локального try/catch ---

            # --- Отправка события FILE_PROCESSED (даже если были ошибки) ---
            $fileEndTime = [DateTimeOffset]::UtcNow
            $processingTimeMs = ($fileEndTime - $fileStartTime).TotalSeconds * 1000

            # Определяем Severity для события
            $eventSeverity = "INFO"
            if ($fileProcessingStatus -like "error*") { $eventSeverity = "ERROR" }
            elseif ($fileProcessingStatus -eq "partial_error") { $eventSeverity = "WARN" }

            # Дополняем детали события
            $fileEventDetails.processing_status = $fileProcessingStatus
            $fileEventDetails.processing_time_ms = [math]::Round($processingTimeMs)
            $fileEventDetails.file_name = $file.Name
            # Добавляем метаданные файла в событие
            if ($fileAgentVersion -ne "[неизвестно]") { $fileEventDetails.agent_version_in_file = $fileAgentVersion }
            if ($fileAssignmentVersion -ne "[неизвестно]") { $fileEventDetails.assignment_version_in_file = $fileAssignmentVersion }
            if ($fileObjectId) { $fileEventDetails.source_object_id_in_file = $fileObjectId }
            if ($totalRecordsInFile -gt 0) { $fileEventDetails.total_records_in_file = $totalRecordsInFile }

            $eventBody = @{
                event_type      = "FILE_PROCESSED"
                severity        = $eventSeverity
                message         = $fileProcessingMessage | Get-OrElse ("Обработка файла '{0}' завершена со статусом '{1}'." -f $file.Name, $fileProcessingStatus)
                source          = "result_loader.ps1 (v$ScriptVersion)"
                related_entity  = "ZRPU_FILE" # Указываем тип сущности
                related_entity_id = $file.Name
                details         = $fileEventDetails
            }
            $eventApiResponse = $null
            try {
                 $eventApiUrl = "$($script:Config.api_base_url.TrimEnd('/'))/v1/events"
                 $eventHeaders = @{ 'X-API-Key' = $script:EffectiveApiKey }
                 $eventApiParams = @{ Uri=$eventApiUrl; Method='Post'; BodyObject=$eventBody; Headers=$eventHeaders; Description="Отправка события FILE_PROCESSED для '$($file.Name)'"}
                 Write-Log ("Отправка события FILE_PROCESSED для '{0}' (Статус файла: {1})..." -f $file.Name, $fileProcessingStatus) -Level Info
                 $eventApiResponse = Invoke-ApiRequestWithRetry @eventApiParams # Отправляем событие
                 if ($eventApiResponse -eq $null) { throw "Не удалось отправить событие после всех попыток." }
                 Write-Log ("Событие FILE_PROCESSED для '{0}' успешно отправлено (EventID: {1})." -f $file.Name, ($eventApiResponse.event_id | Get-OrElse '?')) -Level Info
            } catch {
                # Ошибка отправки события - это ухудшает статус файла до error_event
                 Write-Log ("Критическая ошибка отправки события FILE_PROCESSED для '{0}': {1}" -f $file.Name, $_.Exception.Message) -Level Error
                 # Если до этого была ошибка API, она важнее
                 if ($fileProcessingStatus -ne "error_api") { $fileProcessingStatus = "error_event" }
            }

            # --- Атомарное перемещение файла ---
            # Определяем целевую папку
            $destinationFolder = $null
            switch ($fileProcessingStatus) {
                "success"           { $destinationFolder = $processedFolder }
                "success_empty"     { $destinationFolder = $processedFolder }
                "error_local"       { $destinationFolder = $errorFolder }
                "error_api"         { $destinationFolder = $unrecoverableFolder } # Ошибки API -> в DLQ
                "partial_error"     { $destinationFolder = $unrecoverableFolder } # Частичные ошибки API -> тоже в DLQ
                "error_event"       { $destinationFolder = $unrecoverableFolder } # Ошибка события -> в DLQ
                default             { $destinationFolder = $errorFolder } # Неизвестный статус -> в Error
            }

            $destinationPath = Join-Path $destinationFolder $file.Name
            # Используем временный файл при перемещении на ДРУГОЙ том (если папки на разных дисках)
            # Но т.к. папки рядом, скорее всего, том один, и Move-Item атомарен.
            # Для надежности можно всегда копировать во временный, потом удалять исходный.
            # Но пока используем Move-Item.
            Write-Log ("Перемещение файла '{0}' в '{1}' (Итоговый статус: {2})..." `
                        -f $file.Name, $destinationFolder, $fileProcessingStatus) -Level Info
            try {
                Move-Item -Path $file.FullName -Destination $destinationPath -Force -ErrorAction Stop
                Write-Log ("Файл '{0}' успешно перемещен." -f $file.Name) -Level Info
            } catch {
                 # Если перемещение не удалось - это ОЧЕНЬ ПЛОХО, т.к. файл обработается снова
                 Write-Log ("КРИТИЧЕСКАЯ ОШИБКА перемещения файла '{0}' в '{1}'. ФАЙЛ МОЖЕТ БЫТЬ ОБРАБОТАН ПОВТОРНО! Ошибка: {2}" `
                            -f $file.Name, $destinationPath, $_.Exception.Message) -Level Error
                 # Здесь можно попытаться переименовать файл на месте с добавлением .failed_to_move
            }

            Write-Log "--- Завершение обработки файла: '$($file.FullName)' ---" -Level Info

        } # Конец foreach ($file in $filesToProcess)
    } # Конец else ($filesToProcess.Count -eq 0)

    # --- Пауза перед следующим сканированием ---
    Write-Log "Пауза $scanInterval сек перед следующим сканированием..." -Level Verbose
    Start-Sleep -Seconds $scanInterval

} # --- Конец while ($true) ---

Write-Log "Загрузчик результатов завершил работу непредвиденно (выход из цикла while)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\result_loader\result_loader.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 ====
# ManualTest-Check-CERT_EXPIRY.ps1 (v2.1)
# Скрипт для ручного тестирования Check-CERT_EXPIRY.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseCertAssignment = @{
    assignment_id = 500; method_name = 'CERT_EXPIRY'; node_name = 'Cert Test'; ip_address = $null
    parameters = @{}; success_criteria = $null
}

# --- !!! ВАЖНО: Замените на реальный отпечаток для тестов !!! ---
$existingThumbprint = 'YOUR_CERT_THUMBPRINT_HERE' # Найдите отпечаток в certlm.msc -> Личное -> Сертификаты

$testCases = @(
    @{ Name = "Все SSL серт. сервера (>14 дней)";
       Params = @{ eku_oid = @('1.3.6.1.5.5.7.3.1'); require_private_key = $true; min_days_warning = 30 };
       # Критерий: Для ВСЕХ сертификатов в результате, поле days_left > 14
       Criteria = @{ certificates=@{_condition_='all';_criteria_=@{days_left=@{'>'=14}}} } }
    @{ Name = "Конкретный отпечаток (>60 дней)";
       Params = @{ thumbprint = $existingThumbprint };
       # Критерий: Для ВСЕХ сертификатов, где thumbprint совпадает, поле days_left > 60
       Criteria = @{ certificates=@{_condition_='all';_where_=@{thumbprint=$existingThumbprint};_criteria_=@{days_left=@{'>'=60}}} } }
    @{ Name = "Конкретный отпечаток (Fail < 10000 дней)";
       Params = @{ thumbprint = $existingThumbprint };
       # Критерий: Для ВСЕХ сертификатов, где thumbprint совпадает, поле days_left < 10000 (должен НЕ пройти)
       Criteria = @{ certificates=@{_condition_='all';_where_=@{thumbprint=$existingThumbprint};_criteria_=@{days_left=@{'<'=10000}}} } }
    @{ Name = "Сертификаты от Let's Encrypt (>0 дней)";
       Params = @{ issuer_like = "*Let's Encrypt*" };
       # Критерий: Для ВСЕХ сертификатов от LE, поле days_left > 0
       Criteria = @{ certificates=@{_condition_='all';_where_=@{issuer=@{'contains'="Let's Encrypt"}};_criteria_=@{days_left=@{'>'=0}}} } } # Используем contains
    @{ Name = "Хотя бы один сертификат истекает менее чем через 90 дней (ANY)";
       Params = @{ require_private_key = $true };
       # Критерий: Найти ХОТЯ БЫ ОДИН сертификат, где days_left < 90
       Criteria = @{ certificates=@{_condition_='any';_criteria_=@{days_left=@{'<'=90}}} } }
    @{ Name = "Ошибка: Неверное хранилище";
       Params = @{ store_location = 'InvalidPlace'; store_name = 'My' }; Criteria = $null }
    @{ Name = "Ошибка: Неверный OID";
       Params = @{ eku_oid = @('invalid-oid') }; Criteria = $null }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений, но с проверкой плейсхолдера)
$testIdCounter = $baseCertAssignment.assignment_id
foreach ($testCase in $testCases) {
    if (($testCase.Params.thumbprint -eq 'YOUR_CERT_THUMBPRINT_HERE') -or ($testCase.Criteria -and $testCase.Criteria.certificates -and $testCase.Criteria.certificates._where_ -and $testCase.Criteria.certificates._where_.thumbprint -eq 'YOUR_CERT_THUMBPRINT_HERE')) { Write-Warning "...Пропуск..."; Write-Host ("-"*50); continue }
    $testIdCounter++; $currentAssignment = $baseCertAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 3 -Compress)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"
    $detailsCopy = $result.Details.PSObject.Copy(); if ($detailsCopy.certificates -is [System.Collections.Generic.List[object]] -and $detailsCopy.certificates.Count -gt 3) { $detailsCopy.certificates = $detailsCopy.certificates | Select-Object -First 3; $detailsCopy.Add('certificates_truncated', $true) }
    $resultOutput = $result.PSObject.Copy(); $resultOutput.Details = $detailsCopy
    Write-Host ($resultOutput | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Milliseconds 500
}
Write-Host "Ручное тестирование CERT_EXPIRY завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 ====
# ManualTest-Check-DISK_USAGE.ps1 (v2.1)
# Скрипт для ручного тестирования Check-DISK_USAGE.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseDiskAssignment = @{
    assignment_id = 300; method_name = 'DISK_USAGE'; node_name = 'Disk Test'; ip_address = $null
    parameters = $null; success_criteria = $null
}

# *** ВАЖНО: Результаты зависят от состояния дисков на машине, где запускается тест! ***
$testCases = @(
    @{ Name = "Все диски (без критериев)"; Params = $null; Criteria = $null }
    @{ Name = "Только диск C: (без критериев)"; Params = @{ drives = @('C') }; Criteria = $null }
    @{ Name = "Диск C: > 5% свободно (OK?)"; Params = @{ drives = @('C') };
       # Критерий: Для массива 'disks', где drive_letter='C', поле percent_free должно быть >= 5
       Criteria = @{ disks=@{_condition_='all'; _where_=@{drive_letter='C'}; _criteria_=@{percent_free=@{'>='=5}}} } }
    @{ Name = "Диск C: > 99% свободно (FAIL?)"; Params = @{ drives = @('C') };
       # Критерий: Для C: % свободно > 99 (скорее всего не пройдет)
       Criteria = @{ disks=@{_condition_='all'; _where_=@{drive_letter='C'}; _criteria_=@{percent_free=@{'>'=99}}} } }
    @{ Name = "Все диски: > 1% свободно (OK?)"; Params = $null;
       # Критерий: Для ВСЕХ дисков в массиве 'disks', % свободно > 1
       Criteria = @{ disks=@{_condition_='all'; _criteria_=@{percent_free=@{'>'=1}}} } }
    @{ Name = "Хотя бы один диск < 10% свободно (ANY + <)"; Params = $null;
        # Критерий: Найти ХОТЯ БЫ ОДИН диск, где % свободно < 10
       Criteria = @{ disks=@{_condition_='any'; _criteria_=@{percent_free=@{'<'=10}}} } }
    @{ Name = "Все диски > 0 байт свободно"; Params = $null;
       # Критерий: Проверить, что у всех free_bytes > 0
       Criteria = @{ disks=@{_condition_='all'; _criteria_=@{free_bytes=@{'>'=1}}} } } # Используем >=1, т.к. 0 может быть валидным
    @{ Name = "Ошибка: Некорректный оператор в критерии"; Params = @{drives=@('C')};
       Criteria = @{ disks=@{_condition_='all'; _where_=@{drive_letter='C'}; _criteria_=@{percent_free=@{'bad_op'=10}}} } }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений)
$testIdCounter = $baseDiskAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++; $currentAssignment = $baseDiskAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 2 -Compress)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Seconds 1
}
Write-Host "Ручное тестирование DISK_USAGE завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 ====
# ManualTest-Check-PING.ps1 (v2.1)
# Скрипт для ручного тестирования Check-PING.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try {
    $modulePath = Join-Path -Path $PSScriptRoot -ChildPath "StatusMonitorAgentUtils.psd1"
    Write-Host "Загрузка модуля из '$modulePath'..." -ForegroundColor Cyan
    Import-Module $modulePath -Force
    Write-Host "Модуль загружен." -ForegroundColor Green
} catch { Write-Error "Критическая ошибка загрузки модуля Utils: $($_.Exception.Message)"; exit 1 } finally { $ErrorActionPreference = "Continue" }
Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$basePingAssignment = @{
    assignment_id = 200; method_name = 'PING'; node_name = 'Ping Test'
    parameters = @{}; success_criteria = $null
}

$testCases = @(
    @{ Name = "Успешный пинг localhost (без критериев)"; Target = '127.0.0.1'; Params = @{ count = 1 } }
    @{ Name = "Неуспешный пинг (несущ. IP)"; Target = '192.0.2.1'; Params = @{ timeout_ms = 500; count = 1 } }
    @{ Name = "Успешный пинг ya.ru (RTT <= 1000ms)"; Target = 'ya.ru';
       # Критерий: RTT должен быть меньше или равен 1000
       Criteria = @{ rtt_ms = @{ '<=' = 1000 } } }
    @{ Name = "Успешный пинг ya.ru (RTT <= 1ms - НЕ пройдет)"; Target = 'ya.ru';
       # Критерий: RTT должен быть меньше или равен 1 (заведомо ложно)
       Criteria = @{ rtt_ms = @{ '<=' = 1 } } }
    @{ Name = "Успешный пинг ya.ru (Потери == 0%)"; Target = 'ya.ru';
       # Критерий: Процент потерь должен быть равен 0
       Criteria = @{ packet_loss_percent = @{ '==' = 0 } } }
    @{ Name = "Успешный пинг ya.ru (Потери < 50% - пройдет)"; Target = 'ya.ru'; Params = @{ count = 4 };
       # Критерий: Процент потерь должен быть меньше 50
       Criteria = @{ packet_loss_percent = @{ '<' = 50 } } }
    @{ Name = "Успешный пинг ya.ru (RTT > 10ms И Потери < 50%)"; Target = 'ya.ru'; Params = @{ count = 4 };
       # Критерий: Оба условия должны выполниться
       Criteria = @{ rtt_ms=@{'>'=10}; packet_loss_percent=@{'<'=50} } }
    @{ Name = "Ошибка: Некорректный критерий (не число)"; Target = 'ya.ru';
       # Критерий: Некорректное значение порога
       Criteria = @{ rtt_ms=@{'>'='abc'} } }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений, как в предыдущем ответе)
$testIdCounter = $basePingAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++
    $currentAssignment = $basePingAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name; $currentAssignment.ip_address = $testCase.Target
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }

    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -ForegroundColor Yellow
    Write-Host "  Target: $($currentAssignment.ip_address)"
    Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 2 -Compress)"
    Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 3 -Compress)"

    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 4) -ForegroundColor Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Seconds 1
}
Write-Host "Ручное тестирование PING завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 ====
# ManualTest-Check-PROCESS_LIST.ps1 (v2.1)
# Скрипт для ручного тестирования Check-PROCESS_LIST.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseProcessAssignment = @{
    assignment_id = 400; method_name = 'PROCESS_LIST'; node_name = 'Process Test'; ip_address = $null
    parameters = @{}; success_criteria = $null
}

# *** Результаты зависят от запущенных процессов на машине теста! ***
$testCases = @(
    @{ Name = "Топ 5 по памяти (без критериев)"; Params = @{ sort_by = 'Memory'; sort_descending = $true; top_n = 5 } }
    @{ Name = "Процессы PowerShell (с деталями)"; Params = @{ process_names = @('*powershell*'); include_username = $true; include_path = $true } }
    @{ Name = "Найти svchost (ожидаем >=1)"; Params = @{ process_names = @('svchost') };
       # Критерий: Количество найденных процессов должно быть >= 1
       Criteria = @{ processes=@{_condition_='count';_count_=@{'>='=1}} } }
    @{ Name = "Найти notepad (ожидаем == 0, если не запущен)"; Params = @{ process_names = @('notepad') };
       # Критерий: Количество найденных == 0
       Criteria = @{ processes=@{_condition_='count';_count_=@{'=='=0}} } }
    @{ Name = "Проверить, что НЕТ процесса 'malware.exe'"; Params = $null;
       # Критерий: Ни один процесс не должен соответствовать _where_
       Criteria = @{ processes=@{_condition_='none';_where_=@{name='malware.exe'}} } }
    @{ Name = "Найти хотя бы один процесс с CPU > 10 сек (ANY)"; Params = @{ include_username=$true };
       # Критерий: Хотя бы один процесс (_condition_=any) имеет cpu_seconds > 10
       Criteria = @{ processes=@{_condition_='any';_criteria_=@{cpu_seconds=@{'>'=10.0}}} } }
    @{ Name = "ВСЕ процессы explorer.exe имеют память < 1000 MB (ALL + WHERE)"; Params = $null;
       # Критерий: Все (_condition_=all) процессы, где имя explorer.exe (_where_),
       # должны иметь память < 1000 (_criteria_)
       Criteria = @{ processes=@{_condition_='all'; _where_=@{name='explorer.exe'}; _criteria_=@{memory_ws_mb=@{'<'=1000}}} } }
    @{ Name = "Несуществующий процесс (ожидаем count=0)"; Params = @{ process_names = @('__NoSuchProcess__') };
       Criteria = @{ processes=@{_condition_='count';_count_=@{'=='=0}} } } # Этот критерий должен пройти
    @{ Name = "Ошибка: Неверное поле сортировки"; Params = @{ sort_by = 'InvalidField' } }
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений, но с урезанием вывода Details.processes)
$testIdCounter = $baseProcessAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++; $currentAssignment = $baseProcessAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    if ($testCase.Params) { $currentAssignment.parameters = $testCase.Params }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Parameters: $($currentAssignment.parameters | ConvertTo-Json -Depth 2 -Compress)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"
    $detailsCopy = $result.Details.PSObject.Copy(); if ($detailsCopy.processes -is [System.Collections.Generic.List[object]] -and $detailsCopy.processes.Count -gt 5) { $detailsCopy.processes = $detailsCopy.processes | Select -First 5; $detailsCopy.Add('processes_truncated', $true) }
    $resultOutput = $result.PSObject.Copy(); $resultOutput.Details = $detailsCopy
    Write-Host ($resultOutput | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Milliseconds 500
}
Write-Host "Ручное тестирование PROCESS_LIST завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 ====
# ManualTest-Check-SERVICE_STATUS.ps1 (v2.1)
# Скрипт для ручного тестирования Check-SERVICE_STATUS.ps1 через диспетчер

# --- 1. Загрузка модуля Utils ---
# (Код загрузки модуля без изменений)
$ErrorActionPreference = "Stop"; try { $mp=Join-Path $PSScriptRoot "StatusMonitorAgentUtils.psd1"; Import-Module $mp -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }; Write-Host "..."; Write-Host $('-'*50)

# --- 2. Определение тестовых сценариев ---
$baseServiceAssignment = @{
    assignment_id = 100; method_name = 'SERVICE_STATUS'; node_name = 'Service Test'; ip_address = $null
    parameters = @{}; success_criteria = $null
}

# *** ВАЖНО: Убедитесь, что службы Spooler и wuauserv существуют на машине, где запускается тест! ***
# *** Состояние служб (Running/Stopped) может влиять на результат тестов с критериями. ***
$testCases = @(
    @{ Name = "Spooler - Без критериев (ожидаем CheckSuccess=true если доступна)"; Service = 'Spooler' }
    @{ Name = "Spooler - Критерий: status = Running"; Service = 'Spooler'; Criteria = @{ status = 'Running' } }
    @{ Name = "Spooler - Критерий: status = Stopped (ожидаем FAIL если работает)"; Service = 'Spooler'; Criteria = @{ status = 'Stopped' } }
    @{ Name = "Spooler - Критерий: status != Stopped (ожидаем OK если работает)"; Service = 'Spooler'; Criteria = @{ status = @{'!=' = 'Stopped'} } }
    @{ Name = "Несуществующая служба (ожидаем IsAvailable=false)"; Service = '__NonExistentService__'; Criteria = $null }
    @{ Name = "wuauserv - Критерий: start_type = Manual"; Service = 'wuauserv'; Criteria = @{ start_type = 'Manual' } } # Проверяем тип запуска
    @{ Name = "wuauserv - Критерий: can_stop = true"; Service = 'wuauserv'; Criteria = @{ can_stop = $true } } # Проверяем булево поле
    @{ Name = "Ошибка: Неверный критерий"; Service = 'Spooler'; Criteria = @{ status = @{'invalid_op' = 1} } } # Ожидаем CheckSuccess=null
)

# --- 3. Выполнение тестов ---
# (Код цикла выполнения без изменений)
$testIdCounter = $baseServiceAssignment.assignment_id
foreach ($testCase in $testCases) {
    $testIdCounter++; $currentAssignment = $baseServiceAssignment.PSObject.Copy()
    $currentAssignment.assignment_id = $testIdCounter; $currentAssignment.node_name = $testCase.Name
    $currentAssignment.parameters = @{ service_name = $testCase.Service }
    if ($testCase.Criteria) { $currentAssignment.success_criteria = $testCase.Criteria }
    Write-Host "ЗАПУСК: $($currentAssignment.node_name)" -FG Yellow; Write-Host "  Service: $($currentAssignment.parameters.service_name)"; Write-Host "  SuccessCriteria: $($currentAssignment.success_criteria | ConvertTo-Json -Depth 2 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$currentAssignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 4) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL" -FG Red } else { Write-Host "  Критерии: N/A" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*50); Start-Sleep -Seconds 1
}
Write-Host "Ручное тестирование SERVICE_STATUS завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 ====
# ManualTest-SQL-Checks-Kaskad.ps1 (v2.1)
# --- Скрипт для ручного тестирования SQL-проверок на базе testDB_kaskad через диспетчер ---

# --- 1. Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try { $modulePath = Join-Path -Path $PSScriptRoot -ChildPath "StatusMonitorAgentUtils.psd1"; Import-Module $modulePath -Force } catch { Write-Error "..."; exit 1 } finally { $ErrorActionPreference = "Continue" }
# Проверка модуля SqlServer
if (-not (Get-Command Invoke-Sqlcmd -EA SilentlyContinue)) { Write-Warning "Модуль SqlServer не найден!" }
Write-Host "Модуль Utils загружен." -FG Green; Write-Host $('-'*80)

# --- 2. Параметры ТЕСТОВОЙ БД Kaskad (из testDB_kaskad/docker-compose.yml) ---
$TestSqlServerInstance = "localhost,48010" # Порт из docker-compose
$TestDatabaseName = "kaskad"
$TestSqlUsername = "sa"
$TestSqlPassword = "escort123" # Пароль из docker-compose

Write-Host "ПАРАМЕТРЫ ТЕСТОВОЙ БД Kaskad:"; Write-Host "  Сервер: $TestSqlServerInstance"; Write-Host "  База:   $TestDatabaseName"; Write-Host "  Режим:  SQL Auth ($TestSqlUsername)"; Write-Host $('-'*80)

# --- 3. Базовый объект Задания ---
$baseAssignment = @{
    assignment_id = 9000; node_name = "Kaskad DB Test"; ip_address = $TestSqlServerInstance
    parameters = @{ sql_database = $TestDatabaseName; sql_username = $TestSqlUsername; sql_password = $TestSqlPassword }; success_criteria = $null
}

# --- Функция для выполнения и вывода теста ---
function Run-ManualSqlTest {
    param([Parameter(Mandatory=$true)]$Assignment, [string]$ExpectedResult = "")
    Write-Host "ЗАПУСК: $($Assignment.node_name)" -ForegroundColor Yellow
    Write-Host "  Method: $($Assignment.method_name)"
    Write-Host "  Parameters: $($Assignment.parameters | ConvertTo-Json -Depth 3 -Compress)"
    Write-Host "  SuccessCriteria: $($Assignment.success_criteria | ConvertTo-Json -Depth 4 -Compress)"
    $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$Assignment)
    Write-Host "РЕЗУЛЬТАТ:"; Write-Host ($result | ConvertTo-Json -Depth 5) -FG Gray
    if ($result.IsAvailable) { Write-Host "  Доступность: OK" -FG Green } else { Write-Host "  Доступность: FAIL" -FG Red }
    if ($result.CheckSuccess) { Write-Host "  Критерии: PASS $ExpectedResult" -FG Green } elseif ($result.CheckSuccess -eq $false) { Write-Host "  Критерии: FAIL $ExpectedResult" -FG Red } else { Write-Host "  Критерии: N/A $ExpectedResult" -FG Yellow }
    if ($result.ErrorMessage) { Write-Host "  Ошибка: $($result.ErrorMessage)" -FG Magenta }
    Write-Host ("-"*40)
}

# =================================================
# === ТЕСТЫ Check-SQL_QUERY_EXECUTE ===
# =================================================
Write-Host "ТЕСТЫ: Check-SQL_QUERY_EXECUTE" -FG Yellow

$execBase = $baseAssignment.PSObject.Copy(); $execBase.method_name = 'SQL_QUERY_EXECUTE'
$execId = $execBase.assignment_id

# --- first_row ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - First Row"; $assign.parameters.sql_query = "SELECT TOP 1 * FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'first_row'
Run-ManualSqlTest -Assignment $assign

# --- row_count ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Row Count (1)"; $assign.parameters.sql_query = "SELECT id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'row_count'
Run-ManualSqlTest -Assignment $assign

# --- row_count с критерием (PASS) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Row Count Criteria OK"; $assign.parameters.sql_query = "SELECT id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'row_count'; $assign.success_criteria = @{ row_count = @{ '==' = 1 } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем PASS)"

# --- row_count с критерием (FAIL) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Row Count Criteria FAIL"; $assign.parameters.sql_query = "SELECT id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'row_count'; $assign.success_criteria = @{ row_count = @{ '>' = 5 } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем FAIL)"

# --- scalar ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Scalar (Get ID)"; $assign.parameters.sql_query = "SELECT TOP 1 id FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'scalar'
Run-ManualSqlTest -Assignment $assign

# --- scalar с критерием (PASS) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Scalar Criteria OK"; $assign.parameters.sql_query = "SELECT COUNT(*) FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.return_format = 'scalar'; $assign.success_criteria = @{ scalar_value = @{ '>=' = 1 } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем PASS)"

# --- non_query ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Non-Query (Temp)"; $assign.parameters.sql_query = "IF OBJECT_ID('tempdb..#TempTestExec') IS NULL CREATE TABLE #TempTestExec(col1 INT);"; $assign.parameters.return_format = 'non_query'
Run-ManualSqlTest -Assignment $assign

# --- Ошибка SQL (Bad Table) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - SQL Error (Bad Table)"; $assign.parameters.sql_query = "SELECT * FROM dbo.NonExistentTable"; $assign.parameters.return_format = 'first_row'
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

# --- Ошибка подключения (Bad DB) ---
$assign = $execBase.PSObject.Copy(); $assign.assignment_id = ++$execId; $assign.node_name += " - Connect Error (Bad DB)"; $assign.parameters.sql_database = "NonExistentDB"; $assign.parameters.sql_query = "SELECT 1"; $assign.parameters.return_format = 'scalar'
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

Write-Host "КОНЕЦ ТЕСТОВ: Check-SQL_QUERY_EXECUTE" -FG Green; Write-Host $('='*80); Write-Host ""

# =================================================
# === ТЕСТЫ Check-SQL_XML_QUERY ===
# =================================================
Write-Host "ТЕСТЫ: Check-SQL_XML_QUERY" -FG Yellow

$xmlBase = $baseAssignment.PSObject.Copy(); $xmlBase.method_name = 'SQL_XML_QUERY'
$xmlId = $xmlBase.assignment_id + 10 # Смещаем ID

# --- Успешное извлечение ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Extract OK"; $assign.parameters.sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('VersionStat', 'TS_Version', 'NonExistentKey')
Run-ManualSqlTest -Assignment $assign

# --- Успех с критерием ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Criteria OK"; $assign.parameters.sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('VersionStat', 'TS_Version'); $assign.success_criteria = @{ extracted_data = @{ VersionStat = @{ '==' = '20221206' }; TS_Version = @{ '>' = 100 } } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем PASS)"

# --- Неуспех по критерию ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Criteria FAIL"; $assign.parameters.sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('TS_Version'); $assign.success_criteria = @{ extracted_data = @{ TS_Version = @{ '<' = 100 } } }
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем FAIL)"

# --- Ошибка (Bad XML Column) ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Error (Bad Column)"; $assign.parameters.sql_query = "SELECT TOP 1 id, Revise FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'InvalidXmlColumn'; $assign.parameters.keys_to_extract = @('VersionStat')
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

# --- Ошибка (Column Not XML) ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Error (Not XML)"; $assign.parameters.sql_query = "SELECT TOP 1 CreationDate FROM dbo.ReviseData WHERE id = 1115"; $assign.parameters.xml_column_name = 'CreationDate'; $assign.parameters.keys_to_extract = @('Year')
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: FAIL)"

# --- Ошибка (No Rows) ---
$assign = $xmlBase.PSObject.Copy(); $assign.assignment_id = ++$xmlId; $assign.node_name += " - XML Error (No Rows)"; $assign.parameters.sql_query = "SELECT Revise FROM dbo.ReviseData WHERE id = 99999"; $assign.parameters.xml_column_name = 'Revise'; $assign.parameters.keys_to_extract = @('VersionStat')
Run-ManualSqlTest -Assignment $assign -ExpectedResult "(Ожидаем Доступность: OK, но нет данных)" # IsAvailable=true, т.к. SQL запрос выполнился

Write-Host "КОНЕЦ ТЕСТОВ: Check-SQL_XML_QUERY" -FG Green; Write-Host $('='*80)
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\README.md ====

---

### 4. README для Модуля Утилит

**Файл:** `powershell/StatusMonitorAgentUtils/README.md` (Обновленный)

```markdown
# Модуль PowerShell: StatusMonitorAgentUtils (v1.1.0+)

Этот модуль PowerShell (`StatusMonitorAgentUtils.psm1` и папка `Checks/`) предоставляет общую функциональность для **Гибридного Агента Мониторинга** системы Status Monitor.

## Назначение

*   **Инкапсуляция логики проверок:** Содержит код для выполнения различных типов проверок (PING, статус службы, использование диска, SQL-запросы, проверка сертификатов и т.д.).
*   **Диспетчеризация:** Предоставляет единую точку входа (`Invoke-StatusMonitorCheck`) для Гибридного Агента, которая определяет нужный метод проверки и запускает соответствующий скрипт.
*   **Стандартизация результатов:** Обеспечивает возврат результатов проверок в едином формате (стандартная хэш-таблица).
*   **Проверка Критериев Успеха:** Содержит универсальную функцию `Test-SuccessCriteria` (и вспомогательные `Compare-Values`, `Test-ArrayCriteria`) для гибкой проверки результатов на соответствие заданным критериям (`success_criteria` в задании).
*   **Переиспользование кода:** Содержит общие вспомогательные функции.

## Ключевые компоненты

1.  **`StatusMonitorAgentUtils.psm1`**: Основной файл модуля. Содержит:
    *   **`Invoke-StatusMonitorCheck` (Экспортируемая):**
        *   **Роль:** Диспетчер проверок. Вызывается Гибридным Агентом.
        *   **Вход:** Объект задания (`$Assignment`).
        *   **Логика:** Определяет метод, находит скрипт `Checks/Check-*.ps1`, подготавливает параметры (включая `$SuccessCriteria`), запускает скрипт локально, возвращает результат.
    *   **`New-CheckResultObject` (Экспортируемая):**
        *   **Роль:** Формирование стандартного объекта результата. Используется скриптами `Checks/*.ps1`.
        *   **Вход:** `$IsAvailable`, `$CheckSuccess`, `$Details`, `$ErrorMessage`.
        *   **Выход:** Стандартная хэш-таблица результата.
    *   **`Test-SuccessCriteria` (Экспортируемая):**
        *   **Роль:** Универсальная рекурсивная проверка соответствия объекта `$Details` заданным `$SuccessCriteria`.
        *   **Вход:** `$DetailsObject`, `$CriteriaObject`.
        *   **Логика:** Рекурсивно обходит структуру критериев, использует `Compare-Values` для сравнения значений и `Test-ArrayCriteria` для обработки массивов (с ключами `_condition_`, `_where_`, `_criteria_`, `_count_`).
        *   **Выход:** `@
{ Passed = $true/$false/$null; FailReason = "..."/$null }`.
    *   **`Compare-Values` (Экспортируемая):** Сравнивает два значения с помощью указанного оператора (`==`, `>`, `contains` и т.д.).
    *   **`Test-ArrayCriteria` (Приватная):** Обрабатывает критерии для массивов в `$Details`.

2.  **Папка `Checks/`**: Содержит отдельные `.ps1` файлы для **каждого** метода проверки.
    *   **Именование:** `Check-METHOD_NAME.ps1`.
    *   **Назначение:** Реализация логики конкретной проверки.
    *   **Вход:** Параметры `$TargetIP`, `$Parameters`, `$SuccessCriteria`, `$NodeName`.
    *   **Логика:** Выполнить проверку, сформировать `$details`, определить `$isAvailable`, вызвать `Test-SuccessCriteria` для определения `$checkSuccess` (если нужно), сформировать `$errorMessage`, вернуть результат через `New-CheckResultObject`.

## Стандартный Формат Результата Проверки

(Описание формата результата без изменений)

```powershell
@{
    IsAvailable = [bool] # УДАЛОСЬ ли выполнить проверку?
    CheckSuccess = [nullable[bool]] # Соответствует ли результат КРИТЕРИЯМ? (null если IsAvailable=false или ошибка критериев)
    Timestamp = [string] # UTC ISO 8601
    Details = [hashtable] # Детали проверки (зависят от метода)
    ErrorMessage = [string] # Описание ошибки (если IsAvailable=false ИЛИ CheckSuccess=false/null)
}

Добавление Новых Методов Проверки

(Процесс без изменений)

    Добавить запись в таблицу check_methods БД.

    Создать файл Checks/Check-METHOD_NAME.ps1.

    Реализовать логику:

        Получить параметры.

        Выполнить проверку.

        Сформировать $details.

        Определить $isAvailable.

        Вызвать Test-SuccessCriteria, если нужно.

        Сформировать $errorMessage.

        Вернуть New-CheckResultObject.

    Протестировать через Invoke-StatusMonitorCheck.

    Создать Задание в UI.

Установка и Использование

Модуль копируется вместе с Гибридным Агентом.

    Структура папок:

          
    <Папка_Агента>/
    ├── hybrid-agent/
    │   ├── hybrid-agent.ps1
    │   └── config.json
    └── StatusMonitorAgentUtils/  <-- Модуль здесь
        ├── Checks/
        │   ├── Check-PING.ps1
        │   └── ...
        ├── StatusMonitorAgentUtils.psd1
        └── StatusMonitorAgentUtils.psm1
        └── README.md (этот файл)

        

    IGNORE_WHEN_COPYING_START

    Use code with caution.
    IGNORE_WHEN_COPYING_END

    Скрипт hybrid-agent.ps1 импортирует модуль из ..\StatusMonitorAgentUtils.

      
---

Эти README файлы отражают последние изменения в ТЗ v5.2, включая переход на Гибридный Агент, унификацию API, атомарные операции и папку DLQ для Загрузчика.

    
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\README.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1
# Манифест PowerShell модуля для общих утилит агентов Status Monitor

@{

    # --- ОБНОВЛЕНО: Версия модуля ---
    # Версия 2.0.0: Существенно доработана логика проверки критериев (Test-SuccessCriteria)
    ModuleVersion = '2.0.0'

    # Уникальный идентификатор модуля (GUID). Не меняется.
    GUID = 'e5fa7cfe-608d-47c9-898d-215bb6b0ef0d'

    # Автор модуля
    Author = 'User & AI'

    # Компания (опционально)
    # CompanyName = 'Your Company'

    # Авторские права (опционально)
    # Copyright = '(c) 2024 Your Company. All rights reserved.'

    # --- ОБНОВЛЕНО: Описание модуля ---
    Description = 'Общий модуль для Гибридного Агента системы мониторинга Status Monitor. Содержит диспетчер проверок (Invoke-StatusMonitorCheck), функцию форматирования результата (New-CheckResultObject), универсальную функцию проверки критериев (Test-SuccessCriteria) и скрипты для конкретных проверок в папке Checks.'

    # Минимально необходимая версия PowerShell
    PowerShellVersion = '5.1'

    # Зависимости от других модулей (раскомментировать и добавить при необходимости)
    # Например, если бы использовались командлеты ActiveDirectory:
    # RequiredModules = @{ ModuleName = 'ActiveDirectory'; RequiredVersion = '1.0.0.0' }
    # Для SQL проверок модуль SqlServer ДОЛЖЕН БЫТЬ установлен на машине агента,
    # но его не обязательно указывать здесь, т.к. он используется ВНУТРИ Check-*.ps1
    # RequiredModules = @()

    # Основной файл модуля .psm1
    RootModule = 'StatusMonitorAgentUtils.psm1'

    # --- ПОДТВЕРЖДЕНО: Экспортируемые функции ---
    # Список функций, видимых снаружи модуля.
    # Test-SuccessCriteria и Compare-Values экспортируются для возможности
    # их потенциального использования в более сложных сценариях или тестах.
    FunctionsToExport = @(
        'Invoke-StatusMonitorCheck', # Диспетчер для агента
        'New-CheckResultObject',     # Стандартизация результата (для Checks/*.ps1)
        'Test-SuccessCriteria',      # Универсальная проверка критериев
        'Compare-Values'             # Вспомогательная для Test-SuccessCriteria
        # Test-ArrayCriteria является приватной и не экспортируется
    )

    # Список командлетов, экспортируемых модулем (у нас таких нет).
    CmdletsToExport = @()

    # Список переменных, экспортируемых модулем (не рекомендуется).
    VariablesToExport = @() # Явно указываем пустой список

    # Список псевдонимов (aliases), экспортируемых модулем.
    AliasesToExport = @()

    # Остальные поля манифеста (оставлены без изменений)
    # ModuleList = @()
    # ScriptsToProcess = @()
    # TypesToProcess = @()
    # FormatsToProcess = @()
    # RequiredAssemblies = @()
    # FileList = @()
    # PrivateData = @{}
    # HelpInfoURI = ''
    # DefaultCommandPrefix = ''
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1
# Основной скрипт модуля StatusMonitorAgentUtils.
# Содержит экспортируемые функции и приватные хелперы.
# Версия модуля: 1.1.0 (согласно PSD1)
# Версия этого файла: Включает Test-SuccessCriteria v2.1.8, Compare-Values v1.1, New-CheckResultObject v1.3, Invoke-StatusMonitorCheck v1.2.1

#--------------------------------------------------------------------------
# Приватные функции (не экспортируются)
#--------------------------------------------------------------------------

#region Функция Compare-Values (Приватная, v1.1 - Улучшено сравнение ==/!=)
# Вспомогательная функция для сравнения значений с операторами
# Возвращает: @{ Passed = $true/$false/$null; Reason = "..."/$null }
# ($null для Passed означает ошибку сравнения/типа)
function Compare-Values {
    param(
        $Value, # Фактическое значение из Details
        $Operator, # Оператор сравнения (строка: '>', 'contains', 'matches'...)
        $Threshold # Пороговое значение из Criteria
    )

    $result = @{ Passed = $true; Reason = '' }
    $opLower = $Operator.ToLower()

    try {
        # --- Проверка существования ---
        if ($opLower -eq 'exists') {
            if (($Threshold -eq $true -and $Value -eq $null) -or ($Threshold -eq $false -and $Value -ne $null)) {
                $result.Passed = $false
                $result.Reason = "Проверка существования (exists=$Threshold) не пройдена для значения '$Value'"
            }
            return $result
        }

        # --- Универсальное сравнение для == и != ---
        # Используем стандартный оператор PowerShell
        elseif ($opLower -eq '==') {
             if (-not ($Value -eq $Threshold)) {
                 $result.Passed = $false; $result.Reason = "'$Value' не равно '$Threshold'"
             }
        }
        elseif ($opLower -eq '!=') {
             if (-not ($Value -ne $Threshold)) {
                 $result.Passed = $false; $result.Reason = "'$Value' равно '$Threshold'"
             }
        }
        # --- Числовые сравнения (остаются с преобразованием) ---
        elseif ($opLower -in @('>', '>=', '<', '<=')) {
            $numValue = 0.0; $numThreshold = 0.0
            # Используем региональные настройки текущей культуры для парсинга чисел
            $culture = [System.Globalization.CultureInfo]::CurrentCulture
            $valueParsed = [double]::TryParse($Value, [System.Globalization.NumberStyles]::Any, $culture, [ref]$numValue)
            $thresholdParsed = [double]::TryParse($Threshold, [System.Globalization.NumberStyles]::Any, $culture, [ref]$numThreshold)

            if (-not $valueParsed -or -not $thresholdParsed) {
                $result.Passed = $null # Ошибка типа
                $result.Reason = "Ошибка числового сравнения '$opLower': Не удалось преобразовать '$Value' или '$Threshold' в число."
                return $result
            }
            # Выполняем числовое сравнение
            switch ($opLower) {
                '>'  { if (-not ($numValue -gt $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не больше (>) '$Threshold'" } }
                '>=' { if (-not ($numValue -ge $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не больше или равно (>=) '$Threshold'" } }
                '<'  { if (-not ($numValue -lt $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не меньше (<) '$Threshold'" } }
                '<=' { if (-not ($numValue -le $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не меньше или равно (<=) '$Threshold'" } }
            }
        }
        # --- Строковые сравнения (только специфичные для строк) ---
        elseif ($opLower -in @('contains', 'not_contains', 'matches', 'not_matches')) {
            # Приводим оба операнда к строке
            $strValue = "$Value"
            $strThreshold = "$Threshold"

            # Выполняем сравнение
            switch ($opLower) {
                'contains' { if ($strValue -notlike "*$strThreshold*") { $result.Passed = $false; $result.Reason = "'$strValue' не содержит '$strThreshold'" } }
                'not_contains' { if ($strValue -like "*$strThreshold*") { $result.Passed = $false; $result.Reason = "'$strValue' содержит '$strThreshold'" } }
                'matches' { if ($strValue -notmatch $strThreshold) { $result.Passed = $false; $result.Reason = "'$strValue' не соответствует regex '$strThreshold'" } }
                'not_matches' { if ($strValue -match $strThreshold) { $result.Passed = $false; $result.Reason = "'$strValue' соответствует regex '$strThreshold'" } }
            }
        } else {
            # Неизвестный оператор
            $result.Passed = $null
            $result.Reason = "Неизвестный оператор сравнения: '$Operator'"
        }
    } catch {
        $result.Passed = $null
        $result.Reason = "Ошибка при сравнении оператором '$Operator' для '$Value' и '$Threshold': $($_.Exception.Message)"
    }
    return $result
}
#endregion

#region Функция Test-ArrayCriteria (Приватная, v1.0 - Реализованная, но требует тестов)
# Обрабатывает критерии для массивов (_condition_, _where_, _criteria_, _count_)
function Test-ArrayCriteria {
    param(
        [Parameter(Mandatory=$true)] $DetailsArray,    # Массив данных из Details
        [Parameter(Mandatory=$true)] [hashtable]$ArrayCriteria, # Критерий для массива (содержит _condition_, etc.)
        [string]$Path                             # Текущий путь для логов/ошибок
    )

    $result = @{ Passed = $null; FailReason = $null } # Начинаем с неопределенного

    # 1. Проверка, что DetailsArray - это действительно массив
    if ($DetailsArray -isnot [array]) {
        $result.Passed = $false
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Ожидался массив в данных, но получен '$($DetailsArray.GetType().Name)'."
        return $result
    }

    # 2. Извлечение управляющих ключей из критерия
    $condition = $ArrayCriteria._condition_
    $whereClause = $ArrayCriteria._where_       # Может быть $null или hashtable
    $criteria = $ArrayCriteria._criteria_     # Может быть $null или hashtable (для all, any, none)
    $countCriteria = $ArrayCriteria._count_    # Может быть $null или hashtable (для count)

    # 3. Валидация управляющих ключей
    if (-not $condition -or $condition.ToLower() -notin @('all', 'any', 'none', 'count')) {
        $result.Passed = $null
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Отсутствует или неверный ключ '_condition_'. Допустимые: 'all', 'any', 'none', 'count'."
        return $result
    }
    $conditionLower = $condition.ToLower() # Приводим к нижнему регистру для switch

    if ($conditionLower -in @('all', 'any') -and $null -eq $criteria) {
        $result.Passed = $null
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Для _condition_ '$condition' требуется ключ '_criteria_'."
        return $result
    }
    if ($conditionLower -eq 'count' -and ($null -eq $countCriteria -or -not ($countCriteria.PSObject -ne $null))) { # Проверяем, что countCriteria - объект
        $result.Passed = $null
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Для _condition_ 'count' требуется ключ '_count_' с объектом операторов."
        return $result
    }

    # 4. Фильтрация массива (если есть _where_)
    $filteredArray = $DetailsArray # По умолчанию работаем со всем массивом
    if ($whereClause -ne $null) {
        Write-Verbose "Фильтрация массива по пути '$Path' с использованием _where_..."
        $tempFiltered = [System.Collections.Generic.List[object]]::new()
        $indexCounter = -1 # Счетчик для логов
        foreach ($item in $DetailsArray) {
            $indexCounter++
            # Рекурсивно проверяем КАЖДЫЙ элемент на соответствие _where_
            $filterCheck = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $whereClause -Path "$Path[$indexCounter]" # Передаем индекс
            if ($filterCheck.Passed -eq $true) {
                $tempFiltered.Add($item)
            } elseif ($filterCheck.Passed -eq $null) {
                # Если ошибка при фильтрации элемента - вся проверка критерия массива считается ошибочной
                $result.Passed = $null
                $result.FailReason = "Ошибка при фильтрации элемента массива ($indexCounter) по пути '$Path': $($filterCheck.FailReason)"
                return $result
            }
        }
        $filteredArray = $tempFiltered
        Write-Verbose "Массив по пути '$Path' отфильтрован. Осталось элементов: $($filteredArray.Count)"
    }

    # 5. Применение основного условия (_condition_)
    $finalPassed = $null # Итоговый результат условия

    switch ($conditionLower) {
        'all' {
            if ($filteredArray.Count -eq 0) { $finalPassed = $true }
            else {
                 $allPassed = $true
                 for ($i = 0; $i -lt $filteredArray.Count; $i++) {
                     $item = $filteredArray[$i]
                     $itemResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteria -Path "$Path[$i]"
                     if ($itemResult.Passed -ne $true) {
                         $allPassed = $false; $result.FailReason = "Условие 'all' не выполнено для элемента [$i] по пути '$Path'. Причина: $($itemResult.FailReason)"; break
                     }
                 }
                 $finalPassed = $allPassed
            }
        } # Конец 'all'
        'any' {
             $anyPassed = $false
             if ($filteredArray.Count -gt 0) {
                 for ($i = 0; $i -lt $filteredArray.Count; $i++) {
                     $item = $filteredArray[$i]
                     $itemResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteria -Path "$Path[$i]"
                     if ($itemResult.Passed -eq $true) { $anyPassed = $true; $result.FailReason = $null; break }
                     elseif ($itemResult.Passed -eq $null) { $anyPassed = $null; $result.FailReason = "Ошибка проверки элемента [$i] для 'any' ($($itemResult.FailReason))"; break }
                 }
             }
             if ($anyPassed -eq $false -and $result.FailReason -eq $null) { $result.FailReason = "Условие 'any': ни один элемент в '$Path' не соответствует критериям." }
             $finalPassed = $anyPassed
        } # Конец 'any'
        'none' {
             $nonePassed = $true
             if ($filteredArray.Count -gt 0) {
                 if ($criteria -ne $null) {
                     for ($i = 0; $i -lt $filteredArray.Count; $i++) {
                         $item = $filteredArray[$i]
                         $itemResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteria -Path "$Path[$i]"
                         if ($itemResult.Passed -eq $true) { $nonePassed = $false; $result.FailReason = "Условие 'none': элемент [$i] в '$Path' СООТВЕТСТВУЕТ критериям."; break }
                         elseif ($itemResult.Passed -eq $null) { $nonePassed = $null; $result.FailReason = "Ошибка проверки элемента [$i] для 'none' ($($itemResult.FailReason))"; break }
                     }
                 } else { $nonePassed = $false; $result.FailReason = "Условие 'none': найдены элементы ($($filteredArray.Count) шт.), соответствующие _where_ в '$Path'." }
             }
             $finalPassed = $nonePassed
        } # Конец 'none'
        'count' {
            $itemCount = $filteredArray.Count
            Write-Verbose "Проверка количества элементов ($itemCount) по пути '$Path'..."
            $countCheckPassed = $true
            # Итерируем по операторам в _count_ (это должна быть Hashtable)
            foreach ($operatorProperty in $countCriteria.PSObject.Properties) {
                $operator = $operatorProperty.Name
                $threshold = $operatorProperty.Value
                $comparisonResult = Compare-Values -Value $itemCount -Operator $operator -Threshold $threshold
                if ($comparisonResult.Passed -ne $true) {
                    $countCheckPassed = $comparisonResult.Passed # $false или $null
                    $result.FailReason = "Критерий количества ('count') не пройден ($($comparisonResult.Reason)) по пути '$Path'."
                    break
                }
            }
            $finalPassed = $countCheckPassed
        } # Конец 'count'
    } # Конец switch ($conditionLower)

    $result.Passed = $finalPassed
    # FailReason уже установлен внутри switch
    return $result
}
#endregion

#region Функция Test-SuccessCriteria (Приватная, v2.1.8 - Исправлен доступ к свойству)
# Рекурсивно сравнивает объект Details с объектом Criteria
# Возвращает: @{ Passed = $true/$false/$null; FailReason = "..."/$null }
#region Функция Test-SuccessCriteria (Приватная, v2.1.12 - Убрана рекурсия для не-операторов)
function Test-SuccessCriteria {
    param(
        [Parameter(Mandatory=$true)] $DetailsObject,
        [Parameter(Mandatory=$true)] $CriteriaObject,
        [string]$Path = '$Details'
    )
    # ... (Отладка входа) ...
    Write-Host "--- Test-SuccessCriteria [Вход] ---" # ...

    $overallResult = @{ Passed = $true; FailReason = $null }
    if ($null -eq $CriteriaObject.PSObject) { <# ... ошибка ... #> return $overallResult }
    # ... (проверка DetailsObject) ...

    # --- ИТЕРАЦИЯ ПО КЛЮЧАМ КРИТЕРИЯ ---
    foreach ($entry in $CriteriaObject.GetEnumerator()) {
        $key = $entry.Name
        $currentCriteriaValue = $entry.Value
        $currentPath = "$Path.$key"
        Write-Host "  [Цикл] Path='$Path', Key='$key', CriteriaValue Type='$($currentCriteriaValue.GetType().FullName)'" -ForegroundColor DarkYellow

        # ... (проверка _condition_ ...) ...
        if ($key -in @('_condition_', '_where_', '_criteria_', '_count_')) { <#...#> continue }

        # --- Проверка наличия ключа '$key' в $DetailsObject ---
        $keyExists = $false; $currentDetailsValue = $null; $propertyAccessError = $null
        if ($null -ne $DetailsObject.PSObject) { <# ... код проверки и получения значения v2.1.8 ... #> }
        if (-not $keyExists) { <# ... обработка отсутствия ключа ... #> continue }
        elseif ($null -ne $propertyAccessError) { $overallResult.Passed = $null; $overallResult.FailReason = $propertyAccessError; break }

        # --- КЛЮЧ НАЙДЕН, ЗНАЧЕНИЕ В $currentDetailsValue ---
        $isCriteriaComplex = $currentCriteriaValue -is [hashtable] -or $currentCriteriaValue -is [System.Management.Automation.PSCustomObject]
        if ($isCriteriaComplex) {
            # --- СЛОЖНЫЙ КРИТЕРИЙ ---
            if ($currentCriteriaValue.PSObject.Properties.Name -contains '_condition_') {
                # Критерий для массива
                $arrayResult = Test-ArrayCriteria -DetailsArray $currentDetailsValue -ArrayCriteria $currentCriteriaValue -Path $currentPath
                if ($arrayResult.Passed -ne $true) { $overallResult = $arrayResult; break }
            } else {
                # --- Операторы ИЛИ НЕПОДДЕРЖИВАЕМЫЙ ВЛОЖЕННЫЙ ОБЪЕКТ ---
                $isOperatorObject = $false; $operators = @('>', '>=', '<', '<=', '==', '!=', 'contains', 'not_contains', 'matches', 'not_matches', 'exists'); $keysInCriteriaValue = @($currentCriteriaValue.PSObject.Properties.Name)
                if ($keysInCriteriaValue.Count -gt 0) { $allKeysAreOperators = $true; foreach($ckey in $keysInCriteriaValue){ if($operators -notcontains $ckey.ToLower()){ $allKeysAreOperators = $false; break } }; if($allKeysAreOperators){ $isOperatorObject = $true } }

                if ($isOperatorObject) {
                    # --- ОБРАБОТКА ОПЕРАТОРОВ (код без изменений) ---
                    Write-Verbose "Сравнение операторами для '$currentPath'"
                    foreach ($operatorProperty in $currentCriteriaValue.PSObject.Properties) {
                        $operator = $operatorProperty.Name; $threshold = $operatorProperty.Value
                        Write-Host "      [Оператор] Compare-Values: Value='$currentDetailsValue', Operator='$operator', Threshold='$threshold'" -ForegroundColor DarkMagenta
                        $comparisonResult = Compare-Values -Value $currentDetailsValue -Operator $operator -Threshold $threshold
                        if ($comparisonResult.Passed -ne $true) { $overallResult.Passed = $comparisonResult.Passed; $overallResult.FailReason = "Критерий '$key' не пройден ($($comparisonResult.Reason)) по пути '$Path'."; break }
                    }
                    if ($overallResult.Passed -ne $true) { break }
                } else {
                    # --- НЕПОДДЕРЖИВАЕМЫЙ ВЛОЖЕННЫЙ КРИТЕРИЙ ---
                    # <<< ИЗМЕНЕНО: Вместо рекурсии - ошибка >>>
                    $overallResult.Passed = $null # Ошибка формата критерия
                    $overallResult.FailReason = "Ошибка критерия по пути '$currentPath'. Вложенные объекты без операторов сравнения не поддерживаются (кроме критериев для массивов с _condition_)."
                    Write-Warning $overallResult.FailReason
                    break # Прерываем проверку
                }
            }
        } else {
            # --- Простое сравнение (код без изменений) ---
            Write-Verbose "Простое сравнение для '$currentPath'"
            Write-Host "      [Простое] Compare-Values: Value='$currentDetailsValue', Operator='==', Threshold='$currentCriteriaValue'" -ForegroundColor DarkMagenta
            $comparisonResult = Compare-Values -Value $currentDetailsValue -Operator '==' -Threshold $currentCriteriaValue
            if ($comparisonResult.Passed -ne $true) {
                $overallResult.Passed = $comparisonResult.Passed
                $overallResult.FailReason = "Критерий '$key' не пройден ($($comparisonResult.Reason)) по пути '$Path'."
                break
            }
        }
    } # Конец foreach

    Write-Host "--- Test-SuccessCriteria [Выход] --- Path: $Path, Passed: $($overallResult.Passed), Reason: $($overallResult.FailReason)" -ForegroundColor Yellow
    return $overallResult
}
#endregion

#--------------------------------------------------------------------------
# Экспортируемые функции
#--------------------------------------------------------------------------

#region Функция New-CheckResultObject (Экспортируемая, v1.3)
<#
.SYNOPSIS
    Создает стандартизированный объект результата проверки (хэш-таблицу).
# ... (описание New-CheckResultObject без изменений) ...
#>
function New-CheckResultObject {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)] [bool]$IsAvailable,
        [Parameter(Mandatory = $false)] [nullable[bool]]$CheckSuccess = $null,
        [Parameter(Mandatory = $false)] $Details = $null,
        [Parameter(Mandatory = $false)] [string]$ErrorMessage = $null
    )
    $processedDetails = $null
    if ($null -ne $Details) {
        if ($Details -is [hashtable]) { $processedDetails = $Details }
        elseif ($Details.PSObject -ne $null) { try { $processedDetails = [hashtable]$Details } catch { $processedDetails = @{ OriginalDetails = $Details } } }
        else { $processedDetails = @{ Value = $Details } }
    }
    $result = [ordered]@{
        IsAvailable = $IsAvailable; CheckSuccess = $CheckSuccess; Timestamp = (Get-Date).ToUniversalTime().ToString("o"); Details = $processedDetails; ErrorMessage = $ErrorMessage
    }
    if ($result.IsAvailable) { if ($result.CheckSuccess -eq $null) { $result.CheckSuccess = $true } }
    else { $result.CheckSuccess = $null }
    if ([string]::IsNullOrEmpty($result.ErrorMessage)) { if (-not $result.IsAvailable) { $result.ErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)." } }
    Write-Verbose ("New-CheckResultObject (v1.3): Создан результат: IsAvailable=$($result.IsAvailable), CheckSuccess=$($result.CheckSuccess), Error='$($result.ErrorMessage)'")
    return $result
}
#endregion

#region Функция Invoke-StatusMonitorCheck (Экспортируемая, v1.2.1 - Улучшена обработка parameters/success_criteria)
<#
.SYNOPSIS
    Выполняет проверку мониторинга согласно заданию.
# ... (описание Invoke-StatusMonitorCheck без изменений) ...
#>
function Invoke-StatusMonitorCheck {
    [CmdletBinding(SupportsShouldProcess = $false)]
    param(
        [Parameter(Mandatory = $true)]
        [PSObject]$Assignment
    )

    # --- 1. Валидация входного объекта ---
    if ($null -eq $Assignment.PSObject -or -not ($Assignment.PSObject.Properties.Name -contains 'assignment_id') -or -not ($Assignment.PSObject.Properties.Name -contains 'method_name')) {
        Write-Warning "Invoke-StatusMonitorCheck: Передан некорректный объект задания."; return New-CheckResultObject -IsAvailable $false -ErrorMessage "Некорректный объект задания."
    }

    # --- 2. Извлечение данных ---
    $assignmentId = $Assignment.assignment_id; $methodName = $Assignment.method_name; $targetIP = $null; $nodeName = "Задание ID $assignmentId"
    if ($Assignment.PSObject.Properties.Name -contains 'ip_address') { $targetIP = $Assignment.ip_address }
    if (($Assignment.PSObject.Properties.Name -contains 'node_name') -and $Assignment.node_name) { $nodeName = $Assignment.node_name }
    # Получаем parameters и success_criteria, преобразуя в Hashtable
    $parameters = @{}; $successCriteria = $null
    if (($Assignment.PSObject.Properties.Name -contains 'parameters') -and $Assignment.parameters) { if ($Assignment.parameters.PSObject -ne $null) { try { $parameters = [hashtable]$Assignment.parameters } catch { Write-Warning "[$($assignmentId) | $nodeName] Не удалось преобразовать 'parameters' в Hashtable. Используется пустой объект." } } else { Write-Warning "[$($assignmentId) | $nodeName] Поле 'parameters' не является объектом. Используется пустой объект."} }
    if (($Assignment.PSObject.Properties.Name -contains 'success_criteria') -and $Assignment.success_criteria) { if ($Assignment.success_criteria.PSObject -ne $null) { try { $successCriteria = [hashtable]$Assignment.success_criteria } catch { Write-Warning "[$($assignmentId) | $nodeName] Не удалось преобразовать 'success_criteria' в Hashtable. Критерии не будут применены." } } else { Write-Warning "[$($assignmentId) | $nodeName] Поле 'success_criteria' не является объектом. Критерии не будут применены." } }
    $targetLogString = if ($targetIP) { $targetIP } else { '[Local]' }; Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Запуск '$methodName' (Target: $targetLogString)"

    # --- 3. Поиск и выполнение скрипта ---
    $result = $null
    try {
        $ModuleBase = $MyInvocation.MyCommand.Module.ModuleBase; if (-not $ModuleBase) { if ($PSScriptRoot) { $ModuleBase = $PSScriptRoot } else { throw "Не удалось определить путь модуля." } }
        $ChecksFolder = Join-Path -Path $ModuleBase -ChildPath "Checks"; $CheckScriptFile = "Check-$($methodName).ps1"; $CheckScriptPath = Join-Path -Path $ChecksFolder -ChildPath $CheckScriptFile
        Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Поиск скрипта: $CheckScriptPath"
        if (-not (Test-Path $CheckScriptPath -PathType Leaf)) { $errorMessage = "Скрипт '$CheckScriptFile' не найден."; Write-Warning "[$($assignmentId) | $nodeName] $errorMessage"; return New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details @{ CheckedScriptPath = $CheckScriptPath } }

        $checkParams = [hashtable]@{ TargetIP = $targetIP; Parameters = $parameters; SuccessCriteria = $successCriteria; NodeName = $nodeName }
        Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Запуск '$CheckScriptFile'..."
        try { $result = & $checkScriptPath @checkParams } catch { throw } # Переброс ошибки из скрипта

        # --- 4. Анализ результата ---
        $resultIsValid = $false; if ($null -ne $result) { try { $null = $result.IsAvailable; $resultIsValid = $true } catch { } }
        if (-not $resultIsValid) {
            $errorMessage = "Скрипт '$CheckScriptFile' вернул некорректный результат."; $resultType = if ($null -eq $result) { '$null' } else { $result.GetType().FullName }; Write-Warning "... $resultType ..."; $result = New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details @{ ScriptOutput = ($result | Out-String -Width 200) }
        } else {
            Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Скрипт '$CheckScriptFile' вернул результат."
            if ($result.PSObject.Properties.Name -contains 'Details') { if ($result.Details.PSObject -ne $null -and $result.Details -isnot [hashtable]) { try { $result.Details = [hashtable]$result.Details } catch { $result.Details = @{ OriginalDetails = $result.Details } } } } else { $result.Details = @{} }
            $result.Details.execution_target = $env:COMPUTERNAME; $result.Details.execution_mode = 'local_agent'; $result.Details.check_target_ip = $targetIP
        }
    } catch {
        # --- 5. Обработка КРИТИЧЕСКИХ ОШИБОК диспетчера ---
        $errorMessage = "Критическая ошибка '$methodName' для '$nodeName': $($_.Exception.Message)"; Write-Warning "[$($assignmentId) | $nodeName] $errorMessage"; $result = New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details @{ ErrorRecord = $_.ToString() }
    }

    # --- 6. Возвращаем результат ---
    $isAvailableStr = if ($result -and $result.PSObject.Properties.Name -contains 'IsAvailable') { $result.IsAvailable } else { '[N/A]' }
    $checkSuccessStr = if ($result -and $result.PSObject.Properties.Name -contains 'CheckSuccess') { $result.CheckSuccess } else { '[N/A]' }
    Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Завершение. IsAvailable: $isAvailableStr, CheckSuccess: $checkSuccessStr"
    return $result
}
#endregion


# --- Экспорт функций ---
Export-ModuleMember -Function Invoke-StatusMonitorCheck, New-CheckResultObject, Test-SuccessCriteria, Compare-Values
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Найти все SSL-сертификаты сервера в LocalMachine\My и проверить, что осталось > 14 дней
$certAssignment1 = @{
    assignment_id = 501; method_name = 'CERT_EXPIRY'; node_name = 'Local SSL Certs (>14d)'
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        eku_oid = @('1.3.6.1.5.5.7.3.1') # Server Authentication OID
        require_private_key = $true
        min_days_warning = 30 # Предупреждать за 30 дней
    }
    success_criteria = @{
        min_days_left = 14 # Должно оставаться > 14 дней
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment1) | ConvertTo-Json -Depth 4

# 2. Найти конкретный сертификат по отпечатку и проверить, что осталось > 60 дней
# ЗАМЕНИ 'YOUR_CERT_THUMBPRINT_HERE' на реальный отпечаток существующего сертификата
$thumbprintToTest = 'YOUR_CERT_THUMBPRINT_HERE'
$certAssignment2 = @{
    assignment_id = 502; method_name = 'CERT_EXPIRY'; node_name = "Cert by Thumbprint ($($thumbprintToTest.Substring(0,8))... >60d)"
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        thumbprint = $thumbprintToTest
    }
    success_criteria = @{
        min_days_left = 60
    }
}
if ($thumbprintToTest -ne 'YOUR_CERT_THUMBPRINT_HERE') {
    Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment2) | ConvertTo-Json -Depth 4
} else { Write-Warning "Тест 2 пропущен: Замените YOUR_CERT_THUMBPRINT_HERE на реальный отпечаток." }


# 3. Найти сертификаты, выданные определенным CA (например, внутренним)
$issuerPattern = "*MyInternalCA*" # Замените на часть имени вашего CA
$certAssignment3 = @{
    assignment_id = 503; method_name = 'CERT_EXPIRY'; node_name = "Certs from $issuerPattern (>3d)"
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        issuer_like = $issuerPattern
    }
    success_criteria = @{
        min_days_left = 3
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment3) | ConvertTo-Json -Depth 4

# 4. Тест с ошибкой: Неверное хранилище
$certAssignment4 = @{
    assignment_id = 504; method_name = 'CERT_EXPIRY'; node_name = 'Invalid Store'
    ip_address = $null
    parameters = @{ store_location = 'InvalidPlace'; store_name = 'My' }
    success_criteria = @{ min_days_left = 1 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment4) | ConvertTo-Json -Depth 4

# 5. Тест с ошибкой: Отсутствует обязательный критерий
$certAssignment5 = @{
    assignment_id = 505; method_name = 'CERT_EXPIRY'; node_name = 'Missing Criteria'
    ip_address = $null
    parameters = @{ thumbprint = $thumbprintToTest }
    success_criteria = @{ } # Пустой критерий
}
if ($thumbprintToTest -ne 'YOUR_CERT_THUMBPRINT_HERE') {
    Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment5) | ConvertTo-Json -Depth 4
} else { Write-Warning "Тест 5 пропущен: Замените YOUR_CERT_THUMBPRINT_HERE." }
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 ====
# Убедись, что модуль загружен
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Проверка всех локальных дисков без критериев
$diskAssignment1 = @{ assignment_id = 301; method_name = 'DISK_USAGE'; node_name = 'Local Disk Usage'; ip_address = $null; parameters = $null; success_criteria = $null }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment1) | ConvertTo-Json -Depth 5

# 2. Проверка только диска C: без критериев
$diskAssignment2 = @{ assignment_id = 302; method_name = 'DISK_USAGE'; node_name = 'Local Disk C Usage'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = $null }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment2) | ConvertTo-Json -Depth 5

# 3. Проверка диска C: с критерием > 5% свободно (скорее всего, пройдет)
$diskAssignment3 = @{ assignment_id = 303; method_name = 'DISK_USAGE'; node_name = 'Local Disk C OK'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 5 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment3) | ConvertTo-Json -Depth 5

# 4. Проверка диска C: с заведомо невыполнимым критерием (> 99% свободно)
$diskAssignment4 = @{ assignment_id = 304; method_name = 'DISK_USAGE'; node_name = 'Local Disk C Fail'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 99 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment4) | ConvertTo-Json -Depth 5

# 5. Проверка всех дисков с дефолтным критерием > 1%
$diskAssignment5 = @{ assignment_id = 305; method_name = 'DISK_USAGE'; node_name = 'Local All Disks Default OK'; ip_address = $null; parameters = $null; success_criteria = @{ _default_ = @{ min_percent_free = 1 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment5) | ConvertTo-Json -Depth 5

# 6. Проверка всех дисков, где для C: >99%, для остальных >1% (C: провалится)
$diskAssignment6 = @{ assignment_id = 306; method_name = 'DISK_USAGE'; node_name = 'Local All Disks C Fail Rest OK'; ip_address = $null; parameters = $null; success_criteria = @{ C = @{ min_percent_free = 99 }; _default_ = @{ min_percent_free = 1 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment6) | ConvertTo-Json -Depth 5

# 7. Тест с некорректным критерием
$diskAssignment7 = @{ assignment_id = 307; method_name = 'DISK_USAGE'; node_name = 'Invalid Criteria'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 'десять' } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment7) | ConvertTo-Json -Depth 5
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 ====
# Убедись, что модуль загружен
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Пинг существующего локального адреса (успех)
$pingAssignment1 = @{
    assignment_id = 201; method_name = 'PING'; node_name = 'Localhost Ping'
    ip_address = '127.0.0.1'; parameters = @{ count = 2 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment1) | ConvertTo-Json -Depth 3

# 2. Пинг несуществующего адреса (ошибка доступности)
$pingAssignment2 = @{
    assignment_id = 202; method_name = 'PING'; node_name = 'Non-existent Ping'
    ip_address = '192.168.254.254'; parameters = @{ timeout_ms = 500 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment2) | ConvertTo-Json -Depth 3

# 3. Пинг существующего адреса с критерием RTT (успех по критерию)
$pingAssignment3 = @{
    assignment_id = 203; method_name = 'PING'; node_name = 'Gateway Ping OK'
    ip_address = 'ya.ru'; parameters = @{ count = 1 } # Укажи IP своего шлюза
    success_criteria = @{ max_rtt_ms = 500 } # Критерий RTT < 500ms
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment3) | ConvertTo-Json -Depth 3

# 4. Пинг существующего адреса с критерием RTT (неуспех по критерию)
$pingAssignment4 = @{
    assignment_id = 204; method_name = 'PING'; node_name = 'Gateway Ping Fail RTT'
    ip_address = 'ya.ru'; parameters = @{ count = 1 }
    success_criteria = @{ max_rtt_ms = 1 } # Заведомо невыполнимый критерий
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment4) | ConvertTo-Json -Depth 3
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Все процессы, сортировка по памяти (убывание), топ 5
$procAssignment1 = @{
    assignment_id = 401; method_name = 'PROCESS_LIST'; node_name = 'Local Top 5 Mem Proc'
    ip_address = $null
    parameters = @{ sort_by = 'Memory'; sort_descending = $true; top_n = 5; include_username=$false; include_path=$false }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment1) | ConvertTo-Json -Depth 4

# 2. Процессы PowerShell с путем и пользователем
$procAssignment2 = @{
    assignment_id = 402; method_name = 'PROCESS_LIST'; node_name = 'Local PS Proc Details'
    ip_address = $null
    parameters = @{ process_names = @('*powershell*'); include_username = $true; include_path = $true }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment2) | ConvertTo-Json -Depth 4

# 3. Несуществующий процесс (должен вернуть IsAvailable=true, CheckSuccess=true, пустой список)
$procAssignment3 = @{
    assignment_id = 403; method_name = 'PROCESS_LIST'; node_name = 'Local NonExistent Proc'
    ip_address = $null
    parameters = @{ process_names = @('__NonExistentProcess__') }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment3) | ConvertTo-Json -Depth 4

# 4. Тест с некорректным полем сортировки
$procAssignment4 = @{
    assignment_id = 404; method_name = 'PROCESS_LIST'; node_name = 'Invalid Sort'
    ip_address = $null
    parameters = @{ sort_by = 'InvalidField' }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment4) | ConvertTo-Json -Depth 4

# 5. Удаленный тест (ожидаем ошибку WinRM -> IsAvailable=false)
$procAssignment5 = @{
    assignment_id = 405; method_name = 'PROCESS_LIST'; node_name = 'Remote Proc Fail'
    ip_address = 'REMOTE_HOST_NAME_NO_WINRM' # Замените на имя хоста без доступа по WinRM
    parameters = @{ top_n = 5 }
}
# Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment5) | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 ====
Remove-Module StatusMonitorAgentUtils -Force -ErrorAction SilentlyContinue
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -Verbose

$testAssignment = [PSCustomObject]@{
    assignment_id = 123; method_name = 'SERVICE_STATUS'; ip_address = $null
    node_name = 'Локальный Тест'; parameters = @{ service_name = 'Spooler' }
    success_criteria = @{ status = 'Running' }
}
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4

$testAssignment.parameters.service_name = 'NonExistentService'
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4

$testAssignment.parameters.service_name = 'Spooler'
$testAssignment.success_criteria = @{ status = 'Stopped' }
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# Замени на свои значения
$server = "YOUR_SERVER\YOUR_INSTANCE"
$db = "YourDatabaseName"
$tableName = "YourTableName" # Таблица с какими-нибудь данными

# 1. Получить первую строку
$sqlAssignment1 = @{
    assignment_id = 701; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL First Row Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT TOP 1 * FROM $tableName"
        return_format = 'first_row'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment1) | ConvertTo-Json -Depth 4

# 2. Получить все строки (ОСТОРОЖНО, если строк много!)
$sqlAssignment2 = @{
    assignment_id = 702; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL All Rows Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT Id, Name FROM $tableName WHERE Id < 10" # Пример с WHERE
        return_format = 'all_rows'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment2) | ConvertTo-Json -Depth 4

# 3. Получить количество строк
$sqlAssignment3 = @{
    assignment_id = 703; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Row Count Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT Id FROM $tableName" # Достаточно одного столбца для подсчета
        return_format = 'row_count'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment3) | ConvertTo-Json -Depth 4

# 4. Получить скалярное значение (имя первой записи)
$sqlAssignment4 = @{
    assignment_id = 704; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Scalar Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT TOP 1 Name FROM $tableName ORDER BY Id"
        return_format = 'scalar'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment4) | ConvertTo-Json -Depth 4

# 5. Выполнить Non-Query (например, создать временную таблицу) - ОСТОРОЖНО!
$sqlAssignment5 = @{
    assignment_id = 705; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Non-Query Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "IF OBJECT_ID('tempdb..#TestTempTable') IS NULL CREATE TABLE #TestTempTable (Id INT);" # Пример безопасного non-query
        return_format = 'non_query'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment5) | ConvertTo-Json -Depth 4

# 6. Ошибка - неверная БД
$sqlAssignment6 = $sqlAssignment1.PSObject.Copy()
$sqlAssignment6.assignment_id = 706
$sqlAssignment6.node_name = "SQL Error - Bad DB"
$sqlAssignment6.parameters.sql_database = "NonExistentDatabase"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment6) | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# Замени на свои значения
$server = "YOUR_SERVER\YOUR_INSTANCE" # Или просто "YOUR_SERVER"
$db = "YourDatabaseName"
$query = "SELECT TOP 1 CreationDate, Revise, id, UTCTime FROM YourTable WHERE id = 12345" # Пример запроса
$xmlCol = "Revise"
$keys = @("VersionStat", "ArrivalStationID", "TS_Version", "NonExistentKey")

$sqlAssignment = @{
    assignment_id = 601
    method_name   = 'SQL_XML_QUERY'
    node_name     = "SQL Query Test ($db)"
    ip_address    = $server # Передаем сервер как TargetIP
    parameters    = @{
        sql_database = $db
        sql_query = $query
        xml_column_name = $xmlCol
        keys_to_extract = $keys
        # sql_username = "your_sql_user" # Раскомментируй для SQL Auth
        # sql_password = "your_sql_password" # Раскомментируй для SQL Auth
    }
    success_criteria = $null # Пока не используем
}

Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment) | ConvertTo-Json -Depth 5

# --- Тест с ошибкой (неверное имя столбца) ---
$sqlAssignmentError = $sqlAssignment.PSObject.Copy()
$sqlAssignmentError.parameters.xml_column_name = 'InvalidColumnName'
$sqlAssignmentError.assignment_id = 602
$sqlAssignmentError.node_name = "SQL Error Test (Bad Column)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignmentError) | ConvertTo-Json -Depth 5

# --- Тест с ошибкой (неверный SQL) ---
$sqlAssignmentError2 = $sqlAssignment.PSObject.Copy()
$sqlAssignmentError2.parameters.sql_query = 'SELECT * FRO Arom InvalidTable'
$sqlAssignmentError2.assignment_id = 603
$sqlAssignmentError2.node_name = "SQL Error Test (Bad Query)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignmentError2) | ConvertTo-Json -Depth 5
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1
# --- Версия 2.0.3 --- Исправлена логика установки ErrorMessage при ошибке критерия
<#
.SYNOPSIS
    Скрипт проверки сроков действия локально установленных сертификатов. (v2.0.3)
.DESCRIPTION
    Использует Get-ChildItem для поиска сертификатов. Позволяет фильтровать.
    Формирует $Details со списком 'certificates'.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.PARAMETER TargetIP [string] Обязательный. IP/Имя хоста (для логирования).
.PARAMETER Parameters [hashtable] Опциональный. Параметры фильтра: subject_like,
             issuer_like, thumbprint, require_private_key, eku_oid, min_days_warning.
.PARAMETER SuccessCriteria [hashtable] Опциональный. Критерии для массива 'certificates'
             в $Details (напр., @{ certificates=@{_condition_='all';_criteria_=@{days_left=@{'>'=14}}} }).
.PARAMETER NodeName [string] Опциональный. Имя узла для логирования.
.OUTPUTS Hashtable - Стандартизированный результат.
.NOTES
    Версия: 2.0.3 (Исправлен ErrorMessage при ошибке критерия).
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
#>
param(
    [Parameter(Mandatory = $true)][string]$TargetIP,
    [Parameter(Mandatory = $false)][hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)][hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)][string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ certificates = [System.Collections.Generic.List[object]]::new(); stores_checked = @() }

Write-Verbose "[$NodeName] Check-CERT_EXPIRY (v2.0.3): Начало проверки сертификатов на $TargetIP (локально)"

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Параметры фильтрации ---
    $SubjectLike = $Parameters.subject_like; $IssuerLike = $Parameters.issuer_like; $Thumbprint = $Parameters.thumbprint; $EkuOids = $Parameters.eku_oid
    $RequirePrivateKey = $false; if ($Parameters.ContainsKey('require_private_key')) { try { $RequirePrivateKey = [bool]$Parameters.require_private_key } catch { Write-Warning "..." } }
    $minDaysWarning = 30; if ($Parameters.ContainsKey('min_days_warning')) { $parsed=0; if([int]::TryParse($Parameters.min_days_warning,[ref]$parsed) -and $parsed -ge 0){$minDaysWarning=$parsed}else{Write-Warning "..."} }

    # --- 2. Поиск сертификатов ---
    $storesToSearch = @( @{ Path = "Cert:\LocalMachine\My"; Loc = "LocalMachine"; Name = "My" }, @{ Path = "Cert:\LocalMachine\WebHosting"; Loc = "LocalMachine"; Name = "WebHosting" }, @{ Path = "Cert:\CurrentUser\My"; Loc = "CurrentUser"; Name = "My" })
    $allFoundCertificates = [System.Collections.Generic.List[object]]::new(); $storeAccessErrors = [System.Collections.Generic.List[string]]::new()
    foreach ($storeInfo in $storesToSearch) {
        $certStorePath = $storeInfo.Path; $details.stores_checked.Add($certStorePath)
        try {
            $certsInStore = Get-ChildItem -Path $certStorePath -EA SilentlyContinue
            if ($certsInStore) { $allFoundCertificates.AddRange($certsInStore); Write-Verbose "... В '$certStorePath' найдено: $($certsInStore.Count)" }
            if ($Error.Count -gt 0 -and $Error[0].FullyQualifiedErrorId -match 'StoreCouldNotBeOpened') { $errMsg="Ошибка доступа к '$certStorePath': $($Error[0].Exception.Message)"; $storeAccessErrors.Add($errMsg); Write-Warning "... $errMsg"; $Error.Clear() }
        } catch { $errMsg="Критическая ошибка доступа к '$certStorePath': $($_.Exception.Message)"; $storeAccessErrors.Add($errMsg); Write-Warning "... $errMsg" }
    }
    if ($details.stores_checked.Count -gt 0) { $isAvailable = $true; if ($storeAccessErrors.Count -gt 0) { $details.access_errors = $storeAccessErrors } }
    else { $isAvailable = $false; $errorMessage = "Не удалось получить доступ ни к одному хранилищу."; throw $errorMessage }
    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: IsAvailable=$isAvailable. Найдено до фильтрации: $($allFoundCertificates.Count)."

    # --- 3. Фильтрация сертификатов ---
    $filteredCertificates = $allFoundCertificates; $filterApplied = $false
    if (-not [string]::IsNullOrWhiteSpace($Thumbprint)) { $filterApplied=$true; $t = $Thumbprint.Trim().ToUpper(); $filteredCertificates = $filteredCertificates |? { $_.Thumbprint -eq $t } }
    else { if (-not [string]::IsNullOrWhiteSpace($SubjectLike)) { $filterApplied=$true; $filteredCertificates = $filteredCertificates |? { $_.Subject -like $SubjectLike } }
           if (-not [string]::IsNullOrWhiteSpace($IssuerLike)) { $filterApplied=$true; $filteredCertificates = $filteredCertificates |? { $_.Issuer -like $IssuerLike } } }
    if ($RequirePrivateKey) { $filterApplied=$true; $filteredCertificates = $filteredCertificates |? { $_.HasPrivateKey } }
    if ($EkuOids -is [array] -and $EkuOids.Count -gt 0) { $filterApplied=$true; $filteredCertificates = $filteredCertificates |? { $eku = $_.Extensions |? {$_.Oid.FriendlyName -eq 'Enhanced Key Usage'}; $ekus = $eku.EnhancedKeyUsages; ($EkuOids |? {$ekus.Oid -contains $_}).Count -gt 0 } }
    if (-not $filterApplied) { Write-Warning "[$NodeName] Check-CERT_EXPIRY: Фильтры не заданы, обрабатываются все сертификаты." }
    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Сертификатов после фильтрации: $($filteredCertificates.Count)."

    # --- 4. Формирование $details.certificates ---
    $currentTime = Get-Date
    if ($filteredCertificates.Count -eq 0) { $details.message = "Сертификаты" + ($filterApplied ? ", соотв. фильтрам," : "") + " не найдены." }
    else {
        foreach ($cert in $filteredCertificates) {
            $daysLeft = [math]::Floor((New-TimeSpan -Start $currentTime -End $cert.NotAfter).TotalDays)
            $certInfo = [ordered]@{ thumbprint=$cert.Thumbprint; subject=$cert.Subject; issuer=$cert.Issuer; not_before=$cert.NotBefore.ToUniversalTime().ToString("o"); not_after=$cert.NotAfter.ToUniversalTime().ToString("o"); days_left=$daysLeft; has_private_key=$cert.HasPrivateKey; status="OK"; status_details=""; store_path=$cert.PSParentPath }
            if ($currentTime -gt $cert.NotAfter) { $certInfo.status="Expired"; $certInfo.status_details="Истек $($cert.NotAfter.ToLocalTime())" }
            elseif ($daysLeft -le $minDaysWarning) { $certInfo.status="Expiring (Warn)"; $certInfo.status_details="Истекает через $daysLeft дней (<= $minDaysWarning)" }
            $details.certificates.Add($certInfo)
        }
    }

    # --- 5. Проверка критериев успеха ---
    $failReason = $null
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            # <<< ИСПРАВЛЕНО: Устанавливаем errorMessage ТОЛЬКО если критерий не пройден/ошибка >>>
            if ($checkSuccess -ne $true) {
                $errorMessage = $failReason | Get-OrElse "Критерии успеха для сертификатов не пройдены."
                Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены/ошибка: $errorMessage"
            } else {
                # Критерии пройдены, errorMessage должен быть null (если не было ошибки доступа к хранилищу)
                if ($null -eq $details.access_errors) { $errorMessage = $null }
                else { $errorMessage = "Были ошибки доступа к некоторым хранилищам, но критерии пройдены для найденных сертификатов." } # Или не сбрасываем? Зависит от требований. Пока оставим null. $errorMessage = $null
                Write-Verbose "[$NodeName] ... SuccessCriteria пройдены."
            }
            # <<< КОНЕЦ ИСПРАВЛЕНИЯ >>>
        } else {
            $checkSuccess = $true; # По умолчанию успех, если нет критериев
            # Оставляем $errorMessage, если были ошибки доступа к хранилищам
            if ($details.access_errors) { $errorMessage = "Критерии не заданы, но были ошибки доступа к хранилищам."} else { $errorMessage = $null }
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка проверки сертификатов (IsAvailable=false)." }
    }

    # --- 6. Формирование результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< ОСНОВНОЙ CATCH >>>
    $isAvailable = $false; $checkSuccess = $null
    $critErrorMessage = "Критическая ошибка Check-CERT_EXPIRY: $($_.Exception.Message)"
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }
    if($details.stores_checked.Count -gt 0) { $detailsError.stores_checked = $details.stores_checked } # Сохраняем, что успели проверить
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$detailsError; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-CERT_EXPIRY: Критическая ошибка: $critErrorMessage"
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-CERT_EXPIRY (v2.0.3): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1
# --- Версия 2.0.2 --- Интеграция Test-SuccessCriteria
<#
.SYNOPSIS
    Скрипт проверки использования дискового пространства. (v2.0.2)
.DESCRIPTION
    Использует Get-Volume для получения информации о дисках.
    Формирует $Details с массивом 'disks'.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста (для логирования).
.PARAMETER Parameters
    [hashtable] Опциональный. Параметры: drives ([string[]]).
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для массива 'disks' в $Details
                (напр., @{ disks = @{ _condition_='all'; _criteria_=@{percent_free=@{'>'=10}}} }).
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
.NOTES
    Версия: 2.0.2 (Интеграция Test-SuccessCriteria).
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
    Требует Windows 8 / Server 2012+.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ disks = [System.Collections.Generic.List[object]]::new() }

Write-Verbose "[$NodeName] Check-DISK_USAGE (v2.0.2): Начало проверки дисков на $TargetIP (локально)"

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Выполнение Get-Volume ---
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Вызов Get-Volume..."
    $volumes = Get-Volume -ErrorAction Stop
    $isAvailable = $true # Успех, если нет исключения
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Get-Volume выполнен. Найдено томов: $($volumes.Count)"

    # --- 2. Фильтрация томов ---
    $targetDriveLetters = @(); if ($Parameters.ContainsKey('drives') -and $Parameters.drives -is [array]) { $targetDriveLetters = $Parameters.drives | ForEach-Object { $_.Trim().ToUpper() } }
    $filteredVolumes = $volumes | Where-Object { $_.DriveType -eq 'Fixed' -and $_.DriveLetter -ne $null -and (($targetDriveLetters.Count -eq 0) -or ($targetDriveLetters -contains $_.DriveLetter.ToString().ToUpper())) }
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Найдено Fixed дисков после фильтрации: $($filteredVolumes.Count)"

    # --- 3. Обработка томов и формирование $details.disks ---
    if ($filteredVolumes.Count -eq 0) {
        $details.message = "Нет локальных Fixed дисков" + ($targetDriveLetters.Count -gt 0 ? " (фильтр: $($targetDriveLetters -join ','))" : "") + "."
    } else {
        foreach ($vol in $filteredVolumes) {
            $driveLetter = $vol.DriveLetter.ToString().ToUpper()
            $diskInfo = [ordered]@{ drive_letter=$driveLetter; label=$vol.FileSystemLabel; filesystem=$vol.FileSystem; size_bytes=$vol.Size; free_bytes=$vol.SizeRemaining; used_bytes=($vol.Size - $vol.SizeRemaining); size_gb=$null; free_gb=$null; used_gb=$null; percent_free=$null; percent_used=$null }
            if ($diskInfo.size_bytes -gt 0) {
                $diskInfo.size_gb = [math]::Round($diskInfo.size_bytes / 1GB, 2); $diskInfo.free_gb = [math]::Round($diskInfo.free_bytes / 1GB, 2); $diskInfo.used_gb = [math]::Round($diskInfo.used_bytes / 1GB, 2)
                $diskInfo.percent_free = [math]::Round(($diskInfo.free_bytes / $diskInfo.size_bytes) * 100, 1); $diskInfo.percent_used = [math]::Round(($diskInfo.used_bytes / $diskInfo.size_bytes) * 100, 1)
            } else { $diskInfo.percent_free = 0; $diskInfo.percent_used = 0 } # Диск нулевого размера
            $details.disks.Add($diskInfo)
        }
    }

    # --- 4. Проверка критериев успеха ---
    $failReason = $null
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-DISK_USAGE: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            if ($checkSuccess -ne $true) { $errorMessage = $failReason | Get-OrElse "Критерии успеха для дисков не пройдены."; Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены/ошибка: $errorMessage" }
            else { $errorMessage = $null; Write-Verbose "[$NodeName] ... SuccessCriteria пройдены." }
        } else {
            $checkSuccess = $true; $errorMessage = $null
            Write-Verbose "[$NodeName] Check-DISK_USAGE: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка выполнения Get-Volume (IsAvailable=false)." }
    }

    # --- 5. Формирование результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< ОСНОВНОЙ CATCH >>>
    $isAvailable = $false; $checkSuccess = $null
    $critErrorMessage = "Критическая ошибка Check-DISK_USAGE: $($_.Exception.Message)"
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$detailsError; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-DISK_USAGE: Критическая ошибка: $critErrorMessage"
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-DISK_USAGE (v2.0.2): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1
# --- Версия 2.3.1 --- Интеграция Test-SuccessCriteria
<#
.SYNOPSIS
    Скрипт проверки доступности узла с помощью .NET Ping. (v2.3.1)
.DESCRIPTION
    Использует System.Net.NetworkInformation.Ping.
    Формирует $Details с результатами (RTT, потери и т.д.).
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.PARAMETER TargetIP
    [string] Обязательный. IP-адрес или имя хоста.
.PARAMETER Parameters
    [hashtable] Опциональный. Параметры: timeout_ms, count, buffer_size, ttl.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для полей в $Details
                (напр., @{ rtt_ms = @{'<='=100}; packet_loss_percent = @{'=='=0} }).
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
.NOTES
    Версия: 2.3.1 (Интеграция Test-SuccessCriteria).
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false          # Флаг доступности по результатам PING
$checkSuccess = $null         # Результат проверки критериев (изначально null)
$errorMessage = $null         # Сообщение об ошибке
$finalResult = $null          # Итоговый возвращаемый объект
# $details будет заполнен результатами пинга
$details = @{ target_ip = $TargetIP; packets_sent = 0; packets_received = 0; packet_loss_percent = 100; rtt_ms = $null; ip_address = $null; status_string = '[Error]' }

Write-Host "[$NodeName] Check-PING (v2.3.1 - .NET): Инициализация для $TargetIP" -ForegroundColor Magenta

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY БЛОКА >>>

    # --- 1. Получение параметров пинга ---
    $TimeoutMs = 1000; if ($Parameters.ContainsKey('timeout_ms') -and $Parameters.timeout_ms -ne $null -and [int]::TryParse($Parameters.timeout_ms, [ref]$null) -and $Parameters.timeout_ms -gt 0) { $TimeoutMs = [int]$Parameters.timeout_ms }
    $PingCount = 1; if ($Parameters.ContainsKey('count') -and $Parameters.count -ne $null -and [int]::TryParse($Parameters.count, [ref]$null) -and $Parameters.count -gt 0) { $PingCount = [int]$Parameters.count }
    $BufferSize = 32; if ($Parameters.ContainsKey('buffer_size') -and $Parameters.buffer_size -ne $null -and [int]::TryParse($Parameters.buffer_size, [ref]$null) -and $Parameters.buffer_size -gt 0) { $BufferSize = [int]$Parameters.buffer_size }
    $TtlValue = 128; if ($Parameters.ContainsKey('ttl') -and $Parameters.ttl -ne $null -and [int]::TryParse($Parameters.ttl, [ref]$null) -and $Parameters.ttl -gt 0) { $TtlValue = [int]$Parameters.ttl }
    $details.packets_sent = $PingCount # Сразу записываем в детали

    # --- 2. Выполнение пинга ---
    $pingSender = New-Object System.Net.NetworkInformation.Ping
    $pingOptions = New-Object System.Net.NetworkInformation.PingOptions($TtlValue, $true) # TTL, DontFragment
    $sendBuffer = [byte[]]::new($BufferSize)
    $resultsList = [System.Collections.Generic.List[System.Net.NetworkInformation.PingReply]]::new()
    $successCount = 0; $totalRtt = 0; $firstSuccessReply = $null

    Write-Verbose "[$NodeName] Check-PING: Отправка $PingCount ICMP запросов (Timeout: $TimeoutMs ms)..."
    for ($i = 1; $i -le $PingCount; $i++) {
        $reply = $null
        try {
            $reply = $pingSender.Send($TargetIP, $TimeoutMs, $sendBuffer, $pingOptions)
            $resultsList.Add($reply)
            if ($reply.Status -eq [System.Net.NetworkInformation.IPStatus]::Success) {
                $successCount++; $totalRtt += $reply.RoundtripTime
                if ($null -eq $firstSuccessReply) { $firstSuccessReply = $reply }
            }
            Write-Verbose "[$NodeName] Check-PING: Попытка $i - Статус: $($reply.Status), RTT: $($reply.RoundtripTime)ms"
        } catch [System.Net.NetworkInformation.PingException] {
            # КРИТИЧЕСКАЯ ошибка - пинг невозможен
            $errorMessage = "Ошибка PingException для '$TargetIP': $($_.Exception.Message)"
            Write-Warning "[$NodeName] Check-PING: $errorMessage"
            $details.error = $errorMessage; $details.ErrorRecord = $_.ToString()
            # IsAvailable остается false (значение по умолчанию)
            throw $errorMessage # Прерываем выполнение, чтобы попасть в основной catch
        } catch {
             # Другая ошибка при отправке - логируем, но продолжаем (возможно, следующие пройдут)
             $otherError = "Ошибка при отправке пинга ($i/$PingCount) для '$TargetIP': $($_.Exception.Message)"
             Write-Warning "[$NodeName] Check-PING: $otherError"
             if (-not $details.ContainsKey('ping_errors')) { $details.ping_errors = [System.Collections.Generic.List[string]]::new() }
             $details.ping_errors.Add($otherError)
        }
        if ($PingCount -gt 1 -and $i -lt $PingCount) { Start-Sleep -Milliseconds 100 }
    } # Конец for

    # --- 3. Анализ результатов пинга и заполнение $details ---
    $details.packets_received = $successCount
    $details.packet_loss_percent = if ($PingCount -gt 0) { [math]::Round((($PingCount - $successCount) / $PingCount) * 100) } else { 0 }

    if ($successCount -gt 0) {
        $isAvailable = $true # Пинг УСПЕШЕН (хотя бы один ответ)
        $errorMessage = $null # Сбрасываем ошибку, если она была от неудачных попыток
        $details.status_string = 'Success'
        $details.rtt_ms = if ($successCount -gt 0) { [int][math]::Round($totalRtt / $successCount) } else { $null }
        $details.ip_address = $firstSuccessReply.Address.ToString()
        Write-Verbose "[$NodeName] Check-PING: Пинг успешен. IsAvailable=True. Усп: $successCount/$PingCount. RTT: $($details.rtt_ms)ms."
    } else {
        # IsAvailable остается false
        $statusText = if ($resultsList.Count -gt 0) { $resultsList[0].Status.ToString() } else { "[Нет ответа]" }
        $errorMessage = "Ошибка PING для '$TargetIP': Нет успешных ответов ($successCount/$PingCount). Статус первого: $statusText"
        $details.status_string = $statusText
        $details.error = $errorMessage # Добавляем ошибку в детали
        Write-Warning "[$NodeName] Check-PING: $errorMessage"
    }

    # --- 4. Проверка критериев успеха (вызов универсальной функции) ---
    $failReason = $null
    if ($isAvailable -eq $true) { # Проверяем критерии только если пинг прошел
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-PING: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed # $true, $false или $null
            $failReason = $criteriaResult.FailReason

            if ($checkSuccess -ne $true) { # Если $false или $null (ошибка критерия)
                $errorMessage = $failReason | Get-OrElse "Критерии успеха не пройдены."
                Write-Verbose "[$NodeName] Check-PING: SuccessCriteria НЕ пройдены/ошибка: $errorMessage"
            } else {
                Write-Verbose "[$NodeName] Check-PING: SuccessCriteria пройдены."
                # Убедимся, что errorMessage пуст, если критерии пройдены
                # (на случай, если были ошибки отдельных пингов, но общий результат прошел критерии)
                $errorMessage = $null
            }
        } else {
            # Критерии не заданы - успех, если пинг прошел
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-PING: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        # Пинг не прошел ($isAvailable = $false) -> CheckSuccess остается $null
        $checkSuccess = $null
        # $errorMessage уже установлен выше при анализе результатов пинга
        if ([string]::IsNullOrEmpty($errorMessage)) {
             $errorMessage = "Ошибка PING (IsAvailable=false)." # На всякий случай
        }
    }

    # --- 5. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

# <<< Закрываем основной try >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ошибок (например, PingException при throw) ---
    $isAvailable = $false; $checkSuccess = $null
    $critErrorMessage = "Критическая ошибка Check-PING для '$TargetIP': $($_.Exception.Message)"
    # Добавляем детали ошибки, сохраняя уже собранные детали, если они есть
    if ($null -eq $details) { $details = @{} } # На случай, если $details не инициализировались
    $details.error = $critErrorMessage; $details.ErrorRecord = $_.ToString()
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$details; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-PING: Критическая ошибка: $critErrorMessage"
} # <<< Закрываем основной catch >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Host "[$NodeName] Check-PING (v2.3.1): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr" -ForegroundColor Magenta
return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1
# --- Версия 2.0.2 --- Интеграция Test-SuccessCriteria
<#
.SYNOPSIS
    Получает список запущенных процессов. (v2.0.2)
.DESCRIPTION
    Использует Get-Process. Позволяет фильтровать/сортировать.
    Формирует $Details с массивом 'processes'.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста (для логирования).
.PARAMETER Parameters
    [hashtable] Опциональный. Параметры: process_names, include_username,
                include_path, sort_by, sort_descending, top_n.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для массива 'processes' в $Details
                (напр., @{ processes = @{ _condition_='none'; _where_=@{name='malware*'} } }).
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
.NOTES
    Версия: 2.0.2 (Интеграция Test-SuccessCriteria).
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ processes = [System.Collections.Generic.List[object]]::new() }

Write-Verbose "[$NodeName] Check-PROCESS_LIST (v2.0.2): Начало получения списка процессов на $TargetIP (локально)"

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>

    # --- 1. Обработка параметров ---
    $processNamesFilter = $null; $filteringByName = $false
    if ($Parameters.ContainsKey('process_names') -and $Parameters.process_names -is [array] -and $Parameters.process_names.Count -gt 0) { $processNamesFilter = $Parameters.process_names; $filteringByName = $true }
    $includeUsername = ($Parameters.ContainsKey('include_username') -and ([bool]$Parameters.include_username))
    $includePath = ($Parameters.ContainsKey('include_path') -and ([bool]$Parameters.include_path))
    $sortByInput = $Parameters.sort_by | Get-OrElse 'Name'
    $validSortFields = @('id', 'name', 'cpu_seconds', 'memory_ws_mb', 'start_time'); $sortByActual = switch ($sortByInput.ToLower()) { 'memory'|'mem'|'ws' {$s='memory_ws_mb'}; 'cpu' {$s='cpu_seconds'}; default {if($sortByInput -in $validSortFields){$sortByInput}else{'name'}}}; if($sortByActual -notin $validSortFields){$sortByActual = 'name'}
    $sortDesc = ($Parameters.ContainsKey('sort_descending') -and ([bool]$Parameters.sort_descending))
    $topN = $null; if ($Parameters.ContainsKey('top_n') -and $Parameters.top_n -ne $null) { $parsedTopN = 0; if ([int]::TryParse($Parameters.top_n, [ref]$parsedTopN) -and $parsedTopN -gt 0) { $topN = $parsedTopN } }

    # --- 2. Выполнение Get-Process ---
    $getProcessParams = @{ ErrorAction = 'Stop' }; if ($filteringByName) { $getProcessParams.Name = $processNamesFilter; $getProcessParams.ErrorAction = 'SilentlyContinue' }
    Write-Verbose "[$NodeName] Check-PROCESS_LIST: Вызов Get-Process..."
    $processesRaw = Get-Process @getProcessParams
    $processNotFoundError = $null; if ($filteringByName -and $Error.Count -gt 0 -and $Error[0].CategoryInfo.Reason -eq 'ProcessNotFoundException') { $processNotFoundError = $Error[0].Exception.Message; $Error.Clear() }
    $isAvailable = $true # Успех, если не было необработанного исключения
    $processCount = if ($processesRaw) { @($processesRaw).Count } else { 0 }
    Write-Verbose "[$NodeName] Check-PROCESS_LIST: Get-Process выполнен. Найдено: $processCount."

    # --- 3. Обработка результата и формирование $details.processes ---
    if ($processCount -gt 0) {
        $processedList = foreach ($proc in $processesRaw) {
             $procInfo = [ordered]@{ id=$proc.Id; name=$proc.ProcessName; cpu_seconds=$null; memory_ws_mb=$null; username=$null; path=$null; start_time=$null }
             try { $procInfo.cpu_seconds = [math]::Round($proc.CPU, 2) } catch { }
             try { $procInfo.memory_ws_mb = [math]::Round($proc.WS / 1MB, 1) } catch { }
             try { $procInfo.start_time = $proc.StartTime.ToUniversalTime().ToString("o") } catch { }
             if ($includeUsername) { try { $ownerInfo = Get-CimInstance -ClassName Win32_Process -Filter "ProcessId = $($proc.Id)" | Select-Object -ExpandProperty Owner -EA SilentlyContinue; $procInfo.username = if ($ownerInfo?.User) { "$($ownerInfo.Domain)\$($ownerInfo.User)" } else { '[N/A]' } } catch { $procInfo.username = '[Access Error]' } }
             if ($includePath) { try { $procPath = $proc.Path; if (-not $procPath -and $proc.MainModule) { try { $procPath = $proc.MainModule.FileName } catch {} }; $procInfo.path = $procPath } catch { $procInfo.path = '[Access Error]' } }
             [PSCustomObject]$procInfo
        }
        try { $processedList = $processedList | Sort-Object -Property $sortByActual -Descending:$sortDesc } catch { Write-Warning "... Ошибка сортировки ..."; $processedList = $processedList | Sort-Object 'name' }
        if ($topN -gt 0) { $processedList = $processedList | Select-Object -First $topN }
        $details.processes.AddRange($processedList)
    } elseif ($filteringByName) { $details.message = "Процессы по фильтру '$($processNamesFilter -join ', ')' не найдены." }
    else { $details.message = "Список процессов пуст." }

    # --- 4. Проверка критериев успеха ---
    $failReason = $null
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-PROCESS_LIST: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            if ($checkSuccess -ne $true) { $errorMessage = $failReason | Get-OrElse "Критерии успеха для процессов не пройдены."; Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены/ошибка: $errorMessage" }
            else { $errorMessage = $null; Write-Verbose "[$NodeName] ... SuccessCriteria пройдены." }
        } else {
            $checkSuccess = $true; $errorMessage = $null
            Write-Verbose "[$NodeName] Check-PROCESS_LIST: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка получения списка процессов (IsAvailable=false)." }
    }

    # --- 5. Формирование результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch { # <<< ОСНОВНОЙ CATCH >>>
    $isAvailable = $false; $checkSuccess = $null
    $critErrorMessage = "Критическая ошибка Check-PROCESS_LIST: $($_.Exception.Message)"
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$detailsError; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-PROCESS_LIST: Критическая ошибка: $critErrorMessage"
} # <<< КОНЕЦ ОСНОВНОГО CATCH >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-PROCESS_LIST (v2.0.2): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1
# --- Версия 2.0.1 --- Интеграция Test-SuccessCriteria
<#
.SYNOPSIS
    Проверяет статус указанной системной службы. (v2.0.1)
.DESCRIPTION
    Использует Get-Service для получения статуса службы.
    Формирует $Details с информацией о службе.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста (для логирования).
.PARAMETER Parameters
    [hashtable] Обязательный. Должен содержать 'service_name'.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для полей в $Details
                (напр., @{ status = 'Running'; start_type = 'Automatic' }).
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
.NOTES
    Версия: 2.0.1 (Интеграция Test-SuccessCriteria).
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ service_name = $null } # Базовые детали

Write-Verbose "[$NodeName] Check-SERVICE_STATUS (v2.0.1): Начало проверки для $TargetIP (локально)"

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY >>>
    # 1. Валидация параметра service_name
    $serviceName = $Parameters.service_name
    if (-not $serviceName -or $serviceName -isnot [string] -or $serviceName.Trim() -eq '') {
        throw "Параметр 'service_name' отсутствует или пуст."
    }
    $serviceName = $serviceName.Trim()
    $details.service_name = $serviceName
    Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Проверяемая служба '$serviceName'"

    # 2. Выполнение Get-Service (локально)
    $service = $null
    try {
        Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Вызов Get-Service -Name '$serviceName'..."
        $service = Get-Service -Name $serviceName -ErrorAction Stop
        # --- УСПЕХ Get-Service ---
        $isAvailable = $true # Проверка выполнена
        $currentStatus = $service.Status.ToString()
        Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Служба найдена. Статус: $currentStatus"
        # Заполняем $Details
        $details.status = $currentStatus
        $details.display_name = $service.DisplayName
        $details.start_type = $service.StartType.ToString()
        $details.can_stop = $service.CanStop
        # Добавьте другие нужные свойства, если необходимо
        # $details.can_pause_and_continue = $service.CanPauseAndContinue

    } catch [Microsoft.PowerShell.Commands.ServiceCommandException] {
        # --- ОШИБКА: Служба не найдена ---
        $isAvailable = $false
        $errorMessage = "Служба '$serviceName' не найдена на '$($env:COMPUTERNAME)'."
        $details.error = $errorMessage
        Write-Warning "[$NodeName] Check-SERVICE_STATUS: $errorMessage"
        # CheckSuccess остается $null
    } catch {
        # --- ОШИБКА: Другая ошибка Get-Service ---
        $isAvailable = $false
        $errorMessage = "Ошибка Get-Service для '$serviceName': $($_.Exception.Message)"
        $details.error = $errorMessage; $details.ErrorRecord = $_.ToString()
        Write-Warning "[$NodeName] Check-SERVICE_STATUS: $errorMessage"
        # CheckSuccess остается $null
    }

    # --- 3. Проверка критериев успеха (вызов универсальной функции) ---
    $failReason = $null
    if ($isAvailable -eq $true) { # Проверяем критерии только если Get-Service успешен
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            if ($checkSuccess -ne $true) { # Если $false или $null (ошибка критерия)
                $errorMessage = $failReason | Get-OrElse "Критерии успеха не пройдены."
                Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria НЕ пройдены/ошибка: $errorMessage"
            } else {
                 Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria пройдены."
                 # Если критерии пройдены, убедимся, что сообщение об ошибке пустое
                 $errorMessage = $null
            }
        } else {
            # Критерии не заданы
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        # Get-Service не удался ($isAvailable = $false) -> CheckSuccess остается $null
        $checkSuccess = $null
        # $errorMessage уже установлен в блоках catch выше
        if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка проверки статуса службы (IsAvailable=false)." }
    }

    # --- 4. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

# <<< Закрываем основной try >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ошибок (например, валидация параметра) ---
    $isAvailable = $false; $checkSuccess = $null
    $critErrorMessage = "Критическая ошибка Check-SERVICE_STATUS: $($_.Exception.Message)"
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }
    if ($details.service_name) { $detailsError.service_name = $details.service_name }
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$detailsError; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-SERVICE_STATUS: Критическая ошибка: $critErrorMessage"
} # <<< Закрываем основной catch >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-SERVICE_STATUS (v2.0.1): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1
# --- Версия 2.0.2 --- Исправлена зависимость от Get-OrElse
<#
.SYNOPSIS
    Выполняет SQL-запрос к MS SQL Server и возвращает результат. (v2.0.2)
.DESCRIPTION
    Подключается к SQL Server, выполняет запрос, обрабатывает результат
    согласно 'return_format'.
    Формирует $Details с результатом запроса (scalar_value, row_count, query_result).
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.NOTES
    Версия: 2.0.2 (Убрана зависимость от Get-OrElse).
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
    Требует модуль 'SqlServer'.
#>
param(
    [Parameter(Mandatory = $true)][string]$TargetIP,
    [Parameter(Mandatory = $false)][hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)][hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)][string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ server_instance=$TargetIP; database_name=$null; query_executed=$null; return_format_used='first_row' }

Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE (v2.0.2): Начало выполнения SQL на $TargetIP"

try { # <<< Основной TRY >>>
    # 1. Параметры
    $SqlServerInstance = $TargetIP; $DatabaseName = $Parameters.sql_database; $SqlQuery = $Parameters.sql_query; $SqlUsername = $Parameters.sql_username; $SqlPassword = $Parameters.sql_password
    if (-not $DatabaseName) { throw "Отсутствует 'sql_database'." }
    if (-not $SqlQuery) { throw "Отсутствует 'sql_query'." }
    if ($SqlUsername -and (-not $SqlPassword)) { throw "'sql_password' обязателен при 'sql_username'." }
    $details.database_name = $DatabaseName; $details.query_executed = $SqlQuery

    # --- ИСПРАВЛЕНО: Получение return_format без Get-OrElse ---
    $ReturnFormat = 'first_row' # Значение по умолчанию
    if ($Parameters.ContainsKey('return_format') -and (-not [string]::IsNullOrWhiteSpace($Parameters.return_format))) {
        $tempFormat = $Parameters.return_format.ToLower()
        $validFormats = @('first_row', 'all_rows', 'row_count', 'scalar', 'non_query')
        if ($tempFormat -in $validFormats) { $ReturnFormat = $tempFormat }
        else { throw "Недопустимое значение 'return_format': '$($Parameters.return_format)'." }
    }
    $details.return_format_used = $ReturnFormat
    Write-Verbose "... Используется return_format: $ReturnFormat"

    # --- ИСПРАВЛЕНО: Получение query_timeout_sec без Get-OrElse ---
    $QueryTimeoutSec = 30 # Значение по умолчанию
    if ($Parameters.ContainsKey('query_timeout_sec') -and $Parameters.query_timeout_sec -ne $null) {
        $parsedTimeout = 0
        if ([int]::TryParse($Parameters.query_timeout_sec, [ref]$parsedTimeout) -and $parsedTimeout -gt 0) {
            $QueryTimeoutSec = $parsedTimeout
        } else { Write-Warning "[$NodeName] ... Некорректное 'query_timeout_sec', используется $QueryTimeoutSec сек." }
    }
    Write-Verbose "... Используется query_timeout_sec: $QueryTimeoutSec сек."

    # 2. Параметры Invoke-Sqlcmd
    $invokeSqlParams = @{ ServerInstance=$SqlServerInstance; Database=$DatabaseName; Query=$SqlQuery; QueryTimeout=$QueryTimeoutSec; ErrorAction='Stop'; TrustServerCertificate=$true }
    if ($SqlUsername) { $securePassword = ConvertTo-SecureString -String $SqlPassword -AsPlainText -Force; $invokeSqlParams.Credential = New-Object System.Management.Automation.PSCredential($SqlUsername, $securePassword) }

    # 3. Проверка модуля SqlServer (без изменений)
    if (-not (Get-Command Invoke-Sqlcmd -EA SilentlyContinue)) { if (-not (Get-Module -ListAvailable -Name SqlServer)) { throw "Модуль 'SqlServer' не найден." }; try { Import-Module SqlServer -EA Stop } catch { throw "Не удалось загрузить модуль 'SqlServer'." } }

    # 4. Выполнение SQL-запроса
    Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Выполнение запроса (формат: $ReturnFormat)..."
    $queryResultData = $null; $nonQuerySuccess = $null
    if ($ReturnFormat -eq 'non_query') {
        try { Invoke-Sqlcmd @invokeSqlParams | Out-Null; $isAvailable = $true; $nonQuerySuccess = $true; $details.non_query_success = $true; Write-Verbose "... non-query успешно." }
        catch { $isAvailable = $false; $errorMessage = "Ошибка non-query SQL: $($_.Exception.Message)"; $details.error = $errorMessage; $details.ErrorRecord = $_.ToString(); $details.non_query_success = $false; Write-Warning "... $errorMessage" }
    } else {
        $queryResultData = Invoke-Sqlcmd @invokeSqlParams
        $isAvailable = $true
        Write-Verbose "... запрос с данными выполнен."
        # 5. Обработка результата (пересоздаем $details)
        $details = @{ server_instance=$SqlServerInstance; database_name=$DatabaseName; query_executed=$SqlQuery; return_format_used=$ReturnFormat }
        switch ($ReturnFormat) {
            'first_row' { $res=@{};$count=0; if($queryResultData){$arr=@($queryResultData);$count=$arr.Length;if($count -gt 0){$first=$arr[0];$first.PSObject.Properties|%{$res[$_.Name]=$_.Value}}}; $details.query_result=$res;$details.rows_returned=$count }
            'all_rows' { $res=[System.Collections.Generic.List[object]]::new();$count=0; if($queryResultData){foreach($r in @($queryResultData)){$h=@{};$r.PSObject.Properties|%{$h[$_.Name]=$_.Value};$res.Add($h)};$count=$res.Count}; $details.query_result=$res;$details.rows_returned=$count }
            'row_count' { $count=0; if($queryResultData){$count=@($queryResultData).Length}; $details.row_count=$count }
            'scalar' { $val=$null; if($queryResultData){$first=@($queryResultData)[0];if($first){$pName=($first.PSObject.Properties|select -f 1).Name;if($pName){$val=$first.$pName}}}; $details.scalar_value=$val }
        }
        Write-Verbose ("... результат обработан (формат: {0})." -f $ReturnFormat)
    }

    # 6. Проверка критериев успеха
    $failReason = $null
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            if ($checkSuccess -ne $true) {
                # --- ИСПРАВЛЕНО: Используем if или $() вместо Get-OrElse ---
                $errorMessage = if ([string]::IsNullOrWhiteSpace($failReason)) { "Критерии успеха SQL запроса не пройдены." } else { $failReason }
                Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены/ошибка: $errorMessage"
            } else { $errorMessage = $null; Write-Verbose "[$NodeName] ... SuccessCriteria пройдены." }
        } else {
            $checkSuccess = $true; $errorMessage = $null
            Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка выполнения SQL запроса (IsAvailable=false)." }
    }

    # 7. Формирование результата
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable -CheckSuccess $checkSuccess -Details $details -ErrorMessage $errorMessage

} catch { # <<< Основной CATCH >>>
    $isAvailable = $false; $checkSuccess = $null; $critErrorMessage = "Критическая ошибка Check-SQL_QUERY_EXECUTE: $($_.Exception.Message)"
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString(); server_instance=$TargetIP; database_name=$Parameters?.sql_database; query_executed=$Parameters?.sql_query }
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$detailsError; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-SQL_QUERY_EXECUTE: Критическая ошибка: $critErrorMessage"
}

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[null]' }; $checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[null]' }
Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE (v2.0.2): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"
return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1
# --- Версия 2.0.2 --- Исправлена зависимость от Get-OrElse
<#
.SYNOPSIS
    Выполняет SQL-запрос, извлекает XML, парсит и извлекает значения ключей. (v2.0.2)
.DESCRIPTION
    Подключается к MS SQL, выполняет запрос, ожидает XML, парсит, извлекает ключи.
    Формирует $Details с полем 'extracted_data'.
    Вызывает Test-SuccessCriteria для определения CheckSuccess.
.NOTES
    Версия: 2.0.2 (Убрана зависимость от Get-OrElse).
    Зависит от New-CheckResultObject, Test-SuccessCriteria.
    Требует модуль 'SqlServer'.
#>
param(
    [Parameter(Mandatory = $true)][string]$TargetIP,
    [Parameter(Mandatory = $false)][hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)][hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)][string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ server_instance=$TargetIP; database_name=$null; query_executed=$null; xml_source_column=$null; rows_returned=0; extracted_data=@{} }

Write-Verbose "[$NodeName] Check-SQL_XML_QUERY (v2.0.2): Начало выполнения SQL XML на $TargetIP"

try { # <<< Основной TRY >>>
    # 1. Параметры
    $SqlServerInstance = $TargetIP; $DatabaseName = $Parameters.sql_database; $SqlQuery = $Parameters.sql_query; $XmlColumnName = $Parameters.xml_column_name; $KeysToExtract = $Parameters.keys_to_extract; $SqlUsername = $Parameters.sql_username; $SqlPassword = $Parameters.sql_password
    $details.database_name = $DatabaseName; $details.query_executed = $SqlQuery; $details.xml_source_column = $XmlColumnName
    if (-not $DatabaseName) { throw "Отсутствует 'sql_database'." }
    if (-not $SqlQuery) { throw "Отсутствует 'sql_query'." }
    if (-not $XmlColumnName) { throw "Отсутствует 'xml_column_name'." }
    if (-not ($KeysToExtract -is [array]) -or $KeysToExtract.Count -eq 0) { throw "'keys_to_extract' должен быть непустым массивом." }
    if ($SqlUsername -and (-not $SqlPassword)) { throw "'sql_password' обязателен при 'sql_username'." }
    # --- ИСПРАВЛЕНО: Получение query_timeout_sec без Get-OrElse ---
    $QueryTimeoutSec = 30; if ($Parameters.ContainsKey('query_timeout_sec')) { $parsedTimeout=0; if([int]::TryParse($Parameters.query_timeout_sec,[ref]$parsedTimeout) -and $parsedTimeout -gt 0){$QueryTimeoutSec=$parsedTimeout} }
    Write-Verbose "... Используется query_timeout_sec: $QueryTimeoutSec сек."

    # 2. Параметры Invoke-Sqlcmd (без изменений)
    $invokeSqlParams = @{ ServerInstance=$SqlServerInstance; Database=$DatabaseName; Query=$SqlQuery; QueryTimeout=$QueryTimeoutSec; ErrorAction='Stop'; TrustServerCertificate=$true }
    if ($SqlUsername) { $securePassword = ConvertTo-SecureString -String $SqlPassword -AsPlainText -Force; $invokeSqlParams.Credential = New-Object System.Management.Automation.PSCredential($SqlUsername, $securePassword) }

    # 3. Проверка модуля SqlServer (без изменений)
    if (-not (Get-Command Invoke-Sqlcmd -EA SilentlyContinue)) { if (-not (Get-Module -ListAvailable -Name SqlServer)) { throw "Модуль 'SqlServer' не найден." }; try { Import-Module SqlServer -EA Stop } catch { throw "Не удалось загрузить модуль 'SqlServer'." } }

    # 4. Выполнение SQL-запроса
    Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Выполнение запроса..."
    $queryResult = Invoke-Sqlcmd @invokeSqlParams
    $isAvailable = $true

    # 5. Обработка результата и извлечение XML
    $xmlString = $null; $parseXml = $false; $errorMessageFromSqlOrXml = $null
    if ($queryResult -ne $null) {
        if ($queryResult -isnot [array]) { $queryResult = @($queryResult) }
        $details.rows_returned = $queryResult.Count
        if ($queryResult.Count -gt 0) {
            $firstRow = $queryResult[0]; Write-Verbose "... запрос вернул $($queryResult.Count) строк."
            if ($firstRow.PSObject.Properties.Name -contains $XmlColumnName) {
                $xmlValue = $firstRow.$XmlColumnName
                if ($xmlValue -ne $null -and $xmlValue -ne [System.DBNull]::Value) {
                    $xmlString = [string]$xmlValue; if (-not [string]::IsNullOrWhiteSpace($xmlString)) { $parseXml = $true; Write-Verbose "... получен непустой XML." } else { $errorMessageFromSqlOrXml = "Столбец '$XmlColumnName' пуст." }
                } else { $errorMessageFromSqlOrXml = "Столбец '$XmlColumnName' NULL." }
            } else { $errorMessageFromSqlOrXml = "Столбец '$XmlColumnName' не найден." }
        } else { $details.message = "SQL-запрос не вернул строк."; Write-Verbose $details.message }
    } else { $details.message = "SQL-запрос не вернул данных."; Write-Verbose $details.message }
    if ($errorMessageFromSqlOrXml) { $isAvailable = $false; $errorMessage = $errorMessageFromSqlOrXml; $details.error = $errorMessage; Write-Warning "... $errorMessage" }

    # 6. Парсинг XML и извлечение ключей
    if ($isAvailable -and $parseXml) {
        Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Попытка парсинга XML..."
        $xmlContentSample = $null; $xmlDoc = $null
        try {
            $xmlStringForParsing = $xmlString.Trim(); if ($xmlStringForParsing.StartsWith([char]0xFEFF)) { $xmlStringForParsing = $xmlStringForParsing.Substring(1) }
            if (-not $xmlStringForParsing.StartsWith('<')) { throw "Строка не начинается с '<'." }
            if ($xmlStringForParsing.Length > 500) { $xmlContentSample = $xmlStringForParsing.Substring(0, 500) + "..." } else { $xmlContentSample = $xmlStringForParsing }
            $xmlDoc = New-Object System.Xml.XmlDocument; $xmlDoc.LoadXml($xmlStringForParsing)
            if ($null -eq $xmlDoc.DocumentElement) { throw "Корневой элемент не найден." }
            Write-Verbose "... XML распарсен."
            $extractedData = @{}; foreach ($key in $KeysToExtract) { $value = $null; $el = $xmlDoc.DocumentElement.SelectSingleNode("./*[local-name()='$key']"); if ($el) { $value = $el.InnerText }; $extractedData[$key] = $value; Write-Verbose "... ключ '$key' = '$value'" }; $details.extracted_data = $extractedData
        } catch {
            $isAvailable = $false; $errorMessage = "Ошибка парсинга/обработки XML из '$XmlColumnName': $($_.Exception.Message)"; if ($errorMessage.Length > 500) { $errorMessage = $errorMessage.Substring(0, 500) + "..." }
            $details.error = $errorMessage; $details.ErrorRecord = $_.ToString(); if ($xmlContentSample) { $details.xml_content_sample = $xmlContentSample }; Write-Warning "... $errorMessage"
        }
    }

    # 7. Проверка критериев успеха
    $failReason = $null
    if ($isAvailable -eq $true) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.PSObject.Properties.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            if ($checkSuccess -ne $true) {
                 # --- ИСПРАВЛЕНО: Используем if вместо Get-OrElse ---
                 $errorMessage = if ([string]::IsNullOrWhiteSpace($failReason)) { "Критерии успеха для XML данных не пройдены." } else { $failReason }
                 Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены/ошибка: $errorMessage"
            } else { $errorMessage = $null; Write-Verbose "[$NodeName] ... SuccessCriteria пройдены." }
        } else {
            $checkSuccess = $true; $errorMessage = $null
            Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка выполнения SQL XML запроса (IsAvailable=false)." }
    }

    # 8. Формирование результата
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable -CheckSuccess $checkSuccess -Details $details -ErrorMessage $errorMessage

} catch { # <<< Основной CATCH >>>
    $isAvailable = $false; $checkSuccess = $null; $critErrorMessage = "Критическая ошибка Check-SQL_XML_QUERY: $($_.Exception.Message)"
    $detailsError = @{ error=$critErrorMessage; ErrorRecord=$_.ToString(); server_instance=$TargetIP; database_name=$Parameters?.sql_database; query_executed=$Parameters?.sql_query; xml_source_column=$Parameters?.xml_column_name }
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$detailsError; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-SQL_XML_QUERY: Критическая ошибка: $critErrorMessage"
}

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[null]' }; $checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[null]' }
Write-Verbose "[$NodeName] Check-SQL_XML_QUERY (v2.0.2): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"
return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md ====

---

**5. `powershell/StatusMonitorAgentUtils/Checks/README-Check-CERT_EXPIRY.md`**

```markdown
# Check-CERT_EXPIRY.ps1

**Назначение:**

Этот скрипт проверяет сроки действия локально установленных сертификатов Windows.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется только для логирования, так как скрипт выполняется локально на целевой машине.
2.  Определяет список стандартных хранилищ для поиска: `Cert:\LocalMachine\My`, `Cert:\LocalMachine\WebHosting`, `Cert:\CurrentUser\My`.
3.  Извлекает параметры **фильтрации** из `$Parameters`: `subject_like`, `issuer_like`, `thumbprint`, `require_private_key`, `eku_oid`.
4.  Извлекает **обязательный** критерий успеха `min_days_left` из `$SuccessCriteria`.
5.  Извлекает опциональный параметр `min_days_warning` из `$Parameters`.
6.  Итерирует по списку хранилищ:
    *   Выполняет `Get-ChildItem` для текущего хранилища (`ErrorAction = SilentlyContinue`).
    *   Добавляет найденные сертификаты в общий список `$allFoundCertificates`.
    *   Если при доступе к хранилищу возникла ошибка, записывает ее в `$storeAccessErrors`.
7.  Если были ошибки доступа к хранилищам, устанавливает `IsAvailable = $true` (т.к. часть работы могла быть выполнена), но запоминает ошибки для `ErrorMessage`.
8.  Применяет фильтры к общему списку `$allFoundCertificates`:
    *   Приоритет отдается фильтру по `thumbprint`.
    *   Если отпечаток не указан, применяются фильтры `subject_like` и `issuer_like`.
    *   Применяются фильтры `require_private_key` и `eku_oid`, если они заданы.
9.  Если после фильтрации сертификатов не осталось, проверка считается успешной (`CheckSuccess = $true`).
10. Для каждого отфильтрованного сертификата:
    *   Рассчитывает количество дней до истечения (`days_left`).
    *   Определяет статус сертификата: `OK`, `Expired` (истек), `Expiring (Fail)` (осталось <= `min_days_left`), `Expiring (Warn)` (осталось <= `min_days_warning`), `Error` (ошибка расчета).
    *   Если статус `Expired` или `Expiring (Fail)`, устанавливает общий флаг `$overallCheckSuccess = $false` и добавляет сообщение в `$errorMessages`.
    *   Собирает информацию о сертификате (включая статус) в хэш-таблицу и добавляет ее в `$resultData.Details.certificates`.
11. Устанавливает итоговый `CheckSuccess` равным `$overallCheckSuccess`.
12. Если были ошибки (по критериям или ошибки доступа к хранилищам), формирует `ErrorMessage`.
13. Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста (используется диспетчером).
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами фильтрации.
*   `$SuccessCriteria` ([hashtable], Обязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `subject_like` ([string], Необязательный): Фильтр по имени субъекта (Common Name, CN). Можно использовать wildcard `*`. Пример: `"*.example.com"`.
*   `issuer_like` ([string], Необязательный): Фильтр по имени издателя сертификата. Можно использовать wildcard `*`. Пример: `"*My Internal CA*"`.
*   `thumbprint` ([string], Необязательный): Точный отпечаток (Thumbprint) сертификата для поиска. Если указан, фильтры `subject_like` и `issuer_like` игнорируются.
*   `require_private_key` ([bool], Необязательный, по умолч. `$false`): Искать только сертификаты, у которых есть соответствующий закрытый ключ в хранилище.
*   `eku_oid` ([string[]], Необязательный): Массив строк с идентификаторами объектов (OID) расширенного использования ключа (Extended Key Usage). Сертификат будет отобран, если он содержит *хотя бы один* из указанных OID. Примеры:
    *   `'1.3.6.1.5.5.7.3.1'` - Проверка подлинности сервера (Server Authentication - для SSL/TLS)
    *   `'1.3.6.1.5.5.7.3.2'` - Проверка подлинности клиента (Client Authentication)
    *   `'1.3.6.1.5.5.7.3.8'` - Временная метка (Time Stamping)
*   `min_days_warning` ([int], Необязательный, по умолч. 30): Количество дней до истечения, при котором статус сертификата в `$Details` будет помечен как "Expiring (Warn)". Не влияет на `CheckSuccess`.

**Критерии успеха (`$SuccessCriteria`)**:

*   `min_days_left` ([int], **Обязательный**): Минимальное количество полных дней, которое должно оставаться до истечения срока действия *каждого* найденного по фильтрам сертификата. Если хотя бы у одного сертификата осталось дней меньше или равно этому значению (или он уже истек), `CheckSuccess` будет `$false`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `certificates` (List<object>): Массив хэш-таблиц для каждого найденного и отфильтрованного сертификата. Каждая содержит:
        *   `thumbprint` (string): Отпечаток.
        *   `subject` (string): Имя субъекта.
        *   `issuer` (string): Имя издателя.
        *   `not_before` (string): Дата начала действия (UTC ISO 8601).
        *   `not_after` (string): Дата окончания действия (UTC ISO 8601).
        *   `days_left` (int): Количество полных оставшихся дней.
        *   `has_private_key` (bool): Наличие закрытого ключа.
        *   `status` (string): Рассчитанный статус (`OK`, `Expired`, `Expiring (Fail)`, `Expiring (Warn)`, `Error`).
        *   `status_details` (string): Пояснение к статусу.
        *   `store_path` (string): Путь к хранилищу, где найден сертификат.
    *   `stores_checked` (string[]): Список путей к хранилищам, в которых производился поиск.
    *   `message` (string): (Опционально) Сообщение, если сертификаты не найдены.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Проверить все SSL-сертификаты сервера (>30 дней)
{
  "node_id": 50,
  "method_id": 7, // ID для CERT_EXPIRY
  "is_enabled": true,
  "parameters": {
    "eku_oid": ["1.3.6.1.5.5.7.3.1"], // Server Auth
    "require_private_key": true,
    "min_days_warning": 60 // Предупреждать за 60 дней
  },
  "success_criteria": {
    "min_days_left": 30 // Должно оставаться больше 30 дней
  },
  "description": "Проверка SSL сертификатов сервера (>30 дней)"
}

// Пример 2: Проверить конкретный сертификат по отпечатку (>90 дней)
{
  "node_id": 51,
  "method_id": 7,
  "is_enabled": true,
  "parameters": {
    "thumbprint": "ВАШ_ОТПЕЧАТОК_СЕРТИФИКАТА_ЗДЕСЬ"
  },
  "success_criteria": {
    "min_days_left": 90
  },
  "description": "Проверка конкретного сертификата по отпечатку (>90 дней)"
}

Возможные ошибки и замечания:

    Права доступа: Для доступа к хранилищу LocalMachine требуются права администратора. Доступ к CurrentUser обычно есть у пользователя, от имени которого запущен агент.

    Доступность хранилищ: Если какое-то из стандартных хранилищ отсутствует или недоступно, скрипт запишет ошибку, но продолжит проверку остальных.

    Фильтрация: Убедитесь, что параметры фильтрации (subject_like, thumbprint и т.д.) заданы корректно для поиска нужных сертификатов. Если фильтры не заданы, будут проверяться все сертификаты в стандартных хранилищах.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md ====

---

**3. `powershell/StatusMonitorAgentUtils/Checks/README-Check-DISK_USAGE.md`**

```markdown
# Check-DISK_USAGE.ps1

**Назначение:**

Этот скрипт проверяет использование дискового пространства на локальных дисках, используя командлет `Get-Volume`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` напрямую не используется, так как скрипт выполняется локально на целевой машине (через `Invoke-Command`, если нужно).
2.  Вызывает `Get-Volume` для получения информации обо всех томах. Если команда не выполняется, устанавливает `IsAvailable = $false`.
3.  Фильтрует полученные тома:
    *   Оставляет только диски с `DriveType = 'Fixed'`.
    *   Оставляет только диски, имеющие букву (`DriveLetter`).
    *   Если в `$Parameters.drives` передан массив букв, оставляет только диски из этого списка (регистр не важен).
4.  Если после фильтрации дисков не осталось, проверка считается успешной (`CheckSuccess = $true`), в `$Details` добавляется соответствующее сообщение.
5.  Для каждого отфильтрованного диска:
    *   Рассчитывает общий размер, свободное/занятое место в байтах и ГБ, процент свободного/занятого места.
    *   Ищет применимый критерий успеха в `$SuccessCriteria`: сначала по букве диска (в верхнем регистре), затем по ключу `_default_`.
    *   Если найден критерий `min_percent_free`:
        *   Сравнивает рассчитанный процент свободного места с критерием.
        *   Устанавливает `criteria_passed = $true/$false` и `criteria_failed_reason`.
        *   Если критерий не пройден, устанавливает общий флаг `$overallCheckSuccess = $false` и добавляет сообщение в `$errorMessages`.
        *   Если значение `min_percent_free` некорректно, также считает критерий не пройденным.
    *   Добавляет собранную информацию о диске (включая результаты проверки критерия) в массив `$resultData.Details.disks`.
6.  Устанавливает итоговый `CheckSuccess` равным `$overallCheckSuccess`.
7.  Если были ошибки по критериям, объединяет сообщения из `$errorMessages` и записывает в `ErrorMessage`.
8.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста (используется диспетчером).
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `drives` ([string[]], Необязательный): Массив строк с буквами дисков, которые нужно проверить (например, `@('C', 'D')`). Регистр не важен. Если не указан или пуст, проверяются все локальные диски типа 'Fixed'.

**Критерии успеха (`$SuccessCriteria`)**:

*   Ожидается хэш-таблица, где ключи - **большие** буквы дисков ('C', 'D', ...) или специальный ключ `_default_`.
*   Значения - хэш-таблицы, содержащие критерии.
*   Поддерживаемый критерий:
    *   `min_percent_free` ([int], Необязательный): Минимально допустимый процент свободного места на диске. Если фактический процент меньше этого значения, `CheckSuccess` будет `$false`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `disks` (List<object>): Массив хэш-таблиц, по одной для каждого проверенного диска. Каждая хэш-таблица содержит:
        *   `drive_letter` (string)
        *   `label` (string)
        *   `filesystem` (string)
        *   `size_bytes` (long), `free_bytes` (long), `used_bytes` (long)
        *   `size_gb` (double), `free_gb` (double), `used_gb` (double)
        *   `percent_free` (double), `percent_used` (double)
        *   `criteria_applied` (hashtable/null): Примененный критерий.
        *   `criteria_passed` (bool/null): Результат проверки критерия.
        *   `criteria_failed_reason` (string/null): Причина провала критерия.
    *   `message` (string): (Опционально) Сообщение, если диски не найдены.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Проверить все локальные Fixed диски, нужно > 10% свободно на каждом
{
  "node_id": 10,
  "method_id": 5, // ID для DISK_USAGE
  "is_enabled": true,
  "parameters": null, // Проверяем все диски
  "success_criteria": {
    "_default_": { "min_percent_free": 10 }
  },
  "description": "Проверка свободного места (>10%) на всех дисках"
}

// Пример 2: Проверить диск C (>15%) и диск D (>20%)
{
  "node_id": 10,
  "method_id": 5, // ID для DISK_USAGE
  "is_enabled": true,
  "parameters": {
    "drives": ["C", "D"] // Проверяем только C и D
  },
  "success_criteria": {
    "C": { "min_percent_free": 15 },
    "D": { "min_percent_free": 20 }
  },
  "description": "Проверка места: C>15%, D>20%"
}

GNORE_WHEN_COPYING_END

Возможные ошибки и замечания:

    Версия ОС: Командлет Get-Volume доступен начиная с Windows 8 / Windows Server 2012. На более старых системах проверка не сработает.

    Права доступа: Обычно не требует повышенных прав для локального выполнения.

    Сетевые/Съемные диски: Скрипт по умолчанию проверяет только диски с DriveType = 'Fixed'. Другие типы (Network, Removable, CD-ROM) игнорируются.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.

    ОС Windows 8 / Server 2012 или новее.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md ====
# Check-PING.ps1

**Назначение:**

Этот скрипт выполняет проверку доступности сетевого узла с помощью ICMP эхо-запросов (пинг), используя стандартный командлет `Test-Connection`.

**Принцип работы:**

1.  Получает целевой IP-адрес или имя хоста (`TargetIP`) и опциональные параметры (`Parameters`) от диспетчера.
2.  Извлекает параметры для `Test-Connection` из `$Parameters`:
    *   `count` (количество запросов, по умолчанию 1).
    *   `buffer_size` (размер буфера, по умолчанию 32).
    *   `timeout_ms` (используется для расчета TTL в PowerShell 5.1, по умолчанию 1000).
3.  Выполняет `Test-Connection` к `$TargetIP`.
4.  **Если пинг успешен:**
    *   Устанавливает `IsAvailable = $true`.
    *   Извлекает время ответа (RTT) и фактический IP-адрес ответившего хоста.
    *   Заполняет `$Details` значениями `response_time_ms`, `ip_address` (ответивший), `target_ip` (запрошенный), `ping_count`.
    *   Проверяет `SuccessCriteria`: если задан `max_rtt_ms` и RTT превышает его, устанавливает `CheckSuccess = $false` и добавляет `ErrorMessage`. Иначе `CheckSuccess = $true`.
5.  **Если пинг не прошел (ошибка `Test-Connection`):**
    *   Устанавливает `IsAvailable = $false`.
    *   Записывает сообщение об ошибке в `ErrorMessage` и `Details`.
    *   `CheckSuccess` остается `$null`.
6.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста для пинга.
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами для `Test-Connection`.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `count` ([int], Необязательный, по умолч. 1): Количество ICMP-запросов.
*   `buffer_size` ([int], Необязательный, по умолч. 32): Размер буфера ICMP в байтах.
*   `timeout_ms` ([int], Необязательный, по умолч. 1000): Используется для расчета TTL в PS 5.1. Не является прямым таймаутом `Test-Connection`.

**Критерии успеха (`$SuccessCriteria`)**:

*   `max_rtt_ms` ([int], Необязательный): Максимально допустимое среднее время ответа (RTT) в миллисекундах. Если фактическое RTT больше этого значения, `CheckSuccess` будет `$false`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `response_time_ms` (int): Время ответа в мс (если пинг успешен).
    *   `ip_address` (string): Фактический IP-адрес, ответивший на пинг.
    *   `target_ip` (string): IP-адрес или имя хоста, которое пинговали.
    *   `ping_count` (int): Количество отправленных пакетов.
    *   `success_criteria_failed` (string): (Опционально) Причина неудачи по критерию `max_rtt_ms`.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Простой пинг
{
  "node_id": 15,
  "method_id": 1, // ID для PING
  "is_enabled": true,
  "parameters": {
    "count": 3 // Отправить 3 пакета
  },
  "success_criteria": null, // Критериев нет
  "description": "Пинг сервера SRV-DB (3 пакета)"
}

// Пример 2: Пинг с проверкой RTT
{
  "node_id": 22,
  "method_id": 1, // ID для PING
  "is_enabled": true,
  "parameters": null, // Параметры по умолчанию
  "success_criteria": {
    "max_rtt_ms": 100 // RTT должен быть не более 100 мс
  },
  "description": "Пинг удаленного офиса (RTT < 100ms)"
}


Возможные ошибки и замечания:

    Брандмауэр: Проверьте настройки брандмауэра на целевой машине и промежуточных устройствах (ICMP Echo Request/Reply должны быть разрешены).

    Разрешение имен: Если в качестве TargetIP используется имя хоста, машина, где выполняется скрипт, должна уметь его разрешать в IP-адрес.

    PowerShell Core vs 5.1: Командлет Test-Connection имеет разные параметры в разных версиях. Скрипт пытается это учесть, но поведение может немного отличаться. Параметры BufferSize и TimeToLive используются только в PS 5.1.

    Таймаут: Стандартный таймаут Test-Connection может быть не очень гибким. Для более точного контроля таймаута может потребоваться использование .NET классов (System.Net.NetworkInformation.Ping).

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md ====

---

**4. `powershell/StatusMonitorAgentUtils/Checks/README-Check-PROCESS_LIST.md`**

```markdown
# Check-PROCESS_LIST.ps1

**Назначение:**

Этот скрипт получает список запущенных процессов на локальной машине (или удаленной, если вызван через `Invoke-Command` диспетчером), используя командлет `Get-Process`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется только для логирования, так как `Get-Process` выполняется в контексте машины, где запущен скрипт.
2.  Формирует параметры для `Get-Process` на основе `$Parameters`:
    *   Если задан `process_names`, использует его для фильтрации по имени (с `ErrorAction = SilentlyContinue`, чтобы не падать, если процесс не найден).
    *   Если `process_names` не задан, получает все процессы (с `ErrorAction = Stop`).
3.  Вызывает `Get-Process`. Если произошла критическая ошибка (например, сам командлет не доступен), устанавливает `IsAvailable = $false`.
4.  Если `Get-Process` вернул пустой результат *при фильтрации по имени*, устанавливает `IsAvailable = $true`, `CheckSuccess = $true` и добавляет сообщение в `Details.message`.
5.  Если `Get-Process` вернул процессы:
    *   Устанавливает `IsAvailable = $true`.
    *   Итерирует по каждому объекту процесса:
        *   Извлекает базовые данные: `id`, `name`, `cpu_seconds`, `memory_ws_mb`.
        *   Опционально (если запрошено `include_username`): Пытается получить имя пользователя через `Get-CimInstance Win32_Process` (более надежный способ). Обрабатывает ошибки доступа.
        *   Опционально (если запрошено `include_path`): Пытается получить путь к исполняемому файлу из свойства `Path` или `MainModule.FileName`. Обрабатывает ошибки доступа.
        *   Опционально: Пытается получить время запуска `start_time`.
        *   Собирает данные в объект `[PSCustomObject]`.
    *   Сортирует полученный список процессов согласно параметрам `sort_by` и `sort_descending` (с поддержкой псевдонимов 'memory', 'cpu'). Обрабатывает некорректные поля сортировки.
    *   Ограничивает список первыми `top_n` элементами, если указано.
    *   Добавляет итоговый список в `$resultData.Details.processes`.
    *   Устанавливает `CheckSuccess = $true` (критерии пока не реализованы).
6.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста (используется диспетчером).
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха (пока не используется).
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `process_names` ([string[]], Необязательный): Массив имен процессов для фильтрации (можно использовать `*`, например, `"sql*"`). Если не указан, выводятся все процессы.
*   `include_username` ([bool], Необязательный, по умолч. `$false`): Включать ли имя пользователя, запустившего процесс. Может требовать повышенных прав.
*   `include_path` ([bool], Необязательный, по умолч. `$false`): Включать ли путь к исполняемому файлу процесса. Может быть медленным и требовать повышенных прав.
*   `sort_by` ([string], Необязательный, по умолч. `'Name'`): Поле для сортировки. Допустимые значения (регистр не важен): `'Name'`, `'Id'`, `'CPU'` (или `'cpu_seconds'`), `'Memory'` (или `'memory_ws_mb'`, `'mem'`, `'ws'`), `'start_time'`.
*   `sort_descending` ([bool], Необязательный, по умолч. `$false`): Сортировать по убыванию?
*   `top_n` ([int], Необязательный): Отобразить только указанное количество процессов после сортировки.

**Критерии успеха (`$SuccessCriteria`)**:

*   **Пока не реализованы.** В текущей версии `CheckSuccess` всегда `$true`, если `IsAvailable = $true`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `processes` (List<object>): Массив хэш-таблиц, по одной для каждого процесса (или пустой). Каждая хэш-таблица содержит:
        *   `id` (int)
        *   `name` (string)
        *   `cpu_seconds` (double/null): Общее время процессора в секундах.
        *   `memory_ws_mb` (double/null): Рабочий набор памяти в МБ.
        *   `username` (string/null): Имя пользователя (если запрошено и доступно).
        *   `path` (string/null): Путь к файлу (если запрошено и доступно).
        *   `start_time` (string/null): Время запуска в UTC ISO 8601 (если доступно).
    *   `message` (string): (Опционально) Сообщение, если процессы по фильтру не найдены.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Топ 3 процесса по использованию памяти
{
  "node_id": 40,
  "method_id": 2, // ID для PROCESS_LIST
  "is_enabled": true,
  "parameters": {
    "sort_by": "Memory",
    "sort_descending": true,
    "top_n": 3,
    "include_username": false,
    "include_path": true // Получим путь
  },
  "success_criteria": null,
  "description": "Топ 3 процесса по памяти (с путем)"
}

// Пример 2: Проверить наличие процесса explorer.exe
{
  "node_id": 41,
  "method_id": 2, // ID для PROCESS_LIST
  "is_enabled": true,
  "parameters": {
    "process_names": ["explorer.exe"], // Ищем конкретный процесс
    "include_username": true // Получим пользователя
  },
  "success_criteria": null, // Пока не можем проверить, найден ли он
  "description": "Проверка наличия explorer.exe"
}


Возможные ошибки и замечания:

    Права доступа: Для получения username и path для всех процессов (особенно системных или запущенных другими пользователями) могут потребоваться права администратора. При недостатке прав соответствующие поля будут содержать [Ошибка доступа] или [Недоступен].

    Производительность: Получение path и username (особенно через WMI) может быть ресурсоемким, особенно при проверке большого количества процессов или на слабых машинах. Используйте include_username = $true и include_path = $true с осторожностью.

    Сортировка: Используются базовые свойства для сортировки. Сортировка по CPU может быть не всегда точной из-за того, как Get-Process его измеряет.

    Критерии: Реализация критериев успеха (например, проверка существования/отсутствия процесса, пороговые значения CPU/памяти) потребует доработки скрипта.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md ====

---

**2. `powershell/StatusMonitorAgentUtils/Checks/README-Check-SERVICE_STATUS.md`**

```markdown
# Check-SERVICE_STATUS.ps1

**Назначение:**

Этот скрипт проверяет статус указанной системной службы Windows с помощью командлета `Get-Service`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера.
2.  Извлекает обязательное имя службы из `$Parameters.service_name`.
3.  Определяет, является ли `$TargetIP` удаленным хостом. Если да, будет использовать параметр `-ComputerName` для `Get-Service` (при вызове через `Invoke-Command`).
4.  Вызывает `Get-Service` с указанным именем и (если нужно) `-ComputerName`.
5.  **Если `Get-Service` вернул объект службы:**
    *   Устанавливает `IsAvailable = $true`.
    *   Извлекает текущий статус (`Running`, `Stopped`, `Paused`, etc.), отображаемое имя, тип запуска.
    *   Заполняет `$Details` этой информацией.
    *   Проверяет `$SuccessCriteria`: если задан ключ `status`, сравнивает текущий статус с требуемым. Если `SuccessCriteria.status` не задан, по умолчанию ожидает статус `'Running'`. Устанавливает `CheckSuccess` в `$true` или `$false` и `ErrorMessage`, если статус не соответствует.
6.  **Если `Get-Service` выдал ошибку `ServiceCommandException` (служба не найдена):**
    *   Устанавливает `IsAvailable = $false`.
    *   `CheckSuccess` остается `$null`.
    *   Записывает сообщение "Служба не найдена" в `ErrorMessage` и `Details`.
7.  **Если `Get-Service` выдал другую ошибку (нет доступа, RPC недоступен и т.д.):**
    *   Устанавливает `IsAvailable = $false`.
    *   `CheckSuccess` остается `$null`.
    *   Записывает сообщение об ошибке в `ErrorMessage` и `Details`.
8.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста. Используется диспетчером для `Invoke-Command`.
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `service_name` ([string], **Обязательный**): Имя службы Windows (короткое, например, 'Spooler', 'wuauserv').

**Критерии успеха (`$SuccessCriteria`)**:

*   `status` ([string], Необязательный, по умолч. `'Running'`): Ожидаемый статус службы. `CheckSuccess` будет `$true`, только если текущий статус службы равен этому значению. Допустимые значения зависят от `Get-Service` (обычно 'Running', 'Stopped', 'Paused').

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `service_name` (string): Имя проверенной службы.
    *   `status` (string): Текущий статус службы (если удалось получить).
    *   `display_name` (string): Отображаемое имя службы.
    *   `start_type` (string): Тип запуска службы.
    *   `can_stop` (bool): Может ли служба быть остановлена.
    *   `success_criteria_failed` (string): (Опционально) Причина несоответствия критерию `status`.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Проверить, что служба 'wuauserv' запущена
{
  "node_id": 55,
  "method_id": 4, // ID для SERVICE_STATUS
  "is_enabled": true,
  "parameters": {
    "service_name": "wuauserv"
  },
  "success_criteria": null, // Используется критерий по умолчанию (status = 'Running')
  "description": "Проверка службы Windows Update"
}

// Пример 2: Проверить, что служба 'BITS' остановлена
{
  "node_id": 55,
  "method_id": 4, // ID для SERVICE_STATUS
  "is_enabled": true,
  "parameters": {
    "service_name": "BITS"
  },
  "success_criteria": {
    "status": "Stopped" // Явно указываем ожидаемый статус
  },
  "description": "Проверка, что служба BITS остановлена"
}

Возможные ошибки и замечания:

    Права доступа: Для проверки служб на удаленной машине с помощью Get-Service -ComputerName (через Invoke-Command) требуются соответствующие права (обычно административные) и настроенный WinRM.

    Имя службы: Убедитесь, что service_name указано правильно (короткое имя, а не отображаемое).

    WinRM: При удаленных проверках необходима корректная настройка WinRM на целевой машине и, возможно, на машине агента (TrustedHosts или Kerberos/HTTPS).

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md ====

---

**7. `powershell/StatusMonitorAgentUtils/Checks/README-Check-SQL_QUERY_EXECUTE.md`**

```markdown
# Check-SQL_QUERY_EXECUTE.ps1

**Назначение:**

Этот скрипт выполняет произвольный SQL-запрос к Microsoft SQL Server и возвращает результат в заданном формате.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется как имя SQL Server instance.
2.  Извлекает и валидирует обязательные параметры из `$Parameters`: `sql_database`, `sql_query`.
3.  Извлекает опциональный параметр `return_format` (по умолчанию `'first_row'`) и валидирует его значение.
4.  Извлекает опциональные параметры для SQL-аутентификации (`sql_username`, `sql_password`) и таймаут запроса (`query_timeout_sec`).
5.  Проверяет наличие модуля `SqlServer`. Если отсутствует, генерирует ошибку (`IsAvailable = $false`).
6.  Формирует параметры для `Invoke-Sqlcmd`, включая учетные данные.
7.  Выполняет SQL-запрос с помощью `Invoke-Sqlcmd`. Если произошла ошибка, устанавливает `IsAvailable = $false` и записывает ошибку.
8.  Если запрос выполнен успешно:
    *   Устанавливает `IsAvailable = $true` и `CheckSuccess = $true` (критерии пока не реализованы).
    *   Обрабатывает результат `$queryResultData` в соответствии с указанным `return_format`:
        *   `first_row`: Преобразует первую строку `DataRow` в хэш-таблицу и записывает в `Details.query_result`.
        *   `all_rows`: Преобразует все строки `DataRow` в массив хэш-таблиц и записывает в `Details.query_result`.
        *   `row_count`: Записывает количество строк в `Details.row_count`.
        *   `scalar`: Извлекает значение из первого столбца первой строки и записывает в `Details.scalar_value`.
        *   `non_query`: Записывает `$true` в `Details.non_query_success`.
    *   Записывает количество возвращенных строк (если применимо) в `Details.rows_returned`.
9.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): Имя или IP-адрес SQL Server instance.
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха (пока не используется).
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `sql_database` ([string], **Обязательный**): Имя базы данных.
*   `sql_query` ([string], **Обязательный**): SQL-запрос для выполнения.
*   `return_format` ([string], Необязательный, по умолч. `'first_row'`): Как интерпретировать и вернуть результат запроса. Допустимые значения:
    *   `'first_row'`: Вернуть первую строку как хэш-таблицу (`Details.query_result`).
    *   `'all_rows'`: Вернуть все строки как массив хэш-таблиц (`Details.query_result`). **Осторожно с большими результатами!**
    *   `'row_count'`: Вернуть только количество строк (`Details.row_count`).
    *   `'scalar'`: Вернуть значение первого столбца первой строки (`Details.scalar_value`).
    *   `'non_query'`: Для запросов, не возвращающих данные (INSERT, UPDATE, DELETE, DDL). Возвращает `Details.non_query_success = $true` при успехе.
*   `sql_username` ([string], Необязательный): Имя пользователя для SQL Server аутентификации.
*   `sql_password` ([string], Необязательный): Пароль для SQL Server аутентификации. **(Небезопасно)**.
*   `query_timeout_sec` ([int], Необязательный, по умолч. 30): Таймаут выполнения SQL-запроса.

**Критерии успеха (`$SuccessCriteria`)**:

*   **Пока не реализованы.** Можно будет добавить проверку возвращенных данных, например:
    *   Для `row_count`: `{ "expected_count": 5 }`, `{ "min_count": 1 }`, `{ "max_count": 10 }`
    *   Для `scalar`: `{ "expected_value": "OK" }`, `{ "value_less_than": 100 }`
    *   Для `first_row`/`all_rows`: Проверка значений в конкретных столбцах.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `server_instance` (string)
    *   `database_name` (string)
    *   `query_executed` (string)
    *   `return_format_used` (string)
    *   В зависимости от `return_format`:
        *   `query_result` (hashtable или List<object>): Результат для `first_row` или `all_rows`.
        *   `rows_returned` (int): Количество строк (для `first_row`, `all_rows`).
        *   `row_count` (int): Количество строк (для `row_count`).
        *   `scalar_value` (any): Скалярное значение (для `scalar`).
        *   `non_query_success` (bool): Результат выполнения (для `non_query`).
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Получить количество активных сессий
{
  "node_id": 61,
  "method_id": 9, // ID для SQL_QUERY_EXECUTE
  "is_enabled": true,
  "parameters": {
    "sql_database": "master",
    "sql_query": "SELECT COUNT(*) FROM sys.dm_exec_sessions WHERE is_user_process = 1;",
    "return_format": "scalar" // Вернуть одно значение
  },
  "success_criteria": null, // Можно добавить { "value_less_than": 50 }
  "description": "Количество активных SQL сессий"
}

// Пример 2: Проверить статус задачи в таблице
{
  "node_id": 61,
  "method_id": 9,
  "is_enabled": true,
  "parameters": {
    "sql_database": "ApplicationDB",
    "sql_query": "SELECT Status, LastRunTime FROM dbo.BackgroundTasks WHERE TaskName = 'DailyCleanup'",
    "return_format": "first_row" // Вернуть первую (и единственную?) строку
  },
  "success_criteria": null, // Можно добавить { "expected_Status": "Completed" }
  "description": "Статус задачи DailyCleanup"
}

// Пример 3: Выполнить процедуру очистки (non-query)
{
  "node_id": 61,
  "method_id": 9,
  "is_enabled": true,
  "parameters": {
    "sql_database": "ApplicationDB",
    "sql_query": "EXEC dbo.sp_CleanupOldLogs;",
    "return_format": "non_query" // Ожидаем просто успешное выполнение
  },
  "success_criteria": null,
  "description": "Запуск процедуры очистки логов"
}

Возможные ошибки и замечания:

    Модуль SqlServer: Требуется установка Install-Module SqlServer.

    Права доступа к SQL: Права на подключение, доступ к БД, выполнение запроса.

    Безопасность пароля: Избегайте хранения паролей в параметрах.

    all_rows: Используйте с осторожностью, если запрос может вернуть очень много строк, так как это может потребить много памяти и времени.

    non_query: CheckSuccess=true означает только, что запрос выполнен без синтаксических ошибок или ошибок доступа. Он не гарантирует, что запрос сделал то, что ожидалось (например, UPDATE мог не затронуть ни одной строки). Для этого нужны SuccessCriteria.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.

    Модуль PowerShell SqlServer.

    Доступ к MS SQL Server.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md ====

---

**6. `powershell/StatusMonitorAgentUtils/Checks/README-Check-SQL_XML_QUERY.md`**

```markdown
# Check-SQL_XML_QUERY.ps1

**Назначение:**

Этот скрипт выполняет SQL-запрос к Microsoft SQL Server, извлекает XML-данные из указанного столбца первой строки результата, парсит этот XML и извлекает значения по заданному списку ключей (имен элементов).

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется как имя SQL Server instance.
2.  Извлекает и валидирует обязательные параметры из `$Parameters`: `sql_database`, `sql_query`, `xml_column_name`, `keys_to_extract`.
3.  Извлекает опциональные параметры для SQL-аутентификации (`sql_username`, `sql_password`) и таймаут запроса (`query_timeout_sec`).
4.  Проверяет наличие модуля `SqlServer` на машине выполнения. Если модуль отсутствует, генерирует ошибку (`IsAvailable = $false`).
5.  Формирует параметры для `Invoke-Sqlcmd`, включая учетные данные (Windows Auth по умолчанию или SQL Auth, если переданы `sql_username`/`sql_password`).
6.  Выполняет SQL-запрос с помощью `Invoke-Sqlcmd`. Если произошла ошибка подключения или выполнения запроса, устанавливает `IsAvailable = $false` и записывает ошибку.
7.  Если запрос выполнен успешно:
    *   Устанавливает `IsAvailable = $true`.
    *   Проверяет результат:
        *   Если результат пустой (0 строк), устанавливает `CheckSuccess = $true` и добавляет сообщение в `Details.message`.
        *   Если строки есть, берет первую строку.
        *   Проверяет наличие столбца `$xml_column_name` в первой строке. Если столбца нет или он `NULL`, устанавливает `CheckSuccess = $false` и записывает `ErrorMessage`.
        *   Если столбец найден и содержит данные, пытается преобразовать его содержимое в XML (`[xml]$xmlString`).
        *   Если парсинг XML неудачен, устанавливает `CheckSuccess = $false` и записывает `ErrorMessage` с деталями ошибки и примером XML.
        *   Если XML распарсен успешно:
            *   Итерирует по списку `$keys_to_extract`.
            *   Для каждого ключа пытается найти соответствующий дочерний элемент у корневого элемента XML.
            *   Извлекает текстовое содержимое найденного элемента (или `$null`, если элемент не найден).
            *   Записывает найденные пары ключ-значение в `$resultData.Details.extracted_data`.
            *   Устанавливает `CheckSuccess = $true` (пока нет реализованных критериев для данных).
8.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): Имя или IP-адрес SQL Server instance (например, `SERVER\SQLEXPRESS` или `192.168.1.100`).
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха (пока не используется).
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `sql_database` ([string], **Обязательный**): Имя базы данных для подключения.
*   `sql_query` ([string], **Обязательный**): SQL-запрос, который необходимо выполнить. Запрос должен возвращать как минимум одну строку со столбцом, указанным в `xml_column_name`.
*   `xml_column_name` ([string], **Обязательный**): Имя столбца в результате запроса, который содержит XML-данные для парсинга.
*   `keys_to_extract` ([string[]], **Обязательный**): Массив строк, содержащий имена XML-элементов (ключей), значения которых нужно извлечь. Предполагается, что эти элементы являются прямыми потомками корневого элемента XML.
*   `sql_username` ([string], Необязательный): Имя пользователя для SQL Server аутентификации. Если не указано, используется Windows-аутентификация учетной записи, от имени которой запущен скрипт.
*   `sql_password` ([string], Необязательный): Пароль для SQL Server аутентификации. **Использовать с большой осторожностью! Хранение паролей в параметрах небезопасно.** Рекомендуется использовать Windows-аутентификацию.
*   `query_timeout_sec` ([int], Необязательный, по умолч. 30): Таймаут ожидания выполнения SQL-запроса в секундах.

**Критерии успеха (`$SuccessCriteria`)**:

*   **Пока не реализованы.** Можно будет добавить проверку значений извлеченных ключей (например, `$SuccessCriteria = @{ expected_VersionStat = '20230101' }`).

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `server_instance` (string): Имя SQL Server instance.
    *   `database_name` (string): Имя базы данных.
    *   `query_executed` (string): Выполненный SQL-запрос.
    *   `xml_source_column` (string): Имя столбца, из которого брался XML.
    *   `rows_returned` (int): Количество строк, возвращенных запросом.
    *   `extracted_data` (hashtable): Хэш-таблица с извлеченными данными (ключ - имя элемента, значение - его текстовое содержимое или `$null`, если не найден).
    *   `message` (string): (Опционально) Сообщение, если запрос не вернул строк.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false` или `CheckSuccess = $false`.
    *   `xml_content_sample` (string): (Опционально) Начало XML-строки, если произошла ошибка парсинга.

**Пример конфигурации Задания (Assignment):**

```json
// Пример: Получить VersionStat и TS_Version из столбца Revise
{
  "node_id": 60, // ID узла, представляющего SQL сервер или приложение
  "method_id": 8, // ID для SQL_XML_QUERY
  "is_enabled": true,
  "parameters": {
    "sql_database": "ApplicationDB",
    "sql_query": "SELECT TOP 1 Revise FROM Reports ORDER BY CreationDate DESC",
    "xml_column_name": "Revise",
    "keys_to_extract": ["VersionStat", "TS_Version"],
    "query_timeout_sec": 15
    // Используется Windows аутентификация
  },
  "success_criteria": null, // Критериев пока нет
  "description": "Получение версии ТС и статуса из последнего отчета SQL"
}

Возможные ошибки и замечания:

    Модуль SqlServer: Необходимо установить модуль SqlServer на машине, где выполняется скрипт (Install-Module SqlServer).

    Права доступа к SQL: Учетная запись, от имени которой запускается скрипт (или указанный SQL-пользователь), должна иметь права на подключение к SQL Server, доступ к указанной базе данных и права на выполнение переданного sql_query.

    Безопасность пароля: КАТЕГОРИЧЕСКИ НЕ РЕКОМЕНДУЕТСЯ хранить пароли SQL в параметрах задания. Используйте Windows-аутентификацию или другие безопасные методы управления учетными данными.

    Структура XML: Скрипт предполагает, что искомые ключи (keys_to_extract) являются прямыми дочерними элементами корневого элемента XML. Для более сложных XML-структур потребуется доработка логики извлечения.

    Производительность: Сложные SQL-запросы или запросы, возвращающие большие XML, могут выполняться долго. Настройте query_timeout_sec соответственно.

    Обработка результата: Скрипт обрабатывает только первую строку результата SQL-запроса.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
    Модуль PowerShell SqlServer.
    Доступ к MS SQL Server.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 ====
# Check-CERT_EXPIRY.Tests.ps1
# Тесты для Check-CERT_EXPIRY.ps1 v2.0.3 с моками

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Определяем New-CheckResultObject локально
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-CERT_EXPIRY.ps1 (v2.0.3)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-CERT_EXPIRY.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "..." }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'CERT_EXPIRY'; node_name = 'TestNode-Cert'; ip_address = $null; parameters = @{}; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        # --- Мок Get-ChildItem Cert:\... ---
        # Имитируем несколько сертификатов с разным сроком действия
        $mockCerts = @(
            [PSCustomObject]@{ Thumbprint='CERT1'; Subject='CN=ok.example.com'; Issuer='CN=Test CA'; NotAfter=(Get-Date).AddDays(100); HasPrivateKey=$true; PSParentPath='Cert:\LocalMachine\My' }
            [PSCustomObject]@{ Thumbprint='CERT2'; Subject='CN=warn.example.com'; Issuer='CN=Test CA'; NotAfter=(Get-Date).AddDays(20); HasPrivateKey=$true; PSParentPath='Cert:\LocalMachine\My' } # Истекает через 20 дней (попадет в Warning)
            [PSCustomObject]@{ Thumbprint='CERT3'; Subject='CN=expired.example.com'; Issuer='CN=Test CA'; NotAfter=(Get-Date).AddDays(-5); HasPrivateKey=$true; PSParentPath='Cert:\CurrentUser\My' } # Истек 5 дней назад
            [PSCustomObject]@{ Thumbprint='CERT4'; Subject='CN=nokeys.example.com'; Issuer='CN=Test CA'; NotAfter=(Get-Date).AddDays(300); HasPrivateKey=$false; PSParentPath='Cert:\LocalMachine\WebHosting' } # Без ключа
        )
        Mock Get-ChildItem {
            param($Path)
            Write-Verbose "Mock Get-ChildItem called for Path: $Path"
            $storeName = ($Path -split '\\')[-1]
            # Возвращаем сертификаты в зависимости от пути
            switch -Wildcard ($Path) {
                'Cert:\LocalMachine\My' { return $using:mockCerts | Where-Object {$_.PSParentPath -eq $Path} }
                'Cert:\CurrentUser\My' { return $using:mockCerts | Where-Object {$_.PSParentPath -eq $Path} }
                'Cert:\LocalMachine\WebHosting' { return $using:mockCerts | Where-Object {$_.PSParentPath -eq $Path} }
                Default { return @() } # Пусто для других путей
            }
        } -ModuleName Microsoft.PowerShell.Security
    }

    Context 'Получение данных о сертификатах' {
        It 'Должен вернуть IsAvailable=true и 4 сертификата без фильтров' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and # Нет критериев - успех
                ($Details.certificates.Count -eq 4) -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
            Should -Invoke Test-SuccessCriteria -Times 0 # Нет критериев
        }

        It 'Должен вернуть 1 сертификат по точному отпечатку' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ thumbprint = 'CERT2' }
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $Details.certificates.Count -eq 1 -and $Details.certificates[0].thumbprint -eq 'CERT2'
            }
        }

        It 'Должен вернуть 3 сертификата с приватным ключом' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ require_private_key = $true }
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $Details.certificates.Count -eq 3 -and ($Details.certificates | Where-Object {-not $_.has_private_key}).Count -eq 0
            }
        }
         It 'Должен правильно рассчитать статус (OK, Warn, Expired)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters = @{ min_days_warning = 25 } # Предупреждать, если <= 25 дней
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 ($cert1 = $Details.certificates |? {$_.thumbprint -eq 'CERT1'}) -and $cert1.status -eq 'OK' -and
                 ($cert2 = $Details.certificates |? {$_.thumbprint -eq 'CERT2'}) -and $cert2.status -eq 'Expiring (Warn)' -and # 20 дней <= 25 дней
                 ($cert3 = $Details.certificates |? {$_.thumbprint -eq 'CERT3'}) -and $cert3.status -eq 'Expired' -and
                 ($cert4 = $Details.certificates |? {$_.thumbprint -eq 'CERT4'}) -and $cert4.status -eq 'OK'
             }
         }
    } # Конец Context 'Получение данных'

    Context 'Проверка Критериев Успеха' {
         It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true, если критерий пройден (mock=true)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             # Критерий: все сертификаты > 10 дней
             $assignment.success_criteria = @{ certificates=@{_condition_='all';_criteria_=@{days_left=@{'>'=10}}} }
             Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true -and [string]::IsNullOrEmpty($ErrorMessage) }
         }
         It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false, если критерий НЕ пройден (mock=false)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             # Критерий: все сертификаты > 25 дней (не пройдет из-за CERT2 и CERT3)
             $assignment.success_criteria = @{ certificates=@{_condition_='all';_criteria_=@{days_left=@{'>'=25}}} }
             $failReasonMock = "Сертификат CERT2 истекает через 20 дней"
             Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
         }
    } # Конец Context 'Критерии Успеха'

     Context 'Ошибки Доступа к Хранилищам' {
         BeforeEach {
             # Мокируем Get-ChildItem так, чтобы для LocalMachine\My возникала ошибка
             Mock Get-ChildItem {
                 param($Path)
                 if ($Path -eq 'Cert:\LocalMachine\My') { throw "Отказано в доступе (Mock Store Error)" }
                 else { return $using:mockCerts | Where-Object {$_.PSParentPath -eq $Path} } # Возвращаем остальные
             } -ModuleName Microsoft.PowerShell.Security
         }
         It 'Должен вернуть IsAvailable=true, но содержать ошибку доступа в Details' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $IsAvailable -eq $true -and $CheckSuccess -eq $true -and # Нет критериев -> успех
                 ($Details.certificates.Count -eq 2) -and # Только из CurrentUser и WebHosting
                 ($Details.access_errors -is [array] -and $Details.access_errors.Count -eq 1 -and $Details.access_errors[0] -match 'Отказано в доступе') -and
                 # ErrorMessage должен быть null, т.к. CheckSuccess=true
                 [string]::IsNullOrEmpty($ErrorMessage)
             }
         }
          It 'Должен вернуть CheckSuccess=false, если критерии не пройдены ДЛЯ НАЙДЕННЫХ сертификатов, даже если были ошибки доступа' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              # Критерий: Все найденные должны иметь > 400 дней (не пройдет для CERT4)
              $assignment.success_criteria = @{ certificates=@{_condition_='all';_criteria_=@{days_left=@{'>'=400}}} }
              $failReasonMock = "Срок CERT4 < 400 дней"
              Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
              $result = & $script:scriptPath @assignment
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                   $IsAvailable -eq $true -and $CheckSuccess -eq $false -and
                   ($Details.certificates.Count -eq 2) -and
                   ($Details.access_errors.Count -eq 1) -and
                   # ErrorMessage содержит причину провала критерия
                   $ErrorMessage -eq $using:failReasonMock
              }
          }
     } # Конец Context 'Ошибки Доступа'

} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-CERT_EXPIRY.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 ====
# Check-DISK_USAGE.Tests.ps1
# Тесты для Check-DISK_USAGE.ps1 v2.0.2 с моками

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Определяем New-CheckResultObject локально
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-DISK_USAGE.ps1 (v2.0.2)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-DISK_USAGE.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "Не удалось загрузить модуль $($script:utilsModuleName)" }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'DISK_USAGE'; node_name = 'TestNode-Disk'; ip_address = $null; parameters = $null; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        # Мок Get-Volume (модуль Storage)
        # Возвращаем массив объектов, имитирующих вывод Get-Volume
        Mock Get-Volume {
             Write-Verbose "Mock Get-Volume called"
             return @(
                 [PSCustomObject]@{ DriveLetter = 'C'; FileSystemLabel = 'System'; FileSystem = 'NTFS'; DriveType = 'Fixed'; Size = 500GB; SizeRemaining = 100GB }
                 [PSCustomObject]@{ DriveLetter = 'D'; FileSystemLabel = 'Data'; FileSystem = 'NTFS'; DriveType = 'Fixed'; Size = 1000GB; SizeRemaining = 50GB } # Меньше 10% свободно
                 [PSCustomObject]@{ DriveLetter = 'E'; FileSystemLabel = ''; FileSystem = 'CDFS'; DriveType = 'CD-ROM'; Size = 0; SizeRemaining = 0 } # Не Fixed
                 [PSCustomObject]@{ DriveLetter = $null; FileSystemLabel = 'Recovery'; FileSystem = 'NTFS'; DriveType = 'Fixed'; Size = 1GB; SizeRemaining = 0.5GB } # Без буквы
             )
        } -ModuleName Storage
    }

    Context 'Получение данных о дисках' {
        It 'Должен вернуть IsAvailable=true и данные для дисков C и D без фильтров' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Volume -Times 1 -Exactly -ModuleName Storage
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details -is [hashtable] -and $Details.disks -is [System.Collections.Generic.List[object]] -and $Details.disks.Count -eq 2) -and
                ($Details.disks[0].drive_letter -eq 'C' -and $Details.disks[0].percent_free -eq 20.0) -and # 100GB / 500GB
                ($Details.disks[1].drive_letter -eq 'D' -and $Details.disks[1].percent_free -eq 5.0) -and # 50GB / 1000GB
                [string]::IsNullOrEmpty($ErrorMessage)
            }
             Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
        }

        It 'Должен вернуть только диск C при фильтре parameters.drives = @("C")' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ drives = @('C', 'c') } # Проверяем регистр
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.disks.Count -eq 1 -and $Details.disks[0].drive_letter -eq 'C')
            }
        }

        It 'Должен вернуть пустой список и сообщение, если фильтр не находит дисков' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ drives = @('Z') } # Несуществующий диск
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.disks.Count -eq 0) -and $Details.message -match 'не найдены'
            }
        }
    } # Конец Context 'Получение данных'

    Context 'Проверка Критериев Успеха' {
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true, если критерии пройдены (mock=true)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # Критерий: на всех дисках должно быть > 1% свободно
            $assignment.success_criteria = @{ disks=@{_condition_='all';_criteria_=@{percent_free=@{'>'=1}}} }
            Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject -ne $null }
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true -and [string]::IsNullOrEmpty($ErrorMessage) }
        }

        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false, если критерии НЕ пройдены (mock=false)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
             # Критерий: на диске D должно быть > 10% свободно (в моке 5%)
            $assignment.success_criteria = @{ disks=@{_condition_='all';_where_=@{drive_letter='D'};_criteria_=@{percent_free=@{'>'=10}}} }
            $failReasonMock = "Диск D: процент свободного места 5.0 меньше или равен порогу 10"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
        }
    } # Конец Context 'Проверка Критериев'

    Context 'Ошибка Get-Volume' {
        BeforeEach {
            # Мок Get-Volume, который выдает ошибку
            Mock Get-Volume { throw "Ошибка доступа к WMI (Mock Error)" } -ModuleName Storage
        }
        It 'Должен вернуть IsAvailable=false и сообщение об ошибке' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment
            $result.Mocked | Should -BeNullOr $false # Проверяем реальный результат из catch
            $result.IsAvailable | Should -BeFalse
            $result.CheckSuccess | Should -BeNull
            $result.ErrorMessage | Should -Match 'Критическая ошибка'
            $result.ErrorMessage | Should -Match 'Get-Volume'
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
        }
    } # Конец Context 'Ошибка Get-Volume'

} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-DISK_USAGE.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 ====
# Check-PING.Tests.ps1 (v2.1 - Тесты для Check-PING v2.3.1 с моками)
# --- Версия 2.1 ---
# Изменения:
# - Мокируем System.Net.NetworkInformation.Ping и его метод Send.
# - Мокируем Test-SuccessCriteria для изоляции логики проверки критериев.
# - Добавлены тесты для проверки передачи правильных данных в Test-SuccessCriteria.
# - Добавлены тесты для проверки обработки разных статусов ответа .NET Ping.

# Требуется Pester v5+
# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Определяем New-CheckResultObject локально (v1.3), т.к. будем мокать его в Utils
function New-CheckResultObject {
    [CmdletBinding()] param([Parameter(Mandatory=$true)][bool]$IsAvailable, [Parameter(Mandatory=$false)][nullable[bool]]$CheckSuccess=$null, [Parameter(Mandatory=$false)][hashtable]$Details=$null, [Parameter(Mandatory=$false)][string]$ErrorMessage=$null)
    $result = [ordered]@{ IsAvailable=$IsAvailable; CheckSuccess=$CheckSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$Details; ErrorMessage=$ErrorMessage }; if ($result.IsAvailable) { if ($result.CheckSuccess -eq $null) { $result.CheckSuccess = $true } } else { $result.CheckSuccess = $null }; if ([string]::IsNullOrEmpty($result.ErrorMessage)) { if (-not $result.IsAvailable) { $result.ErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)." } }; return $result
}

# --- Настройка перед тестами ---
Describe 'Check-PING.ps1 (v2.3.1 - .NET Ping)' {

    $script:scriptPath = $null # Путь к тестируемому скрипту
    $script:utilsModuleName = 'StatusMonitorAgentUtils' # Имя модуля для моков

    BeforeAll {
        # Получаем путь к скрипту
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-PING.ps1') -EA Stop
        Write-Host "INFO: Тестируемый скрипт: $($script:scriptPath)" -FC Cyan
        # Загружаем модуль Utils, чтобы мокать его функции
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "Не удалось загрузить модуль $($script:utilsModuleName)" }
    }

    # --- Базовый объект задания ---
    $baseAssignment = @{ method_name = 'PING'; node_name = 'TestNode-PING'; ip_address = '8.8.8.8'; parameters = @{}; success_criteria = $null }

    # --- Общие моки ---
    BeforeEach {
        # --- Мок для New-CheckResultObject ---
        # Мокируем функцию из НАШЕГО модуля Utils
        Mock New-CheckResultObject {
            param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
            # Возвращаем объект с маркером, чтобы тесты видели, что мок сработал
            # и могли проверить переданные параметры
            return @{ Mocked = $true; M_IsAvailable = $IsAvailable; M_CheckSuccess = $CheckSuccess; M_Details = $Details; M_ErrorMessage = $ErrorMessage }
        } -ModuleName $script:utilsModuleName

        # --- Мок для Test-SuccessCriteria ---
        # По умолчанию считаем, что критерии пройдены
        Mock Test-SuccessCriteria {
            param($DetailsObject, $CriteriaObject)
            Write-Verbose "Mock Test-SuccessCriteria: CriteriaObject = $($CriteriaObject | ConvertTo-Json -Depth 1 -Compress)"
            return @{ Passed = $true; FailReason = $null }
        } -ModuleName $script:utilsModuleName

        # --- Мок для System.Net.NetworkInformation.Ping ---
        # Мокируем конструктор и метод Send
        # ПРИМЕЧАНИЕ: Мокирование .NET напрямую может быть нестабильно в PS 5.1.
        # Если будут проблемы, альтернатива - мокать Invoke-Expression или обернуть .NET вызов в функцию внутри скрипта и мокать её.
        # Но попробуем так:
        Mock New-Object {
             param($TypeName)
             if ($TypeName -eq 'System.Net.NetworkInformation.Ping') {
                 # Возвращаем мок-объект Ping с моком метода Send
                 $mockPing = [PSCustomObject]@{ Send = { Mock Ping.Send @PSBoundParameters } }
                 return $mockPing
             }
             # Для других вызовов New-Object возвращаем реальный объект
             return New-Object @PSBoundParameters
        }

        # Мок для метода Send (будет вызван из мока New-Object выше)
        # По умолчанию имитируем успешный пинг
        Mock Ping.Send {
            param($hostname, $timeout, $buffer, $options)
            Write-Verbose "Mock Ping.Send: Host=$hostname, Timeout=$timeout"
            # Возвращаем мок-объект PingReply
            return [PSCustomObject]@{
                Status        = [System.Net.NetworkInformation.IPStatus]::Success
                Address       = [System.Net.IPAddress]::Parse('8.8.8.8')
                RoundtripTime = 15L # Возвращаем long
            }
        }
    }

    # --- Контексты и тесты ---

    Context 'Успешный Пинг (.NET Send возвращает Success)' {

        It 'Должен вернуть IsAvailable=true, CheckSuccess=true без критериев' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment # Используем splatting
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details -is [hashtable] -and $Details.rtt_ms -eq 15 -and $Details.packet_loss_percent -eq 0) -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
        }

        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true, если критерии переданы и мок=true' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = 100 } }
            Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It # Переопределяем мок для теста

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 ($DetailsObject.rtt_ms -eq 15) -and ($CriteriaObject.rtt_ms.'<=' -eq 100)
            }
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and [string]::IsNullOrEmpty($ErrorMessage)
            }
        }

        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false, если критерии переданы и мок=false' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ packet_loss_percent = @{ '==' = 0 } }
            $failReasonMock = "Потери не 0%"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock
            }
        }
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=null, если критерии переданы и мок=null' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.success_criteria = @{ rtt_ms = @{ '==' = "not number" } }
             $failReasonMock = "Ошибка сравнения"
             Mock Test-SuccessCriteria { return @{ Passed = $null; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It

             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $IsAvailable -eq $true -and $CheckSuccess -eq $null -and $ErrorMessage -eq $using:failReasonMock
             }
        }
    } # Конец Context 'Успешный Пинг'

    Context 'Неуспешный Пинг (.NET Send НЕ возвращает Success)' {
        BeforeEach {
            # Мок для Ping.Send, имитирующий таймаут
             Mock Ping.Send { return [PSCustomObject]@{ Status = [System.Net.NetworkInformation.IPStatus]::TimedOut; Address = $null; RoundtripTime = 0L } }
        }
        It 'Должен вернуть IsAvailable=false, CheckSuccess=$null и НЕ вызывать Test-SuccessCriteria' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = 100 } } # Критерии есть, но не должны проверяться

            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $false -and $CheckSuccess -eq $null -and
                ($Details -is [hashtable] -and $Details.status_string -eq 'TimedOut') -and
                $ErrorMessage -match 'Нет успешных ответов' -and $ErrorMessage -match 'TimedOut'
            }
        }
    } # Конец Context 'Неуспешный Пинг'

    Context 'Критическая ошибка PingException' {
         BeforeEach {
             # Мок для Ping.Send, который выбрасывает исключение
             Mock Ping.Send { throw [System.Net.NetworkInformation.PingException]::new("Хост не найден (Mock)") }
         }
         It 'Должен вернуть IsAvailable=false, CheckSuccess=$null и содержать ошибку в Details/ErrorMessage' {
            $assignment = $script:baseAssignment.PSObject.Copy()

            $result = & $script:scriptPath @assignment
            # Проверяем РЕАЛЬНЫЙ результат, т.к. New-CheckResultObject НЕ вызывался в основном потоке
            $result | Should -Not -BeNull
            $result.Mocked | Should -BeNullOr ( ($result.PSObject.Properties.Name -notcontains 'Mocked') -or (-not $result.Mocked)) # Проверяем, что это не мок New-CheckResultObject
            $result.IsAvailable | Should -BeFalse
            $result.CheckSuccess | Should -BeNull
            $result.ErrorMessage | Should -Match 'Критическая ошибка'
            $result.ErrorMessage | Should -Match 'PingException'
            $result.Details | Should -Not -BeNull
            $result.Details.error | Should -Match 'PingException'
            $result.Details.ErrorRecord | Should -Not -BeNullOrEmpty
            # Test-SuccessCriteria не должен был вызываться
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
         }
    } # Конец Context 'Критическая ошибка'
} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 ====
# Check-PROCESS_LIST.Tests.ps1
# Тесты для Check-PROCESS_LIST.ps1 v2.0.2 с моками

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Определяем New-CheckResultObject локально
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-PROCESS_LIST.ps1 (v2.0.2)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-PROCESS_LIST.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "Не удалось загрузить модуль $($script:utilsModuleName)" }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'PROCESS_LIST'; node_name = 'TestNode-Proc'; ip_address = $null; parameters = @{}; success_criteria = $null }

    # --- Общие моки ---
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName

        # --- Мок Get-Process ---
        # Возвращаем набор тестовых процессов
        $mockProcesses = @(
            [PSCustomObject]@{ Id = 101; ProcessName = 'powershell'; CPU = 10.5; WS = 200MB; StartTime = (Get-Date).AddHours(-1) }
            [PSCustomObject]@{ Id = 102; ProcessName = 'explorer'; CPU = 5.2; WS = 150MB; StartTime = (Get-Date).AddHours(-5) }
            [PSCustomObject]@{ Id = 103; ProcessName = 'svchost'; CPU = 0.1; WS = 10MB; StartTime = (Get-Date).AddDays(-1) }
            [PSCustomObject]@{ Id = 104; ProcessName = 'svchost'; CPU = 0.5; WS = 15MB; StartTime = (Get-Date).AddDays(-1).AddHours(1) }
        )
        Mock Get-Process {
            param($Name)
            Write-Verbose "Mock Get-Process called. Filter Name: '$($Name -join ',')'"
            if ($Name) { return $using:mockProcesses | Where-Object { $proc = $_; $Name | ForEach-Object { $pattern = $_; if ($proc.ProcessName -like $pattern) { return $true } }; return $false } }
            else { return $using:mockProcesses }
        } -ModuleName Microsoft.PowerShell.Management

        # --- Мок Get-CimInstance для Win32_Process (получение Username) ---
        # Возвращаем разные данные в зависимости от ProcessId
        Mock Get-CimInstance {
            param($ClassName, $Filter)
            Write-Verbose "Mock Get-CimInstance Win32_Process called. Filter: $Filter"
            if ($ClassName -ne 'Win32_Process' -or -not $Filter -match 'ProcessId = (\d+)') { return $null }
            $procId = [int]$Matches[1]
            switch ($procId) {
                101 { return [PSCustomObject]@{Owner = [PSCustomObject]@{Domain='DOMAIN'; User='UserPS'}} }
                102 { return [PSCustomObject]@{Owner = [PSCustomObject]@{Domain=$env:USERDOMAIN; User=$env:USERNAME}} } # Текущий пользователь
                103 { return [PSCustomObject]@{Owner = [PSCustomObject]@{User='SYSTEM'}} } # Без домена
                default { return $null } # Для остальных возвращаем null
            }
        } -ModuleName CimCmdlets
    }

    Context 'Получение списка процессов' {
        It 'Должен вернуть все 4 процесса без фильтров и с базовыми полями' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Process -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management -ParameterFilter { $Name -eq $null }
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.processes.Count -eq 4) -and
                ($Details.processes[0].name -eq 'powershell' -and $Details.processes[0].username -eq $null -and $Details.processes[0].path -eq $null)
            }
        }
        It 'Должен вернуть процессы PowerShell с Username и Path при include=true' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ process_names = @('*powershell*'); include_username = $true; include_path = $true }
            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Process -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management -ParameterFilter { $Name -ne $null }
            Should -Invoke Get-CimInstance -Times 1 -Exactly -ModuleName CimCmdlets -ParameterFilter { $Filter -match '101' } # Вызов для powershell
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $Details.processes.Count -eq 1 -and
                $Details.processes[0].name -eq 'powershell' -and
                $Details.processes[0].username -eq 'DOMAIN\UserPS' -and
                # Path мокнуть сложнее, т.к. $proc.Path зависит от реального процесса
                ($Details.processes[0].path -eq $null -or $Details.processes[0].path -eq '[Access Error]') # Ожидаем null или ошибку, т.к. мок Get-Process не имеет реального пути
            }
        }
         It 'Должен вернуть отсортированный список по CPU (убывание)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters = @{ sort_by = 'cpu'; sort_descending = $true }
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $Details.processes[0].name -eq 'powershell' -and # 10.5 CPU
                 $Details.processes[1].name -eq 'explorer' -and # 5.2 CPU
                 $Details.processes[2].name -eq 'svchost' -and # 0.5 CPU
                 $Details.processes[3].name -eq 'svchost' # 0.1 CPU
             }
         }
         It 'Должен вернуть топ 2 процесса по памяти (убывание)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters = @{ sort_by = 'memory'; sort_descending = $true; top_n = 2 }
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                  $Details.processes.Count -eq 2 -and
                  $Details.processes[0].name -eq 'powershell' -and # 200MB
                  $Details.processes[1].name -eq 'explorer' # 150MB
             }
         }
         It 'Должен вернуть пустой список и сообщение, если процесс по фильтру не найден' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters = @{ process_names = @('notepad') }
             Mock Get-Process { return $null } -ModuleName Microsoft.PowerShell.Management -Scope It # Мок возвращает null
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                  $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                  ($Details.processes.Count -eq 0) -and ($Details.message -match 'не найдены')
             }
         }
    } # Конец Context 'Получение списка'

    Context 'Проверка Критериев Успеха' {
         It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true, если критерий пройден (mock=true)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             # Критерий: Должен быть хотя бы один svchost
             $assignment.success_criteria = @{ processes=@{_condition_='count';_where_=@{name='svchost'};_count_=@{'>='=1}} }
             Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true }
         }
         It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false, если критерий НЕ пройден (mock=false)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
              # Критерий: Не должно быть explorer.exe
             $assignment.success_criteria = @{ processes=@{_condition_='none';_where_=@{name='explorer.exe'}} }
             $failReasonMock = "Найден запрещенный процесс explorer.exe"
             Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
         }
    } # Конец Context 'Критерии Успеха'

    Context 'Ошибка Get-Process' {
         BeforeEach { Mock Get-Process { throw "Критическая ошибка доступа (Mock)" } -ModuleName Microsoft.PowerShell.Management }
         It 'Должен вернуть IsAvailable=false и сообщение об ошибке' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $result = & $script:scriptPath @assignment
             $result.Mocked | Should -BeNullOr $false # Реальный результат из catch
             $result.IsAvailable | Should -BeFalse
             $result.CheckSuccess | Should -BeNull
             $result.ErrorMessage | Should -Match 'Критическая ошибка'
             Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
         }
    } # Конец Context 'Ошибка Get-Process'

} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PROCESS_LIST.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 ====
# Check-SERVICE_STATUS.Tests.ps1
# Тесты для Check-SERVICE_STATUS.ps1 v2.0.1 с моками

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Определяем New-CheckResultObject локально (v1.3)
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-SERVICE_STATUS.ps1 (v2.0.1)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-SERVICE_STATUS.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "Не удалось загрузить модуль $($script:utilsModuleName)" }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'SERVICE_STATUS'; node_name = 'TestNode-Service'; ip_address = $null; parameters = @{}; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        # Мок Get-Service по умолчанию возвращает "Running"
        Mock Get-Service { param($Name) Write-Verbose "Mock Get-Service called for $Name"; return [PSCustomObject]@{Name=$Name; Status='Running'; DisplayName="Mock $Name"; StartType='Automatic'; CanStop=$true} } -ModuleName Microsoft.PowerShell.Management
    }

    Context 'Служба Найдена (Get-Service успешен)' {

        It 'Должен вернуть IsAvailable=true, CheckSuccess=true, если статус Running и нет критериев' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'Spooler' }
            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Service -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management -ParameterFilter { $Name -eq 'Spooler' }
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName # Критериев нет
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details -is [hashtable] -and $Details.status -eq 'Running') -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
        }

        It 'Должен вернуть CheckSuccess=true, если статус Running и критерий status=Running' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'Spooler' }
            $assignment.success_criteria = @{ status = 'Running' }
            Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.status -eq 'Running' }
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true -and [string]::IsNullOrEmpty($ErrorMessage) }
        }

        It 'Должен вернуть CheckSuccess=false, если статус Running и критерий status=Stopped (mock=false)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'Spooler' }
            $assignment.success_criteria = @{ status = 'Stopped' }
            $failReasonMock = "Статус 'Running' не равен 'Stopped'"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
        }

        It 'Должен вернуть CheckSuccess=null, если произошла ошибка в Test-SuccessCriteria (mock=null)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters = @{ service_name = 'Spooler' }
             $assignment.success_criteria = @{ status = @{'invalid_op'=1} } # Неверный критерий
             $failReasonMock = "Ошибка обработки критерия"
             Mock Test-SuccessCriteria { return @{ Passed = $null; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $null -and $ErrorMessage -eq $using:failReasonMock }
        }

         It 'Должен вернуть CheckSuccess=true, если статус Stopped и критериев нет' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'BITS' }
            # Мокируем Get-Service для этого теста, чтобы вернуть Stopped
            Mock Get-Service { return [PSCustomObject]@{Name='BITS'; Status='Stopped'; DisplayName='Mock BITS'; StartType='Manual'; CanStop=$true} } -ModuleName Microsoft.PowerShell.Management -Scope It
            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                 ($Details.status -eq 'Stopped') -and [string]::IsNullOrEmpty($ErrorMessage)
            }
         }

    } # Конец Context 'Служба Найдена'

    Context 'Служба Не Найдена (Get-Service выдает ServiceCommandException)' {
        BeforeEach {
            # Мокируем Get-Service, чтобы он выбрасывал ошибку
            Mock Get-Service { param($Name) throw [Microsoft.PowerShell.Commands.ServiceCommandException]::new("Служба $Name не найдена (Mock)") } -ModuleName Microsoft.PowerShell.Management
        }
        It 'Должен вернуть IsAvailable=false, CheckSuccess=$null и не вызывать Test-SuccessCriteria' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters = @{ service_name = 'NonExistentSvc' }
            $assignment.success_criteria = @{ status = 'Running' } # Критерий есть, но не должен проверяться

            $result = & $script:scriptPath @assignment
            Should -Invoke Get-Service -Times 1 -Exactly -ModuleName Microsoft.PowerShell.Management
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $false -and $CheckSuccess -eq $null -and
                ($Details -is [hashtable] -and $Details.error -match 'не найдена') -and
                $ErrorMessage -match 'не найдена'
            }
        }
    } # Конец Context 'Служба Не Найдена'

    Context 'Ошибка Валидации Параметра service_name' {
         It 'Должен вернуть IsAvailable=false, если service_name не передан' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             # $assignment.parameters не содержит service_name
             $result = & $script:scriptPath @assignment
             # Проверяем реальный результат из catch блока
             $result.Mocked | Should -BeNullOr $false # Это не мок
             $result.IsAvailable | Should -BeFalse
             $result.CheckSuccess | Should -BeNull
             $result.ErrorMessage | Should -Contain 'service_name'
         }
    } # Конец Context 'Ошибка Валидации'
} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SERVICE_STATUS.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 ====
# Check-SQL_QUERY_EXECUTE.Tests.ps1
# Тесты для Check-SQL_QUERY_EXECUTE.ps1 v2.0.1 с моками Invoke-Sqlcmd

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Локальная New-CheckResultObject
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-SQL_QUERY_EXECUTE.ps1 (v2.0.1)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-SQL_QUERY_EXECUTE.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "..." }
        # Мок Get-Command, чтобы скрипт думал, что модуль SqlServer есть
        Mock Get-Command { param($Name) if($Name -eq 'Invoke-Sqlcmd'){ return $true } else { Get-Command @PSBoundParameters } }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'SQL_QUERY_EXECUTE'; node_name = 'TestNode-SQL'; ip_address = 'TestSQLServer'; parameters = @{sql_database='TestDB'}; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        # --- Мок Invoke-Sqlcmd ---
        # По умолчанию возвращает одну строку
        $mockSqlData = @( [PSCustomObject]@{ ID = 1; Name = 'Row1'; Value = 100 } )
        Mock Invoke-Sqlcmd { param($Query) Write-Verbose "Mock Invoke-Sqlcmd: Query=$Query"; return $using:mockSqlData }
    }

    Context 'Обработка разных return_format' {
        It 'first_row: Должен вернуть первую строку как хэш-таблицу' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT *"; $assignment.parameters.return_format = 'first_row'
            $result = & $script:scriptPath @assignment
            Should -Invoke Invoke-Sqlcmd -Times 1 -Exactly
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.return_format_used -eq 'first_row') -and
                ($Details.query_result -is [hashtable]) -and $Details.query_result.ID -eq 1 -and $Details.query_result.Name -eq 'Row1' -and
                ($Details.rows_returned -eq 1)
            }
        }
        It 'all_rows: Должен вернуть массив хэш-таблиц' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT *"; $assignment.parameters.return_format = 'all_rows'
            # Мок вернет тот же массив из 1 элемента
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                 $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                 ($Details.return_format_used -eq 'all_rows') -and
                 ($Details.query_result -is [System.Collections.Generic.List[object]]) -and $Details.query_result.Count -eq 1 -and
                 ($Details.query_result[0] -is [hashtable]) -and $Details.query_result[0].Value -eq 100 -and
                 ($Details.rows_returned -eq 1)
            }
        }
         It 'row_count: Должен вернуть количество строк' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT ID"; $assignment.parameters.return_format = 'row_count'
             # Мок вернет 1 строку
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                  $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                  ($Details.return_format_used -eq 'row_count') -and ($Details.row_count -eq 1)
             }
         }
          It 'scalar: Должен вернуть значение первого столбца первой строки' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "SELECT Value"; $assignment.parameters.return_format = 'scalar'
              # Мок вернет объект с Value=100
              $result = & $script:scriptPath @assignment
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                   $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                   ($Details.return_format_used -eq 'scalar') -and ($Details.scalar_value -eq 100)
              }
          }
          It 'non_query: Должен вернуть non_query_success = true' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "UPDATE T"; $assignment.parameters.return_format = 'non_query'
              Mock Invoke-Sqlcmd { return $null } -Scope It # Non-query обычно ничего не возвращает
              $result = & $script:scriptPath @assignment
              Should -Invoke Invoke-Sqlcmd -Times 1 -Exactly
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                   $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                   ($Details.return_format_used -eq 'non_query') -and ($Details.non_query_success -eq $true)
              }
          }
          It 'Должен обработать пустой результат от Invoke-Sqlcmd для first_row' {
               $assignment = $script:baseAssignment.PSObject.Copy()
               $assignment.parameters.sql_query = "SELECT * WHERE 1=0"; $assignment.parameters.return_format = 'first_row'
               Mock Invoke-Sqlcmd { return $null } -Scope It
               $result = & $script:scriptPath @assignment
               Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                    $IsAvailable -eq $true -and $CheckSuccess -eq $true -and # Пустой результат - не ошибка
                    ($Details.return_format_used -eq 'first_row') -and ($Details.query_result -eq $null) -and ($Details.rows_returned -eq 0)
               }
          }
    } # Конец Context 'Обработка return_format'

    Context 'Проверка Критериев Успеха' {
         It 'Должен вызвать Test-SuccessCriteria для row_count и вернуть CheckSuccess=false (mock=false)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT ID"; $assignment.parameters.return_format = 'row_count'
             $assignment.success_criteria = @{ row_count = @{ '==' = 0 } } # Критерий: строк должно быть 0
             $failReasonMock = "Количество строк (1) не равно 0"
             Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
             # Мок Invoke-Sqlcmd возвращает 1 строку
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.row_count -ne $null }
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
         }
         It 'Должен вызвать Test-SuccessCriteria для scalar и вернуть CheckSuccess=true (mock=true)' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "SELECT Value"; $assignment.parameters.return_format = 'scalar'
              $assignment.success_criteria = @{ scalar_value = @{ '<' = 200 } } # Критерий: значение < 200
              Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
              # Мок Invoke-Sqlcmd возвращает 100
              $result = & $script:scriptPath @assignment
              Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.scalar_value -ne $null }
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true }
         }
    } # Конец Context 'Проверка Критериев'

    Context 'Ошибки Invoke-Sqlcmd' {
         BeforeEach { Mock Invoke-Sqlcmd { throw "Ошибка подключения к SQL (Mock)" } }
         It 'Должен вернуть IsAvailable=false и сообщение об ошибке SQL' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT 1"; $assignment.parameters.return_format = 'scalar'
             $result = & $script:scriptPath @assignment
             $result.Mocked | Should -BeNullOr $false # Реальный результат из catch
             $result.IsAvailable | Should -BeFalse
             $result.CheckSuccess | Should -BeNull
             $result.ErrorMessage | Should -Match 'Критическая ошибка'
             $result.ErrorMessage | Should -Match 'SQL'
             Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName $script:utilsModuleName
         }
          It 'non_query: Должен вернуть IsAvailable=false и non_query_success=false' {
              $assignment = $script:baseAssignment.PSObject.Copy()
              $assignment.parameters.sql_query = "UPDATE T"; $assignment.parameters.return_format = 'non_query'
              $result = & $script:scriptPath @assignment
              Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                   $IsAvailable -eq $false -and $CheckSuccess -eq $null -and
                   ($Details.non_query_success -eq $false) -and
                   $ErrorMessage -match 'Ошибка non-query SQL'
              }
          }
    } # Конец Context 'Ошибки Invoke-Sqlcmd'
} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_QUERY_EXECUTE.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 ====
# Check-SQL_XML_QUERY.Tests.ps1
# Тесты для Check-SQL_XML_QUERY.ps1 v2.0.1 с моками Invoke-Sqlcmd

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# Локальная New-CheckResultObject
function New-CheckResultObject { [CmdletBinding()] param([bool]$IsAvailable,[nullable[bool]]$CheckSuccess=$null,[hashtable]$Details=$null,[string]$ErrorMessage=$null); $r=[ordered]@{IsAvailable=$IsAvailable;CheckSuccess=$CheckSuccess;Timestamp=(Get-Date).ToUniversalTime().ToString("o");Details=$Details;ErrorMessage=$ErrorMessage}; if($r.IsAvailable){if($r.CheckSuccess-eq$null){$r.CheckSuccess=$true}}else{$r.CheckSuccess=$null}; if([string]::IsNullOrEmpty($r.ErrorMessage)){if(-not $r.IsAvailable){$r.ErrorMessage="Ошибка выполнения проверки (IsAvailable=false)."}}; return $r }

Describe 'Check-SQL_XML_QUERY.ps1 (v2.0.1)' {

    $script:scriptPath = $null
    $script:utilsModuleName = 'StatusMonitorAgentUtils'

    BeforeAll {
        $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-SQL_XML_QUERY.ps1') -EA Stop
        try { Import-Module (Join-Path $PSScriptRoot '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop } catch { throw "..." }
        Mock Get-Command { param($Name) if($Name -eq 'Invoke-Sqlcmd'){ return $true } else { Get-Command @PSBoundParameters } }
    }

    # Базовое задание
    $baseAssignment = @{ method_name = 'SQL_XML_QUERY'; node_name = 'TestNode-SQLXML'; ip_address = 'TestSQLServer'; parameters = @{sql_database='TestDB'}; success_criteria = $null }

    # Общие моки
    BeforeEach {
        Mock New-CheckResultObject { param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage); return @{ Mocked=$true; M_IsAvailable=$IsAvailable; M_CheckSuccess=$CheckSuccess; M_Details=$Details; M_ErrorMessage=$ErrorMessage } } -ModuleName $script:utilsModuleName
        Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName
        # --- Мок Invoke-Sqlcmd ---
        # По умолчанию возвращает строку с валидным XML
        $mockXmlString = '<Root><KeyA>ValueA</KeyA><KeyB>123</KeyB></Root>'
        $mockSqlData = @( [PSCustomObject]@{ XmlColumn = $mockXmlString; OtherColumn = 'data' } )
        Mock Invoke-Sqlcmd { param($Query) Write-Verbose "Mock Invoke-Sqlcmd: Query=$Query"; return $using:mockSqlData }
    }

    Context 'Успешное выполнение и парсинг XML' {
        It 'Должен извлечь значения для существующих ключей' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'
            $assignment.parameters.keys_to_extract = @('KeyA', 'KeyB')
            $result = & $script:scriptPath @assignment
            Should -Invoke Invoke-Sqlcmd -Times 1 -Exactly
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                ($Details.extracted_data -is [hashtable]) -and
                $Details.extracted_data.KeyA -eq 'ValueA' -and
                $Details.extracted_data.KeyB -eq '123'
            }
             Should -Invoke Test-SuccessCriteria -Times 0 # Критериев нет
        }

        It 'Должен вернуть null для несуществующих ключей' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'
             $assignment.parameters.keys_to_extract = @('KeyA', 'NonExistentKey')
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter {
                  $IsAvailable -eq $true -and $CheckSuccess -eq $true -and
                  $Details.extracted_data.KeyA -eq 'ValueA' -and
                  $Details.extracted_data.ContainsKey('NonExistentKey') -and $Details.extracted_data.NonExistentKey -eq $null
             }
        }
    } # Конец Context 'Успешное выполнение'

    Context 'Проверка Критериев Успеха' {
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=true (mock=true)' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'; $assignment.parameters.keys_to_extract = @('KeyA', 'KeyB')
             $assignment.success_criteria = @{ extracted_data = @{ KeyA = 'ValueA'; KeyB = @{'>'=100} } }
             Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName $script:utilsModuleName -Scope It
             $result = & $script:scriptPath @assignment
             Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CriteriaObject.extracted_data -ne $null }
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $true }
        }
        It 'Должен вызвать Test-SuccessCriteria и вернуть CheckSuccess=false (mock=false)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT XmlColumn"; $assignment.parameters.xml_column_name = 'XmlColumn'; $assignment.parameters.keys_to_extract = @('KeyB')
            $assignment.success_criteria = @{ extracted_data = @{ KeyB = @{'<'=100} } } # Критерий KeyB < 100 (не пройдет, т.к. он 123)
            $failReasonMock = "KeyB (123) не меньше 100"
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName $script:utilsModuleName -Scope It
            $result = & $script:scriptPath @assignment
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName $script:utilsModuleName
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $CheckSuccess -eq $false -and $ErrorMessage -eq $using:failReasonMock }
        }
    } # Конец Context 'Проверка Критериев'

    Context 'Ошибки SQL или Парсинга' {
        It 'Должен вернуть IsAvailable=false, если Invoke-Sqlcmd выдает ошибку' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "ERROR"; $assignment.parameters.xml_column_name = 'C'; $assignment.parameters.keys_to_extract = @('K')
            Mock Invoke-Sqlcmd { throw "SQL Error (Mock)" } -Scope It
            $result = & $script:scriptPath @assignment
            $result.Mocked | Should -BeNullOr $false
            $result.IsAvailable | Should -BeFalse; $result.CheckSuccess | Should -BeNull; $result.ErrorMessage | Should -Match 'Критическая ошибка'; $result.ErrorMessage | Should -Match 'SQL Error'
            Should -Invoke Test-SuccessCriteria -Times 0
        }
        It 'Должен вернуть IsAvailable=false, если столбец XML не найден' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT OtherColumn"; $assignment.parameters.xml_column_name = 'WrongColumnName'; $assignment.parameters.keys_to_extract = @('K')
            # Мок Invoke-Sqlcmd возвращает OtherColumn='data'
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $IsAvailable -eq $false -and $ErrorMessage -match 'не найден' }
            Should -Invoke Test-SuccessCriteria -Times 0
        }
        It 'Должен вернуть IsAvailable=false, если XML невалиден' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.parameters.sql_query = "SELECT BadXml"; $assignment.parameters.xml_column_name = 'BadXml'; $assignment.parameters.keys_to_extract = @('K')
            Mock Invoke-Sqlcmd { return @([PSCustomObject]@{ BadXml = '<Root><KeyA>ValueA</Root' }) } -Scope It # Незакрытый тег
            $result = & $script:scriptPath @assignment
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $IsAvailable -eq $false -and $ErrorMessage -match 'Ошибка парсинга' }
            Should -Invoke Test-SuccessCriteria -Times 0
        }
         It 'Должен вернуть IsAvailable=true, если SQL не вернул строк' {
             $assignment = $script:baseAssignment.PSObject.Copy()
             $assignment.parameters.sql_query = "SELECT XmlCol WHERE 1=0"; $assignment.parameters.xml_column_name = 'XmlCol'; $assignment.parameters.keys_to_extract = @('K')
             Mock Invoke-Sqlcmd { return $null } -Scope It # Имитируем пустой результат
             $result = & $script:scriptPath @assignment
             Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName $script:utilsModuleName -ParameterFilter { $IsAvailable -eq $true -and $CheckSuccess -eq $true -and $Details.message -match 'не вернул строк' }
             Should -Invoke Test-SuccessCriteria -Times 0
         }
    } # Конец Context 'Ошибки SQL или Парсинга'

} # Конец Describe
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-SQL_XML_QUERY.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 ====
# Invoke-StatusMonitorCheck.Tests.ps1 (v8 - ���������� $PSScriptRoot � BeforeAll)

# --- ���� ���������� ---
# BeforeAll ����������� ���� ��� ����� ����� ������� � ���� Describe �����.
BeforeAll {
    # ���������� $PSScriptRoot, ������� ��������� �� ���������� �������� ����� ����� (.Tests.ps1)
    Write-Host "INFO: PSScriptRoot ��������� ���: $PSScriptRoot" # ��� ��� �������
    if (-not $PSScriptRoot) {
        throw "�� ������� ���������� ���������� ����� (\$PSScriptRoot). ���������� ����� ������."
    }

    # ������ ���� � ��������� ������������ ����� tests
    $moduleManifestRelativePath = '..\StatusMonitorAgentUtils.psd1'
    $moduleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath $moduleManifestRelativePath

    # ���������� Resolve-Path ��� ��������� ������� ���� � �������� �������������
    try {
        $resolvedModulePath = Resolve-Path -Path $moduleManifestPath -ErrorAction Stop
        Write-Host "INFO: ������ ���� � ��������� ������: $resolvedModulePath"
    } catch {
        # ��������� ����� ��������� ��������� �� ������
        Write-Error "�� ������� �����/���������� ���� � ��������� ������ '$moduleManifestPath'. ���������, ��� ��������� ����� �����: tests/ ��������� ������ StatusMonitorAgentUtils/. ������ Resolve-Path: $($_.Exception.Message)"
        throw "�� ������� ����� ������ ��� ������������." # ��������� ����������
    }

    # ����������� ������ �� ������� ����
    Write-Host "INFO: �������� ������ �� $resolvedModulePath ��� ������..."
    Remove-Module StatusMonitorAgentUtils -Force -ErrorAction SilentlyContinue
    Import-Module $resolvedModulePath -Force
    Write-Host "INFO: ������ StatusMonitorAgentUtils ��������."
}

# --- ����� ---
Describe 'Invoke-StatusMonitorCheck (��������� ��������)' {

    # --- Mocking (��� ���������) ---
    Mock New-CheckResultObject { Param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
        return @{ Mocked = $true; IsAvailable = $IsAvailable; CheckSuccess = $CheckSuccess; ErrorMessage = $ErrorMessage; Details = $Details }
    } -ModuleName StatusMonitorAgentUtils

    Mock Test-Path { Param($Path)
        if ($Path -like "*Checks\Check-*.ps1") { return $true }
        return Test-Path @using:PSBoundParameters
    } -ModuleName Microsoft.PowerShell.Management

    Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
        Write-Verbose "��� Invoke-CheckScript: ���������� ����� '$ScriptPath'"
        return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp = (Get-Date).ToUniversalTime().ToString("o"); Details = @{ CalledScript = $ScriptPath; ParamsPassed = $ParametersForScript }; ErrorMessage = $null }
    } -ModuleName StatusMonitorAgentUtils

    # --- �������� ������ (��� ���������) ---
    $baseAssignment = @{
        assignment_id = 101; node_id = 1; node_name = 'TestNode'; ip_address = '127.0.0.1'
        parameters = @{ timeout = 500 }; success_criteria = @{ max_rtt_ms = 100 }
    }

    # --- ����� (��� ���������) ---

    It '������ �������� Invoke-CheckScript ��� ������ PING � ����������� �����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'PING'
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            $ScriptPath | Should -EndWith '\Checks\Check-PING.ps1'
            $ParametersForScript | Should -Not -BeNull
            $ParametersForScript.TargetIP | Should -Be $using:assignment.ip_address
            $ParametersForScript.Parameters | Should -Be $using:assignment.parameters
            $ParametersForScript.SuccessCriteria | Should -Be $using:assignment.success_criteria
            $ParametersForScript.NodeName | Should -Be $using:assignment.node_name
            return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=@{mocked_call_for='PING'}; ErrorMessage=$null }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        $result.IsAvailable | Should -BeTrue
        $result.Details.mocked_call_for | Should -Be 'PING'
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
    }

    It '������ �������� Invoke-CheckScript ��� SERVICE_STATUS � ����������� �����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'SERVICE_STATUS'
        $assignment.parameters = @{ service_name = 'Spooler' }
        $assignment.success_criteria = @{ status = 'Running' }
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            $ScriptPath | Should -EndWith '\Checks\Check-SERVICE_STATUS.ps1'
            $ParametersForScript.TargetIP | Should -Be $using:assignment.ip_address
            $ParametersForScript.Parameters.service_name | Should -Be 'Spooler'
            $ParametersForScript.SuccessCriteria.status | Should -Be 'Running'
            return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=@{mocked_call_for='SERVICE'}; ErrorMessage=$null }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        $result.IsAvailable | Should -BeTrue
        $result.Details.mocked_call_for | Should -Be 'SERVICE'
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
    }

    It '������ ���������� ������, ���� ������ �������� �� ������ (Test-Path ������ false)' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'NON_EXISTENT_METHOD'
        Mock Test-Path { Param($Path)
            if ($Path -like "*Check-NON_EXISTENT_METHOD.ps1") { return $false }
            return $true
        } -ModuleName Microsoft.PowerShell.Management -Verifiable
        Mock Invoke-CheckScript { throw "Invoke-CheckScript �� ������ ��� ���������!" } -ModuleName StatusMonitorAgentUtils -Verifiable -Scope It
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Test-Path -Times 1 -ModuleName Microsoft.PowerShell.Management
        Should -Invoke Invoke-CheckScript -Times 0 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '�� ������'
        $result.ErrorMessage | Should -Contain 'Check-NON_EXISTENT_METHOD.ps1'
    }

    It '������ ���������� ������, ���� ����� �� ������ � �������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.PSObject.Properties.Remove('method_name')
        Mock Invoke-CheckScript { throw "�� ������ ���� ����� �� ������ �������" } -ModuleName StatusMonitorAgentUtils -Verifiable -Scope It
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 0 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '������������ ������ �������'
    }

     It '������ ���������� ������, ���� Invoke-CheckScript ����������� ����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'SCRIPT_WITH_ERROR'
        $errorMessageFromInvoke = "����������� ������ ��� ������ �������"
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            if ($ScriptPath -like "*Check-SCRIPT_WITH_ERROR.ps1") {
                throw $errorMessageFromInvoke
            }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        Mock Test-Path { return $true } -ModuleName Microsoft.PowerShell.Management
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain $errorMessageFromInvoke
        $result.ErrorMessage | Should -Contain '������ ���������� ������� ��������'
    }

     It '������ ���������� ������, ���� Invoke-CheckScript ������ ������������ ������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'BAD_FORMAT_SCRIPT'
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            if ($ScriptPath -like "*Check-BAD_FORMAT_SCRIPT.ps1") {
                return "��� ������ ������, � �� ���-�������"
            }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        Mock Test-Path { return $true } -ModuleName Microsoft.PowerShell.Management
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '������ ������������ ������'
    }
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 ====

