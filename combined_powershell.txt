=== СПИСОК ФАЙЛОВ ===
Файл: F:\status\source\powershell\Dockerfile.tests (Кодировка: UTF8)
Файл: F:\status\source\powershell\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\configurator\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\configurator\README.txt (Кодировка: UTF8)
Файл: F:\status\source\powershell\offline-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\offline-agent\offline-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\offline-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\online-agent\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\online-agent\online-agent.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\online-agent\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\config.json (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\result_loader\result_loader.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\500 (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\README.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
Файл: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)


=== ДЕРЕВО КАТАЛОГОВ ===
F:\status\source\powershell
  |-- Dockerfile.tests (Кодировка: UTF8)
  |-- README.md (Кодировка: UTF8)
  |-- configurator\config.json (Кодировка: UTF8)
  |-- configurator\generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
  |-- configurator\README.txt (Кодировка: UTF8)
  |-- offline-agent\config.json (Кодировка: UTF8)
  |-- offline-agent\offline-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- offline-agent\README.md (Кодировка: UTF8)
  |-- online-agent\config.json (Кодировка: UTF8)
  |-- online-agent\online-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- online-agent\README.md (Кодировка: UTF8)
  |-- result_loader\config.json (Кодировка: UTF8)
  |-- result_loader\README.md (Кодировка: UTF8)
  |-- result_loader\result_loader.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\500 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\README.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-PING.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\configurator
  |-- config.json (Кодировка: UTF8)
  |-- generate_and_deliver_config.ps1 (Кодировка: UTF8 with BOM)
  |-- README.txt (Кодировка: UTF8)
F:\status\source\powershell\offline-agent
  |-- config.json (Кодировка: UTF8)
  |-- offline-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\online-agent
  |-- config.json (Кодировка: UTF8)
  |-- online-agent.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
F:\status\source\powershell\result_loader
  |-- config.json (Кодировка: UTF8)
  |-- README.md (Кодировка: UTF8)
  |-- result_loader.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\StatusMonitorAgentUtils
  |-- 500 (Кодировка: UTF8)
  |-- ManualTest-Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- ManualTest-SQL-Checks-Kaskad.ps1 (Кодировка: UTF8 with BOM)
  |-- README.md (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils.psd1 (Кодировка: UTF8)
  |-- StatusMonitorAgentUtils.psm1 (Кодировка: UTF8)
  |-- TEST_CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_PING.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- TEST_SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- Checks\README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- Checks\README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- Checks\README-Check-PING.md (Кодировка: UTF8)
  |-- Checks\README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- Checks\README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- Checks\README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- Checks\README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
  |-- tests\Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- tests\Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)
F:\status\source\powershell\StatusMonitorAgentUtils\Checks
  |-- Check-CERT_EXPIRY.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-DISK_USAGE.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PING.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-PROCESS_LIST.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SERVICE_STATUS.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_QUERY_EXECUTE.ps1 (Кодировка: UTF8 with BOM)
  |-- Check-SQL_XML_QUERY.ps1 (Кодировка: UTF8 with BOM)
  |-- README-Check-CERT_EXPIRY.md (Кодировка: UTF8)
  |-- README-Check-DISK_USAGE.md (Кодировка: UTF8)
  |-- README-Check-PING.md (Кодировка: UTF8)
  |-- README-Check-PROCESS_LIST.md (Кодировка: UTF8)
  |-- README-Check-SERVICE_STATUS.md (Кодировка: UTF8)
  |-- README-Check-SQL_QUERY_EXECUTE.md (Кодировка: UTF8)
  |-- README-Check-SQL_XML_QUERY.md (Кодировка: UTF8)
F:\status\source\powershell\StatusMonitorAgentUtils\tests
  |-- Check-PING.Tests.ps1 (Кодировка: UTF8 with BOM)
  |-- Invoke-StatusMonitorCheck.Tests.ps1 (Кодировка: UTF8 with BOM)


==== BEGIN FILE: F:\status\source\powershell\Dockerfile.tests ====
# Используем официальный образ PowerShell (на базе Linux по умолчанию)
FROM mcr.microsoft.com/powershell:latest

# Устанавливаем рабочую директорию
WORKDIR /tests

# Копируем ВСЮ папку модуля с тестами внутрь контейнера
# Убедись, что Dockerfile лежит в ПАПКЕ powershell/
# или измени путь копирования на `COPY ./ ./` если Dockerfile в корне powershell/StatusMonitorAgentUtils
COPY ./StatusMonitorAgentUtils /tests/StatusMonitorAgentUtils

# Устанавливаем Pester и другие зависимости (если нужны)
# Используем pwsh для выполнения команд PowerShell
# УБИРАЕМ Set-ExecutionPolicy
RUN pwsh -Command "Install-Module Pester -Force -SkipPublisherCheck -Scope CurrentUser; \
                   # Install-Module SqlServer -Force -SkipPublisherCheck -Scope CurrentUser; # Пример другой зависимости
                   Write-Host 'Pester installed.'"

# Устанавливаем рабочую директорию ВНУТРЬ папки с тестами модуля
WORKDIR /tests/StatusMonitorAgentUtils/tests

# Команда по умолчанию для запуска тестов
CMD ["pwsh", "-Command", "Invoke-Pester -Output Detailed -CI -PassThru"]
==== END FILE: F:\status\source\powershell\Dockerfile.tests ====

==== BEGIN FILE: F:\status\source\powershell\README.md ====
# PowerShell Скрипты для Status Monitor

Эта папка содержит PowerShell скрипты и модули, которые выполняют роль агентов мониторинга и вспомогательных утилит для системы Status Monitor.

## Структура

*   **`online-agent/`**: Содержит скрипт и конфигурацию для **Онлайн-агента**, работающего на машинах с прямым доступом к API сервера мониторинга.
    *   [`online-agent/README.md`](online-agent/README.md)
*   **`offline-agent/`**: Содержит скрипт и конфигурацию для **Оффлайн-агента**, работающего в изолированных сетях без доступа к API.
    *   [`offline-agent/README.md`](offline-agent/README.md)
*   **`result_loader/`**: Скрипт и конфигурация **Загрузчика Результатов**, который обрабатывает файлы (`*.zrpu`) от оффлайн-агентов и отправляет данные в API.
    *   [`result_loader/README.md`](result_loader/README.md)
*   **`configurator/`**: Скрипт и конфигурация **Конфигуратора**, который генерирует файлы с заданиями для оффлайн-агентов, запрашивая данные у API.
    *   [`configurator/README.md`](configurator/README.md)
*   **`StatusMonitorAgentUtils/`**: **ОБЩИЙ МОДУЛЬ PowerShell**, содержащий основную логику выполнения проверок. Используется как онлайн, так и оффлайн агентами.
    *   [`StatusMonitorAgentUtils/README.md`](StatusMonitorAgentUtils/README.md)

## Ключевой компонент: `StatusMonitorAgentUtils`

Этот модуль является сердцем выполнения проверок на стороне PowerShell.

*   **Диспетчер (`Invoke-StatusMonitorCheck`)**: Основная экспортируемая функция модуля. Агенты вызывают именно ее, передавая объект задания. Функция определяет, какой метод проверки нужно выполнить (`method_name` из задания), находит соответствующий скрипт `Checks/Check-*.ps1` и **запускает его локально** на машине агента, передавая нужные параметры.
*   **Скрипты проверок (`Checks/Check-*.ps1`)**: Папка `Checks` внутри `StatusMonitorAgentUtils` содержит отдельные `.ps1` файлы для каждого метода проверки (например, `Check-PING.ps1`, `Check-SERVICE_STATUS.ps1`). Каждый такой скрипт выполняет **только свою конкретную проверку**, используя переданные ему параметры (например, IP-адрес цели, имя службы), и возвращает стандартизированный результат.
*   **Вспомогательные функции**: Модуль также содержит функции для стандартизации формата результата (`New-CheckResultObject`) и, в будущем, может содержать другие общие утилиты.

**Важно:** Для добавления поддержки нового метода мониторинга необходимо создать соответствующий `Check-METHOD_NAME.ps1` файл в папке `Checks/` и реализовать в нем логику проверки и возврата стандартизированного результата.

## Принцип работы с Заданиями (Assignments)

Система использует модель "Заданий" (`Assignments`), хранящихся в центральной БД. Каждый результат проверки должен быть связан с конкретным заданием через `assignment_id`.

*   **Online-агент:** Получает задания (с `assignment_id`) от API. Вызывает `Invoke-StatusMonitorCheck`. Получает результат. Отправляет результат **вместе с `assignment_id`** в API `/api/v1/checks`.
*   **Offline-агент:** Получает задания (с `assignment_id`) из файла `.json.status.КОД_ТС`. Вызывает `Invoke-StatusMonitorCheck`. Получает результат. **Добавляет `assignment_id`** к полученному результату. Сохраняет массив дополненных результатов в файл `*.zrpu`.
*   **Загрузчик (`result_loader`):** Читает файл `*.zrpu`. Для каждой записи результата извлекает `assignment_id` и остальные данные, формирует запрос и отправляет его в API `/api/v1/checks`.

Это позволяет серверу точно сопоставить каждый полученный результат с конкретным заданием, настроенным администратором.
==== END FILE: F:\status\source\powershell\README.md ====

==== BEGIN FILE: F:\status\source\powershell\configurator\config.json ====
{
  "api_base_url": "http://localhost:48030/api",
  "api_key": "eWfRuIrdREe_Bt8jaOzUmZ23JYIwk6Keeu9dQZnywwI",
  "output_path_base": "F:\\status\\builds\\configs\\Generated",
  "delivery_path_base": "F:\\status\\builds\\delivery_conf",
  "log_file": "F:\\status\\builds\\Logs\\configurator.log",
  "log_level": "Info", 
  "subdivision_ids_to_process": [1516, 1060],
  "output_filename_template": "{version_tag}_assignments.json.status.{transport_code}",
  "delivery_subdir_template": "{transport_code}",
  "api_timeout_sec": 60
}
==== END FILE: F:\status\source\powershell\configurator\config.json ====

==== BEGIN FILE: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 ====
# powershell\configurator\generate_and_deliver_config.ps1 (Версия 3.6 - Полный JSON, без .zrpu)
<#
.SYNOPSIS
    Генерирует и доставляет конфигурационные файлы для оффлайн-агентов v4.4+.
    Файл содержит ПОЛНЫЙ JSON (метаданные + задания + хеш).
    Имя файла формируется БЕЗ .zrpu.
.NOTES
    Версия: 3.6
    Дата: 2024-05-19 (или актуальная)
    Изменения:
        - Сохраняет весь JSON ответ от API /offline_config.
        - Убран суффикс .zrpu из имени файла.
        - Добавлены проверки на наличие обязательных полей в ответе API.
#>
param(
    [string]$ConfigFile = "$PSScriptRoot\config.json",
    [string]$ParamLogFile = $null,
    [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
    [string]$ParamLogLevel = $null
)

# --- Вспомогательные функции (Sanitize-String, Write-Log, Get-OrElse) ---
filter Get-OrElse { param([object]$DefaultValue); if ($_) { $_ } else { $DefaultValue } }
function Sanitize-String { param([Parameter(Mandatory=$true)][string]$InputString,[string]$ReplacementChar=''); if($null-eq$InputString){return $null};try{return $InputString -replace '\p{C}',$ReplacementChar}catch{Write-Warning "Ошибка санитизации строки: $($_.Exception.Message)";return $InputString} }
function Write-Log { param ([Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)][string]$Level = "Info"); if (-not $script:Config -or -not $script:Config.log_file) { Write-Host "[$Level] $Message"; return }; $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }; $currentLevelValue = $logLevels[$script:EffectiveLogLevel]; if ($null -eq $currentLevelValue) { $currentLevelValue = $logLevels["Info"] }; $messageLevelValue = $logLevels[$Level]; if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] }; if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] - $Message"; Write-Host $logMessage -ForegroundColor $(switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}); try { $logDir = Split-Path $script:Config.log_file -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки для лога: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }; $logMessage | Out-File -FilePath $script:Config.log_file -Append -Encoding UTF8 -ErrorAction Stop } catch { Write-Host "[Error] Невозможно записать в лог '$($script:Config.log_file)': $($_.Exception.Message)" -ForegroundColor Red } } }

# --- Начало скрипта ---
$ScriptVersion = "3.6"
$script:Config = $null
$script:EffectiveLogLevel = "Info"
$script:ApiKey = $null

# --- Шаг 1: Чтение и валидация конфигурации ---
Write-Host "Загрузка конфигурации из файла: $ConfigFile"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Error "Критическая ошибка: Файл конфигурации '$ConfigFile' не найден."; exit 1 }
try { $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error "Критическая ошибка: Ошибка чтения/парсинга JSON '$ConfigFile'. Ошибка: $($_.Exception.Message)"; exit 1 }
# Проверка всех ОБЯЗАТЕЛЬНЫХ полей
$requiredConfigFields = @("api_base_url", "api_key", "output_path_base", "delivery_path_base", "log_file", "log_level", "subdivision_ids_to_process", "output_filename_template", "delivery_subdir_template")
$missingFields = $requiredConfigFields | Where-Object { -not $script:Config.PSObject.Properties.Name.Contains($_) }
if ($missingFields) { Write-Error "Критическая ошибка: В '$ConfigFile' отсутствуют поля: $($missingFields -join ', ')"; exit 1 }
# Проверка типа subdivision_ids_to_process
if ($script:Config.subdivision_ids_to_process -isnot [array]) { Write-Error "Критическая ошибка: 'subdivision_ids_to_process' должен быть массивом."; exit 1 }
# Переопределение logFile и logLevel из параметров, если переданы
if ($ParamLogFile) { $script:Config.log_file = $ParamLogFile }
if ($ParamLogLevel) { $script:Config.log_level = $ParamLogLevel }
# Валидация LogLevel
$validLogLevelsMap = @{ "Debug" = 0; "Verbose" = 1; "Info" = 2; "Warn" = 3; "Error" = 4 }
if (-not $validLogLevelsMap.ContainsKey($script:Config.log_level)) { Write-Host "[WARN] Некорректный LogLevel '$($script:Config.log_level)'. Используется 'Info'." -F Yellow; $script:Config.log_level = "Info" }
$script:EffectiveLogLevel = $script:Config.log_level
$script:ApiKey = $script:Config.api_key

# --- Шаг 2: Инициализация и логирование ---
$logDir = Split-Path $script:Config.log_file -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки лога: '$logDir'..."; try { New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null } catch { Write-Error "Критическая: Не удалось создать папку лога '$logDir': $($_.Exception.Message)"; exit 1 } }
Write-Log "Скрипт конфигуратора (v$ScriptVersion) запущен." "Info"
Write-Log "Конфигурация из '$ConfigFile'" "Verbose"
Write-Log "API URL: $($script:Config.api_base_url)" "Verbose"
$apiKeyPartial = "[Не задан]"; if($script:ApiKey){$len=$script:ApiKey.Length;$p=$script:ApiKey.Substring(0,[math]::Min(4,$len));$s=if($len -gt 8){$script:ApiKey.Substring($len-4,4)}else{""};$apiKeyPartial="$p....$s"}; Write-Log "API Key (частично): $apiKeyPartial" "Debug";
Write-Log "Папка вывода: $($script:Config.output_path_base)" "Verbose"
Write-Log "Папка доставки: $($script:Config.delivery_path_base | Get-OrElse '[Не задана]')" "Verbose"
Write-Log "Шаблон имени файла: $($script:Config.output_filename_template)" "Verbose" # Убрали .zrpu
Write-Log "Шаблон подпапки доставки: $($script:Config.delivery_subdir_template)" "Verbose"
Write-Log "Список ID для обработки: $($script:Config.subdivision_ids_to_process -join ', ' | Get-OrElse '[Авто (все с кодом ТС)]')" "Verbose"

# --- Шаг 3: Определение списка ObjectId для обработки ---
$objectIdsToProcess = @()
Write-Log "Анализ 'subdivision_ids_to_process'..." "Info"
if ($script:Config.subdivision_ids_to_process.Count -gt 0) {
    Write-Log "Обнаружен список ID в конфиге. Обработка для: $($script:Config.subdivision_ids_to_process -join ', ')" "Info"
    $objectIdsToProcess = $script:Config.subdivision_ids_to_process | Where-Object { $_ -match '^\d+$' } | ForEach-Object { [int]$_ }
    if ($objectIdsToProcess.Count -ne $script:Config.subdivision_ids_to_process.Count) { Write-Log "Предупреждение: Нечисловые значения в 'subdivision_ids_to_process' проигнорированы." "Warn" }
} else {
    Write-Log "Список ID в конфиге пуст (`[]`). Запрашиваем все подразделения с кодом ТС из API..." "Info"
    $apiUrlSubdivisions = "$($script:Config.api_base_url.TrimEnd('/'))/v1/subdivisions?limit=1000" # Запрос всех
    $headers = @{ 'X-API-Key' = $script:ApiKey }
    try {
        Write-Log "Запрос: GET $apiUrlSubdivisions" "Verbose"
        $response = Invoke-RestMethod -Uri $apiUrlSubdivisions -Method Get -Headers $headers -TimeoutSec ($script:Config.api_timeout_sec | Get-OrElse 60) -ErrorAction Stop
        if ($response -and $response.items -is [array]) {
            $subdivisions = $response.items
            # Фильтруем по наличию transport_system_code и object_id
            $objectIdsToProcess = $subdivisions | Where-Object { $_.transport_system_code -and $_.object_id } | Select-Object -ExpandProperty object_id
            Write-Log "Получено $($subdivisions.Count) подразделений. Найдено для обработки (с кодом ТС): $($objectIdsToProcess.Count)" "Info"
            if ($objectIdsToProcess.Count -eq 0 -and $subdivisions.Count -gt 0) { Write-Log "Предупреждение: Ни у одного подразделения из API не задан transport_system_code." "Warn" }
        } else { Write-Log "Ответ API /subdivisions не содержит ожидаемый массив 'items'." "Warn" }
    } catch {
        $rawErrorMessage = $_.Exception.Message; $responseBody="[N/A]"; $statusCode=$null; if($_.Exception.Response){try{$statusCode=$_.Exception.Response.StatusCode}catch{}; try{$stream=[System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream());$responseBody=$stream.ReadToEnd();$stream.Close()}catch{$responseBody="[Read Error]"}};
        $cleanErrorMessage = Sanitize-String -InputString $rawErrorMessage; $cleanResponseBody = Sanitize-String -InputString $responseBody; $finalLogMessage = "${cleanErrorMessage} - Code: $($statusCode|Get-OrElse 'N/A') - Resp: ${cleanResponseBody}"
        Write-Log "Критическая ошибка получения списка подразделений из API ($apiUrlSubdivisions): $finalLogMessage" "Error"
        Write-Log "Проверьте доступность API, API ключ и права доступа. Завершение работы." "Error"
        exit 1
    }
}

if ($objectIdsToProcess.Count -eq 0) { Write-Log "Нет ObjectId для обработки. Завершение." "Info"; exit 0 }

# --- Шаг 4: Цикл обработки каждого ObjectId ---
Write-Log "Начало цикла обработки для $($objectIdsToProcess.Count) подразделений: $($objectIdsToProcess -join ', ')" "Info"
foreach ($currentObjectId in $objectIdsToProcess) {
    Write-Log "--- Обработка ObjectId: $currentObjectId ---" "Info"
    # 1. Запрос конфигурации
    $apiUrlConfig = "$($script:Config.api_base_url.TrimEnd('/'))/v1/objects/${currentObjectId}/offline_config"
    $apiResponse = $null
    $headersConfig = @{ 'X-API-Key' = $script:ApiKey }
    Write-Log "Запрос конфигурации: GET $apiUrlConfig" "Verbose"
    try {
        $apiResponse = Invoke-RestMethod -Uri $apiUrlConfig -Method Get -Headers $headersConfig -TimeoutSec ($script:Config.api_timeout_sec | Get-OrElse 60) -ErrorAction Stop

        # <<< Проверка ответа API на наличие ОБЯЗАТЕЛЬНЫХ полей >>>
        if (-not ($apiResponse -is [PSCustomObject]) -or
            (-not $apiResponse.PSObject.Properties.Name.Contains('assignment_config_version')) -or
            (-not $apiResponse.PSObject.Properties.Name.Contains('transport_system_code')) -or
            (-not $apiResponse.PSObject.Properties.Name.Contains('assignments')) -or
            ($apiResponse.assignments -isnot [array]))
        {
            # Если структура не та, но есть поле error от API
            if($apiResponse -is [PSCustomObject] -and $apiResponse.error -and $apiResponse.message){
                throw "API вернул ошибку: Код '$($apiResponse.error)', Сообщение '$($apiResponse.message)'"
            } else {
                throw "Некорректная структура ответа API /offline_config или отсутствуют обязательные поля (assignment_config_version, transport_system_code, assignments) для ObjectId ${currentObjectId}."
            }
        }

        # <<< Извлекаем данные после проверки >>>
        $versionTag = $apiResponse.assignment_config_version
        $transportCode = $apiResponse.transport_system_code
        $assignmentCount = $apiResponse.assignments.Count
        Write-Log "Конфигурация получена. Версия: ${versionTag}. Заданий: ${assignmentCount}. Код ТС: ${transportCode}." "Info"

    } catch {
        $exceptionMessage = $_.Exception.Message; $responseBody = "[Нет тела ответа]"; $statusCode = $null;
        if ($_.Exception.Response) { try {$statusCode = $_.Exception.Response.StatusCode} catch {}; try {$errorStream = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream()); $responseBody = $errorStream.ReadToEnd(); $errorStream.Close()} catch {$responseBody = "[Ошибка чтения тела ответа]"} };
        $logErrorMessage = "Ошибка получения конфигурации от API для ObjectId ${currentObjectId}: $($exceptionMessage)";
        if ($statusCode -eq 401 -or $statusCode -eq 403) { $logErrorMessage += " (Проверьте API ключ и права доступа 'configurator'!)"; }
        else { $logErrorMessage += " - Code: $($statusCode | Get-OrElse 'N/A') - Resp: $responseBody"; };
        Write-Log $logErrorMessage "Error";
        continue # Пропускаем этот ID и переходим к следующему
    }

    # 2. Формирование имени файла (БЕЗ .zrpu)
    $outputFileNameBase = $script:Config.output_filename_template -replace "{version_tag}", $versionTag -replace "{transport_code}", $transportCode
    # Убираем недопустимые символы из ИМЕНИ файла
    $outputFileName = $outputFileNameBase -replace '[\\/:*?"<>|]', '_'
    # Собираем полный путь
    $outputFilePath = Join-Path -Path $script:Config.output_path_base -ChildPath $outputFileName
    $outputDir = Split-Path $outputFilePath -Parent

    # 3. Создание папки вывода, если её нет
    if (-not (Test-Path $outputDir -PathType Container)) {
        Write-Log "Создание папки вывода '$outputDir'" "Verbose"
        try { New-Item -Path $outputDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }
        catch { Write-Log "Ошибка создания папки вывода '$outputDir'. Пропуск ${currentObjectId}. Error: $($_.Exception.Message)" "Error"; continue }
    }

    # 4. Сохранение ПОЛНОГО JSON ответа API в файл
    Write-Log "Сохранение полной конфигурации в файл: $outputFilePath" "Verbose"
    try {
        # Преобразуем объект PowerShell в красивую JSON строку
        $jsonToSave = $apiResponse | ConvertTo-Json -Depth 10 -WarningAction SilentlyContinue
        # Используем WriteAllText для записи строки в UTF-8 без BOM
        $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false)
        [System.IO.File]::WriteAllText($outputFilePath, $jsonToSave, $Utf8NoBomEncoding)
        Write-Log "Файл конфигурации '$outputFileName' сохранен в '$outputDir'." "Info"
    } catch {
        Write-Log "Ошибка сохранения файла '$outputFilePath'. Пропуск ${currentObjectId}. Error: $($_.Exception.Message)" "Error"
        continue
    }

    # 5. Доставка файла (если delivery_path_base задан)
    if ($script:Config.delivery_path_base) {
        $deliverySubDir = $script:Config.delivery_subdir_template -replace "{transport_code}", $transportCode
        $deliveryPath = Join-Path -Path $script:Config.delivery_path_base -ChildPath $deliverySubDir
        $deliveryFileName = $outputFileName # Имя файла уже сформировано правильно
        $deliveryFilePath = Join-Path -Path $deliveryPath -ChildPath $deliveryFileName
        Write-Log "Проверка пути доставки: $deliveryFilePath" "Info"

        # Создаем папку доставки, если ее нет
        if (-not (Test-Path $deliveryPath -PathType Container)) {
            Write-Log "Папка доставки '$deliveryPath' не найдена. Создание..." "Warn"
            try { New-Item -Path $deliveryPath -ItemType Directory -Force -ErrorAction Stop | Out-Null; Write-Log "Папка '$deliveryPath' создана." "Verbose" }
            catch { Write-Log "Ошибка создания папки доставки '$deliveryPath'. Пропуск доставки. Error: $($_.Exception.Message)" "Error"; }
        }

        # Копируем файл, если папка доставки существует
        if (Test-Path $deliveryPath -PathType Container) {
            Write-Log "Копирование '$outputFilePath' -> '$deliveryFilePath'" "Verbose"
            try { Copy-Item -Path $outputFilePath -Destination $deliveryFilePath -Force -ErrorAction Stop; Write-Log "Файл '$outputFileName' доставлен в '$deliveryPath'." "Info" }
            catch { Write-Log "Ошибка копирования в '$deliveryFilePath'. Error: $($_.Exception.Message)" "Error"; }
        }
    } else { Write-Log "delivery_path_base не задан. Пропуск доставки." "Info" }

    Write-Log "--- Обработка ObjectId: $currentObjectId завершена ---" "Info"
} # --- Конец цикла foreach ---

Write-Log "Работа скрипта конфигуратора успешно завершена." "Info"
==== END FILE: F:\status\source\powershell\configurator\generate_and_deliver_config.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\configurator\README.txt ====

---

**8. `powershell/configurator/README.md` (Обновление)**

(Замени существующий README.md на этот)

```markdown
# PowerShell Конфигуратор Оффлайн-Агентов (configurator) v3.6

Этот скрипт (`generate_and_deliver_config.ps1`) предназначен для автоматической генерации и (опционально) доставки файлов конфигурации с заданиями для **оффлайн-агентов** системы мониторинга Status Monitor.

## Назначение

*   Подключаться к центральному API системы мониторинга.
*   Запрашивать актуальную конфигурацию заданий для одного или нескольких подразделений (объектов), идентифицируемых по их `ObjectId`.
*   Сохранять полученную конфигурацию (включая метаданные и список заданий) в **JSON файлы** специального формата (`{version_tag}_assignments.json.status.{transport_code}`).
*   Опционально доставлять (копировать) сгенерированные файлы в указанные папки (например, общие сетевые ресурсы, откуда их заберет Транспортная Система или напрямую оффлайн-агент).

## Принцип Работы

1.  Скрипт запускается (вручную или по расписанию).
2.  Читает параметры из файла `config.json`.
3.  Определяет, для каких подразделений (`ObjectId`) нужно сгенерировать конфигурацию:
    *   Если массив `subdivision_ids_to_process` в `config.json` не пуст, обрабатываются только эти ID.
    *   Если массив пуст (`[]`), скрипт запрашивает у API список *всех* подразделений (`GET /api/v1/subdivisions`) и выбирает те, у которых задан `transport_system_code`.
4.  Для каждого выбранного `ObjectId`:
    *   Выполняет GET-запрос к эндпоинту `/api/v1/objects/{ObjectId}/offline_config`, используя API-ключ (с ролью `configurator`).
    *   API (через функцию БД `generate_offline_config`) формирует и возвращает JSON-объект конфигурации, который включает:
        *   `object_id`, `config_type`, `generated_at`
        *   `assignment_config_version`: Уникальный тег версии этой конфигурации (используется оффлайн-агентом).
        *   `transport_system_code`: Код ТС подразделения.
        *   `default_check_interval_seconds`
        *   `assignments`: Массив актуальных заданий для этого объекта.
    *   Скрипт проверяет корректность ответа API.
    *   Формирует имя файла на основе шаблона `output_filename_template`, подставляя `version_tag` и `transport_code`. Пример: `20240520123000_1060_a1b2c3d4_assignments.json.status.TSP`.
    *   Сохраняет полученный JSON от API в файл с этим именем в папку `output_path_base` (в кодировке UTF-8 без BOM).
    *   Если в `config.json` задан `delivery_path_base`:
        *   Формирует путь к целевой подпапке на основе `delivery_subdir_template` и `transport_code`.
        *   Создает целевую папку, если ее нет.
        *   Копирует сгенерированный файл конфигурации в эту целевую папку.
5.  Логирует свою работу в файл, указанный в `config.json`.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке:

```json
{
  "api_base_url": "http://localhost:48030/api",
  "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_CONFIGURATOR",
  "output_path_base": "F:\\status\\builds\\configs\\Generated",
  "delivery_path_base": "F:\\status\\builds\\delivery_conf",
  "log_file": "F:\\status\\builds\\Logs\\configurator.log",
  "log_level": "Info",
  "subdivision_ids_to_process": [],
  "output_filename_template": "{version_tag}_assignments.json.status.{transport_code}",
  "delivery_subdir_template": "{transport_code}",
  "api_timeout_sec": 60
}

Поля конфигурации:

    api_base_url: (Строка, Обязательно) Базовый URL API сервера Status Monitor.

    api_key: (Строка, Обязательно) API ключ с ролью configurator.

    output_path_base: (Строка, Обязательно) Папка для локального сохранения сгенерированных *.json.status.* файлов.

    delivery_path_base: (Строка, Обязательно) Базовый путь для доставки файлов (например, корень общих папок ТС). Скрипт создаст подпапки внутри этого пути.

    log_file: (Строка, Обязательно) Полный путь к лог-файлу конфигуратора.

    log_level: (Строка, Опционально, По умолчанию "Info") Уровень логирования (Debug, Verbose, Info, Warn, Error).

    subdivision_ids_to_process: (Массив Чисел, Обязательно) Определяет, какие подразделения обрабатывать:

        [] (пустой массив): Обработать все с transport_system_code.

        [1516, 1060]: Обработать только указанные ObjectId.

    output_filename_template: (Строка, Обязательно) Шаблон имени файла. Плейсхолдеры: {version_tag}, {transport_code}. Расширение должно быть .json.status.{transport_code}.

    delivery_subdir_template: (Строка, Обязательно) Шаблон имени подпапки в delivery_path_base. Обычно {transport_code}.

    api_timeout_sec: (Число, Опционально, По умолчанию 60) Таймаут ожидания ответа от API в секундах.


# Использовать config.json по умолчанию
.\generate_and_deliver_config.ps1

# Указать другой файл конфигурации
.\generate_and_deliver_config.ps1 -ConfigFile "C:\configs\monitor_cfg.json"

Требования

    PowerShell 5.1+.

    Сетевой доступ к API (api_base_url).

    Права на запись в output_path_base и delivery_path_base.

    Права на запись в log_file.

    Действительный API ключ с ролью configurator.
==== END FILE: F:\status\source\powershell\configurator\README.txt ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\config.json ====
{
    "object_id": 1060, 
    "config_type": "offline_multi_check_agent_v2.3", 
    "check_interval_seconds": 60,
    "output_path": "F:\\status\\builds\\results_offline", 
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_OfflineChecks.json.status.zrpu", 
    "logFile": "F:\\status\\builds\\Logs\\offline_agent.log",
    "LogLevel": "Debug", 
    "assignments_file_path": "F:\\status\\builds\\delivery_conf\\TSP"
}
==== END FILE: F:\status\source\powershell\offline-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\offline-agent.ps1 ====
# powershell\offline-agent\offline-agent.ps1
# Оффлайн-агент мониторинга v3.1.
# Исправлено добавление assignment_id к результатам.
<#
.SYNOPSIS
    Оффлайн-агент системы мониторинга Status Monitor v3.1.
.DESCRIPTION
    Предназначен для работы в изолированных сетях без доступа к API.
    1. Читает локальную конфигурацию агента ('config.json').
    2. Периодически проверяет наличие файла с заданиями
       в папке 'assignments_file_path'.
    3. При обнаружении нового файла заданий:
       - Читает JSON-содержимое.
       - Извлекает список 'assignments' и 'assignment_config_version'.
       - Сохраняет их для выполнения.
    4. В цикле выполняет ВСЕ активные задания с помощью
       Invoke-StatusMonitorCheck из модуля StatusMonitorAgentUtils.
    5. Собирает стандартизированные результаты всех проверок.
    6. **Создает новый объект для каждого результата, объединяя
       стандартный результат и 'assignment_id'.**
    7. Формирует итоговый JSON-файл (*.zrpu) в папке 'output_path',
       включая метаданные (версии агента и конфига) и массив 'results'.
    8. Этот *.zrpu файл затем передается и загружается на сервер.
.NOTES
    Версия: 3.1
    Дата: 2024-05-20
    Изменения v3.1:
        - Исправлен способ добавления 'assignment_id' к результатам. Вместо
          Add-Member теперь создается новый объект путем слияния хэш-таблиц.
    Изменения v3.0:
        - Попытка добавить поле 'assignment_id' к каждому элементу в массиве 'results'.
    Зависимости: PowerShell 5.1+, модуль StatusMonitorAgentUtils, наличие файла конфигурации заданий.
#>

param (
    # Путь к файлу конфигурации агента.
    [string]$configFile = "$PSScriptRoot\config.json",

    # Параметры для переопределения лог-файла и уровня логирования из командной строки.
    [string]$paramLogFile = $null,
    [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
    [string]$paramLogLevel = $null
)

# --- Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try {
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils загружен."
} catch {
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    exit 1
} finally {
    $ErrorActionPreference = "Continue"
}
# --- Конец загрузки модуля ---

# --- Глобальные переменные ---
# Версия текущего скрипта оффлайн-агента
$AgentScriptVersion = "agent_script_v3.1" # Обновили версию

# Имя компьютера
$script:ComputerName = $env:COMPUTERNAME
# Текущий список заданий (массив объектов PSCustomObject из файла конфигурации)
$script:currentAssignments = $null
# Текущая версия файла конфигурации заданий (строка из файла)
$script:currentAssignmentVersion = $null
# Путь к последнему обработанному файлу конфигурации заданий
$script:lastProcessedConfigFile = $null
# Объект с конфигурацией самого агента (из config.json)
$script:localConfig = $null
# Путь к лог-файлу агента
$script:logFile = $null
# Установленный уровень логирования
$script:LogLevel = "Info"
# Допустимые уровни логирования
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")


# --- Функции ---

#region Функции

<#
.SYNOPSIS Записывает сообщение в лог.
#>
function Write-Log{
    param( [Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug","Verbose","Info","Warn","Error",IgnoreCase=$true)] [string]$Level="Info" ); if (-not $script:localConfig -or -not $script:logFile) { Write-Host "[$Level] $Message"; return }; $logLevels=@{"Debug"=4;"Verbose"=3;"Info"=2;"Warn"=1;"Error"=0}; $effectiveLogLevel = $script:LogLevel; if(-not $logLevels.ContainsKey($effectiveLogLevel)){ $effectiveLogLevel="Info" }; $currentLevelValue = $logLevels[$effectiveLogLevel]; $messageLevelValue = $logLevels[$Level]; if($null -eq $messageLevelValue){ $messageLevelValue=$logLevels["Info"] }; if($messageLevelValue -le $currentLevelValue){ $timestamp=Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage="[$timestamp] [$Level] [$script:ComputerName] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; if($script:logFile){ try { $logDir = Split-Path $script:logFile -Parent; if($logDir -and (-not(Test-Path $logDir -PathType Container))){ Write-Host "[INFO] Создание папки логов: '$logDir'."; New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null }; Add-Content -Path $script:logFile -Value $logMessage -Encoding UTF8 -Force -EA Stop } catch { Write-Host "[CRITICAL] Ошибка записи в лог '$script:logFile': $($_.Exception.Message)" -ForegroundColor Red; try { $fallbackLog = "$PSScriptRoot\offline_agent_fallback.log"; Add-Content -Path $fallbackLog -Value $logMessage -Encoding UTF8 -Force -EA SilentlyContinue; Add-Content -Path $fallbackLog -Value "[CRITICAL] Ошибка записи в '$script:logFile': $($_.Exception.Message)" -Encoding UTF8 -Force -EA SilentlyContinue } catch {} } } }
}

<#
.SYNOPSIS Возвращает значение по умолчанию, если входное значение ложно.
#>
filter Get-OrElse_Internal{ param([object]$DefaultValue); if ($_) { $_ } else { $DefaultValue } }

#endregion Функции

# --- Основной код агента ---

# 1. Чтение и валидация конфигурации агента
# ... (код чтения и валидации конфига без изменений) ...
Write-Host "Оффлайн-агент мониторинга v$AgentScriptVersion"; Write-Host "Чтение конфигурации агента: $configFile"
if(-not(Test-Path $configFile -PathType Leaf)){ Write-Error "Критическая ошибка: Файл конфигурации '$configFile' не найден."; exit 1 }
try { $script:localConfig = Get-Content -Path $configFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error "Критическая ошибка: Ошибка чтения/парсинга JSON из '$configFile': $($_.Exception.Message)"; exit 1 }
$requiredLocalConfigFields = @("object_id","output_path","output_name_template","assignments_file_path","logFile","LogLevel","check_interval_seconds"); $missingFields = $requiredLocalConfigFields | Where-Object { -not ($script:localConfig.PSObject.Properties.Name.Contains($_)) -or $null -eq $script:localConfig.$_ -or ($script:localConfig.$_ -is [string] -and [string]::IsNullOrWhiteSpace($script:localConfig.$_))}; if($missingFields){ Write-Error "Критическая ошибка: Отсутствуют/пусты обязательные поля в '$configFile': $($missingFields -join ', ')"; exit 1 }
$script:logFile = if($PSBoundParameters.ContainsKey('paramLogFile') -and $paramLogFile){ $paramLogFile } else { $script:localConfig.logFile }; $script:LogLevel = if($PSBoundParameters.ContainsKey('paramLogLevel') -and $paramLogLevel){ $paramLogLevel } else { $script:localConfig.LogLevel }; if(-not $ValidLogLevels.Contains($script:LogLevel)){ Write-Host "[WARN] Некорректный LogLevel '$($script:LogLevel)'. Используется 'Info'." -ForegroundColor Yellow; $script:LogLevel = "Info" }; $checkInterval = 60; if($script:localConfig.check_interval_seconds -and [int]::TryParse($script:localConfig.check_interval_seconds,[ref]$null) -and $script:localConfig.check_interval_seconds -ge 5){ $checkInterval = $script:localConfig.check_interval_seconds } else { Write-Log "Некорректное значение check_interval_seconds ('$($script:localConfig.check_interval_seconds)'). Используется $checkInterval сек." "Warn" }
$objectId = $script:localConfig.object_id; $outputPath = $script:localConfig.output_path; $outputNameTemplate = $script:localConfig.output_name_template; $assignmentsFolderPath = $script:localConfig.assignments_file_path


# 2. Инициализация и проверка путей
# ... (код инициализации и проверки путей без изменений) ...
Write-Log "Оффлайн-агент запущен. Версия: $AgentScriptVersion. Имя хоста: $script:ComputerName" "Info"; Write-Log ("Параметры: ObjectID={0}, Интервал={1} сек, Папка заданий='{2}', Папка результатов='{3}'" -f $objectId, $checkInterval, $assignmentsFolderPath, $outputPath) "Info"; Write-Log "Логирование в '$script:logFile' с уровнем '$script:LogLevel'" "Info"; if(-not(Test-Path $outputPath -PathType Container)){ Write-Log "Папка для результатов '$outputPath' не найдена. Попытка создать..." "Warn"; try { New-Item -Path $outputPath -ItemType Directory -Force -ErrorAction Stop | Out-Null; Write-Log "Папка '$outputPath' успешно создана." "Info" } catch { Write-Log "Критическая ошибка: Не удалось создать папку для результатов '$outputPath': $($_.Exception.Message)" "Error"; exit 1 } }; if(-not(Test-Path $assignmentsFolderPath -PathType Container)){ Write-Log "Критическая ошибка: Папка для файлов заданий '$assignmentsFolderPath' не найдена." "Error"; exit 1 }


# --- 3. Основной цикл работы агента ---
Write-Log "Запуск основного цикла агента..." "Info"
while ($true) {
    $cycleStartTime = Get-Date
    Write-Log "Начало итерации цикла ($($cycleStartTime.ToString('s')))." "Verbose"

    # --- 3.1 Поиск и чтение файла конфигурации заданий ---
    # ... (код поиска и чтения файла конфига без изменений) ...
    $latestConfigFile = $null; $configError = $null; $configData = $null
    try { $configFileNamePattern = "*_${objectId}_*_assignments.json.status.*"; Write-Log "Поиск файла конфигурации в '$assignmentsFolderPath' по шаблону '$configFileNamePattern'..." "Debug"; $foundFiles = Get-ChildItem -Path $assignmentsFolderPath -Filter $configFileNamePattern -File -ErrorAction SilentlyContinue; if ($Error.Count -gt 0 -and $Error[0].CategoryInfo.Category -eq 'ReadError') { throw ("Ошибка доступа при поиске файла конфигурации в '$assignmentsFolderPath': " + $Error[0].Exception.Message); $Error.Clear() }; if ($foundFiles) { $latestConfigFile = $foundFiles | Sort-Object Name -Descending | Select-Object -First 1; Write-Log "Найден последний файл конфигурации: $($latestConfigFile.FullName)" "Verbose" } else { Write-Log "Файлы конфигурации для ObjectID $objectId в '$assignmentsFolderPath' не найдены." "Warn" } } catch { $configError = "Ошибка поиска файла конфигурации: $($_.Exception.Message)"; Write-Log $configError "Error" }
    if ($latestConfigFile -ne $null -and $configError -eq $null) { if ($latestConfigFile.FullName -ne $script:lastProcessedConfigFile) { Write-Log "Обнаружен новый/обновленный файл конфигурации: $($latestConfigFile.Name). Чтение..." "Info"; $tempAssignments = $null; $tempVersionTag = $null; try { $fileContent = Get-Content -Path $latestConfigFile.FullName -Raw -Encoding UTF8 -ErrorAction Stop; $fileContentClean = $fileContent.TrimStart([char]0xFEFF); $configData = $fileContentClean | ConvertFrom-Json -ErrorAction Stop; if ($null -eq $configData -or (-not $configData.PSObject.Properties.Name.Contains('assignments')) -or ($configData.assignments -isnot [array]) -or (-not $configData.PSObject.Properties.Name.Contains('assignment_config_version')) -or (-not $configData.assignment_config_version) ) { throw ("Файл '$($latestConfigFile.Name)' имеет некорректную структуру JSON...") }; $tempVersionTag = $configData.assignment_config_version; $tempAssignments = $configData.assignments; Write-Log ("Файл '{0}' успешно прочитан..." -f $latestConfigFile.Name, $tempAssignments.Count, $tempVersionTag) "Info"; $script:currentAssignments = $tempAssignments; $script:currentAssignmentVersion = $tempVersionTag; $script:lastProcessedConfigFile = $latestConfigFile.FullName; Write-Log "Список заданий обновлен (версия: $tempVersionTag)..." "Info" } catch { $errorMsg = "Критическая ошибка обработки файла '$($latestConfigFile.Name)': $($_.Exception.Message)"; Write-Log $errorMsg "Error"; Write-Log ("Продолжаем использовать предыдущий список заданий (версия: {0})." -f ($script:currentAssignmentVersion | Get-OrElse_Internal '[неизвестно]')) "Warn" } } else { Write-Log "Файл конфигурации '$($latestConfigFile.Name)' не изменился." "Verbose" } } elseif ($configError -ne $null) { Write-Log "Продолжаем использовать предыдущий список заданий..." "Warn" } elseif ($script:lastProcessedConfigFile -ne $null) { Write-Log "Файлы конфигурации не найдены. Продолжаем использовать предыдущий список..." "Warn" } else { Write-Log "Файлы конфигурации не найдены..." "Info" }

    # --- 3.2 Выполнение текущего списка заданий ---
    $cycleCheckResultsList = [System.Collections.Generic.List[object]]::new()

    if ($script:currentAssignments -ne $null -and $script:currentAssignments.Count -gt 0) {
        $assignmentsCount = $script:currentAssignments.Count
        Write-Log "Начало выполнения $assignmentsCount заданий (Версия конфига: $($script:currentAssignmentVersion | Get-OrElse_Internal 'N/A'))..." "Info"
        $completedCount = 0

        foreach ($assignmentRaw in $script:currentAssignments) {
            $completedCount++
            $assignment = [PSCustomObject]$assignmentRaw
            Write-Log "Выполнение $completedCount/$assignmentsCount (ID: $($assignment.assignment_id))..." "Verbose"

            if ($null -eq $assignment -or $null -eq $assignment.assignment_id -or -not $assignment.method_name) {
                Write-Log "Пропущено некорректное задание в списке: $($assignment | Out-String)" "Warn"
                # --- ИЗМЕНЕНО: Создаем объект ошибки через слияние ---
                $errorDetails = @{ assignment_object = ($assignment | Out-String) }
                $errorResultBase = New-CheckResultObject -IsAvailable $false `
                                      -ErrorMessage "Некорректная структура задания в файле конфигурации." `
                                      -Details $errorDetails
                $idPart = @{ assignment_id = ($assignment.assignment_id | Get-OrElse_Internal $null) }
                $errorResultToSave = $idPart + $errorResultBase
                $cycleCheckResultsList.Add($errorResultToSave)
                # --- КОНЕЦ ИЗМЕНЕНИЯ ---
                continue
            }

            $checkResult = $null
            try {
                # Вызываем диспетчер проверок
                $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment `
                                                        -Verbose:$VerbosePreference `
                                                        -Debug:$DebugPreference

                Write-Log ("Результат ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f `
                           $assignment.assignment_id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) "Verbose"

                # --- ИЗМЕНЕНО: Создаем НОВЫЙ объект результата с ID через слияние ---
                $idPart = @{ assignment_id = $assignment.assignment_id }
                $resultToSave = $idPart + $checkResult
                # --- КОНЕЦ ИЗМЕНЕНИЯ ---

                # Отладочный вывод (если включен Debug)
                Write-Debug ("Объект ДО добавления в список (ID: {0}): {1}" -f `
                             $assignment.assignment_id, ($resultToSave | ConvertTo-Json -Depth 4 -Compress))

                # Добавляем результат в список для файла
                $cycleCheckResultsList.Add($resultToSave)

            } catch {
                 # Обработка критической ошибки выполнения Invoke-StatusMonitorCheck
                 $errorMessage = "Критическая ошибка при выполнении задания ID $($assignment.assignment_id): $($_.Exception.Message)"
                 Write-Log $errorMessage "Error"
                 # Создаем запись об ошибке
                 $errorDetails = @{ ErrorRecord = $_.ToString() }
                 $errorResultBase = New-CheckResultObject -IsAvailable $false `
                                      -ErrorMessage $errorMessage `
                                      -Details $errorDetails
                 # --- ИЗМЕНЕНО: Создаем НОВЫЙ объект ошибки с ID через слияние ---
                 $idPart = @{ assignment_id = $assignment.assignment_id }
                 $errorResultToSave = $idPart + $errorResultBase
                 # --- КОНЕЦ ИЗМЕНЕНИЯ ---

                 # Отладочный вывод для ошибки
                 Write-Debug ("ОБЪЕКТ ОШИБКИ ДО добавления в список (ID: {0}): {1}" -f `
                              $assignment.assignment_id, ($errorResultToSave | ConvertTo-Json -Depth 4 -Compress))

                 # Добавляем результат с ошибкой в общий список
                 $cycleCheckResultsList.Add($errorResultToSave)
            }
        } # Конец foreach assignment

        Write-Log "Выполнение $assignmentsCount заданий завершено. Собрано результатов: $($cycleCheckResultsList.Count)." "Info"

    } else {
        Write-Log "Нет активных заданий для выполнения в этой итерации." "Verbose"
    }

    # --- 3.3 Формирование и сохранение файла результатов (*.zrpu) ---
    if ($cycleCheckResultsList.Count -gt 0) {
        # ... (код формирования $finalPayload и сохранения файла без изменений) ...
        $finalPayload = @{ agent_script_version = $AgentScriptVersion; assignment_config_version = $script:currentAssignmentVersion; results = $cycleCheckResultsList }
        $timestampForFile = Get-Date -Format "ddMMyy_HHmmss"; $outputFileName = $outputNameTemplate -replace "{object_id}", $objectId -replace "{ddMMyy_HHmmss}", $timestampForFile; $outputFileName = $outputFileName -replace '[\\/:*?"<>|]', '_'; $outputFileFullPath = Join-Path $outputPath $outputFileName
        Write-Log "Сохранение $($cycleCheckResultsList.Count) результатов в файл: '$outputFileFullPath'" "Info"; Write-Log ("Версия агента: {0}, Версия конфига заданий: {1}" -f $AgentScriptVersion, ($script:currentAssignmentVersion | Get-OrElse_Internal 'N/A')) "Verbose"
        try { $jsonToSave = $finalPayload | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue; $Utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false); [System.IO.File]::WriteAllText($outputFileFullPath, $jsonToSave, $Utf8NoBomEncoding); Write-Log "Файл результатов '$outputFileName' успешно сохранен." "Info" }
        catch { Write-Log "Критическая ошибка сохранения файла результатов '$outputFileFullPath': $($_.Exception.Message)" "Error" }
    } else {
        Write-Log "Нет результатов для сохранения в файл в этой итерации." "Verbose"
    }

    # --- 3.4 Пауза перед следующей итерацией ---
    # ... (код расчета паузы и Start-Sleep без изменений) ...
    $cycleEndTime = Get-Date; $elapsedSeconds = ($cycleEndTime - $cycleStartTime).TotalSeconds; $sleepSeconds = $checkInterval - $elapsedSeconds; if ($sleepSeconds -lt 1) { $sleepSeconds = 1 }
    Write-Log ("Итерация заняла {0:N2} сек. Пауза {1:N2} сек до следующего цикла..." -f $elapsedSeconds, $sleepSeconds) "Verbose"; Start-Sleep -Seconds $sleepSeconds

} # --- Конец while ($true) ---

Write-Log "Оффлайн-агент завершает работу (неожиданный выход из основного цикла)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\offline-agent\offline-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\offline-agent\README.md ====

---

**6. `powershell/offline-agent/README.md` (Обновление)**

```markdown
# PowerShell Offline Агент (offline-agent) v3.1

Этот скрипт (`offline-agent.ps1`) выполняет роль агента мониторинга для узлов, работающих в **изолированных сетевых сегментах** без прямого доступа к центральному API системы Status Monitor.

## Назначение

*   Периодически проверять наличие/обновление локального файла с заданиями мониторинга (`*.json.status.*`).
*   Читать и выполнять задания из этого файла с помощью `Invoke-StatusMonitorCheck` из модуля `StatusMonitorAgentUtils`.
*   Собирать **стандартизированные результаты** каждой проверки (включая `IsAvailable`, `CheckSuccess`, `Details`, `ErrorMessage`, `Timestamp`).
*   **Добавлять `assignment_id`** к каждому полученному результату.
*   Сохранять массив этих дополненных результатов в единый JSON-файл (`*.zrpu`) вместе с метаданными (версии скрипта и конфига) в указанную папку для последующей передачи и загрузки в центральную систему.

## Принцип работы

1.  Администратор с помощью скрипта **Конфигуратора** генерирует файл конфигурации заданий (`{version_tag}_assignments.json.status.{transport_code}`) для данного объекта.
2.  Этот файл доставляется на машину агента (например, с помощью Транспортной Системы) в папку, указанную в параметре `assignments_file_path` в локальном `config.json` оффлайн-агента.
3.  Скрипт `offline-agent.ps1` запускается (например, через Планировщик Задач Windows).
4.  Читает параметры из своего локального файла `config.json`.
5.  Импортирует модуль `StatusMonitorAgentUtils`.
6.  В бесконечном цикле (с интервалом `check_interval_seconds`):
    *   Ищет самый новый файл конфигурации заданий в папке `assignments_file_path`.
    *   Если найден новый или измененный файл:
        *   Читает JSON, извлекает массив `assignments` и `assignment_config_version`.
        *   Сохраняет их в памяти (`$script:currentAssignments`, `$script:currentAssignmentVersion`).
    *   Если список `$script:currentAssignments` не пуст:
        *   Для **каждого** задания:
            *   Вызывает **локально** `Invoke-StatusMonitorCheck`, передавая объект задания.
            *   Получает стандартизированный результат (`$checkResult`).
            *   **Создает новый объект**, объединяя `$checkResult` и `assignment_id`.
            *   Добавляет этот новый объект в массив `$cycleCheckResultsList`.
            *   Обрабатывает ошибки выполнения, также добавляя `assignment_id` к записи об ошибке.
    *   Если `$cycleCheckResultsList` не пуст:
        *   Формирует итоговый JSON (`$finalPayload`), включающий `agent_script_version`, `assignment_config_version` и массив `results` (содержащий дополненные результаты).
        *   Сохраняет `$finalPayload` в файл `.zrpu` в папку `output_path`.
    *   Ожидает интервал `check_interval_seconds` перед следующим циклом.
    *   Логирует свою работу.
7.  Файлы `*.zrpu` из папки `output_path` затем забираются и доставляются для обработки Загрузчиком Результатов.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `offline-agent.ps1`:

```json
{
    "object_id": 1060,
    "config_type": "offline_multi_check_agent_v3.1",
    "check_interval_seconds": 60,
    "output_path": "C:\\StatusMonitor\\Results",
    "output_name_template": "{ddMMyy_HHmmss}_{object_id}_OfflineChecks.json.status.zrpu",
    "logFile": "C:\\Logs\\StatusMonitor\\offline_agent.log",
    "LogLevel": "Info",
    "assignments_file_path": "C:\\StatusMonitor\\Config"
}

Поля конфигурации:

    object_id: (Число, Обязательно) Внешний ID подразделения (subdivisions.object_id), которому соответствует этот агент. Используется для поиска файла конфигурации.

    config_type: (Строка, Информационно) Тип и версия агента.

    check_interval_seconds: (Число, Опционально, По умолчанию 60) Как часто (в секундах) агент будет выполнять весь цикл проверок и генерировать файл результатов.

    output_path: (Строка, Обязательно) Папка, куда будут сохраняться файлы с результатами (*.zrpu). Папка должна существовать и быть доступна для записи.

    output_name_template: (Строка, Обязательно) Шаблон имени файла результатов. Плейсхолдеры: {ddMMyy_HHmmss}, {object_id}. Расширение должно быть .zrpu.

    logFile: (Строка, Обязательно) Полный путь к лог-файлу агента.

    LogLevel: (Строка, Опционально, По умолчанию "Info") Уровень детализации логов (Debug, Verbose, Info, Warn, Error).

    assignments_file_path: (Строка, Обязательно) Папка, где агент ищет самый новый файл конфигурации, соответствующий его object_id и шаблону (*_<object_id>_*_assignments.json.status.*).

Формат файла результатов (*.zrpu)

Файл представляет собой JSON-объект со следующей структурой:

{
  "agent_script_version": "agent_script_v3.1", // Версия скрипта offline-agent.ps1
  "assignment_config_version": "20240520120000_1060_abc...", // Версия файла с заданиями
  "results": [ // Массив результатов проверок
    {
      // Стандартизированный результат от Invoke-StatusMonitorCheck
      "IsAvailable": true,
      "CheckSuccess": true,
      "Timestamp": "2024-05-20T12:05:30.1234567Z",
      "Details": {
        "disk_letter": "C",
        "percent_free": 25.5,
        "execution_mode": "local_agent",
        // ... другие детали ...
      },
      "ErrorMessage": null,
      // Добавленное поле:
      "assignment_id": 101
    },
    {
      "IsAvailable": false,
      "CheckSuccess": null,
      "Timestamp": "2024-05-20T12:05:35.9876543Z",
      "Details": {
        "error": "Служба 'MyService' не найдена.",
        // ... другие детали ...
      },
      "ErrorMessage": "Служба 'MyService' не найдена.",
      "assignment_id": 102
    }
    // ... другие результаты ...
  ]
}

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль StatusMonitorAgentUtils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой offline-agent или в путях $env:PSModulePath.

    Конфиг Заданий: Необходим файл конфигурации заданий (*.json.status.*), сгенерированный Конфигуратором и доставленный в assignments_file_path.

    Права: Права на чтение из assignments_file_path, запись в output_path и logFile. Права для выполнения конкретных проверок.

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows.

Замечания

    Агент не требует прямого доступа к API.

    Логика конкретных проверок находится в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.

    Убедитесь, что Транспортная Система корректно доставляет файлы конфигурации и забирает файлы результатов (*.zrpu).
==== END FILE: F:\status\source\powershell\offline-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\config.json ====
{
    "object_id": 1516,
    "config_type": "online_multi_check_agent_v3",
    "apiBaseUrl": "http://localhost:48030/api",
    "api_key": "HC_ig1ko5JM8mPs1pNM-mE2aDoUJDrtruD_6zpOp1aw",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 120,
    "logFile": "online_check.log",
    "LogLevel": "Debug"
}
==== END FILE: F:\status\source\powershell\online-agent\config.json ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\online-agent.ps1 ====
# powershell\online-agent\online-agent.ps1
# Версия с поддержкой нового диспетчера, формата результата,
# улучшенным форматированием, комментариями и исправленными ошибками.
<#
.SYNOPSIS
    Онлайн-агент для системы мониторинга Status Monitor v5.5.
.DESCRIPTION
    Этот агент предназначен для работы на машинах, имеющих прямой сетевой
    доступ к API сервера мониторинга. Он выполняет следующие действия:
    1. Читает локальную конфигурацию из файла 'config.json'.
    2. Импортирует необходимый модуль StatusMonitorAgentUtils.
    3. Периодически (раз в api_poll_interval_seconds) обращается к API
       сервера (/api/v1/assignments) для получения списка активных заданий
       мониторинга, предназначенных для его object_id.
    4. Хранит список заданий в памяти и самостоятельно планирует их выполнение
       согласно интервалам, указанным в заданиях или в конфиге по умолчанию.
    5. Для выполнения каждой проверки вызывает функцию Invoke-StatusMonitorCheck
       из импортированного модуля.
    6. Получает стандартизированный результат от Invoke-StatusMonitorCheck.
    7. Преобразует результат в формат, ожидаемый API /checks (v1).
    8. Немедленно отправляет результат каждой проверки на сервер через
       POST-запрос к API /api/v1/checks, используя API-ключ для аутентификации.
    9. Ведет лог своей работы в указанный файл.
.NOTES
    Версия: 5.5
    Дата: 2024-05-20
    Изменения v5.5:
        - Исправлена ошибка CommandNotFoundException из-за заглушек "..." в ConvertTo-Json при сравнении заданий.
    Изменения v5.4:
        - Исправлена ошибка ParameterBindingException при вызове Write-Verbose с уровнем Debug. Заменено на Write-Debug.
    Изменения v5.3:
        - Исправлена ошибка парсинга строки в блоке catch функции Send-CheckResultToApi.
    Изменения v5.2:
        - Исправлена ошибка CommandNotFoundException из-за заглушек "...".
        - Реализовано корректное частичное отображение API ключа в логах.
        - Разбиты длинные строки кода на несколько для читаемости.
        - Добавлены подробные комментарии.
        - Улучшено форматирование.
        - Функция Get-ActiveAssignments вынесена и исправлена.
    Изменения v5.1:
        - Адаптация под новый формат результата Invoke-StatusMonitorCheck.
        - Использование полей IsAvailable и CheckSuccess из результата проверки.
        - Формирование detail_type и detail_data для API на основе результата.
        - Использование IsAvailable для определения доступности узла при отправке.
    Зависимости: PowerShell 5.1+, модуль StatusMonitorAgentUtils, доступ к API.
#>
param(
    # Путь к файлу конфигурации агента.
    [string]$ConfigFile = "$PSScriptRoot\config.json"
)

# --- Загрузка необходимого модуля утилит ---
# Устанавливаем строгий режим обработки ошибок на время импорта
$ErrorActionPreference = "Stop"
try {
    # Определяем путь к манифесту модуля относительно текущего скрипта
    $ModuleManifestPath = Join-Path -Path $PSScriptRoot `
                                    -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "[INFO] Загрузка модуля '$ModuleManifestPath'..."
    # Принудительно импортируем модуль
    Import-Module $ModuleManifestPath -Force -ErrorAction Stop
    Write-Host "[INFO] Модуль Utils загружен."
} catch {
    # Критическая ошибка - агент не может работать без модуля
    Write-Host "[CRITICAL] Критическая ошибка загрузки модуля '$ModuleManifestPath': $($_.Exception.Message)" -ForegroundColor Red
    # Завершаем работу скрипта с кодом ошибки
    exit 1
} finally {
    # Возвращаем стандартное поведение обработки ошибок
    $ErrorActionPreference = "Continue"
}
# --- Конец загрузки модуля ---

# --- Глобальные переменные и константы ---

# Версия текущего скрипта агента
$ScriptVersion = "5.5" # Обновили версию

# Хэш-таблица для хранения активных заданий (ключ - assignment_id, значение - объект задания)
$script:ActiveAssignments = @{}
# Хэш-таблица для хранения времени последнего выполнения каждого задания (ключ - assignment_id, значение - строка ISO 8601 UTC)
$script:LastExecutedTimes = @{}
# Объект для хранения конфигурации из файла config.json
$script:Config = $null
# API ключ для аутентификации на сервере
$script:ApiKey = $null
# Имя текущего компьютера для идентификации в логах и результатах
$script:ComputerName = $env:COMPUTERNAME

# --- Значения по умолчанию для параметров конфигурации ---
# Как часто опрашивать API на предмет новых/измененных заданий (секунды)
$DefaultApiPollIntervalSeconds = 60
# Интервал выполнения проверки по умолчанию (если не указан в задании, секунды)
$DefaultCheckIntervalSeconds = 120
# Уровень логирования по умолчанию
$DefaultLogLevel = "Info"
# Путь к лог-файлу по умолчанию (в папке со скриптом)
$DefaultLogFile = "$PSScriptRoot\online_agent.log"
# Таймаут ожидания ответа от API (секунды)
$ApiTimeoutSeconds = 30
# Максимальное количество попыток запроса к API при ошибке
$MaxApiRetries = 3
# Задержка между повторными попытками запроса к API (секунды)
$RetryDelaySeconds = 5
# Допустимые уровни логирования
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error")
# Эффективный уровень логирования (будет установлен после чтения конфига)
$script:EffectiveLogLevel = $DefaultLogLevel

# --- Функции ---

#region Функции

<#
.SYNOPSIS
    Записывает сообщение в лог-файл и/или выводит в консоль.
# ... (документация Write-Log без изменений) ...
#>
function Write-Log {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
        [string]$Level = "Info"
    )
    # ... (код функции Write-Log без изменений) ...
    $logFilePath = $script:Config.logFile | Get-OrElse $DefaultLogFile; $logLevels = @{ "Debug" = 4; "Verbose" = 3; "Info" = 2; "Warn" = 1; "Error" = 0 }; $currentLevelValue = $logLevels[$script:EffectiveLogLevel]; if ($null -eq $currentLevelValue) { $currentLevelValue = $logLevels["Info"] }; $messageLevelValue = $logLevels[$Level]; if ($null -eq $messageLevelValue) { $messageLevelValue = $logLevels["Info"] }; if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] [$script:ComputerName] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; try { $logDir = Split-Path $logFilePath -Parent; if ($logDir -and (-not (Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки логов: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -ErrorAction Stop | Out-Null }; $logMessage | Out-File -FilePath $logFilePath -Append -Encoding UTF8 -ErrorAction Stop } catch { Write-Host "[Error] Не удалось записать в лог '$($logFilePath)': $($_.Exception.Message)" -ForegroundColor Red } }
}

<#
.SYNOPSIS
    Возвращает значение по умолчанию, если входное значение ложно.
# ... (документация Get-OrElse без изменений) ...
#>
filter Get-OrElse {
    param([object]$DefaultValue)
    if ($_) { $_ } else { $DefaultValue }
}

<#
.SYNOPSIS
    Отправляет результат ОДНОЙ проверки в API /checks.
# ... (документация Send-CheckResultToApi без изменений) ...
#>
function Send-CheckResultToApi {
    param (
        [Parameter(Mandatory = $true)]
        [hashtable]$CheckResult,
        [Parameter(Mandatory = $true)]
        [PSCustomObject]$Assignment
    )

    $assignmentId = $Assignment.assignment_id
    Write-Log "Отправка результата для задания ID $assignmentId..." "Verbose"

    # --- Формируем тело запроса для API /checks ---
    $isAvailableApi = [bool]$CheckResult.IsAvailable
    $checkTimestampApi = $CheckResult.Timestamp
    $detailTypeApi = $null
    $detailDataApi = $null

    if ($CheckResult.Details -ne $null -and $CheckResult.Details -is [hashtable]) {
        $detailTypeApi = $Assignment.method_name
        $detailDataApi = $CheckResult.Details
        if ($CheckResult.ContainsKey('CheckSuccess')) {
            $detailDataApi.check_success = $CheckResult.CheckSuccess
        }
        if (-not [string]::IsNullOrEmpty($CheckResult.ErrorMessage)) {
             $detailDataApi.error_message_from_check = $CheckResult.ErrorMessage
        }
    }
    elseif (-not [string]::IsNullOrEmpty($CheckResult.ErrorMessage)) {
        $detailTypeApi = "ERROR"
        $detailDataApi = @{ message = $CheckResult.ErrorMessage }
    }

    $body = @{
        assignment_id        = $assignmentId
        is_available         = $isAvailableApi
        check_timestamp      = $checkTimestampApi
        executor_object_id   = $script:Config.object_id
        executor_host        = $script:ComputerName
        resolution_method    = $Assignment.method_name
        detail_type          = $detailTypeApi
        detail_data          = $detailDataApi
        agent_script_version = $ScriptVersion
    }
    # --- Конец формирования тела запроса ---

    # Преобразуем тело в JSON строку
    try {
        $jsonBody = $body | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
    } catch {
         # Используем -f для форматирования строки
         Write-Log ("Критическая ошибка ConvertTo-Json для ID {0}: {1}" -f $assignmentId, $_.Exception.Message) "Error"
         Write-Log "Проблемный объект: $($body | Out-String)" "Error"
         return $false
    }

    # Заголовки и URL
    $headers = @{
        'Content-Type' = 'application/json; charset=utf-8'
        'X-API-Key'    = $script:ApiKey
    }
    $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/checks"
    Write-Log "URL отправки: $apiUrl" "Debug"
    Write-Log "Тело JSON: $jsonBody" "Debug"

    # --- Отправка запроса с логикой повторных попыток (retry) ---
    $retryCount = 0; $success = $false
    while ($retryCount -lt $MaxApiRetries -and (-not $success)) {
        try {
            $response = Invoke-RestMethod -Uri $apiUrl `
                                          -Method Post `
                                          -Body ([System.Text.Encoding]::UTF8.GetBytes($jsonBody)) `
                                          -Headers $headers `
                                          -TimeoutSec $ApiTimeoutSeconds `
                                          -ErrorAction Stop

            Write-Log ("Результат ID {0} отправлен. Ответ API: {1}" -f `
                        $assignmentId, ($response | ConvertTo-Json -Depth 2 -Compress -WarningAction SilentlyContinue)) "Info"
            $success = $true

        } catch {
            $retryCount++; $statusCode = $null; if ($_.Exception.Response) { try { $statusCode = [int]$_.Exception.Response.StatusCode } catch {} }; $errorMessage = $_.Exception.Message;
            $errorResponseBody = "[не удалось прочитать тело ответа]"; if ($_.Exception.Response) { try { $errorStream = $_.Exception.Response.GetResponseStream(); $reader = New-Object System.IO.StreamReader($errorStream); $errorResponseBody = $reader.ReadToEnd(); $reader.Close(); $errorStream.Dispose() } catch {} };
            Write-Log ("Ошибка отправки ID {0} (попытка {1}/{2}). Код: {3}. Error: {4}. Ответ: {5}" -f $assignmentId, $retryCount, $MaxApiRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage, $errorResponseBody) "Error"
            if ($statusCode -eq 401 -or $statusCode -eq 403) { Write-Log "Критическая ошибка: Неверный API ключ или права (Код: $statusCode). Завершение работы." "Error"; exit 1 }
            if ($retryCount -ge $MaxApiRetries) { Write-Log "Превышено кол-во попыток ($MaxApiRetries) для ID $assignmentId." "Error"; break }
            Write-Log "Пауза $RetryDelaySeconds сек..." "Warn"; Start-Sleep -Seconds $RetryDelaySeconds
        }
    } # Конец while retry
    return $success
}

<#
.SYNOPSIS
    Запрашивает активные задания у API сервера.
# ... (документация Get-ActiveAssignments без изменений) ...
#>
function Get-ActiveAssignments {
    Write-Log "Запрос активных заданий у API..." "Info"
    $apiUrl = "$($script:Config.apiBaseUrl.TrimEnd('/'))/v1/assignments?object_id=$($script:Config.object_id)"
    Write-Log "URL: $apiUrl" "Verbose"

    # Отображение части API ключа
    $apiKeyPartial = "[Не задан]"
    if ($script:ApiKey) {
        $len = $script:ApiKey.Length; $prefix = $script:ApiKey.Substring(0, [math]::Min(4, $len)); $suffix = if ($len -gt 8) { $script:ApiKey.Substring($len - 4, 4) } else { "" }; $apiKeyPartial = "$prefix....$suffix"
    }
    Write-Log "Исп. API ключ (частично): $apiKeyPartial" "Debug"

    $headers = @{ 'X-API-Key' = $script:ApiKey }
    $newAssignments = $null; $retryCount = 0
    while ($retryCount -lt $MaxApiRetries -and $newAssignments -eq $null) {
        try {
            $newAssignments = Invoke-RestMethod -Uri $apiUrl `
                                                -Method Get `
                                                -Headers $headers `
                                                -TimeoutSec $ApiTimeoutSeconds `
                                                -ErrorAction Stop
            if ($newAssignments -isnot [array]) { throw ("API ответ не является массивом: $($newAssignments | Out-String)") }
            Write-Log "Получено $($newAssignments.Count) активных заданий." "Info"
            return $newAssignments
        } catch {
            $retryCount++; $statusCode = $null; if ($_.Exception.Response) { try { $statusCode = [int]$_.Exception.Response.StatusCode } catch {} }; $errorMessage = $_.Exception.Message;
            Write-Log ("Ошибка API при получении заданий (попытка {0}/{1}). Код: {2}. Error: {3}" -f $retryCount, $MaxApiRetries, ($statusCode | Get-OrElse 'N/A'), $errorMessage) "Error"
            if ($statusCode -eq 401 -or $statusCode -eq 403) { Write-Log "Критическая ошибка: Неверный API ключ или права (Код: $statusCode). Завершение работы." "Error"; exit 1 }
            if ($retryCount -ge $MaxApiRetries) { Write-Log "Превышено кол-во попыток ($MaxApiRetries) получения заданий." "Error"; return $null }
            Write-Log "Пауза $RetryDelaySeconds сек..." "Warn"; Start-Sleep -Seconds $RetryDelaySeconds
        }
    } # Конец while retry
    return $null
}

#endregion Функции

# --- Основной код агента ---

# 1. Чтение конфигурации из файла
Write-Host "Чтение конфигурации из: $ConfigFile"
if (-not (Test-Path $ConfigFile -PathType Leaf)) { Write-Error ...; exit 1 }
try { $script:Config = Get-Content -Path $ConfigFile -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
catch { Write-Error ...; exit 1 }
$requiredCfg=@("object_id","apiBaseUrl","api_key","logFile","LogLevel","api_poll_interval_seconds","default_check_interval_seconds"); $missingCfg=$requiredCfg|?{-not $script:Config.PSObject.Properties.Name.Contains($_) -or !$script:Config.$_}; if($missingCfg){ Write-Error ...; exit 1 }
$script:EffectiveLogLevel = $script:Config.LogLevel | Get-OrElse $DefaultLogLevel
if ($script:EffectiveLogLevel -notin $ValidLogLevels) { Write-Host ...; $script:EffectiveLogLevel = $DefaultLogLevel }
$script:ApiKey = $script:Config.api_key

# 2. Инициализация и логирование старта агента
Write-Log "Онлайн-агент v$ScriptVersion запущен." "Info"
Write-Log "Конфигурация: ObjectID=$($script:Config.object_id), API URL=$($script:Config.apiBaseUrl)" "Info"
Write-Log ("Интервал опроса API: {0} сек, Стандартный интервал проверки: {1} сек." -f `
    $script:Config.api_poll_interval_seconds, $script:Config.default_check_interval_seconds) "Verbose"
Write-Log "Логирование в '$($script:Config.logFile)' с уровнем '$($script:EffectiveLogLevel)'" "Info"

# 3. Основной цикл работы агента
$lastApiPollTime = [DateTime]::MinValue
$apiPollInterval = [TimeSpan]::FromSeconds($script:Config.api_poll_interval_seconds)
$DefaultCheckInterval = [TimeSpan]::FromSeconds($script:Config.default_check_interval_seconds)

Write-Log "Запуск основного цикла обработки заданий..." "Info"
while ($true) {
    $loopStartTime = Get-Date
    Write-Log "Начало итерации цикла." "Verbose"

    # 3.1 Запрос/обновление списка активных заданий у API
    if (($loopStartTime - $lastApiPollTime) -ge $apiPollInterval) {
        Write-Log "Время обновить список заданий с API." "Info"; $fetchedAssignments = Get-ActiveAssignments
        if ($fetchedAssignments -ne $null) {
            Write-Log "Обработка полученных заданий..." "Info"; $newAssignmentMap = @{}; $fetchedIds = [System.Collections.Generic.List[int]]::new()
            foreach ($assignment in $fetchedAssignments) { if ($assignment.assignment_id -ne $null) { $id = $assignment.assignment_id; $newAssignmentMap[$id] = $assignment; $fetchedIds.Add($id) } else { Write-Log "..." "Warn" } }
            $currentIds = $script:ActiveAssignments.Keys | ForEach-Object { [int]$_ }; $removedIds = $currentIds | Where-Object { $fetchedIds -notcontains $_ }
            if ($removedIds) { foreach ($removedId in $removedIds) { Write-Log "... $removedId" "Info"; $script:ActiveAssignments.Remove($removedId); $script:LastExecutedTimes.Remove($removedId) } }
            $addedCount = 0; $updatedCount = 0
            foreach ($assignmentId in $fetchedIds) {
                if (-not $script:ActiveAssignments.ContainsKey($assignmentId)) {
                    # Добавление нового задания
                    Write-Log "Добавлено новое задание ID $assignmentId" "Info"
                    $script:ActiveAssignments[$assignmentId] = $newAssignmentMap[$assignmentId]
                    $script:LastExecutedTimes[$assignmentId] = (Get-Date).AddDays(-1).ToUniversalTime().ToString("o")
                    $addedCount++
                } else {
                    # Проверка, изменилось ли существующее задание
                    # --- ИСПРАВЛЕНО: Убраны заглушки "..." ---
                    $oldJson = $script:ActiveAssignments[$assignmentId] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                    $newJson = $newAssignmentMap[$assignmentId] | ConvertTo-Json -Depth 5 -Compress -WarningAction SilentlyContinue
                    # --- КОНЕЦ ИСПРАВЛЕНИЯ ---
                    if ($oldJson -ne $newJson) {
                         Write-Log "Обновлено задание ID $assignmentId" "Verbose"
                         $script:ActiveAssignments[$assignmentId] = $newAssignmentMap[$assignmentId]
                         # Сбрасывать ли LastExecutedTimes при обновлении?
                         # Пока не будем, чтобы не вызвать выполнение сразу после обновления.
                         $updatedCount++
                    }
                }
            } # Конец foreach ($assignmentId in $fetchedIds)
            Write-Log ("Синхронизация заданий завершена. Добавлено:{0}. Обновлено:{1}. Удалено:{2}." -f $addedCount, $updatedCount, $removedIds.Count) "Info"
            $lastApiPollTime = $loopStartTime
        } else { Write-Log "Не удалось получить задания от API..." "Error" }
    } else { Write-Log "Опрос API еще не требуется..." "Verbose" }

    # 3.2 Выполнение запланированных проверок
    # ... (код выполнения проверок, вызова Invoke-StatusMonitorCheck и Send-CheckResultToApi без изменений) ...
    $currentTime = Get-Date
    if ($script:ActiveAssignments.Count -gt 0) {
        Write-Log "Проверка запланированных заданий ($($script:ActiveAssignments.Count) активно)..." "Verbose"
        $assignmentIdsToCheck = $script:ActiveAssignments.Keys | ForEach-Object { $_ }
        foreach ($id in $assignmentIdsToCheck) {
            if (-not $script:ActiveAssignments.ContainsKey($id)) { continue }
            $assignment = $script:ActiveAssignments[$id]; $checkIntervalSeconds = $assignment.check_interval_seconds | Get-OrElse $script:Config.default_check_interval_seconds; if ($checkIntervalSeconds -le 0) { $checkIntervalSeconds = $script:Config.default_check_interval_seconds }; $checkInterval = [TimeSpan]::FromSeconds($checkIntervalSeconds); $lastRunString = $script:LastExecutedTimes[$id]; $lastRunTime = [DateTime]::MinValue; if ($lastRunString) { try { $lastRunTime = [DateTime]::ParseExact($lastRunString,"o",$null).ToLocalTime() } catch { Write-Log "... ID ${id}: '$lastRunString'" "Error"; $lastRunTime = [DateTime]::MinValue } }; $nextRunTime = $lastRunTime + $checkInterval
            Write-Debug ("Задание ID {0}: Интервал={1} сек, Посл.={2}, След.={3}" -f $id, $checkInterval.TotalSeconds, $lastRunTime.ToString('s'), $nextRunTime.ToString('s'))
            if ($currentTime -ge $nextRunTime) {
                Write-Log ("ВЫПОЛНЕНИЕ ЗАДАНИЯ ID {0} ({1} для {2})." -f $id, $assignment.method_name, $assignment.node_name) "Info"; $checkResult = $null
                try { $checkResult = Invoke-StatusMonitorCheck -Assignment $assignment -Verbose:$VerbosePreference -Debug:$DebugPreference; Write-Log ("Результат проверки ID {0}: IsAvailable={1}, CheckSuccess={2}, Error='{3}'" -f $id, $checkResult.IsAvailable, $checkResult.CheckSuccess, $checkResult.ErrorMessage) "Verbose"; Write-Log ("Детали результата ID {0}: {1}" -f $id, ($checkResult.Details | ConvertTo-Json -Depth 3 -Compress -WarningAction SilentlyContinue)) "Debug"; $sendSuccess = Send-CheckResultToApi -CheckResult $checkResult -Assignment $assignment; if ($sendSuccess) { $script:LastExecutedTimes[$id] = $currentTime.ToUniversalTime().ToString("o"); Write-Log "Время последнего выполнения ID $id обновлено." "Verbose" } else { Write-Log "Результат для ID $id НЕ был успешно отправлен в API." "Error" } } catch { Write-Log "Критическая ошибка при ВЫПОЛНЕНИИ задания ID ${id}: $($_.Exception.Message)" "Error" }
            }
        }
    } else { Write-Log "Нет активных заданий для выполнения." "Verbose" }

    # 3.3 Пауза перед следующей итерацией
    Start-Sleep -Seconds 1

} # --- Конец while ($true) ---

Write-Log "Онлайн-агент завершает работу (неожиданный выход из основного цикла)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\online-agent\online-agent.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\online-agent\README.md ====
# PowerShell Online Агент (online-agent) v5.5

Этот скрипт (`online-agent.ps1`) выполняет роль агента мониторинга для узлов, имеющих **прямой сетевой доступ** к центральному API системы Status Monitor.

## Назначение

*   Периодически подключаться к API и запрашивать актуальный список заданий мониторинга (`Assignments`), предназначенных для подразделения, в котором он работает (определяется по `object_id` в конфигурации).
*   Самостоятельно планировать и выполнять полученные задания с заданными интервалами.
*   Для выполнения каждой проверки использовать **локально** модуль `StatusMonitorAgentUtils` и его функцию-диспетчер `Invoke-StatusMonitorCheck`.
*   Немедленно отправлять стандартизированный результат **каждой** выполненной проверки обратно в API (`POST /api/v1/checks`), используя API-ключ для аутентификации.

## Принцип работы

1.  Скрипт `online-agent.ps1` запускается (например, через Планировщик Задач или как Служба Windows).
2.  Читает параметры из локального файла `config.json`.
3.  Импортирует модуль `StatusMonitorAgentUtils` (он должен находиться рядом или в путях PowerShell).
4.  Периодически (с интервалом `api_poll_interval_seconds`) выполняет GET-запрос к API (`/api/v1/assignments?object_id=...`), используя `object_id` и `api_key`.
5.  Хранит полученный список активных заданий в памяти (`$script:ActiveAssignments`). Сравнивает с предыдущим списком, добавляет новые, удаляет неактуальные.
6.  В бесконечном цикле проверяет, не пришло ли время выполнить какое-либо из активных заданий (с учетом `check_interval_seconds` из задания или `default_check_interval_seconds` из конфига).
7.  При наступлении времени выполнения для задания:
    *   Вызывает **локально** `Invoke-StatusMonitorCheck`, передавая ему объект задания.
    *   `Invoke-StatusMonitorCheck` находит и **локально** запускает соответствующий скрипт `Checks/Check-*.ps1`.
    *   Скрипт `Check-*.ps1` выполняет проверку (например, `Test-Connection` к целевому IP, `Get-Service` и т.д.).
    *   Агент получает стандартизированный результат (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
    *   Агент формирует тело запроса для `POST /api/v1/checks`, включая `assignment_id`, статус `is_available` (из результата), `timestamp` (из результата), `details` (включая `CheckSuccess` и `ErrorMessage`), `agent_script_version`.
    *   Отправляет POST-запрос в API с помощью функции `Send-CheckResultToApi`, используя API-ключ.
    *   Обновляет время последнего выполнения для этого задания локально (только при успешной отправке).
8.  Логирует свою работу в файл, указанный в `config.json`.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `online-agent.ps1`:

```json
{
    "object_id": 1516,
    "config_type": "online_multi_check_agent_v5.5",
    "apiBaseUrl": "http://localhost:48030/api",
    "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_AGENT",
    "api_poll_interval_seconds": 60,
    "default_check_interval_seconds": 120,
    "logFile": "C:\\Logs\\StatusMonitor\\online_agent.log",
    "LogLevel": "Info"
}

Поля конфигурации:

    object_id: (Число, Обязательно) Уникальный внешний ID подразделения (subdivisions.object_id) из центральной БД. Агент будет получать задания только для узлов этого подразделения.

    config_type: (Строка, Информационно) Тип и версия агента.

    apiBaseUrl: (Строка, Обязательно) Базовый URL API сервера Status Monitor (например, http://status.example.com/api). Без /v1/ в конце.

    api_key: (Строка, Обязательно) API ключ, сгенерированный в системе Status Monitor с ролью agent. Используется для аутентификации при запросах к API.

    api_poll_interval_seconds: (Число, Опционально, По умолчанию 60) Как часто (в секундах) агент будет опрашивать API для обновления списка своих заданий.

    default_check_interval_seconds: (Число, Опционально, По умолчанию 120) Интервал выполнения проверки (в секундах), который будет использоваться, если интервал не указан в самом задании, полученном от API.

    logFile: (Строка, Обязательно) Полный путь к файлу, куда агент будет писать логи. Папка должна существовать и быть доступна для записи.

    LogLevel: (Строка, Опционально, По умолчанию "Info") Уровень детализации логов (Debug, Verbose, Info, Warn, Error).

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Модуль StatusMonitorAgentUtils: Папка StatusMonitorAgentUtils должна находиться рядом с папкой online-agent (т.е. ..\StatusMonitorAgentUtils) или в одном из путей, перечисленных в $env:PSModulePath.

    Сеть: Требуется сетевой доступ с машины агента к apiBaseUrl И к целевым узлам, которые он будет проверять (например, для PING, Get-Service).

    Права:

        Права на запись в logFile.

        Права, необходимые для выполнения конкретных проверок (например, для Get-Service на удаленной машине могут потребоваться права администратора и настроенный WinRM).

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows для обеспечения непрерывной работы и автоматического перезапуска.

Замечания

    Убедитесь, что API ключ, указанный в config.json, действителен и имеет роль agent.

    Для методов проверки, отличных от PING, необходимо реализовать соответствующую логику в скриптах Checks/Check-*.ps1 модуля StatusMonitorAgentUtils.
==== END FILE: F:\status\source\powershell\online-agent\README.md ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\config.json ====
{
    "api_base_url": "http://localhost:48030/api",
    "api_key": "zwhd4NDpNEQ4WARdCrGRiN6br6hzr_N14_YwOmJADj0",
    "check_folder": "F:\\status\\builds\\results_offline", 
    "log_file": "F:\\status\\builds\\Logs\\result_loader.log",
    "log_level": "Info",
    "scan_interval_seconds": 30, 
    "api_timeout_sec": 30,
    "max_api_retries": 3, 
    "retry_delay_sec": 5
  }
==== END FILE: F:\status\source\powershell\result_loader\config.json ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\README.md ====

---

**7. `powershell/result_loader/README.md` (Обновление)**

(Замени существующий README.md на этот, так как предыдущий был сгенерирован до финальных исправлений)

```markdown
# PowerShell Загрузчик Результатов (result_loader) v3.16

Этот скрипт (`result_loader.ps1`) предназначен для обработки файлов с результатами мониторинга (`*.zrpu`), сгенерированных **оффлайн-агентами**, и загрузки этих данных в центральное API системы Status Monitor.

## Назначение

*   Периодически сканировать указанную папку (`check_folder`) на наличие файлов результатов (`*_OfflineChecks.json.status*.zrpu`).
*   Читать содержимое каждого файла `.zrpu`.
*   Извлекать метаданные (`agent_script_version`, `assignment_config_version`) и массив `results`.
*   Для каждой записи результата проверки из массива `results`:
    *   Извлечь `assignment_id` и другие данные (статус, детали и т.д.).
    *   Отправить POST-запрос на эндпоинт `/api/v1/checks` центрального API, передавая все необходимые данные, включая версии из метаданных файла.
*   После успешной обработки всех записей в файле, отправить событие `FILE_PROCESSED` на эндпоинт `/api/v1/events` для логирования факта обработки файла.
*   Перемещать обработанный файл в подпапку `Processed` или `Error` внутри `check_folder`.

## Принцип работы

1.  Транспортная Система доставляет файлы результатов (`*.zrpu`) от оффлайн-агентов в папку, указанную как `check_folder` в `config.json` загрузчика.
2.  Скрипт `result_loader.ps1` запускается (например, через Планировщик Задач) на машине, имеющей доступ к `check_folder` и центральному API.
3.  Читает параметры из своего файла `config.json`.
4.  В бесконечном цикле:
    *   Сканирует папку `check_folder` на наличие файлов, соответствующих маске `*_OfflineChecks.json.status*.zrpu`.
    *   Для каждого найденного файла:
        *   Пытается прочитать и распарсить его как JSON.
        *   Извлекает `agent_script_version`, `assignment_config_version` из корневого объекта JSON.
        *   Извлекает массив `results`.
        *   Для **каждой** записи (`$resultItem`) в `results`:
            *   Проверяет наличие `assignment_id`, `IsAvailable`, `Timestamp`. Если чего-то нет, пропускает запись и логирует ошибку.
            *   Формирует тело запроса для `/api/v1/checks`, используя поля из `$resultItem` (такие как `is_available`, `check_timestamp`, `details`, `check_success`, `error_message` и т.д.), `assignment_id` из записи, а также `agent_script_version` и `assignment_config_version` из метаданных файла.
            *   Формирует полные заголовки запроса (включая `X-API-Key`).
            *   Отправляет POST-запрос к API с помощью функции `Invoke-ApiRequestWithRetry`. Обрабатывает возможные ошибки и повторные попытки.
        *   Если **все** записи из файла успешно отправлены (или пропущены из-за отсутствия `assignment_id`), статус обработки файла считается `success` или `partial_error`.
        *   Если при чтении/парсинге файла или при отправке записей возникли **критические** ошибки (не удалось отправить после ретраев), статус обработки файла считается `error`.
        *   Формирует тело события `FILE_PROCESSED` с информацией об обработке.
        *   Формирует полные заголовки и отправляет событие в API `/api/v1/events`.
        *   Перемещает файл в подпапку `Processed` (если статус `success`) или `Error` (если статус `partial_error` или `error`).
    *   Ожидает интервал `scan_interval_seconds` перед следующим сканированием.
    *   Логирует свою работу.

## Конфигурация (`config.json`)

Необходимо создать и настроить файл `config.json` в той же папке, что и `result_loader.ps1`:

```json
{
    "api_base_url": "http://localhost:48030/api",
    "api_key": "ВАШ_API_КЛЮЧ_С_РОЛЬЮ_LOADER",
    "check_folder": "F:\\StatusMonitor\\IncomingResults",
    "log_file": "F:\\Logs\\StatusMonitor\\result_loader.log",
    "log_level": "Info",
    "scan_interval_seconds": 30,
    "api_timeout_sec": 30,
    "max_api_retries": 3,
    "retry_delay_sec": 5
}

Поля конфигурации:

    api_base_url: (Строка, Обязательно) Базовый URL API сервера Status Monitor.

    api_key: (Строка, Обязательно) API ключ, сгенерированный в системе Status Monitor с ролью loader.

    check_folder: (Строка, Обязательно) Папка, куда Транспортная Система доставляет файлы результатов (*.zrpu) от оффлайн-агентов.

    log_file: (Строка, Обязательно) Полный путь к лог-файлу загрузчика.

    log_level: (Строка, Опционально, По умолчанию "Info") Уровень детализации логов (Debug, Verbose, Info, Warn, Error).

    scan_interval_seconds: (Число, Опционально, По умолчанию 30) Интервал сканирования папки check_folder в секундах.

    api_timeout_sec: (Число, Опционально, По умолчанию 30) Таймаут ожидания ответа от API в секундах.

    max_api_retries: (Число, Опционально, По умолчанию 3) Максимальное количество попыток запроса к API при сбое.

    retry_delay_sec: (Число, Опционально, По умолчанию 5) Задержка в секундах перед повторной попыткой запроса к API.

Запуск и Требования

    PowerShell: Версия 5.1 или выше.

    Сеть: Требуется сетевой доступ с машины загрузчика к apiBaseUrl.

    Доступ к Файлам: Требуются права на чтение, запись и удаление файлов в check_folder и ее подпапках Processed, Error.

    Права: Скрипту нужны права на запись в logFile.

    Запуск: Рекомендуется запускать через Планировщик Задач Windows или как Службу Windows для обеспечения непрерывной работы.

Замечания

    Убедитесь, что API ключ имеет роль loader.

    Скрипт ожидает, что файлы *.zrpu имеют корректную JSON-структуру, созданную offline-agent.ps1 версии 3.0 или выше (т.е. содержат assignment_id в каждой записи results).

    Ошибки при отправке отдельных записей или пропуск записей без assignment_id приведут к перемещению всего файла в папку Error. Детали ошибок будут в логе скрипта и в событии FILE_PROCESSED.
==== END FILE: F:\status\source\powershell\result_loader\README.md ====

==== BEGIN FILE: F:\status\source\powershell\result_loader\result_loader.ps1 ====
# powershell/result_loader/result_loader.ps1
# Загрузчик результатов оффлайн-агентов v3.18 (исправления -f через интерполяцию)
# Исправлены ошибки ParameterBindingException путем замены оператора -f на строковую интерполяцию.
<#
.SYNOPSIS
    Обрабатывает файлы *.zrpu от оффлайн-агентов
    и отправляет данные пакетом в API Status Monitor (v3.18).
.DESCRIPTION
    Скрипт-загрузчик результатов. Выполняется на машине, имеющей
    доступ как к папке с результатами от оффлайн-агентов (`check_folder`),
    так и к API сервера мониторинга (`api_base_url`).

    Принцип работы:
    1. Читает параметры конфигурации из 'config.json'.
    2. В бесконечном цикле с интервалом (`scan_interval_seconds`):
       a. Сканирует `check_folder` на наличие файлов `*_OfflineChecks.json.status*.zrpu`.
       b. Для каждого найденного файла:
          i.   Читает и парсит JSON.
          ii.  Проверяет базовую структуру (наличие `results`, `agent_script_version`, `assignment_config_version`).
          iii. Если файл валиден и содержит результаты:
               - Формирует тело Bulk-запроса (весь распарсенный JSON).
               - Отправляет ОДИН POST-запрос на `/api/v1/checks/bulk`, используя функцию `Invoke-ApiRequestWithRetry`.
          iv.  Анализирует ответ от Bulk API (`status`, `processed`, `failed`, `errors`).
          v.   Определяет итоговый статус обработки файла (`success`, `partial_error`, `error_api`, `error_local`).
          vi.  Отправляет событие `FILE_PROCESSED` в API `/api/v1/events` с деталями обработки.
          vii. Перемещает обработанный файл в подпапку `Processed` или `Error`.
       c. Если файлов нет, ждет.
    3. Ждет `scan_interval_seconds` и повторяет цикл.
    4. Логирует все действия.
.PARAMETER ConfigFile
    [string] Путь к файлу конфигурации загрузчика (JSON).
    По умолчанию: "$PSScriptRoot\config.json".
# ... (остальные параметры для переопределения) ...
.EXAMPLE
    # Запуск с конфигом по умолчанию
    .\result_loader.ps1
.NOTES
    Версия: 3.18
    Дата: 2025-05-02
    Изменения v3.18:
        - Исправлены ошибки ParameterBindingException путем замены оператора -f на строковую интерполяцию в Invoke-ApiRequestWithRetry.
    # ... (предыдущая история изменений) ...
    Зависимости: PowerShell 5.1+, Сетевой доступ к API, Права доступа к папке check_folder.
#>
param(
    [string]$ConfigFile = "$PSScriptRoot\config.json",
    # --- Параметры для переопределения конфига ---
    [string]$apiBaseUrl = $null,
    [string]$apiKey = $null,
    [string]$checkFolder = $null,
    [string]$logFile = $null,
    [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)]
    [string]$LogLevel = $null,
    [int]$ScanIntervalSeconds = $null,
    [int]$ApiTimeoutSeconds = $null,
    [int]$MaxApiRetries = $null,
    [int]$RetryDelaySeconds = $null
)

# --- Глобальные переменные и константы ---
$ScriptVersion = "3.18" # Обновляем версию
$script:Config = $null
$script:EffectiveLogLevel = "Info"
$script:logFilePath = $null
$script:ComputerName = $env:COMPUTERNAME
$DefaultLogLevel = "Info"; $DefaultScanInterval = 30; $DefaultApiTimeout = 30; $DefaultMaxRetries = 3; $DefaultRetryDelay = 5;
$ValidLogLevels = @("Debug", "Verbose", "Info", "Warn", "Error");
$script:EffectiveApiKey = $null

# --- Функции ---

#region Функции

<#
.SYNOPSIS Пишет сообщение в лог и/или консоль.
#>
function Write-Log{
    param ( [Parameter(Mandatory=$true)][string]$Message, [ValidateSet("Debug", "Verbose", "Info", "Warn", "Error", IgnoreCase = $true)][string]$Level = "Info" )
    # ... (код функции Write-Log без изменений) ...
    if (-not $script:logFilePath) { Write-Host "[$Level] $Message"; return }
    $logLevels=@{"Debug"=4;"Verbose"=3;"Info"=2;"Warn"=1;"Error"=0}; $currentLevelValue=$logLevels[$script:EffectiveLogLevel]; if($null -eq $currentLevelValue){ $currentLevelValue = $logLevels["Info"] }; $messageLevelValue=$logLevels[$Level]; if($null -eq $messageLevelValue){ $messageLevelValue = $logLevels["Info"] };
    if ($messageLevelValue -le $currentLevelValue) { $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'; $logMessage = "[$timestamp] [$Level] [$($script:ComputerName)] - $Message"; $consoleColor = switch($Level){"Error"{"Red"};"Warn"{"Yellow"};"Info"{"White"};"Verbose"{"Gray"};"Debug"{"DarkGray"};Default{"Gray"}}; Write-Host $logMessage -ForegroundColor $consoleColor; if ($script:logFilePath) { try { $logDir = Split-Path $script:logFilePath -Parent; if ($logDir -and (-not(Test-Path $logDir -PathType Container))) { Write-Host "[INFO] Создание папки логов: '$logDir'"; New-Item -Path $logDir -ItemType Directory -Force -EA Stop | Out-Null }; Add-Content -Path $script:logFilePath -Value $logMessage -Encoding UTF8 -Force -EA Stop } catch { Write-Host ("[Error] Не удалось записать в лог '{0}': {1}" -f $script:logFilePath, $_.Exception.Message) -ForegroundColor Red } } }

}

<#
.SYNOPSIS Возвращает значение по умолчанию, если исходное пустое.
#>
filter Get-OrElse_Internal{ param([object]$DefaultValue); if ($_) { $_ } else { $DefaultValue } }

<#
.SYNOPSIS Выполняет HTTP-запрос к API с логикой повторных попыток.
#>
function Invoke-ApiRequestWithRetry {
    param(
        [Parameter(Mandatory=$true)] [string]$Uri,
        [Parameter(Mandatory=$true)] [string]$Method,
        [Parameter(Mandatory=$false)]$Body = $null,
        [Parameter(Mandatory=$true)] [hashtable]$Headers, # Включая X-API-Key
        [Parameter(Mandatory=$true)] [string]$Description
    )

    $retryCount = 0
    $response = $null
    $currentMaxRetries = $script:EffectiveMaxApiRetries | Get-OrElse_Internal $DefaultMaxRetries
    $currentTimeoutSec = $script:EffectiveApiTimeoutSeconds | Get-OrElse_Internal $DefaultApiTimeout
    $currentRetryDelay = $script:EffectiveRetryDelaySeconds | Get-OrElse_Internal $DefaultRetryDelay

    $invokeParams = @{ Uri = $Uri; Method = $Method; Headers = $Headers; TimeoutSec = $currentTimeoutSec; ErrorAction = 'Stop' }
    if ($Body -ne $null -and $Method -notin @('GET', 'DELETE')) {
        if ($Body -is [array] -and $Body.Count -gt 0 -and $Body[0] -is [byte]) { $invokeParams.Body = $Body }
        elseif ($Body -is [string]) { $invokeParams.Body = [System.Text.Encoding]::UTF8.GetBytes($Body) }
        else { $invokeParams.Body = $Body }
        if (-not $invokeParams.Headers.ContainsKey('Content-Type')) { $invokeParams.Headers.'Content-Type' = 'application/json; charset=utf-8' }
    }

    while ($retryCount -lt $currentMaxRetries -and $response -eq $null) {
        try {
            Write-Log ("Выполнение запроса ({0}): {1} {2}" -f $Description, $Method, $Uri) -Level Verbose
            if ($invokeParams.Body) {
                 if ($invokeParams.Body -is [array] -and $invokeParams.Body[0] -is [byte]) { Write-Log "Тело (байты): $($invokeParams.Body.Count) bytes" -Level Debug }
                 else { Write-Log "Тело: $($invokeParams.Body | Out-String -Width 500)..." -Level Debug }
            }

            $response = Invoke-RestMethod @invokeParams

            if ($null -eq $response -and $? -and ($Error.Count -eq 0)) {
                 Write-Log ("API вернул успешный ответ без тела (вероятно, 204 No Content) для ({0})." -f $Description) -Level Verbose
                 return $true
            }
            Write-Log ("Успешный ответ API ({0})." -f $Description) -Level Verbose
            return $response

        } catch {
            $retryCount++
            $statusCode = $null; if ($_.Exception.Response) { try { $statusCode = [int]$_.Exception.Response.StatusCode } catch {} }; $errorMessage = $_.Exception.Message;
            $errorResponseBody = "[Не удалось прочитать тело ошибки]"; if ($_.Exception.Response) { try { $errorStream = $_.Exception.Response.GetResponseStream(); $reader = New-Object System.IO.StreamReader($errorStream); $errorResponseBody = $reader.ReadToEnd(); $reader.Close(); $errorStream.Dispose() } catch { } };
            # <<<< ИСПРАВЛЕНО: Используем СТРОКОВУЮ ИНТЕРПОЛЯЦИЮ >>>>
            Write-Log "Ошибка API ($Description) (Попытка $retryCount/$currentMaxRetries). Код: $($statusCode | Get-OrElse_Internal 'N/A'). Error: $($errorMessage.Replace('{','{{').Replace('}','}}')). Ответ: $($errorResponseBody.Replace('{','{{').Replace('}','}}'))" "Error"

            if ($statusCode -eq 401 -or $statusCode -eq 403) { Write-Log ("Критическая ошибка аутентификации/авторизации ({0}). Проверьте API ключ и его роль ('loader'). Завершение работы." -f $Description) -Level Error; exit 1 };
            if ($retryCount -ge $currentMaxRetries) {
                 # <<<< ИСПРАВЛЕНО: Используем СТРОКОВУЮ ИНТЕРПОЛЯЦИЮ >>>>
                 Write-Log "Превышено кол-во попыток ($currentMaxRetries) для ($Description)." -Level Error;
                 return $null
            };
            Write-Log ("Пауза $currentRetryDelay сек перед повторной попыткой...") "Warn"; Start-Sleep -Seconds $currentRetryDelay
        }
    } # Конец while
    return $null
}

#endregion Функции

# --- Основная логика ---

# 1. Чтение и валидация конфигурации
Write-Host "Запуск загрузчика результатов PowerShell v$ScriptVersion"
Write-Log "Чтение конфигурации..." "Info"
# ... (код чтения конфига без изменений) ...
if (Test-Path $ConfigFile -PathType Leaf) {
    try { $script:Config = Get-Content $ConfigFile -Raw -Enc UTF8 | ConvertFrom-Json -EA Stop }
    catch { Write-Log ("Ошибка чтения/парсинга JSON из '{0}': {1}. Используются параметры по умолчанию/командной строки." -f $ConfigFile, $_.Exception.Message) "Error" }
} else { Write-Log ("Файл конфигурации '{0}' не найден. Используются параметры по умолчанию/командной строки." -f $ConfigFile) "Warn" }
$EffectiveApiBaseUrl = $apiBaseUrl | Get-OrElse_Internal $script:Config.api_base_url
$script:EffectiveApiKey = $apiKey | Get-OrElse_Internal $script:Config.api_key
$EffectiveCheckFolder = $checkFolder | Get-OrElse_Internal $script:Config.check_folder
$EffectiveLogFile = $logFile | Get-OrElse_Internal ($script:Config.log_file | Get-OrElse_Internal "$PSScriptRoot\result_loader.log")
$EffectiveLogLevel = $LogLevel | Get-OrElse_Internal ($script:Config.log_level | Get-OrElse_Internal $DefaultLogLevel)
$EffectiveScanIntervalSeconds = $ScanIntervalSeconds | Get-OrElse_Internal ($script:Config.scan_interval_seconds | Get-OrElse_Internal $DefaultScanInterval)
$EffectiveApiTimeoutSeconds = $ApiTimeoutSeconds | Get-OrElse_Internal ($script:Config.api_timeout_sec | Get-OrElse_Internal $DefaultApiTimeout)
$EffectiveMaxApiRetries = $MaxApiRetries | Get-OrElse_Internal ($script:Config.max_api_retries | Get-OrElse_Internal $DefaultMaxRetries)
$EffectiveRetryDelaySeconds = $RetryDelaySeconds | Get-OrElse_Internal ($script:Config.retry_delay_sec | Get-OrElse_Internal $DefaultRetryDelay)
$script:logFilePath = $EffectiveLogFile
$script:EffectiveLogLevel = $EffectiveLogLevel
if (-not $ValidLogLevels.Contains($script:EffectiveLogLevel)) { Write-Log ("Некорректный LogLevel '{0}'. Используется '{1}'." -f $script:EffectiveLogLevel, $DefaultLogLevel) "Warn"; $script:EffectiveLogLevel = $DefaultLogLevel }
if (-not $EffectiveApiBaseUrl) { Write-Log "Критическая ошибка: Не задан 'api_base_url'." "Error"; exit 1 }; if (-not $script:EffectiveApiKey) { Write-Log "Критическая ошибка: Не задан 'api_key'." "Error"; exit 1 }; if (-not $EffectiveCheckFolder) { Write-Log "Критическая ошибка: Не задан 'check_folder'." "Error"; exit 1 }
if ($EffectiveScanIntervalSeconds -lt 5) { Write-Log "ScanIntervalSeconds < 5. Установлено 5 сек." "Warn"; $EffectiveScanIntervalSeconds = 5 }
if ($EffectiveApiTimeoutSeconds -le 0) { $EffectiveApiTimeoutSeconds = $DefaultApiTimeout }; if ($EffectiveMaxApiRetries -lt 0) { $EffectiveMaxApiRetries = $DefaultMaxRetries }; if ($EffectiveRetryDelaySeconds -lt 0) { $EffectiveRetryDelaySeconds = $DefaultRetryDelay }
$script:EffectiveScanIntervalSeconds = $EffectiveScanIntervalSeconds; $script:EffectiveApiTimeoutSeconds = $EffectiveApiTimeoutSeconds; $script:EffectiveMaxApiRetries = $EffectiveMaxApiRetries; $script:EffectiveRetryDelaySeconds = $EffectiveRetryDelaySeconds


# 2. Подготовка окружения
Write-Log "Инициализация загрузчика." "Info"
Write-Log ("Параметры: API='{0}', Папка='{1}', Интервал={2} сек, Лог='{3}', Уровень='{4}'" -f $EffectiveApiBaseUrl, $EffectiveCheckFolder, $script:EffectiveScanIntervalSeconds, $script:logFilePath, $script:EffectiveLogLevel) "Info"
$apiKeyPart = "[не задан]"; if($script:EffectiveApiKey){ $l=$script:EffectiveApiKey.Length; $p=$script:EffectiveApiKey.Substring(0,[math]::Min(4,$l)); $s=if($l -gt 8){$script:EffectiveApiKey.Substring($l-4,4)}else{""}; $apiKeyPart="$p....$s" }; Write-Log "API ключ (частично): $apiKeyPart" "Debug"
if (-not (Test-Path $EffectiveCheckFolder -PathType Container)) { Write-Log "Критическая ошибка: Папка для сканирования '$($EffectiveCheckFolder)' не существует." "Error"; exit 1 };
$processedFolder = Join-Path $EffectiveCheckFolder "Processed"; $errorFolder = Join-Path $EffectiveCheckFolder "Error"; foreach ($folder in @($processedFolder, $errorFolder)) { if (-not (Test-Path $folder -PathType Container)) { Write-Log "Создание папки: $folder" "Info"; try { New-Item -Path $folder -ItemType Directory -Force -EA Stop | Out-Null } catch { Write-Log ("Критическая ошибка: Не удалось создать папку '{0}'. Ошибка: {1}" -f $folder, $_.Exception.Message) "Error"; exit 1 } } }


# --- 3. Основной цикл сканирования и обработки ---
Write-Log "Начало цикла сканирования папки '$($EffectiveCheckFolder)'..." "Info"
while ($true) {
    Write-Log "Сканирование папки..." "Verbose"
    $filesToProcess = @()
    try {
        $resultsFileFilter = "*_OfflineChecks.json.status*.zrpu"
        $filesToProcess = Get-ChildItem -Path $EffectiveCheckFolder -Filter $resultsFileFilter -File -ErrorAction Stop
    } catch {
        # <<<< ИСПРАВЛЕНО: Используем интерполяцию >>>>
        Write-Log "Критическая ошибка доступа к папке '$EffectiveCheckFolder': $($_.Exception.Message). Пропуск итерации." "Error";
        Start-Sleep -Seconds $script:EffectiveScanIntervalSeconds; continue
    }

    if ($filesToProcess.Count -eq 0) { Write-Log "Нет файлов *.zrpu для обработки." "Verbose" }
    else {
        Write-Log "Найдено файлов для обработки: $($filesToProcess.Count)." "Info"
        # --- Обработка каждого файла ---
        foreach ($file in $filesToProcess) {
            $fileStartTime = Get-Date; Write-Log "--- Начало обработки файла: '$($file.FullName)' ---" "Info"
            $fileProcessingStatus = "unknown"; $fileProcessingMessage = ""; $fileEventDetails = @{}; $apiResponse = $null;

            try {
                # --- Чтение и парсинг файла ---
                Write-Log "Чтение файла '$($file.Name)'..." "Debug"
                $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
                $fileContentClean = $fileContent.TrimStart([char]0xFEFF)
                $payloadFromFile = $fileContentClean | ConvertFrom-Json -ErrorAction Stop
                Write-Log "Файл '$($file.Name)' успешно прочитан и распарсен." "Debug"

                # --- Валидация структуры файла ---
                if ($null -eq $payloadFromFile -or -not $payloadFromFile.PSObject.Properties.Name.Contains('results') -or $payloadFromFile.results -isnot [array] -or -not $payloadFromFile.PSObject.Properties.Name.Contains('agent_script_version') -or -not $payloadFromFile.PSObject.Properties.Name.Contains('assignment_config_version')) {
                     # <<<< ИСПРАВЛЕНО: Используем интерполяцию в throw >>>>
                    throw "Некорректная структура JSON файла '$($file.Name)'. Отсутствуют обязательные поля."
                }
                $resultsArray = $payloadFromFile.results
                $fileAgentVersion = $payloadFromFile.agent_script_version | Get-OrElse_Internal "[не указана]"
                $fileAssignmentVersion = $payloadFromFile.assignment_config_version | Get-OrElse_Internal "[не указана]"
                $totalRecordsInFile = $resultsArray.Count
                # <<<< ИСПРАВЛЕНО: Форматируем строку ДО вызова Write-Log >>>>
                $logMsgFileRead = "Файл '{0}' содержит записей: {1}. AgentVer: '{2}', ConfigVer: '{3}'" -f $file.Name, $totalRecordsInFile, $fileAgentVersion, $fileAssignmentVersion
                Write-Log $logMsgFileRead "Info"

                if ($totalRecordsInFile -eq 0) {
                    # <<<< ИСПРАВЛЕНО: Форматируем строку ДО вызова Write-Log >>>>
                    Write-Log ("Файл '{0}' не содержит записей в массиве 'results'. Файл будет перемещен в Processed." -f $file.Name) "Warn"
                    $fileProcessingStatus = "success_empty"
                    $fileProcessingMessage = "Обработка файла завершена (пустой массив results)."
                    $fileEventDetails = @{ total_records_in_file = 0; agent_version_in_file = $fileAgentVersion; assignment_version_in_file = $fileAssignmentVersion }
                } else {
                    # --- Отправка Bulk запроса ---
                    $apiUrlBulk = "$EffectiveApiBaseUrl/v1/checks/bulk"
                    $jsonBodyToSend = $null
                    try {
                         $jsonBodyToSend = $payloadFromFile | ConvertTo-Json -Depth 10 -Compress -WarningAction SilentlyContinue
                    } catch {
                        # <<<< ИСПРАВЛЕНО: Используем интерполяцию в throw >>>>
                        throw "Ошибка сериализации данных файла '$($file.Name)' в JSON: $($_.Exception.Message)"
                    }
                    $headersForBulk = @{ 'Content-Type' = 'application/json; charset=utf-8'; 'X-API-Key' = $script:EffectiveApiKey }
                    $bulkApiParams = @{ Uri = $apiUrlBulk; Method = 'Post'; Body = [System.Text.Encoding]::UTF8.GetBytes($jsonBodyToSend); Headers = $headersForBulk; Description = "Отправка Bulk из файла '$($file.Name)' ($totalRecordsInFile записей)" }
                    Write-Log ("Отправка Bulk запроса для файла '$($file.Name)' ({0} записей)..." -f $totalRecordsInFile) -Level Info
                    $apiResponse = Invoke-ApiRequestWithRetry @bulkApiParams

                    # Обработка ответа Bulk API
                    if ($apiResponse -eq $null) {
                        $fileProcessingStatus = "error_api"
                        $fileProcessingMessage = "Ошибка отправки Bulk запроса в API после всех попыток."
                        $fileEventDetails.error = "API request failed after retries."; $fileEventDetails.api_response_status = $null
                    } else {
                        $processed = $apiResponse.processed | Get-OrElse_Internal 0; $failed = $apiResponse.failed | Get-OrElse_Internal 0; $apiStatus = $apiResponse.status | Get-OrElse_Internal "unknown"
                        if ($apiStatus -eq "success") { $fileProcessingStatus = "success"; $fileProcessingMessage = "Пакетная обработка файла успешно завершена API. Обработано: $processed." }
                        elseif ($apiStatus -eq "partial_error") { $fileProcessingStatus = "partial_error"; $fileProcessingMessage = "Пакетная обработка файла завершена API с ошибками. Успешно: $processed, Ошибки: $failed."; $fileEventDetails.api_errors = $apiResponse.errors }
                        else { $fileProcessingStatus = "error_api_response"; $fileProcessingMessage = "API вернул статус '$apiStatus' при пакетной обработке. Успешно: $processed, Ошибки: $failed."; $fileEventDetails.error = "API processing error status: $apiStatus"; $fileEventDetails.api_errors = $apiResponse.errors }
                        $fileEventDetails.api_response_status = $apiStatus; $fileEventDetails.api_processed_count = $processed; $fileEventDetails.api_failed_count = $failed
                        $fileEventDetails.total_records_in_file = $totalRecordsInFile; $fileEventDetails.agent_version_in_file = $fileAgentVersion; $fileEventDetails.assignment_version_in_file = $fileAssignmentVersion
                    }
                    # --- Конец Bulk запроса ---
                } # Конец else ($totalRecordsInFile -eq 0)

            } catch { # Обработка ошибок чтения/парсинга файла
                $errorMessage = "Критическая ошибка обработки файла '$($file.FullName)': $($_.Exception.Message)"
                Write-Log $errorMessage "Error"
                $fileProcessingStatus = "error_local"
                $fileProcessingMessage = "Ошибка чтения или парсинга JSON файла."
                $fileEventDetails = @{ error = $errorMessage; ErrorRecord = $_.ToString() }
            }

            # --- Отправка события FILE_PROCESSED ---
            $fileEndTime = Get-Date; $processingTimeMs = ($fileEndTime - $fileStartTime).TotalMilliseconds;
            $fileLogSeverity = "INFO"; if ($fileProcessingStatus -like "error*") { $fileLogSeverity = "ERROR" } elseif ($fileProcessingStatus -eq "partial_error") { $fileLogSeverity = "WARN" }
            $fileEventDetails.processing_time_ms = [math]::Round($processingTimeMs)
            if ($fileProcessingStatus -eq "error_event") { $fileEventDetails.event_sending_error = $true }

            $fileEventBody = @{ event_type = "FILE_PROCESSED"; severity = $fileLogSeverity; message = $fileProcessingMessage; source = "result_loader.ps1 (v$ScriptVersion)"; related_entity = "FILE"; related_entity_id = $file.Name; details = $fileEventDetails }
            $fileEventJsonBody = $fileEventBody | ConvertTo-Json -Compress -Depth 5 -WarningAction SilentlyContinue;
            $apiUrlEvents = "$EffectiveApiBaseUrl/v1/events";
            $headersForEvent = @{ 'Content-Type' = 'application/json; charset=utf-8'; 'X-API-Key' = $script:EffectiveApiKey }
            $eventApiParams = @{ Uri = $apiUrlEvents; Method = 'Post'; Body = [System.Text.Encoding]::UTF8.GetBytes($fileEventJsonBody); Headers = $headersForEvent; Description = "Отправка события FILE_PROCESSED для '$($file.Name)'" }

            Write-Log ("Отправка события FILE_PROCESSED для '$($file.Name)' (Статус: $fileProcessingStatus)...") "Info"
            $eventResponse = Invoke-ApiRequestWithRetry @eventApiParams

            if ($eventResponse -eq $null) {
                 Write-Log ("Не удалось отправить событие FILE_PROCESSED для '$($file.Name)'. Помечаем статус как 'error_event'.") "Error";
                 $fileProcessingStatus = "error_event"
            } else {
                $eventId = if ($eventResponse -is [PSCustomObject] -and $eventResponse.PSObject.Properties.Name.Contains('event_id')) { $eventResponse.event_id } else { '(id ?)' };
                Write-Log ("Событие FILE_PROCESSED для '$($file.Name)' отправлено. Event ID: $eventId") "Info"
            }

            # --- Перемещение файла ---
            $destinationFolder = if ($fileProcessingStatus -like "success*") { $processedFolder } else { $errorFolder };
            $destinationPath = Join-Path $destinationFolder $file.Name;
            # <<<< ИСПРАВЛЕНО: Форматируем строку ДО вызова Write-Log >>>>
            $moveLogMsg = "Перемещение '{0}' в '{1}' (Итоговый статус: {2})." -f $file.Name, $destinationFolder, $fileProcessingStatus
            Write-Log $moveLogMsg "Info";
            try {
                Move-Item -Path $file.FullName -Destination $destinationPath -Force -ErrorAction Stop;
                Write-Log ("Файл '$($file.Name)' успешно перемещен.") "Info"
            } catch {
                 # <<<< ИСПРАВЛЕНО: Форматируем строку ДО вызова Write-Log >>>>
                 Write-Log ("КРИТИЧЕСКАЯ ОШИБКА перемещения файла '{0}' в '{1}'. Файл может быть обработан повторно! Ошибка: {2}" -f $file.Name, $destinationPath, $_.Exception.Message) "Error";
            }

            Write-Log "--- Завершение обработки файла: '$($file.FullName)' ---" "Info"

        } # Конец foreach ($file in $filesToProcess)
    } # Конец else ($filesToProcess.Count -eq 0)

    # --- Пауза перед следующим сканированием ---
    Write-Log "Пауза $script:EffectiveScanIntervalSeconds сек перед следующим сканированием..." "Verbose"
    Start-Sleep -Seconds $script:EffectiveScanIntervalSeconds

} # --- Конец while ($true) ---

Write-Log "Загрузчик результатов завершил работу непредвиденно (выход из цикла while)." "Error"
exit 1
==== END FILE: F:\status\source\powershell\result_loader\result_loader.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\500 ====
116
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\500 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 ====
# ManualTest-Check-PING.ps1
# Скрипт для ручного тестирования Check-PING.ps1

# --- 1. Загрузка модуля Utils ---
$ErrorActionPreference = "Stop"
try {
    # Укажи правильный путь к манифесту модуля
    $modulePath = Join-Path -Path $PSScriptRoot -ChildPath "..\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1"
    Write-Host "Загрузка модуля из '$modulePath'..." -ForegroundColor Cyan
    Import-Module $modulePath -Force
    Write-Host "Модуль загружен." -ForegroundColor Green
} catch {
    Write-Error "Критическая ошибка загрузки модуля Utils: $($_.Exception.Message)"
    exit 1
} finally {
    $ErrorActionPreference = "Continue"
}

# --- 2. Путь к тестируемому скрипту ---
$checkScriptPath = Join-Path -Path $PSScriptRoot -ChildPath "Checks\Check-PING.ps1"
if (-not (Test-Path $checkScriptPath -PathType Leaf)) {
    Write-Error "Скрипт '$checkScriptPath' не найден!"
    exit 1
}
Write-Host "Тестируемый скрипт: $checkScriptPath"

# --- 3. Определение тестовых сценариев ---
$testCases = @(
    @{
        TestName = "Успешный пинг localhost (без критериев)"
        TargetIP = '127.0.0.1'
        Parameters = @{ count = 1 }
        SuccessCriteria = $null
        ExpectedIsAvailable = $true
        ExpectedCheckSuccess = $true # т.к. IsAvailable и нет критериев
        ExpectedError = $false
    }
    @{
        TestName = "Неуспешный пинг (несуществующий IP)"
        TargetIP = '192.0.2.1' # Зарезервированный немаршрутизируемый IP
        Parameters = @{ timeout_ms = 500; count = 1 }
        SuccessCriteria = $null
        ExpectedIsAvailable = $false
        ExpectedCheckSuccess = $null # т.к. IsAvailable=false
        ExpectedError = $true
    }
    @{
        TestName = "Успешный пинг с пройденным критерием RTT"
        TargetIP = 'ya.ru' # Или другой доступный хост
        Parameters = @{}
        SuccessCriteria = @{ rtt_ms = @{ '<=' = 1000 } } # Ожидаем RTT <= 1000ms
        ExpectedIsAvailable = $true
        ExpectedCheckSuccess = $true # Критерий должен пройти (если RTT < 1000)
        ExpectedError = $false
        # Ожидаем, что Test-SuccessCriteria вернет {Passed=$true}
    }
    @{
        TestName = "Успешный пинг с НЕ пройденным критерием RTT"
        TargetIP = 'ya.ru'
        Parameters = @{}
        SuccessCriteria = @{ rtt_ms = @{ '<=' = 1 } } # Заведомо невыполнимый критерий
        ExpectedIsAvailable = $true
        ExpectedCheckSuccess = $false # Критерий НЕ должен пройти
        ExpectedError = $true # Ожидаем ErrorMessage с причиной провала критерия
        # Ожидаем, что Test-SuccessCriteria вернет {Passed=$false, FailReason=...}
    }
    @{
        TestName = "Успешный пинг с некорректным критерием RTT"
        TargetIP = 'ya.ru'
        Parameters = @{}
        SuccessCriteria = @{ rtt_ms = @{ '<=' = 'не число' } } # Некорректное значение
        ExpectedIsAvailable = $true
        ExpectedCheckSuccess = $null # Ошибка обработки критерия -> null
        ExpectedError = $true # Ожидаем ErrorMessage с ошибкой критерия
        # Ожидаем, что Test-SuccessCriteria вернет {Passed=$null, FailReason=...}
    }
    @{
        TestName = "Пинг с двумя критериями (RTT и Потери, потери = 0)"
        TargetIP = 'ya.ru'
        Parameters = @{}
        SuccessCriteria = @{ rtt_ms = @{ '<=' = 1000 }; packet_loss_percent = @{ '==' = 0 } } # Оба должны пройти
        ExpectedIsAvailable = $true
        ExpectedCheckSuccess = $true
        ExpectedError = $false
    }
)

# --- 4. Выполнение тестов ---
Write-Host ("-"*50)
foreach ($testCase in $testCases) {
    Write-Host "Запуск теста: $($testCase.TestName)" -ForegroundColor Yellow
    Write-Host "Параметры:"
    Write-Host "  TargetIP: $($testCase.TargetIP)"
    Write-Host "  Parameters: $($testCase.Parameters | ConvertTo-Json -Depth 1 -Compress)"
    Write-Host "  SuccessCriteria: $($testCase.SuccessCriteria | ConvertTo-Json -Depth 2 -Compress)"

    # <<< ИСПРАВЛЕНО: Подготовка параметров для splatting >>>
    $scriptArgs = @{
        TargetIP        = $testCase.TargetIP
        Parameters      = $testCase.Parameters
        SuccessCriteria = $testCase.SuccessCriteria
        NodeName        = $testCase.TestName # Используем имя теста для логов
    }

    # Вызов скрипта через оператор '&' и splatting '@scriptArgs'
    try {
        # & вызывает скрипт в дочерней области видимости, но функции модуля будут доступны
        $result = & $checkScriptPath @scriptArgs
    } catch {
        Write-Error "Критическая ошибка при ВЫЗОВЕ скрипта '$checkScriptPath': $($_.Exception.Message)"
        $result = $null # Не удалось получить результат
    }

    # --- 5. Проверка результата (остается без изменений) ---
    Write-Host "Результат:"
    if ($result -ne $null) {
        # ... (код проверки результата) ...
        Write-Host ($result | ConvertTo-Json -Depth 4) -ForegroundColor Gray

        # Проверка IsAvailable
        if ($result.IsAvailable -eq $testCase.ExpectedIsAvailable) {
            Write-Host "  [PASS] IsAvailable: $($result.IsAvailable)" -ForegroundColor Green
        } else {
            Write-Host "  [FAIL] IsAvailable: Ожидалось $($testCase.ExpectedIsAvailable), получено $($result.IsAvailable)" -ForegroundColor Red
        }
        # Проверка CheckSuccess
        if ($result.CheckSuccess -eq $testCase.ExpectedCheckSuccess) {
            Write-Host "  [PASS] CheckSuccess: $($result.CheckSuccess)" -ForegroundColor Green
        } else {
            Write-Host "  [FAIL] CheckSuccess: Ожидалось $($testCase.ExpectedCheckSuccess), получено $($result.CheckSuccess)" -ForegroundColor Red
        }
        # Проверка ErrorMessage
        $hasError = -not [string]::IsNullOrEmpty($result.ErrorMessage)
        if ($hasError -eq $testCase.ExpectedError) {
            Write-Host "  [PASS] ErrorMessage: $($hasError) (Сообщение: '$($result.ErrorMessage)')" -ForegroundColor Green
        } else {
            Write-Host "  [FAIL] ErrorMessage: Ожидалось $($testCase.ExpectedError), получено $($hasError) (Сообщение: '$($result.ErrorMessage)')" -ForegroundColor Red
        }
        # Дополнительно можно проверить содержимое Details
        if($testCase.ExpectedIsAvailable -eq $true -and $testCase.ExpectedError -eq $false){
            # Проверяем, есть ли Details, есть ли в нем ключ rtt_ms, и значение НЕ null
            if($result.Details -ne $null -and ($result.Details.PSObject.Properties.Name -contains 'rtt_ms') -and $result.Details.rtt_ms -ne $null){
                 Write-Host "  [INFO] RTT: $($result.Details.rtt_ms)ms" -ForegroundColor DarkGray # Сделаем серым, т.к. это инфо
            } else {
                 # Выводим WARN только если RTT действительно должен был быть (т.е. ExpectedIsAvailable=true, ExpectedError=false)
                 Write-Host "  [WARN] RTT равен null или отсутствует в Details при УСПЕШНОМ результате." -ForegroundColor Yellow
            }
        }

    } else {
        Write-Host "  [FAIL] Результат выполнения скрипта равен null!" -ForegroundColor Red
    }
    Write-Host ("-"*50)
    Start-Sleep -Seconds 1 # Небольшая пауза между тестами
}

Write-Host "Тестирование завершено."
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-Check-PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1
# --- Скрипт для ручного тестирования SQL-проверок на базе testDB_kaskad ---

# --- 1. Загрузка модуля Utils ---
$ErrorActionPreference = "Stop" # Прерывать выполнение при ошибке
try {
    # Путь к манифесту модуля относительно ЭТОГО скрипта
    $modulePath = Join-Path -Path $PSScriptRoot -ChildPath "StatusMonitorAgentUtils.psd1"
    Write-Host "INFO: Загрузка модуля из '$modulePath'..." -ForegroundColor Cyan
    Import-Module $modulePath -Force
    Write-Host "INFO: Модуль StatusMonitorAgentUtils загружен." -ForegroundColor Green
} catch {
    Write-Error "КРИТИЧЕСКАЯ ОШИБКА: Не удалось загрузить модуль Utils: $($_.Exception.Message)"
    exit 1
} finally {
    $ErrorActionPreference = "Continue" # Возвращаем стандартное поведение
}
Write-Host "INFO: Проверка наличия команды Invoke-StatusMonitorCheck:"
Get-Command Invoke-StatusMonitorCheck -ErrorAction SilentlyContinue | Format-Table Name, ModuleName -AutoSize
Write-Host "INFO: Проверка наличия команды Invoke-Sqlcmd:"
Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue | Format-Table Name, ModuleName -AutoSize
if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
    Write-Warning "Модуль SqlServer не найден или не загружен. SQL-проверки не будут работать."
    # Можно добавить: Install-Module SqlServer -Force -Scope CurrentUser; Import-Module SqlServer
    # exit 1 # Или прервать выполнение
}
Write-Host $('-'*80)

# --- 2. Параметры подключения к тестовой БД ---
# Имя инстанса SQL Server с нестандартным портом
$TestSqlServerInstance = "localhost,48010"
$TestDatabaseName = "kaskad"
# Для SQL аутентификации (раскомментировать и использовать при необходимости)
$TestSqlUsername = "sa"
$TestSqlPassword = "escort123"

Write-Host "ПАРАМЕТРЫ ТЕСТОВОЙ БД:"
Write-Host "  Сервер: $TestSqlServerInstance"
Write-Host "  База:   $TestDatabaseName"
# if ($TestSqlUsername) { Write-Host "  Режим:  SQL Auth ($TestSqlUsername)" }
# else { Write-Host "  Режим:  Windows Auth" }
Write-Host $('-'*80)

# --- 3. Базовый объект Задания (для копирования) ---
$baseAssignment = @{
    assignment_id = 9000 # Начальный ID
    method_name   = ''     # Будет заменен
    node_name     = "Kaskad DB Test"
    ip_address    = $TestSqlServerInstance # Сервер передаем как IP/Host
    parameters    = @{}  # Будут добавлены
    success_criteria = $null # Будет добавлен при необходимости
}

# ==============================================================================
# === ТЕСТЫ ДЛЯ Check-SQL_QUERY_EXECUTE.ps1 ===
# ==============================================================================
Write-Host "НАЧАЛО ТЕСТОВ: Check-SQL_QUERY_EXECUTE" -ForegroundColor Yellow
Write-Host $('-'*80)

# --- Тест 1: first_row (успех) ---
$assignment1 = $baseAssignment.PSObject.Copy()
$assignment1.assignment_id += 1
$assignment1.method_name = 'SQL_QUERY_EXECUTE'
$assignment1.node_name = "SQL Execute: First Row (Success)"
$assignment1.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT TOP 1 id, CreationDate, Revise FROM dbo.ReviseData WHERE id = 1115" # Запрос существующей записи
    return_format = 'first_row'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword

    
}
Write-Host "ЗАПУСК: $($assignment1.node_name)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment1) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 2: all_rows (успех, ожидаем 1 строку) ---
$assignment2 = $baseAssignment.PSObject.Copy()
$assignment2.assignment_id += 2
$assignment2.method_name = 'SQL_QUERY_EXECUTE'
$assignment2.node_name = "SQL Execute: All Rows (Success, 1 row)"
$assignment2.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT id, CreationDate FROM dbo.ReviseData WHERE id = 1115" # Только 2 столбца
    return_format = 'all_rows'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword

}
Write-Host "ЗАПУСК: $($assignment2.node_name)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment2) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 3: row_count (успех, ожидаем 1) ---
$assignment3 = $baseAssignment.PSObject.Copy()
$assignment3.assignment_id += 3
$assignment3.method_name = 'SQL_QUERY_EXECUTE'
$assignment3.node_name = "SQL Execute: Row Count (Success, expects 1)"
$assignment3.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT id FROM dbo.ReviseData" # Считаем все строки (должна быть 1)
    return_format = 'row_count'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment3.node_name)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment3) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 4: scalar (успех, получаем ID) ---
$assignment4 = $baseAssignment.PSObject.Copy()
$assignment4.assignment_id += 4
$assignment4.method_name = 'SQL_QUERY_EXECUTE'
$assignment4.node_name = "SQL Execute: Scalar (Success, get ID)"
$assignment4.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT TOP 1 id FROM dbo.ReviseData ORDER BY CreationDate DESC"
    return_format = 'scalar'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment4.node_name)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment4) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 5: non_query (успех, временная таблица) ---
$assignment5 = $baseAssignment.PSObject.Copy()
$assignment5.assignment_id += 5
$assignment5.method_name = 'SQL_QUERY_EXECUTE'
$assignment5.node_name = "SQL Execute: Non-Query (Success, temp table)"
$assignment5.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "IF OBJECT_ID('tempdb..#TempTestExec') IS NULL BEGIN CREATE TABLE #TempTestExec(col1 INT) END;"
    return_format = 'non_query'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment5.node_name)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment5) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 6: Ошибка SQL (неверное имя таблицы) ---
$assignment6 = $baseAssignment.PSObject.Copy()
$assignment6.assignment_id += 6
$assignment6.method_name = 'SQL_QUERY_EXECUTE'
$assignment6.node_name = "SQL Execute: SQL Error (Bad Table)"
$assignment6.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT * FROM dbo.NonExistentTable"
    return_format = 'first_row'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment6.node_name) (Ожидаем IsAvailable=false)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment6) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 7: Ошибка подключения (неверное имя БД) ---
$assignment7 = $baseAssignment.PSObject.Copy()
$assignment7.assignment_id += 7
$assignment7.method_name = 'SQL_QUERY_EXECUTE'
$assignment7.node_name = "SQL Execute: Connection Error (Bad DB)"
$assignment7.parameters = @{
    sql_database = "NonExistentKaskadDB" # Неверная БД
    sql_query = "SELECT 1"
    return_format = 'scalar'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment7.node_name) (Ожидаем IsAvailable=false)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment7) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 8: row_count с критерием (успех) ---
$assignment8 = $baseAssignment.PSObject.Copy()
$assignment8.assignment_id += 8
$assignment8.method_name = 'SQL_QUERY_EXECUTE'
$assignment8.node_name = "SQL Execute: Row Count with Criteria (Success)"
$assignment8.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT id FROM dbo.ReviseData WHERE id = 1115" # 1 строка
    return_format = 'row_count'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
# Критерий: количество строк должно быть равно 1
$assignment8.success_criteria = @{ row_count = @{ '==' = 1 } }
Write-Host "ЗАПУСК: $($assignment8.node_name) (Ожидаем CheckSuccess=true)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment8) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 9: row_count с критерием (неуспех) ---
$assignment9 = $baseAssignment.PSObject.Copy()
$assignment9.assignment_id += 9
$assignment9.method_name = 'SQL_QUERY_EXECUTE'
$assignment9.node_name = "SQL Execute: Row Count with Criteria (Fail)"
$assignment9.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT id FROM dbo.ReviseData" # 1 строка
    return_format = 'row_count'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
# Критерий: количество строк должно быть БОЛЬШЕ 5
$assignment9.success_criteria = @{ row_count = @{ '>' = 5 } }
Write-Host "ЗАПУСК: $($assignment9.node_name) (Ожидаем CheckSuccess=false)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment9) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 10: scalar с критерием (успех) ---
$assignment10 = $baseAssignment.PSObject.Copy()
$assignment10.assignment_id += 10
$assignment10.method_name = 'SQL_QUERY_EXECUTE'
$assignment10.node_name = "SQL Execute: Scalar with Criteria (Success)"
$assignment10.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT COUNT(*) FROM dbo.ReviseData" # Получаем кол-во
    return_format = 'scalar'
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
# Критерий: скалярное значение (кол-во) должно быть >= 1
$assignment10.success_criteria = @{ scalar_value = @{ '>=' = 1 } }
Write-Host "ЗАПУСК: $($assignment10.node_name) (Ожидаем CheckSuccess=true)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment10) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

Write-Host "КОНЕЦ ТЕСТОВ: Check-SQL_QUERY_EXECUTE" -ForegroundColor Green
Write-Host $('='*80)
Write-Host ""

# ==============================================================================
# === ТЕСТЫ ДЛЯ Check-SQL_XML_QUERY.ps1 ===
# ==============================================================================
Write-Host "НАЧАЛО ТЕСТОВ: Check-SQL_XML_QUERY" -ForegroundColor Yellow
Write-Host $('-'*80)

# --- Тест 11: Успешное извлечение XML и ключей ---
$assignment11 = $baseAssignment.PSObject.Copy()
$assignment11.assignment_id += 11
$assignment11.method_name = 'SQL_XML_QUERY'
$assignment11.node_name = "SQL XML Query: Success"
$assignment11.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"
    xml_column_name = 'Revise'
    keys_to_extract = @('VersionStat', 'ArrivalStationID', 'TS_Version', 'NonExistentKey')
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment11.node_name) (Ожидаем извлеченные значения и null для NonExistentKey)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment11) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 12: Успешное извлечение с критерием ---
$assignment12 = $baseAssignment.PSObject.Copy()
$assignment12.assignment_id += 12
$assignment12.method_name = 'SQL_XML_QUERY'
$assignment12.node_name = "SQL XML Query: Criteria Success"
$assignment12.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"
    xml_column_name = 'Revise'
    keys_to_extract = @('VersionStat', 'TS_Version')
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
# Критерий: VersionStat должен быть равен '20221206' И TS_Version > 100
$assignment12.success_criteria = @{
    extracted_data = @{
        VersionStat = @{ '==' = '20221206' }
        TS_Version = @{ '>' = 100 }
    }
}
Write-Host "ЗАПУСК: $($assignment12.node_name) (Ожидаем CheckSuccess=true)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment12) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 13: Неуспех по критерию ---
$assignment13 = $baseAssignment.PSObject.Copy()
$assignment13.assignment_id += 13
$assignment13.method_name = 'SQL_XML_QUERY'
$assignment13.node_name = "SQL XML Query: Criteria Fail (TS_Version)"
$assignment13.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT TOP 1 Revise FROM dbo.ReviseData WHERE id = 1115"
    xml_column_name = 'Revise'
    keys_to_extract = @('TS_Version')
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
# Критерий: TS_Version должен быть МЕНЬШЕ 100
$assignment13.success_criteria = @{ extracted_data = @{ TS_Version = @{ '<' = 100 } } }
Write-Host "ЗАПУСК: $($assignment13.node_name) (Ожидаем CheckSuccess=false)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment13) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 14: Ошибка - неверное имя столбца XML ---
$assignment14 = $baseAssignment.PSObject.Copy()
$assignment14.assignment_id += 14
$assignment14.method_name = 'SQL_XML_QUERY'
$assignment14.node_name = "SQL XML Query: Error (Bad XML Column)"
$assignment14.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT TOP 1 id, Revise FROM dbo.ReviseData WHERE id = 1115"
    xml_column_name = 'InvalidXmlColumnName' # Неверное имя
    keys_to_extract = @('VersionStat')
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment14.node_name) (Ожидаем IsAvailable=false)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment14) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 15: Ошибка - столбец не XML ---
$assignment15 = $baseAssignment.PSObject.Copy()
$assignment15.assignment_id += 15
$assignment15.method_name = 'SQL_XML_QUERY'
$assignment15.node_name = "SQL XML Query: Error (Column Not XML)"
$assignment15.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT TOP 1 id, CreationDate FROM dbo.ReviseData WHERE id = 1115"
    xml_column_name = 'CreationDate' # Это DATETIME, а не XML
    keys_to_extract = @('Year') # Не важно, что извлекать
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment15.node_name) (Ожидаем IsAvailable=false, ошибка парсинга XML)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment15) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 16: Ошибка - SQL запрос не вернул строк ---
$assignment16 = $baseAssignment.PSObject.Copy()
$assignment16.assignment_id += 16
$assignment16.method_name = 'SQL_XML_QUERY'
$assignment16.node_name = "SQL XML Query: Error (No Rows)"
$assignment16.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT Revise FROM dbo.ReviseData WHERE id = 99999" # Несуществующий ID
    xml_column_name = 'Revise'
    keys_to_extract = @('VersionStat')
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment16.node_name) (Ожидаем IsAvailable=true, Details.message, CheckSuccess=true)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment16) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)

# --- Тест 17: Ошибка SQL (как в тесте 6) ---
$assignment17 = $baseAssignment.PSObject.Copy()
$assignment17.assignment_id += 17
$assignment17.method_name = 'SQL_XML_QUERY'
$assignment17.node_name = "SQL XML Query: SQL Error (Bad Table)"
$assignment17.parameters = @{
    sql_database = $TestDatabaseName
    sql_query = "SELECT Revise FROM dbo.NonExistentTable"
    xml_column_name = 'Revise'
    keys_to_extract = @('AnyKey')
    sql_username = $TestSqlUsername
    sql_password = $TestSqlPassword
}
Write-Host "ЗАПУСК: $($assignment17.node_name) (Ожидаем IsAvailable=false)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment17) | ConvertTo-Json -Depth 5
Write-Host $('-'*40)


Write-Host "КОНЕЦ ТЕСТОВ: Check-SQL_XML_QUERY" -ForegroundColor Green
Write-Host $('='*80)
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\ManualTest-SQL-Checks-Kaskad.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\README.md ====

---

**9. `powershell/StatusMonitorAgentUtils/README.md` (Новый)**

```markdown
# Модуль PowerShell: StatusMonitorAgentUtils

Этот модуль PowerShell (`StatusMonitorAgentUtils.psm1` и папка `Checks/`) предоставляет общую функциональность для агентов мониторинга (online и offline) системы Status Monitor.

## Назначение

*   **Инкапсуляция логики проверок:** Содержит код для выполнения различных типов проверок (PING, статус службы, использование диска и т.д.).
*   **Диспетчеризация:** Предоставляет единую точку входа (`Invoke-StatusMonitorCheck`) для агентов, которая определяет нужный метод проверки и запускает соответствующий скрипт.
*   **Стандартизация результатов:** Обеспечивает возврат результатов проверок в едином формате.
*   **Переиспользование кода:** Содержит общие вспомогательные функции.

## Ключевые компоненты

1.  **`StatusMonitorAgentUtils.psm1`**: Основной файл модуля. Содержит:
    *   **`Invoke-StatusMonitorCheck` (Экспортируемая функция):**
        *   **Роль:** Диспетчер проверок.
        *   **Вход:** Объект задания (`$Assignment`) от агента.
        *   **Логика:**
            *   Определяет имя метода (`$Assignment.method_name`).
            *   Находит соответствующий скрипт `Checks/Check-METHOD_NAME.ps1`.
            *   Проверяет существование скрипта.
            *   Подготавливает параметры (`$checkParams`) для скрипта проверки (извлекая нужные данные из `$Assignment`).
            *   **Запускает скрипт `Checks/Check-*.ps1` ЛОКАЛЬНО** на машине, где работает агент (используя оператор `&`).
            *   Перехватывает ошибки выполнения скрипта проверки.
            *   Возвращает стандартизированный результат, полученный от скрипта проверки (или сформированный при ошибке).
    *   **`New-CheckResultObject` (Экспортируемая функция):**
        *   **Роль:** Вспомогательная функция для создания стандартизированного объекта результата.
        *   **Вход:** Параметры результата (`IsAvailable`, `CheckSuccess`, `Details`, `ErrorMessage`).
        *   **Логика:** Создает хэш-таблицу с обязательными полями (`IsAvailable`, `CheckSuccess`, `Timestamp` (в UTC ISO 8601)) и переданными опциональными данными. Применяет логику для `CheckSuccess` и `ErrorMessage` по умолчанию.
        *   **Выход:** Хэш-таблица стандартного результата.
    *   **`Invoke-RemoteCheck` (Приватная функция, НЕ используется агентами):**
        *   Реализует логику вызова скрипта проверки на **удаленной** машине через `Invoke-Command`. *Эта функция не используется текущими онлайн/оффлайн агентами, так как они выполняют проверки сами.*

2.  **Папка `Checks/`**: Содержит отдельные `.ps1` файлы для **каждого** метода проверки, поддерживаемого системой.
    *   **Именование:** `Check-METHOD_NAME.ps1` (например, `Check-PING.ps1`, `Check-SERVICE_STATUS.ps1`). `METHOD_NAME` должно точно совпадать со значением `method_name` в таблице `check_methods` БД.
    *   **Назначение:** Каждый скрипт отвечает за логику **только своей** проверки.
    *   **Вход:** Принимает параметры через `param()` (например, `$TargetIP`, `$Parameters`, `$SuccessCriteria`, `$NodeName`), которые ему передает диспетчер `Invoke-StatusMonitorCheck`.
    *   **Выход:** **Обязан** возвращать стандартизированный объект-результат (хэш-таблицу), используя `New-CheckResultObject` или создавая его вручную по тому же формату.

## Стандартный Формат Результата Проверки

Каждый скрипт `Checks/Check-*.ps1` и функция `Invoke-StatusMonitorCheck` должны возвращать результат в виде хэш-таблицы следующей структуры:

```powershell
@{
    # --- Обязательные поля ---

    # Удалось ли ВЫПОЛНИТЬ саму проверку?
    # $false если: нет доступа к цели, нет прав, объект не найден,
    #             ошибка в скрипте проверки, ошибка парсинга и т.д.
    # $true если: удалось получить какие-либо данные (даже если они
    #             не соответствуют критериям).
    IsAvailable = [bool]

    # Соответствует ли результат проверки КРИТЕРИЯМ УСПЕХА?
    # Устанавливается ТОЛЬКО если IsAvailable = $true.
    # $true:  Проверка выполнена И результат соответствует критериям (или критериев нет).
    # $false: Проверка выполнена, НО результат НЕ соответствует критериям.
    # $null:  Проверка НЕ была выполнена (IsAvailable = $false) ИЛИ
    #          критерии не применялись или их проверка не удалась.
    CheckSuccess = [nullable[bool]]

    # Время выполнения проверки в формате UTC ISO 8601 (YYYY-MM-DDTHH:mm:ss.fffffffZ)
    Timestamp = [string]

    # --- Опциональные поля ---

    # Детализированная информация о результате проверки.
    # Содержимое зависит от конкретного метода.
    # Например, для DISK_USAGE это будет @{ disks = @(...) }
    # Может содержать доп. информацию об ошибке, если IsAvailable = $false.
    Details = [hashtable] # Или $null

    # Текстовое описание проблемы.
    # Заполняется, если IsAvailable = $false ИЛИ CheckSuccess = $false.
    ErrorMessage = [string] # Или $null
}

Добавление Новых Методов Проверки

    Добавить запись в таблицу check_methods в базе данных (указать уникальный method_name).

    Создать файл Checks/Check-METHOD_NAME.ps1 в папке модуля StatusMonitorAgentUtils.

    Реализовать логику проверки внутри этого скрипта:

        Определить необходимые параметры в блоке param().

        Написать код для выполнения проверки (используя PowerShell командлеты, .NET классы, WMI и т.д.).

        Обработать возможные ошибки.

        Определить значения для IsAvailable и CheckSuccess.

        Сформировать хэш-таблицу $Details с результатами.

        Сформировать $ErrorMessage при необходимости.

        Вернуть стандартизированный результат с помощью New-CheckResultObject или вручную.

    Обновить StatusMonitorAgentUtils.psd1, если нужно экспортировать новые вспомогательные функции (обычно не требуется для добавления только скрипта проверки).

    Протестировать новый скрипт локально, вызвав его через Invoke-StatusMonitorCheck с тестовым объектом $Assignment.

    Создать Задание в веб-интерфейсе Status Monitor, использующее новый метод.

Установка и Использование

Модуль StatusMonitorAgentUtils не нужно устанавливать глобально. Его необходимо скопировать вместе с агентами (online/offline).

    Структура папок:
    <Папка_Агента>/
├── online-agent/
│   └── online-agent.ps1
│   └── config.json
│   └── README.md
├── offline-agent/
│   └── offline-agent.ps1
│   └── config.json
│   └── README.md
└── StatusMonitorAgentUtils/  <-- Модуль должен быть здесь
    ├── Checks/
    │   ├── Check-PING.ps1
    │   ├── Check-SERVICE_STATUS.ps1
    │   └── ... (другие скрипты проверок) ...
    ├── StatusMonitorAgentUtils.psd1
    └── StatusMonitorAgentUtils.psm1
    └── README.md (этот файл)

    Скрипты агентов (online-agent.ps1, offline-agent.ps1) автоматически импортируют модуль из относительного пути ..\StatusMonitorAgentUtils.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\README.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1
# Манифест PowerShell модуля для общих утилит агентов Status Monitor

@{

    # Версия модуля. Увеличивайте при внесении изменений в экспортируемые функции или общую структуру.
    # Версия 1.1.0: Удалена функция/фильтр Get-OrElse.
    ModuleVersion = '1.1.0'

    # Уникальный идентификатор модуля (GUID). Генерируется один раз.
    # Используйте `[guid]::NewGuid()` для генерации, если это новый модуль.
    GUID = 'e5fa7cfe-608d-47c9-898d-215bb6b0ef0d' # Оставляем существующий

    # Автор модуля
    Author = 'User & AI'

    # Компания (опционально)
    # CompanyName = 'Your Company'

    # Авторские права (опционально)
    # Copyright = '(c) 2024 Your Company. All rights reserved.'

    # Описание назначения модуля
    Description = 'Общий модуль для агентов системы мониторинга Status Monitor. Содержит диспетчер выполнения проверок (Invoke-StatusMonitorCheck), функцию форматирования результата (New-CheckResultObject) и скрипты для конкретных проверок в папке Checks.'

    # Минимально необходимая версия PowerShell для работы модуля
    PowerShellVersion = '5.1'

    # Зависимости от других модулей PowerShell (если есть).
    # Например, если бы проверки SQL были прямо в psm1, добавили бы 'SqlServer'.
    # RequiredModules = @()

    # Указываем основной файл модуля, содержащий скрипты экспортируемых функций.
    RootModule = 'StatusMonitorAgentUtils.psm1'

    # Список функций, которые будут видны и доступны для вызова ИЗВНЕ этого модуля
    # после его импорта (Import-Module). Все остальные функции в .psm1 будут приватными.
    FunctionsToExport = @(
        # Основная функция-диспетчер для запуска проверок агентами.
        'Invoke-StatusMonitorCheck'

        # Вспомогательная функция для создания стандартизированного объекта результата
        # проверки. Используется внутри скриптов Checks/*.ps1.
        'New-CheckResultObject',

        'Test-SuccessCriteria',
        'Compare-Values'
        # Get-OrElse была УДАЛЕНА
    )

    # Список командлетов, экспортируемых модулем (у нас таких нет).
    CmdletsToExport = @()

    # Список переменных, экспортируемых модулем (обычно не рекомендуется).
    VariablesToExport = '*' # Можно заменить на @() для чистоты

    # Список псевдонимов (aliases), экспортируемых модулем (у нас таких нет).
    AliasesToExport = @()

    # Список всех файлов .ps1, .psm1, которые являются частью модуля
    # (PowerShell попытается загрузить их все при импорте).
    # Указание RootModule обычно достаточно, если нет сложной структуры.
    # ModuleList = @()

    # Файлы со скриптами, которые нужно выполнить при импорте модуля (.ps1).
    # ScriptsToProcess = @()

    # Файлы типов (.types.ps1xml) и форматов (.format.ps1xml).
    # TypesToProcess = @()
    # FormatsToProcess = @()

    # Необходимые сборки .NET (если используются напрямую).
    # RequiredAssemblies = @()

    # Список файлов модуля (информационно).
    # FileList = @()

    # Другие метаданные...
    # PrivateData = @{}
    # HelpInfoURI = ''
    # DefaultCommandPrefix = ''
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psd1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1
# Основной скрипт модуля StatusMonitorAgentUtils.
# Содержит экспортируемые функции и приватные хелперы.
# Версия модуля: 1.1.0 (согласно PSD1)
# Версия этого файла: Включает Test-SuccessCriteria v2.1.8, Compare-Values v1.1, New-CheckResultObject v1.3, Invoke-StatusMonitorCheck v1.2.1

#--------------------------------------------------------------------------
# Приватные функции (не экспортируются)
#--------------------------------------------------------------------------

#region Функция Compare-Values (Приватная, v1.1 - Улучшено сравнение ==/!=)
# Вспомогательная функция для сравнения значений с операторами
# Возвращает: @{ Passed = $true/$false/$null; Reason = "..."/$null }
# ($null для Passed означает ошибку сравнения/типа)
function Compare-Values {
    param(
        $Value, # Фактическое значение из Details
        $Operator, # Оператор сравнения (строка: '>', 'contains', 'matches'...)
        $Threshold # Пороговое значение из Criteria
    )

    $result = @{ Passed = $true; Reason = '' }
    $opLower = $Operator.ToLower()

    try {
        # --- Проверка существования ---
        if ($opLower -eq 'exists') {
            if (($Threshold -eq $true -and $Value -eq $null) -or ($Threshold -eq $false -and $Value -ne $null)) {
                $result.Passed = $false
                $result.Reason = "Проверка существования (exists=$Threshold) не пройдена для значения '$Value'"
            }
            return $result
        }

        # --- Универсальное сравнение для == и != ---
        # Используем стандартный оператор PowerShell
        elseif ($opLower -eq '==') {
             if (-not ($Value -eq $Threshold)) {
                 $result.Passed = $false; $result.Reason = "'$Value' не равно '$Threshold'"
             }
        }
        elseif ($opLower -eq '!=') {
             if (-not ($Value -ne $Threshold)) {
                 $result.Passed = $false; $result.Reason = "'$Value' равно '$Threshold'"
             }
        }
        # --- Числовые сравнения (остаются с преобразованием) ---
        elseif ($opLower -in @('>', '>=', '<', '<=')) {
            $numValue = 0.0; $numThreshold = 0.0
            # Используем региональные настройки текущей культуры для парсинга чисел
            $culture = [System.Globalization.CultureInfo]::CurrentCulture
            $valueParsed = [double]::TryParse($Value, [System.Globalization.NumberStyles]::Any, $culture, [ref]$numValue)
            $thresholdParsed = [double]::TryParse($Threshold, [System.Globalization.NumberStyles]::Any, $culture, [ref]$numThreshold)

            if (-not $valueParsed -or -not $thresholdParsed) {
                $result.Passed = $null # Ошибка типа
                $result.Reason = "Ошибка числового сравнения '$opLower': Не удалось преобразовать '$Value' или '$Threshold' в число."
                return $result
            }
            # Выполняем числовое сравнение
            switch ($opLower) {
                '>'  { if (-not ($numValue -gt $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не больше (>) '$Threshold'" } }
                '>=' { if (-not ($numValue -ge $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не больше или равно (>=) '$Threshold'" } }
                '<'  { if (-not ($numValue -lt $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не меньше (<) '$Threshold'" } }
                '<=' { if (-not ($numValue -le $numThreshold)) { $result.Passed = $false; $result.Reason = "'$Value' не меньше или равно (<=) '$Threshold'" } }
            }
        }
        # --- Строковые сравнения (только специфичные для строк) ---
        elseif ($opLower -in @('contains', 'not_contains', 'matches', 'not_matches')) {
            # Приводим оба операнда к строке
            $strValue = "$Value"
            $strThreshold = "$Threshold"

            # Выполняем сравнение
            switch ($opLower) {
                'contains' { if ($strValue -notlike "*$strThreshold*") { $result.Passed = $false; $result.Reason = "'$strValue' не содержит '$strThreshold'" } }
                'not_contains' { if ($strValue -like "*$strThreshold*") { $result.Passed = $false; $result.Reason = "'$strValue' содержит '$strThreshold'" } }
                'matches' { if ($strValue -notmatch $strThreshold) { $result.Passed = $false; $result.Reason = "'$strValue' не соответствует regex '$strThreshold'" } }
                'not_matches' { if ($strValue -match $strThreshold) { $result.Passed = $false; $result.Reason = "'$strValue' соответствует regex '$strThreshold'" } }
            }
        } else {
            # Неизвестный оператор
            $result.Passed = $null
            $result.Reason = "Неизвестный оператор сравнения: '$Operator'"
        }
    } catch {
        $result.Passed = $null
        $result.Reason = "Ошибка при сравнении оператором '$Operator' для '$Value' и '$Threshold': $($_.Exception.Message)"
    }
    return $result
}
#endregion

#region Функция Test-ArrayCriteria (Приватная, v1.0 - Реализованная, но требует тестов)
# Обрабатывает критерии для массивов (_condition_, _where_, _criteria_, _count_)
function Test-ArrayCriteria {
    param(
        [Parameter(Mandatory=$true)] $DetailsArray,    # Массив данных из Details
        [Parameter(Mandatory=$true)] [hashtable]$ArrayCriteria, # Критерий для массива (содержит _condition_, etc.)
        [string]$Path                             # Текущий путь для логов/ошибок
    )

    $result = @{ Passed = $null; FailReason = $null } # Начинаем с неопределенного

    # 1. Проверка, что DetailsArray - это действительно массив
    if ($DetailsArray -isnot [array]) {
        $result.Passed = $false
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Ожидался массив в данных, но получен '$($DetailsArray.GetType().Name)'."
        return $result
    }

    # 2. Извлечение управляющих ключей из критерия
    $condition = $ArrayCriteria._condition_
    $whereClause = $ArrayCriteria._where_       # Может быть $null или hashtable
    $criteria = $ArrayCriteria._criteria_     # Может быть $null или hashtable (для all, any, none)
    $countCriteria = $ArrayCriteria._count_    # Может быть $null или hashtable (для count)

    # 3. Валидация управляющих ключей
    if (-not $condition -or $condition.ToLower() -notin @('all', 'any', 'none', 'count')) {
        $result.Passed = $null
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Отсутствует или неверный ключ '_condition_'. Допустимые: 'all', 'any', 'none', 'count'."
        return $result
    }
    $conditionLower = $condition.ToLower() # Приводим к нижнему регистру для switch

    if ($conditionLower -in @('all', 'any') -and $null -eq $criteria) {
        $result.Passed = $null
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Для _condition_ '$condition' требуется ключ '_criteria_'."
        return $result
    }
    if ($conditionLower -eq 'count' -and ($null -eq $countCriteria -or -not ($countCriteria.PSObject -ne $null))) { # Проверяем, что countCriteria - объект
        $result.Passed = $null
        $result.FailReason = "Ошибка критерия массива по пути '$Path': Для _condition_ 'count' требуется ключ '_count_' с объектом операторов."
        return $result
    }

    # 4. Фильтрация массива (если есть _where_)
    $filteredArray = $DetailsArray # По умолчанию работаем со всем массивом
    if ($whereClause -ne $null) {
        Write-Verbose "Фильтрация массива по пути '$Path' с использованием _where_..."
        $tempFiltered = [System.Collections.Generic.List[object]]::new()
        $indexCounter = -1 # Счетчик для логов
        foreach ($item in $DetailsArray) {
            $indexCounter++
            # Рекурсивно проверяем КАЖДЫЙ элемент на соответствие _where_
            $filterCheck = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $whereClause -Path "$Path[$indexCounter]" # Передаем индекс
            if ($filterCheck.Passed -eq $true) {
                $tempFiltered.Add($item)
            } elseif ($filterCheck.Passed -eq $null) {
                # Если ошибка при фильтрации элемента - вся проверка критерия массива считается ошибочной
                $result.Passed = $null
                $result.FailReason = "Ошибка при фильтрации элемента массива ($indexCounter) по пути '$Path': $($filterCheck.FailReason)"
                return $result
            }
        }
        $filteredArray = $tempFiltered
        Write-Verbose "Массив по пути '$Path' отфильтрован. Осталось элементов: $($filteredArray.Count)"
    }

    # 5. Применение основного условия (_condition_)
    $finalPassed = $null # Итоговый результат условия

    switch ($conditionLower) {
        'all' {
            if ($filteredArray.Count -eq 0) { $finalPassed = $true }
            else {
                 $allPassed = $true
                 for ($i = 0; $i -lt $filteredArray.Count; $i++) {
                     $item = $filteredArray[$i]
                     $itemResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteria -Path "$Path[$i]"
                     if ($itemResult.Passed -ne $true) {
                         $allPassed = $false; $result.FailReason = "Условие 'all' не выполнено для элемента [$i] по пути '$Path'. Причина: $($itemResult.FailReason)"; break
                     }
                 }
                 $finalPassed = $allPassed
            }
        } # Конец 'all'
        'any' {
             $anyPassed = $false
             if ($filteredArray.Count -gt 0) {
                 for ($i = 0; $i -lt $filteredArray.Count; $i++) {
                     $item = $filteredArray[$i]
                     $itemResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteria -Path "$Path[$i]"
                     if ($itemResult.Passed -eq $true) { $anyPassed = $true; $result.FailReason = $null; break }
                     elseif ($itemResult.Passed -eq $null) { $anyPassed = $null; $result.FailReason = "Ошибка проверки элемента [$i] для 'any' ($($itemResult.FailReason))"; break }
                 }
             }
             if ($anyPassed -eq $false -and $result.FailReason -eq $null) { $result.FailReason = "Условие 'any': ни один элемент в '$Path' не соответствует критериям." }
             $finalPassed = $anyPassed
        } # Конец 'any'
        'none' {
             $nonePassed = $true
             if ($filteredArray.Count -gt 0) {
                 if ($criteria -ne $null) {
                     for ($i = 0; $i -lt $filteredArray.Count; $i++) {
                         $item = $filteredArray[$i]
                         $itemResult = Test-SuccessCriteria -DetailsObject $item -CriteriaObject $criteria -Path "$Path[$i]"
                         if ($itemResult.Passed -eq $true) { $nonePassed = $false; $result.FailReason = "Условие 'none': элемент [$i] в '$Path' СООТВЕТСТВУЕТ критериям."; break }
                         elseif ($itemResult.Passed -eq $null) { $nonePassed = $null; $result.FailReason = "Ошибка проверки элемента [$i] для 'none' ($($itemResult.FailReason))"; break }
                     }
                 } else { $nonePassed = $false; $result.FailReason = "Условие 'none': найдены элементы ($($filteredArray.Count) шт.), соответствующие _where_ в '$Path'." }
             }
             $finalPassed = $nonePassed
        } # Конец 'none'
        'count' {
            $itemCount = $filteredArray.Count
            Write-Verbose "Проверка количества элементов ($itemCount) по пути '$Path'..."
            $countCheckPassed = $true
            # Итерируем по операторам в _count_ (это должна быть Hashtable)
            foreach ($operatorProperty in $countCriteria.PSObject.Properties) {
                $operator = $operatorProperty.Name
                $threshold = $operatorProperty.Value
                $comparisonResult = Compare-Values -Value $itemCount -Operator $operator -Threshold $threshold
                if ($comparisonResult.Passed -ne $true) {
                    $countCheckPassed = $comparisonResult.Passed # $false или $null
                    $result.FailReason = "Критерий количества ('count') не пройден ($($comparisonResult.Reason)) по пути '$Path'."
                    break
                }
            }
            $finalPassed = $countCheckPassed
        } # Конец 'count'
    } # Конец switch ($conditionLower)

    $result.Passed = $finalPassed
    # FailReason уже установлен внутри switch
    return $result
}
#endregion

#region Функция Test-SuccessCriteria (Приватная, v2.1.8 - Исправлен доступ к свойству)
# Рекурсивно сравнивает объект Details с объектом Criteria
# Возвращает: @{ Passed = $true/$false/$null; FailReason = "..."/$null }
#region Функция Test-SuccessCriteria (Приватная, v2.1.12 - Убрана рекурсия для не-операторов)
function Test-SuccessCriteria {
    param(
        [Parameter(Mandatory=$true)] $DetailsObject,
        [Parameter(Mandatory=$true)] $CriteriaObject,
        [string]$Path = '$Details'
    )
    # ... (Отладка входа) ...
    Write-Host "--- Test-SuccessCriteria [Вход] ---" # ...

    $overallResult = @{ Passed = $true; FailReason = $null }
    if ($null -eq $CriteriaObject.PSObject) { /* ... ошибка ... */ return $overallResult }
    # ... (проверка DetailsObject) ...

    # --- ИТЕРАЦИЯ ПО КЛЮЧАМ КРИТЕРИЯ ---
    foreach ($entry in $CriteriaObject.GetEnumerator()) {
        $key = $entry.Name
        $currentCriteriaValue = $entry.Value
        $currentPath = "$Path.$key"
        Write-Host "  [Цикл] Path='$Path', Key='$key', CriteriaValue Type='$($currentCriteriaValue.GetType().FullName)'" -ForegroundColor DarkYellow

        # ... (проверка _condition_ ...) ...
        if ($key -in @('_condition_', '_where_', '_criteria_', '_count_')) { /*...*/ continue }

        # --- Проверка наличия ключа '$key' в $DetailsObject ---
        $keyExists = $false; $currentDetailsValue = $null; $propertyAccessError = $null
        if ($null -ne $DetailsObject.PSObject) { /* ... код проверки и получения значения v2.1.8 ... */ }
        if (-not $keyExists) { /* ... обработка отсутствия ключа ... */ continue }
        elseif ($null -ne $propertyAccessError) { $overallResult.Passed = $null; $overallResult.FailReason = $propertyAccessError; break }

        # --- КЛЮЧ НАЙДЕН, ЗНАЧЕНИЕ В $currentDetailsValue ---
        $isCriteriaComplex = $currentCriteriaValue -is [hashtable] -or $currentCriteriaValue -is [System.Management.Automation.PSCustomObject]
        if ($isCriteriaComplex) {
            # --- СЛОЖНЫЙ КРИТЕРИЙ ---
            if ($currentCriteriaValue.PSObject.Properties.Name -contains '_condition_') {
                # Критерий для массива
                $arrayResult = Test-ArrayCriteria -DetailsArray $currentDetailsValue -ArrayCriteria $currentCriteriaValue -Path $currentPath
                if ($arrayResult.Passed -ne $true) { $overallResult = $arrayResult; break }
            } else {
                # --- Операторы ИЛИ НЕПОДДЕРЖИВАЕМЫЙ ВЛОЖЕННЫЙ ОБЪЕКТ ---
                $isOperatorObject = $false; $operators = @('>', '>=', '<', '<=', '==', '!=', 'contains', 'not_contains', 'matches', 'not_matches', 'exists'); $keysInCriteriaValue = @($currentCriteriaValue.PSObject.Properties.Name)
                if ($keysInCriteriaValue.Count -gt 0) { $allKeysAreOperators = $true; foreach($ckey in $keysInCriteriaValue){ if($operators -notcontains $ckey.ToLower()){ $allKeysAreOperators = $false; break } }; if($allKeysAreOperators){ $isOperatorObject = $true } }

                if ($isOperatorObject) {
                    # --- ОБРАБОТКА ОПЕРАТОРОВ (код без изменений) ---
                    Write-Verbose "Сравнение операторами для '$currentPath'"
                    foreach ($operatorProperty in $currentCriteriaValue.PSObject.Properties) {
                        $operator = $operatorProperty.Name; $threshold = $operatorProperty.Value
                        Write-Host "      [Оператор] Compare-Values: Value='$currentDetailsValue', Operator='$operator', Threshold='$threshold'" -ForegroundColor DarkMagenta
                        $comparisonResult = Compare-Values -Value $currentDetailsValue -Operator $operator -Threshold $threshold
                        if ($comparisonResult.Passed -ne $true) { $overallResult.Passed = $comparisonResult.Passed; $overallResult.FailReason = "Критерий '$key' не пройден ($($comparisonResult.Reason)) по пути '$Path'."; break }
                    }
                    if ($overallResult.Passed -ne $true) { break }
                } else {
                    # --- НЕПОДДЕРЖИВАЕМЫЙ ВЛОЖЕННЫЙ КРИТЕРИЙ ---
                    # <<< ИЗМЕНЕНО: Вместо рекурсии - ошибка >>>
                    $overallResult.Passed = $null # Ошибка формата критерия
                    $overallResult.FailReason = "Ошибка критерия по пути '$currentPath'. Вложенные объекты без операторов сравнения не поддерживаются (кроме критериев для массивов с _condition_)."
                    Write-Warning $overallResult.FailReason
                    break # Прерываем проверку
                }
            }
        } else {
            # --- Простое сравнение (код без изменений) ---
            Write-Verbose "Простое сравнение для '$currentPath'"
            Write-Host "      [Простое] Compare-Values: Value='$currentDetailsValue', Operator='==', Threshold='$currentCriteriaValue'" -ForegroundColor DarkMagenta
            $comparisonResult = Compare-Values -Value $currentDetailsValue -Operator '==' -Threshold $currentCriteriaValue
            if ($comparisonResult.Passed -ne $true) {
                $overallResult.Passed = $comparisonResult.Passed
                $overallResult.FailReason = "Критерий '$key' не пройден ($($comparisonResult.Reason)) по пути '$Path'."
                break
            }
        }
    } # Конец foreach

    Write-Host "--- Test-SuccessCriteria [Выход] --- Path: $Path, Passed: $($overallResult.Passed), Reason: $($overallResult.FailReason)" -ForegroundColor Yellow
    return $overallResult
}
#endregion

#--------------------------------------------------------------------------
# Экспортируемые функции
#--------------------------------------------------------------------------

#region Функция New-CheckResultObject (Экспортируемая, v1.3)
<#
.SYNOPSIS
    Создает стандартизированный объект результата проверки (хэш-таблицу).
# ... (описание New-CheckResultObject без изменений) ...
#>
function New-CheckResultObject {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)] [bool]$IsAvailable,
        [Parameter(Mandatory = $false)] [nullable[bool]]$CheckSuccess = $null,
        [Parameter(Mandatory = $false)] $Details = $null,
        [Parameter(Mandatory = $false)] [string]$ErrorMessage = $null
    )
    $processedDetails = $null
    if ($null -ne $Details) {
        if ($Details -is [hashtable]) { $processedDetails = $Details }
        elseif ($Details.PSObject -ne $null) { try { $processedDetails = [hashtable]$Details } catch { $processedDetails = @{ OriginalDetails = $Details } } }
        else { $processedDetails = @{ Value = $Details } }
    }
    $result = [ordered]@{
        IsAvailable = $IsAvailable; CheckSuccess = $CheckSuccess; Timestamp = (Get-Date).ToUniversalTime().ToString("o"); Details = $processedDetails; ErrorMessage = $ErrorMessage
    }
    if ($result.IsAvailable) { if ($result.CheckSuccess -eq $null) { $result.CheckSuccess = $true } }
    else { $result.CheckSuccess = $null }
    if ([string]::IsNullOrEmpty($result.ErrorMessage)) { if (-not $result.IsAvailable) { $result.ErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)." } }
    Write-Verbose ("New-CheckResultObject (v1.3): Создан результат: IsAvailable=$($result.IsAvailable), CheckSuccess=$($result.CheckSuccess), Error='$($result.ErrorMessage)'")
    return $result
}
#endregion

#region Функция Invoke-StatusMonitorCheck (Экспортируемая, v1.2.1 - Улучшена обработка parameters/success_criteria)
<#
.SYNOPSIS
    Выполняет проверку мониторинга согласно заданию.
# ... (описание Invoke-StatusMonitorCheck без изменений) ...
#>
function Invoke-StatusMonitorCheck {
    [CmdletBinding(SupportsShouldProcess = $false)]
    param(
        [Parameter(Mandatory = $true)]
        [PSObject]$Assignment
    )

    # --- 1. Валидация входного объекта ---
    if ($null -eq $Assignment.PSObject -or -not ($Assignment.PSObject.Properties.Name -contains 'assignment_id') -or -not ($Assignment.PSObject.Properties.Name -contains 'method_name')) {
        Write-Warning "Invoke-StatusMonitorCheck: Передан некорректный объект задания."; return New-CheckResultObject -IsAvailable $false -ErrorMessage "Некорректный объект задания."
    }

    # --- 2. Извлечение данных ---
    $assignmentId = $Assignment.assignment_id; $methodName = $Assignment.method_name; $targetIP = $null; $nodeName = "Задание ID $assignmentId"
    if ($Assignment.PSObject.Properties.Name -contains 'ip_address') { $targetIP = $Assignment.ip_address }
    if (($Assignment.PSObject.Properties.Name -contains 'node_name') -and $Assignment.node_name) { $nodeName = $Assignment.node_name }
    # Получаем parameters и success_criteria, преобразуя в Hashtable
    $parameters = @{}; $successCriteria = $null
    if (($Assignment.PSObject.Properties.Name -contains 'parameters') -and $Assignment.parameters) { if ($Assignment.parameters.PSObject -ne $null) { try { $parameters = [hashtable]$Assignment.parameters } catch { Write-Warning "[$($assignmentId) | $nodeName] Не удалось преобразовать 'parameters' в Hashtable. Используется пустой объект." } } else { Write-Warning "[$($assignmentId) | $nodeName] Поле 'parameters' не является объектом. Используется пустой объект."} }
    if (($Assignment.PSObject.Properties.Name -contains 'success_criteria') -and $Assignment.success_criteria) { if ($Assignment.success_criteria.PSObject -ne $null) { try { $successCriteria = [hashtable]$Assignment.success_criteria } catch { Write-Warning "[$($assignmentId) | $nodeName] Не удалось преобразовать 'success_criteria' в Hashtable. Критерии не будут применены." } } else { Write-Warning "[$($assignmentId) | $nodeName] Поле 'success_criteria' не является объектом. Критерии не будут применены." } }
    $targetLogString = if ($targetIP) { $targetIP } else { '[Local]' }; Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Запуск '$methodName' (Target: $targetLogString)"

    # --- 3. Поиск и выполнение скрипта ---
    $result = $null
    try {
        $ModuleBase = $MyInvocation.MyCommand.Module.ModuleBase; if (-not $ModuleBase) { if ($PSScriptRoot) { $ModuleBase = $PSScriptRoot } else { throw "Не удалось определить путь модуля." } }
        $ChecksFolder = Join-Path -Path $ModuleBase -ChildPath "Checks"; $CheckScriptFile = "Check-$($methodName).ps1"; $CheckScriptPath = Join-Path -Path $ChecksFolder -ChildPath $CheckScriptFile
        Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Поиск скрипта: $CheckScriptPath"
        if (-not (Test-Path $CheckScriptPath -PathType Leaf)) { $errorMessage = "Скрипт '$CheckScriptFile' не найден."; Write-Warning "[$($assignmentId) | $nodeName] $errorMessage"; return New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details @{ CheckedScriptPath = $CheckScriptPath } }

        $checkParams = [hashtable]@{ TargetIP = $targetIP; Parameters = $parameters; SuccessCriteria = $successCriteria; NodeName = $nodeName }
        Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Запуск '$CheckScriptFile'..."
        try { $result = & $checkScriptPath @checkParams } catch { throw } # Переброс ошибки из скрипта

        # --- 4. Анализ результата ---
        $resultIsValid = $false; if ($null -ne $result) { try { $null = $result.IsAvailable; $resultIsValid = $true } catch { } }
        if (-not $resultIsValid) {
            $errorMessage = "Скрипт '$CheckScriptFile' вернул некорректный результат."; $resultType = if ($null -eq $result) { '$null' } else { $result.GetType().FullName }; Write-Warning "... $resultType ..."; $result = New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details @{ ScriptOutput = ($result | Out-String -Width 200) }
        } else {
            Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Скрипт '$CheckScriptFile' вернул результат."
            if ($result.PSObject.Properties.Name -contains 'Details') { if ($result.Details.PSObject -ne $null -and $result.Details -isnot [hashtable]) { try { $result.Details = [hashtable]$result.Details } catch { $result.Details = @{ OriginalDetails = $result.Details } } } } else { $result.Details = @{} }
            $result.Details.execution_target = $env:COMPUTERNAME; $result.Details.execution_mode = 'local_agent'; $result.Details.check_target_ip = $targetIP
        }
    } catch {
        # --- 5. Обработка КРИТИЧЕСКИХ ОШИБОК диспетчера ---
        $errorMessage = "Критическая ошибка '$methodName' для '$nodeName': $($_.Exception.Message)"; Write-Warning "[$($assignmentId) | $nodeName] $errorMessage"; $result = New-CheckResultObject -IsAvailable $false -ErrorMessage $errorMessage -Details @{ ErrorRecord = $_.ToString() }
    }

    # --- 6. Возвращаем результат ---
    $isAvailableStr = if ($result -and $result.PSObject.Properties.Name -contains 'IsAvailable') { $result.IsAvailable } else { '[N/A]' }
    $checkSuccessStr = if ($result -and $result.PSObject.Properties.Name -contains 'CheckSuccess') { $result.CheckSuccess } else { '[N/A]' }
    Write-Verbose "[$($assignmentId) | $nodeName] Invoke-StatusMonitorCheck: Завершение. IsAvailable: $isAvailableStr, CheckSuccess: $checkSuccessStr"
    return $result
}
#endregion


# --- Экспорт функций ---
Export-ModuleMember -Function Invoke-StatusMonitorCheck, New-CheckResultObject, Test-SuccessCriteria, Compare-Values
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\StatusMonitorAgentUtils.psm1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Найти все SSL-сертификаты сервера в LocalMachine\My и проверить, что осталось > 14 дней
$certAssignment1 = @{
    assignment_id = 501; method_name = 'CERT_EXPIRY'; node_name = 'Local SSL Certs (>14d)'
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        eku_oid = @('1.3.6.1.5.5.7.3.1') # Server Authentication OID
        require_private_key = $true
        min_days_warning = 30 # Предупреждать за 30 дней
    }
    success_criteria = @{
        min_days_left = 14 # Должно оставаться > 14 дней
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment1) | ConvertTo-Json -Depth 4

# 2. Найти конкретный сертификат по отпечатку и проверить, что осталось > 60 дней
# ЗАМЕНИ 'YOUR_CERT_THUMBPRINT_HERE' на реальный отпечаток существующего сертификата
$thumbprintToTest = 'YOUR_CERT_THUMBPRINT_HERE'
$certAssignment2 = @{
    assignment_id = 502; method_name = 'CERT_EXPIRY'; node_name = "Cert by Thumbprint ($($thumbprintToTest.Substring(0,8))... >60d)"
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        thumbprint = $thumbprintToTest
    }
    success_criteria = @{
        min_days_left = 60
    }
}
if ($thumbprintToTest -ne 'YOUR_CERT_THUMBPRINT_HERE') {
    Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment2) | ConvertTo-Json -Depth 4
} else { Write-Warning "Тест 2 пропущен: Замените YOUR_CERT_THUMBPRINT_HERE на реальный отпечаток." }


# 3. Найти сертификаты, выданные определенным CA (например, внутренним)
$issuerPattern = "*MyInternalCA*" # Замените на часть имени вашего CA
$certAssignment3 = @{
    assignment_id = 503; method_name = 'CERT_EXPIRY'; node_name = "Certs from $issuerPattern (>3d)"
    ip_address = $null
    parameters = @{
        store_location = 'LocalMachine'
        store_name = 'My'
        issuer_like = $issuerPattern
    }
    success_criteria = @{
        min_days_left = 3
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment3) | ConvertTo-Json -Depth 4

# 4. Тест с ошибкой: Неверное хранилище
$certAssignment4 = @{
    assignment_id = 504; method_name = 'CERT_EXPIRY'; node_name = 'Invalid Store'
    ip_address = $null
    parameters = @{ store_location = 'InvalidPlace'; store_name = 'My' }
    success_criteria = @{ min_days_left = 1 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment4) | ConvertTo-Json -Depth 4

# 5. Тест с ошибкой: Отсутствует обязательный критерий
$certAssignment5 = @{
    assignment_id = 505; method_name = 'CERT_EXPIRY'; node_name = 'Missing Criteria'
    ip_address = $null
    parameters = @{ thumbprint = $thumbprintToTest }
    success_criteria = @{ } # Пустой критерий
}
if ($thumbprintToTest -ne 'YOUR_CERT_THUMBPRINT_HERE') {
    Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$certAssignment5) | ConvertTo-Json -Depth 4
} else { Write-Warning "Тест 5 пропущен: Замените YOUR_CERT_THUMBPRINT_HERE." }
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 ====
# Убедись, что модуль загружен
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Проверка всех локальных дисков без критериев
$diskAssignment1 = @{ assignment_id = 301; method_name = 'DISK_USAGE'; node_name = 'Local Disk Usage'; ip_address = $null; parameters = $null; success_criteria = $null }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment1) | ConvertTo-Json -Depth 5

# 2. Проверка только диска C: без критериев
$diskAssignment2 = @{ assignment_id = 302; method_name = 'DISK_USAGE'; node_name = 'Local Disk C Usage'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = $null }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment2) | ConvertTo-Json -Depth 5

# 3. Проверка диска C: с критерием > 5% свободно (скорее всего, пройдет)
$diskAssignment3 = @{ assignment_id = 303; method_name = 'DISK_USAGE'; node_name = 'Local Disk C OK'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 5 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment3) | ConvertTo-Json -Depth 5

# 4. Проверка диска C: с заведомо невыполнимым критерием (> 99% свободно)
$diskAssignment4 = @{ assignment_id = 304; method_name = 'DISK_USAGE'; node_name = 'Local Disk C Fail'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 99 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment4) | ConvertTo-Json -Depth 5

# 5. Проверка всех дисков с дефолтным критерием > 1%
$diskAssignment5 = @{ assignment_id = 305; method_name = 'DISK_USAGE'; node_name = 'Local All Disks Default OK'; ip_address = $null; parameters = $null; success_criteria = @{ _default_ = @{ min_percent_free = 1 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment5) | ConvertTo-Json -Depth 5

# 6. Проверка всех дисков, где для C: >99%, для остальных >1% (C: провалится)
$diskAssignment6 = @{ assignment_id = 306; method_name = 'DISK_USAGE'; node_name = 'Local All Disks C Fail Rest OK'; ip_address = $null; parameters = $null; success_criteria = @{ C = @{ min_percent_free = 99 }; _default_ = @{ min_percent_free = 1 } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment6) | ConvertTo-Json -Depth 5

# 7. Тест с некорректным критерием
$diskAssignment7 = @{ assignment_id = 307; method_name = 'DISK_USAGE'; node_name = 'Invalid Criteria'; ip_address = $null; parameters = @{ drives = @('C') }; success_criteria = @{ C = @{ min_percent_free = 'десять' } } }
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$diskAssignment7) | ConvertTo-Json -Depth 5
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 ====
# Убедись, что модуль загружен
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Пинг существующего локального адреса (успех)
$pingAssignment1 = @{
    assignment_id = 201; method_name = 'PING'; node_name = 'Localhost Ping'
    ip_address = '127.0.0.1'; parameters = @{ count = 2 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment1) | ConvertTo-Json -Depth 3

# 2. Пинг несуществующего адреса (ошибка доступности)
$pingAssignment2 = @{
    assignment_id = 202; method_name = 'PING'; node_name = 'Non-existent Ping'
    ip_address = '192.168.254.254'; parameters = @{ timeout_ms = 500 }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment2) | ConvertTo-Json -Depth 3

# 3. Пинг существующего адреса с критерием RTT (успех по критерию)
$pingAssignment3 = @{
    assignment_id = 203; method_name = 'PING'; node_name = 'Gateway Ping OK'
    ip_address = 'ya.ru'; parameters = @{ count = 1 } # Укажи IP своего шлюза
    success_criteria = @{ max_rtt_ms = 500 } # Критерий RTT < 500ms
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment3) | ConvertTo-Json -Depth 3

# 4. Пинг существующего адреса с критерием RTT (неуспех по критерию)
$pingAssignment4 = @{
    assignment_id = 204; method_name = 'PING'; node_name = 'Gateway Ping Fail RTT'
    ip_address = 'ya.ru'; parameters = @{ count = 1 }
    success_criteria = @{ max_rtt_ms = 1 } # Заведомо невыполнимый критерий
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$pingAssignment4) | ConvertTo-Json -Depth 3
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# 1. Все процессы, сортировка по памяти (убывание), топ 5
$procAssignment1 = @{
    assignment_id = 401; method_name = 'PROCESS_LIST'; node_name = 'Local Top 5 Mem Proc'
    ip_address = $null
    parameters = @{ sort_by = 'Memory'; sort_descending = $true; top_n = 5; include_username=$false; include_path=$false }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment1) | ConvertTo-Json -Depth 4

# 2. Процессы PowerShell с путем и пользователем
$procAssignment2 = @{
    assignment_id = 402; method_name = 'PROCESS_LIST'; node_name = 'Local PS Proc Details'
    ip_address = $null
    parameters = @{ process_names = @('*powershell*'); include_username = $true; include_path = $true }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment2) | ConvertTo-Json -Depth 4

# 3. Несуществующий процесс (должен вернуть IsAvailable=true, CheckSuccess=true, пустой список)
$procAssignment3 = @{
    assignment_id = 403; method_name = 'PROCESS_LIST'; node_name = 'Local NonExistent Proc'
    ip_address = $null
    parameters = @{ process_names = @('__NonExistentProcess__') }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment3) | ConvertTo-Json -Depth 4

# 4. Тест с некорректным полем сортировки
$procAssignment4 = @{
    assignment_id = 404; method_name = 'PROCESS_LIST'; node_name = 'Invalid Sort'
    ip_address = $null
    parameters = @{ sort_by = 'InvalidField' }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment4) | ConvertTo-Json -Depth 4

# 5. Удаленный тест (ожидаем ошибку WinRM -> IsAvailable=false)
$procAssignment5 = @{
    assignment_id = 405; method_name = 'PROCESS_LIST'; node_name = 'Remote Proc Fail'
    ip_address = 'REMOTE_HOST_NAME_NO_WINRM' # Замените на имя хоста без доступа по WinRM
    parameters = @{ top_n = 5 }
}
# Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$procAssignment5) | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 ====
Remove-Module StatusMonitorAgentUtils -Force -ErrorAction SilentlyContinue
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -Verbose

$testAssignment = [PSCustomObject]@{
    assignment_id = 123; method_name = 'SERVICE_STATUS'; ip_address = $null
    node_name = 'Локальный Тест'; parameters = @{ service_name = 'Spooler' }
    success_criteria = @{ status = 'Running' }
}
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4

$testAssignment.parameters.service_name = 'NonExistentService'
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4

$testAssignment.parameters.service_name = 'Spooler'
$testAssignment.success_criteria = @{ status = 'Stopped' }
Invoke-StatusMonitorCheck -Assignment $testAssignment | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# Замени на свои значения
$server = "YOUR_SERVER\YOUR_INSTANCE"
$db = "YourDatabaseName"
$tableName = "YourTableName" # Таблица с какими-нибудь данными

# 1. Получить первую строку
$sqlAssignment1 = @{
    assignment_id = 701; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL First Row Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT TOP 1 * FROM $tableName"
        return_format = 'first_row'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment1) | ConvertTo-Json -Depth 4

# 2. Получить все строки (ОСТОРОЖНО, если строк много!)
$sqlAssignment2 = @{
    assignment_id = 702; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL All Rows Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT Id, Name FROM $tableName WHERE Id < 10" # Пример с WHERE
        return_format = 'all_rows'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment2) | ConvertTo-Json -Depth 4

# 3. Получить количество строк
$sqlAssignment3 = @{
    assignment_id = 703; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Row Count Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT Id FROM $tableName" # Достаточно одного столбца для подсчета
        return_format = 'row_count'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment3) | ConvertTo-Json -Depth 4

# 4. Получить скалярное значение (имя первой записи)
$sqlAssignment4 = @{
    assignment_id = 704; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Scalar Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "SELECT TOP 1 Name FROM $tableName ORDER BY Id"
        return_format = 'scalar'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment4) | ConvertTo-Json -Depth 4

# 5. Выполнить Non-Query (например, создать временную таблицу) - ОСТОРОЖНО!
$sqlAssignment5 = @{
    assignment_id = 705; method_name = 'SQL_QUERY_EXECUTE'; node_name = "SQL Non-Query Test"
    ip_address = $server
    parameters = @{
        sql_database = $db
        sql_query = "IF OBJECT_ID('tempdb..#TestTempTable') IS NULL CREATE TABLE #TestTempTable (Id INT);" # Пример безопасного non-query
        return_format = 'non_query'
    }
}
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment5) | ConvertTo-Json -Depth 4

# 6. Ошибка - неверная БД
$sqlAssignment6 = $sqlAssignment1.PSObject.Copy()
$sqlAssignment6.assignment_id = 706
$sqlAssignment6.node_name = "SQL Error - Bad DB"
$sqlAssignment6.parameters.sql_database = "NonExistentDatabase"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment6) | ConvertTo-Json -Depth 4
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_QUERY_EXECUTE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 ====
Import-Module .\StatusMonitorAgentUtils.psd1 -Force -ErrorAction Stop

# Замени на свои значения
$server = "YOUR_SERVER\YOUR_INSTANCE" # Или просто "YOUR_SERVER"
$db = "YourDatabaseName"
$query = "SELECT TOP 1 CreationDate, Revise, id, UTCTime FROM YourTable WHERE id = 12345" # Пример запроса
$xmlCol = "Revise"
$keys = @("VersionStat", "ArrivalStationID", "TS_Version", "NonExistentKey")

$sqlAssignment = @{
    assignment_id = 601
    method_name   = 'SQL_XML_QUERY'
    node_name     = "SQL Query Test ($db)"
    ip_address    = $server # Передаем сервер как TargetIP
    parameters    = @{
        sql_database = $db
        sql_query = $query
        xml_column_name = $xmlCol
        keys_to_extract = $keys
        # sql_username = "your_sql_user" # Раскомментируй для SQL Auth
        # sql_password = "your_sql_password" # Раскомментируй для SQL Auth
    }
    success_criteria = $null # Пока не используем
}

Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignment) | ConvertTo-Json -Depth 5

# --- Тест с ошибкой (неверное имя столбца) ---
$sqlAssignmentError = $sqlAssignment.PSObject.Copy()
$sqlAssignmentError.parameters.xml_column_name = 'InvalidColumnName'
$sqlAssignmentError.assignment_id = 602
$sqlAssignmentError.node_name = "SQL Error Test (Bad Column)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignmentError) | ConvertTo-Json -Depth 5

# --- Тест с ошибкой (неверный SQL) ---
$sqlAssignmentError2 = $sqlAssignment.PSObject.Copy()
$sqlAssignmentError2.parameters.sql_query = 'SELECT * FRO Arom InvalidTable'
$sqlAssignmentError2.assignment_id = 603
$sqlAssignmentError2.node_name = "SQL Error Test (Bad Query)"
Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$sqlAssignmentError2) | ConvertTo-Json -Depth 5
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\TEST_SQL_XML_QUERY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1
# --- Версия 2.0.2 ---
# Изменения:
# - Исправлены синтаксические ошибки (закрывающие скобки, оператор ?.)
# - Добавлены комментарии и улучшено форматирование.
# - Логика проверки SuccessCriteria вынесена в универсальную функцию Test-SuccessCriteria.
# - Стандартизирован формат $Details.
# - Убран прямой расчет CheckSuccess на основе min_days_left.
# - Добавлен вызов Test-SuccessCriteria.

<#
.SYNOPSIS
    Скрипт проверки сроков действия локально установленных сертификатов. (v2.0.2)
.DESCRIPTION
    Использует Get-ChildItem для поиска сертификатов в стандартных хранилищах.
    Позволяет фильтровать сертификаты по различным критериям.
    Формирует стандартизированный объект $Details со списком найденных сертификатов
    и их статусами (OK, Expired, Expiring (Warn)).
    Для определения итогового CheckSuccess использует универсальную функцию
    Test-SuccessCriteria, сравнивающую $Details с переданным $SuccessCriteria.
    Ожидаемый формат SuccessCriteria для проверки срока:
    @{ certificates = @{ _condition_ = 'all'; days_left = @{ '>' = <кол-во дней> } } }
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста. Используется для логирования,
             скрипт выполняется локально.
.PARAMETER Parameters
    [hashtable] Параметры фильтрации сертификатов:
    - subject_like (string): Фильтр по имени субъекта (с wildcard *?).
    - issuer_like (string): Фильтр по имени издателя (с wildcard *?).
    - thumbprint (string): Точный отпечаток (игнорирует subject/issuer).
    - require_private_key (bool): Искать только с закрытым ключом (default: $false).
    - eku_oid (string[]): Массив OID'ов EKU (хотя бы один должен совпасть).
    - min_days_warning (int): Порог дней для статуса "Warning" в Details (default: 30).
                              Не влияет на итоговый CheckSuccess.
.PARAMETER SuccessCriteria
    [hashtable] Критерии успеха. Для проверки срока действия ожидается структура,
                работающая с массивом 'certificates' в $Details. Например:
                @{ certificates = @{ _condition_ = 'all'; days_left = @{ '>' = 14 } } }
                (где '>' - оператор сравнения, 14 - пороговое значение).
                Обработка этого формата выполняется функцией Test-SuccessCriteria.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
                Поле Details (hashtable) содержит:
                - certificates (List<object>): Массив данных о найденных и отфильтрованных сертификатах.
                - stores_checked (string[]): Список проверенных хранилищ.
                - message (string): Опциональное сообщение (напр., если сертификаты не найдены).
                - access_errors (string[]): Опционально, список ошибок доступа к хранилищам.
                - error (string): Опциональное сообщение об ошибке выполнения скрипта.
                - ErrorRecord (string): Опционально, полный текст исключения.
.NOTES
    Версия: 2.0.2
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria из StatusMonitorAgentUtils.psm1.
    Требует прав доступа к хранилищам сертификатов.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,

    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},

    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,

    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация переменных для результата ---
$isAvailable = $false          # Смогли ли мы вообще выполнить проверку?
$checkSuccess = $null         # Прошли ли критерии? (null до проверки)
$errorMessage = $null         # Сообщение для ErrorMessage в итоговом объекте
$finalResult = $null          # Итоговый объект, возвращаемый скриптом
$details = @{                 # Стандартная структура Details
    certificates   = [System.Collections.Generic.List[object]]::new() # Список найденных серт-ов
    stores_checked = @()        # Какие хранилища проверяли
    # Дополнительные поля будут добавлены по ходу дела (message, access_errors, error)
}

Write-Verbose "[$NodeName] Check-CERT_EXPIRY (v2.0.2): Начало проверки сертификатов на $TargetIP (локально на $env:COMPUTERNAME)"

# --- Основной блок Try/Catch для перехвата критических ошибок ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY БЛОКА >>>

    # --- 1. Валидация и извлечение параметров фильтрации из $Parameters ---
    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Обработка параметров фильтрации..."
    $SubjectLike = $Parameters.subject_like # Может быть $null
    $IssuerLike = $Parameters.issuer_like   # Может быть $null
    $Thumbprint = $Parameters.thumbprint   # Может быть $null
    $EkuOids = $Parameters.eku_oid       # Может быть $null или массив строк

    # Получаем флаг require_private_key с обработкой ошибок
    $RequirePrivateKey = $false # Значение по умолчанию
    if ($Parameters.ContainsKey('require_private_key')) {
        try {
            $RequirePrivateKey = [bool]$Parameters.require_private_key # Пытаемся преобразовать к булеву значению
        } catch {
            Write-Warning "[$NodeName] Check-CERT_EXPIRY: Некорректное значение 'require_private_key' ('$($Parameters.require_private_key)'), используется значение по умолчанию `$false."
        }
    }
    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: RequirePrivateKey = $RequirePrivateKey"

    # Получаем порог дней для статуса "Warning" в $Details
    $minDaysWarning = 30 # Значение по умолчанию
    if ($Parameters.ContainsKey('min_days_warning') -and $Parameters.min_days_warning -ne $null) {
        $parsedWarningDays = 0
        if ([int]::TryParse($Parameters.min_days_warning, [ref]$parsedWarningDays) -and $parsedWarningDays -ge 0) {
            $minDaysWarning = $parsedWarningDays # Используем значение из параметра
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Используется min_days_warning: $minDaysWarning дней."
        } else {
            Write-Warning "[$NodeName] Check-CERT_EXPIRY: Некорректное или отрицательное значение 'min_days_warning' ('$($Parameters.min_days_warning)'), используется значение по умолчанию $minDaysWarning дней."
        }
    } else {
        Write-Verbose "[$NodeName] Check-CERT_EXPIRY: min_days_warning не задан, используется значение по умолчанию: $minDaysWarning дней."
    }

    # --- 2. Поиск сертификатов в стандартных хранилищах ---
    $storesToSearch = @(
        @{ Path = "Cert:\LocalMachine\My"; Location = "LocalMachine"; Name = "My" }
        @{ Path = "Cert:\LocalMachine\WebHosting"; Location = "LocalMachine"; Name = "WebHosting" }
        @{ Path = "Cert:\CurrentUser\My"; Location = "CurrentUser"; Name = "My" }
    )
    $allFoundCertificates = [System.Collections.Generic.List[object]]::new() # Общий список найденных
    $storeAccessErrors = [System.Collections.Generic.List[string]]::new()    # Список ошибок доступа

    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Поиск сертификатов в хранилищах: $($storesToSearch.Path -join ', ')"
    # Цикл по хранилищам
    foreach ($storeInfo in $storesToSearch) {
        $certStorePath = $storeInfo.Path
        $details.stores_checked.Add($certStorePath) # Запоминаем, что пытались проверить
        Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Проверка хранилища: $certStorePath"
        # Внутренний try/catch для доступа к КОНКРЕТНОМУ хранилищу
        try {
            # Получаем сертификаты, подавляя ошибку "не найдено"
            $certsInStore = Get-ChildItem -Path $certStorePath -ErrorAction SilentlyContinue
            if ($certsInStore) {
                $allFoundCertificates.AddRange($certsInStore) # Добавляем найденные в общий список
                Write-Verbose "[$NodeName] Check-CERT_EXPIRY: В '$($certStorePath)' найдено: $($certsInStore.Count) серт."
            } else {
                 Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Хранилище '$($certStorePath)' пусто или не найдено."
            }
            # Проверяем, была ли ошибка доступа (например, отказано в доступе к LocalMachine)
            if ($Error.Count -gt 0 -and $Error[0].FullyQualifiedErrorId -match 'StoreCouldNotBeOpened|GetCertificateStore') {
                 $errMsg = "Ошибка доступа к хранилищу '$($certStorePath)': $($Error[0].Exception.Message)"
                 $storeAccessErrors.Add($errMsg)
                 Write-Warning "[$NodeName] Check-CERT_EXPIRY: $errMsg"
                 $Error.Clear() # Очищаем ошибку, чтобы не влиять на следующие итерации
            }
        } catch { # Ловим другие непредвиденные ошибки при доступе к хранилищу
             $errMsg = "Критическая ошибка доступа к хранилищу '$($certStorePath)': $($_.Exception.Message)"
             $storeAccessErrors.Add($errMsg)
             Write-Warning "[$NodeName] Check-CERT_EXPIRY: $errMsg"
        } # <<< Закрывает внутренний catch >>>
    } # <<< Закрывает foreach ($storeInfo in $storesToSearch) >>>

    # Устанавливаем IsAvailable = $true, если удалось проверить ХОТЯ БЫ одно хранилище
    if ($details.stores_checked.Count -gt 0) {
        $isAvailable = $true
        # Если были ошибки доступа, добавляем их в Details
        if ($storeAccessErrors.Count -gt 0) {
            $details.access_errors = $storeAccessErrors
        }
    } else {
        # Если не удалось проверить НИ ОДНО хранилище, проверка не удалась
        $isAvailable = $false
        $errorMessage = "Не удалось получить доступ ни к одному из проверяемых хранилищ сертификатов."
        # Выбрасываем исключение, т.к. дальнейшая работа бессмысленна
        throw $errorMessage
    }
    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: IsAvailable=$isAvailable. Всего найдено сертификатов до фильтрации: $($allFoundCertificates.Count)."

    # --- 3. Фильтрация найденных сертификатов по заданным параметрам ---
    $filteredCertificates = $allFoundCertificates # Начинаем со всех найденных
    $filterApplied = $false # Флаг, что хотя бы один фильтр применен

    # Приоритет у фильтра по отпечатку
    if (-not [string]::IsNullOrWhiteSpace($Thumbprint)) {
        $filterApplied = $true
        $Thumbprint = $Thumbprint.Trim().ToUpper() # Нормализуем отпечаток
        Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Применяем фильтр по Thumbprint: '$Thumbprint'"
        $filteredCertificates = $filteredCertificates | Where-Object { $_.Thumbprint -eq $Thumbprint }
    } else {
        # Если отпечаток не задан, применяем фильтры по Subject и Issuer
        if (-not [string]::IsNullOrWhiteSpace($SubjectLike)) {
            $filterApplied = $true
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Применяем фильтр по Subject like: '$SubjectLike'"
            $filteredCertificates = $filteredCertificates | Where-Object { $_.Subject -like $SubjectLike }
        }
        if (-not [string]::IsNullOrWhiteSpace($IssuerLike)) {
            $filterApplied = $true
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Применяем фильтр по Issuer like: '$IssuerLike'"
            $filteredCertificates = $filteredCertificates | Where-Object { $_.Issuer -like $IssuerLike }
        }
    }

    # Фильтр по наличию закрытого ключа
    if ($RequirePrivateKey) {
        $filterApplied = $true
        Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Применяем фильтр 'require_private_key = $true'"
        $filteredCertificates = $filteredCertificates | Where-Object { $_.HasPrivateKey }
    }

    # Фильтр по EKU (Extended Key Usage)
    if ($EkuOids -is [array] -and $EkuOids.Count -gt 0) {
        $filterApplied = $true
        Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Применяем фильтр по EKU OIDs: $($EkuOids -join ', ')"
        # Отбираем сертификаты, у которых в EKU есть ХОТЯ БЫ ОДИН из указанных OID
        $filteredCertificates = $filteredCertificates | Where-Object {
            $cert = $_
            # Получаем расширение EKU
            $ekuExtension = $cert.Extensions | Where-Object { $_.Oid.FriendlyName -eq 'Enhanced Key Usage' } | Select-Object -First 1
            # Получаем список OID'ов из этого расширения
            $certEkus = $ekuExtension.EnhancedKeyUsages
            if ($certEkus) {
                # Проверяем пересечение массивов OID'ов
                ($EkuOids | Where-Object { $certEkus.Oid -contains $_ }).Count -gt 0
            } else { $false } # Нет EKU - не соответствует фильтру
        }
    }

    # Выводим предупреждение, если фильтры не применялись
    if (-not $filterApplied) {
         Write-Warning "[$NodeName] Check-CERT_EXPIRY: Критерии фильтрации не заданы. Будут обработаны ВСЕ сертификаты из проверенных хранилищ."
    }
    Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Количество сертификатов после фильтрации: $($filteredCertificates.Count)."

    # --- 4. Формирование массива сертификатов для поля $Details ---
    $currentTime = Get-Date # Фиксируем текущее время для консистентного расчета дней

    if ($filteredCertificates.Count -eq 0) {
        # Если после фильтрации сертификатов не осталось
        $details.message = "Сертификаты" + ($filterApplied ? ", соответствующие фильтрам," : "") + " не найдены."
        Write-Verbose "[$NodeName] Check-CERT_EXPIRY: $($details.message)"
    } else {
        # Обрабатываем каждый отфильтрованный сертификат
        foreach ($cert in $filteredCertificates) {
            # Рассчитываем оставшееся время и дни
            $timeRemaining = New-TimeSpan -Start $currentTime -End $cert.NotAfter
            $daysLeft = [math]::Floor($timeRemaining.TotalDays) # Целое количество дней (вниз)

            # Формируем объект с информацией о сертификате для $Details
            $certInfo = [ordered]@{
                thumbprint      = $cert.Thumbprint
                subject         = $cert.Subject
                issuer          = $cert.Issuer
                not_before      = $cert.NotBefore.ToUniversalTime().ToString("o") # ISO 8601 UTC
                not_after       = $cert.NotAfter.ToUniversalTime().ToString("o")  # ISO 8601 UTC
                days_left       = $daysLeft         # Это поле будет проверяться Test-SuccessCriteria
                has_private_key = $cert.HasPrivateKey
                status          = "OK"              # Статус для отображения
                status_details  = ""                # Пояснение к статусу
                store_path      = $cert.PSParentPath # Путь к хранилищу
            }

            # --- Определяем статус для отображения (OK/Expired/Warn/Error) ---
            # Этот статус не влияет на CheckSuccess, он только для информации в $Details
            if ($currentTime -gt $cert.NotAfter) {
                $certInfo.status = "Expired"
                $certInfo.status_details = "Истек {0:dd.MM.yyyy HH:mm}" -f $cert.NotAfter.ToLocalTime()
            } elseif ($daysLeft -lt 0) {
                # Эта ситуация маловероятна, если $currentTime > $cert.NotAfter обработан
                $certInfo.status = "Error"
                $certInfo.status_details = "Ошибка расчета оставшегося срока (daysLeft < 0)."
            } elseif ($daysLeft -le $minDaysWarning) {
                 # Если дней осталось <= порога предупреждения
                 $certInfo.status = "Expiring (Warn)"
                 $certInfo.status_details = "Истекает через {0} дней (Предупреждение: <= {1})" -f $daysLeft, $minDaysWarning
                 Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Сертификат $($cert.Thumbprint.Substring(0,8))... истекает скоро ($daysLeft дней)."
            }
            # Иначе статус остается "OK"

            # Добавляем информацию о сертификате в $Details.certificates
            $details.certificates.Add($certInfo)

        } # Конец foreach ($cert in $filteredCertificates)
    } # Конец else (если сертификаты найдены)

    # --- 5. Вызов универсальной функции проверки критериев ---
    # Инициализируем переменные для результата проверки критериев
    $checkSuccess = $null
    $failReason = $null

    # Проверяем критерии ТОЛЬКО если сама проверка была доступна ($isAvailable = true)
    if ($isAvailable) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            # Если критерии переданы и они не пустые
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: Вызов Test-SuccessCriteria для проверки критериев..."
            # Вызываем универсальную функцию, передавая ей наши Details и SuccessCriteria
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed # Получаем результат: $true, $false или $null
            $failReason = $criteriaResult.FailReason # Получаем причину провала или ошибки

            if ($checkSuccess -eq $null) {
                # Ошибка при обработке самих критериев
                $errorMessage = "Ошибка при обработке SuccessCriteria: $failReason"
                Write-Warning "[$NodeName] $errorMessage"
            } elseif ($checkSuccess -eq $false) {
                # Критерии не пройдены
                $errorMessage = $failReason # Используем причину как сообщение об ошибке
                Write-Verbose "[$NodeName] Check-CERT_EXPIRY: SuccessCriteria НЕ пройдены: $failReason"
            } else {
                # Критерии пройдены ($checkSuccess = $true)
                $errorMessage = $null # Нет сообщения об ошибке
                Write-Verbose "[$NodeName] Check-CERT_EXPIRY: SuccessCriteria пройдены."
            }
        } else {
            # Критерии НЕ ЗАДАНЫ
            # Если проверка была доступна, но критериев нет, считаем CheckSuccess = true
            $checkSuccess = $true
            $errorMessage = $null # Ошибки, связанной с критериями, нет
            Write-Verbose "[$NodeName] Check-CERT_EXPIRY: SuccessCriteria не заданы, CheckSuccess установлен в true (т.к. IsAvailable=true)."
        }
    } else {
        # Если IsAvailable = $false, то CheckSuccess должен быть $null
        $checkSuccess = $null
        # $errorMessage уже должен быть установлен ранее (например, ошибка доступа к хранилищам
        # или исключение, выброшенное при невозможности проверить ни одно хранилище)
        if ([string]::IsNullOrEmpty($errorMessage)) {
            # Эта ветка не должна выполняться, если логика выше верна,
            # но добавлена для подстраховки.
            $errorMessage = "Не удалось выполнить проверку сертификатов (IsAvailable=false)."
        }
    }

    # --- 6. Формирование итогового результата ---
    # Используем New-CheckResultObject для создания стандартного объекта
    # $errorMessage будет содержать либо причину провала критерия, либо ошибку выполнения проверки
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

# <<< ИСПРАВЛЕНО: Закрывающая скобка для ОСНОВНОГО try блока >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ошибок скрипта ---
    # Сюда попадаем, если произошла ошибка, не обработанная выше
    # (например, ошибка в параметрах, исключение при throw из-за недоступности хранилищ)
    $isAvailable = $false
    $checkSuccess = $null
    $exceptionMessage = $_.Exception.Message
    # Обрезаем слишком длинные сообщения
    if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
    $critErrorMessage = "Критическая ошибка при проверке сертификатов: {0}" -f $exceptionMessage

    # Формируем Details с информацией об ошибке
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }
    # Добавляем хранилища, которые успели проверить, если они есть
    if ($details.stores_checked.Count -gt 0) { $detailsError.stores_checked = $details.stores_checked }

    # Создаем финальный результат ВРУЧНУЮ, т.к. New-CheckResultObject может быть недоступен
    $finalResult = @{
        IsAvailable  = $isAvailable
        CheckSuccess = $checkSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $detailsError
        ErrorMessage = $critErrorMessage
    }
    Write-Error "[$NodeName] Check-CERT_EXPIRY: Критическая ошибка: $critErrorMessage"
} # <<< Закрывает ОСНОВНОЙ catch блок >>>

# --- Возврат результата ---
# <<< ИСПРАВЛЕНО: Заменяем ?. на стандартный доступ, проверяя $finalResult >>>
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[finalResult is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[finalResult is null]' }
Write-Verbose "[$NodeName] Check-CERT_EXPIRY (v2.0.2): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-CERT_EXPIRY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1
# --- Версия 2.0 ---
# Изменения:
# - Логика проверки SuccessCriteria вынесена в универсальную функцию Test-SuccessCriteria.
# - Стандартизирован формат $Details.
# - Убран прямой расчет CheckSuccess на основе min_percent_free.
# - Добавлен вызов Test-SuccessCriteria.

<#
.SYNOPSIS
    Скрипт проверки использования дискового пространства. (v2.0)
.DESCRIPTION
    Получает информацию о локальных дисках типа 'Fixed' с помощью Get-Volume.
    Позволяет фильтровать диски по букве.
    Формирует стандартизированный объект $Details с массивом 'disks', содержащим
    детальную информацию о каждом проверенном диске.
    Для определения итогового CheckSuccess использует универсальную функцию
    Test-SuccessCriteria, сравнивающую $Details с переданным $SuccessCriteria.
    Ожидаемый формат SuccessCriteria для проверки дисков:
    @{ disks = @{ _condition_ = 'all'; _where_ = @{ drive_letter='C' }; percent_free = @{ '>' = 10 } } }
    (Пример: для всех дисков, где буква 'C', % свободного места должен быть > 10).
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста. Используется для логирования,
             скрипт выполняется локально.
.PARAMETER Parameters
    [hashtable] Опциональный. Параметры проверки:
    - drives ([string[]]): Массив букв дисков для проверки (регистр не важен).
                           Если не указан, проверяются все локальные диски типа 'Fixed'.
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха. Ожидается структура для проверки
                массива 'disks' в $Details (см. пример выше). Обрабатывается
                функцией Test-SuccessCriteria.
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
                Поле Details (hashtable) содержит:
                - disks (List<object>): Массив хэш-таблиц с информацией о дисках
                  (drive_letter, label, filesystem, size_bytes, free_bytes,
                  used_bytes, size_gb, free_gb, used_gb, percent_free, percent_used).
                - message (string): Опциональное сообщение (напр., если диски не найдены).
                - error (string): Опциональное сообщение об ошибке выполнения.
                - ErrorRecord (string): Опционально, полный текст исключения.
.NOTES
    Версия: 2.0.1 (Добавлены комментарии, форматирование, улучшена обработка 0 размера диска).
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria из StatusMonitorAgentUtils.psm1.
    Требует ОС Windows 8 / Server 2012 или новее для Get-Volume.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,

    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},

    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,

    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация переменных ---
$isAvailable = $false
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null
# Инициализируем $Details с пустым списком дисков
$details = @{
    disks = [System.Collections.Generic.List[object]]::new()
    # message будет добавлено при необходимости
}

Write-Verbose "[$NodeName] Check-DISK_USAGE (v2.0.1): Начало проверки дисков на $TargetIP (локально на $env:COMPUTERNAME)"

# --- Основной блок Try/Catch ---
try {

    # --- 1. Выполнение Get-Volume ---
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Вызов Get-Volume..."
    # Выполняем команду, перехватывая критические ошибки (например, командлет не найден на старой ОС)
    $volumes = Get-Volume -ErrorAction Stop

    # Если команда выполнилась без исключения, считаем проверку доступной
    $isAvailable = $true
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Get-Volume выполнен. Получено томов: $($volumes.Count)"

    # --- 2. Фильтрация томов ---
    $targetDriveLetters = @() # Массив для целевых букв (Upper Case)
    # Проверяем параметр 'drives'
    if ($Parameters.ContainsKey('drives') -and $Parameters.drives -is [array] -and $Parameters.drives.Count -gt 0) {
        $targetDriveLetters = $Parameters.drives | ForEach-Object { $_.Trim().ToUpper() }
        Write-Verbose "[$NodeName] Check-DISK_USAGE: Фильтрация по указанным дискам: $($targetDriveLetters -join ', ')"
    } else {
        Write-Verbose "[$NodeName] Check-DISK_USAGE: Параметр 'drives' не указан, обрабатываем все диски типа 'Fixed'."
    }

    # Фильтруем тома по типу 'Fixed', наличию буквы и списку $targetDriveLetters (если он задан)
    $filteredVolumes = $volumes | Where-Object {
        $isFixed = $_.DriveType -eq 'Fixed'
        $currentDriveLetterChar = $_.DriveLetter
        $hasLetter = $null -ne $currentDriveLetterChar -and (-not [string]::IsNullOrWhiteSpace($currentDriveLetterChar))
        $currentDriveLetterString = $currentDriveLetterChar.ToString()
        $isInTargetList = ($targetDriveLetters.Count -eq 0) -or ($targetDriveLetters -contains $currentDriveLetterString.ToUpper())
        # Условие: Fixed И HasLetter И (Нет фильтра ИЛИ Входит в фильтр)
        $isFixed -and $hasLetter -and $isInTargetList
    }
    Write-Verbose "[$NodeName] Check-DISK_USAGE: Количество томов после фильтрации: $($filteredVolumes.Count)"

    # --- 3. Обработка отфильтрованных томов и формирование $Details ---
    if ($filteredVolumes.Count -eq 0) {
        # Если дисков для проверки не осталось
        $details.message = "Нет локальных дисков типа 'Fixed'"
        if ($targetDriveLetters.Count -gt 0) {
            $details.message += ", соответствующих указанным буквам ($($targetDriveLetters -join ', '))"
        }
        $details.message += "."
        Write-Verbose "[$NodeName] Check-DISK_USAGE: $($details.message)"
        # CheckSuccess остается $null, будет установлен в $true ниже, если $isAvailable = $true
    } else {
        # Если есть диски для обработки
        foreach ($vol in $filteredVolumes) {
            $driveLetter = $vol.DriveLetter.ToString().ToUpper()
            Write-Verbose "[$NodeName] Check-DISK_USAGE: Обработка диска $driveLetter"

            # Собираем информацию о диске
            $diskInfo = [ordered]@{
                drive_letter = $driveLetter
                label        = $vol.FileSystemLabel
                filesystem   = $vol.FileSystem
                size_bytes   = $vol.Size
                free_bytes   = $vol.SizeRemaining
                used_bytes   = $vol.Size - $vol.SizeRemaining
                size_gb      = $null
                free_gb      = $null
                used_gb      = $null
                percent_free = $null
                percent_used = $null
                # <<< УБРАНЫ ПОЛЯ КРИТЕРИЕВ ИЗ Details >>>
                # criteria_applied = $null
                # criteria_passed  = $null
                # criteria_failed_reason = $null
            }

            # Рассчитываем производные значения (GB, %)
            if ($diskInfo.size_bytes -gt 0) {
                $diskInfo.size_gb = [math]::Round($diskInfo.size_bytes / 1GB, 2)
                $diskInfo.free_gb = [math]::Round($diskInfo.free_bytes / 1GB, 2)
                $diskInfo.used_gb = [math]::Round($diskInfo.used_bytes / 1GB, 2)
                $diskInfo.percent_free = [math]::Round(($diskInfo.free_bytes / $diskInfo.size_bytes) * 100, 1)
                $diskInfo.percent_used = [math]::Round(($diskInfo.used_bytes / $diskInfo.size_bytes) * 100, 1)
            } else {
                # Обработка дисков с нулевым размером
                Write-Warning "[$NodeName] Check-DISK_USAGE: Диск $driveLetter имеет размер 0 байт."
                $diskInfo.size_gb = 0; $diskInfo.free_gb = 0; $diskInfo.used_gb = 0
                $diskInfo.percent_free = 0; $diskInfo.percent_used = 0 # Условно 0% свободно, 0% занято
            }

            # Добавляем информацию о диске в список $Details.disks
            $details.disks.Add($diskInfo)

            # <<< УБРАНА ЛОГИКА ПРОВЕРКИ КРИТЕРИЕВ ЗДЕСЬ >>>

        } # Конец foreach ($vol in $filteredVolumes)
    } # Конец else (если были диски для проверки)

    # --- 4. Вызов универсальной функции проверки критериев ---
    $failReason = $null

    if ($isAvailable) { # Проверяем критерии ТОЛЬКО если проверка прошла
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-DISK_USAGE: Вызов Test-SuccessCriteria..."
            # Вызываем универсальную функцию
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed # $true, $false или $null
            $failReason = $criteriaResult.FailReason

            if ($checkSuccess -eq $null) {
                $errorMessage = "Ошибка при обработке SuccessCriteria: $failReason"
                Write-Warning "[$NodeName] $errorMessage"
            } elseif ($checkSuccess -eq $false) {
                $errorMessage = $failReason # Причина провала станет ErrorMessage
                Write-Verbose "[$NodeName] Check-DISK_USAGE: SuccessCriteria НЕ пройдены: $failReason"
            } else {
                $errorMessage = $null # Критерии пройдены
                Write-Verbose "[$NodeName] Check-DISK_USAGE: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-DISK_USAGE: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        # Если IsAvailable = $false
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) {
            # $errorMessage должен был установиться в catch блоке ниже
            $errorMessage = "Ошибка выполнения проверки дисков (IsAvailable=false)."
        }
    }

    # --- 5. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

# <<< Закрываем основной try блок >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ошибок скрипта ---
    # Например, Get-Volume не найден или другая ошибка PowerShell
    $isAvailable = $false
    $checkSuccess = $null
    $exceptionMessage = $_.Exception.Message
    if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
    $critErrorMessage = "Критическая ошибка при проверке дисков: {0}" -f $exceptionMessage

    # Формируем Details с ошибкой
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }

    # Создаем финальный результат ВРУЧНУЮ
    $finalResult = @{
        IsAvailable  = $isAvailable
        CheckSuccess = $checkSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $detailsError
        ErrorMessage = $critErrorMessage
    }
    Write-Error "[$NodeName] Check-DISK_USAGE: Критическая ошибка: $critErrorMessage"
} # <<< Закрываем основной catch блок >>>

# --- Возврат результата ---
# Используем стандартный доступ к свойствам, проверив $finalResult
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-DISK_USAGE (v2.0.1): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-DISK_USAGE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1
# --- Версия 2.3.0 --- Использование .NET Ping
# Изменения:
# - Полностью заменен вызов Test-Connection на использование System.Net.NetworkInformation.Ping.
# - Логика адаптирована под результаты .NET Ping (Status, RoundtripTime).
# - Убрана зависимость от версии PowerShell для логики пинга.

<#
.SYNOPSIS
    Скрипт проверки доступности узла с помощью .NET Ping. (v2.3.0)
.DESCRIPTION
    Использует класс System.Net.NetworkInformation.Ping для отправки ICMP эхо-запросов.
    Этот метод более надежен и предсказуем, чем Test-Connection, особенно в PS 5.1.
    Анализирует результат PingReply для определения доступности ($IsAvailable) и RTT.
    Формирует стандартизированный $Details с результатом.
    Для определения итогового CheckSuccess использует универсальную функцию Test-SuccessCriteria.
.PARAMETER TargetIP
    [string] Обязательный. IP-адрес или имя хоста для пинга.
.PARAMETER Parameters
    [hashtable] Опциональный. Параметры для пинга:
    - timeout_ms (int): Таймаут ожидания ответа в миллисекундах (default: 1000).
    - count (int): Количество отправляемых запросов (default: 1). Скрипт отправит столько запросов
                   и вычислит среднее RTT и потери.
    - buffer_size (int): Размер буфера ICMP в байтах (default: 32).
    - ttl (int): Time To Live (default: 128).
.PARAMETER SuccessCriteria
    [hashtable] Опциональный. Критерии успеха для сравнения с полями в $Details.
                Пример: @{ rtt_ms = @{ '<=' = 100 }; packet_loss_percent = @{ '<=' = 0 } }
.PARAMETER NodeName
    [string] Опциональный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
                Поле Details (hashtable) содержит (при получении хотя бы одного ответа):
                - target_ip (string): Пингуемый адрес/имя.
                - ip_address (string): IP-адрес, фактически ответивший (первый успешный).
                - rtt_ms (int): Среднее время ответа по успешным пингам в мс (или RTT первого, если count=1).
                - packets_sent (int): Отправлено пакетов.
                - packets_received (int): Получено пакетов (успешных ответов).
                - packet_loss_percent (int): Процент потерь.
                - status_string (string): Статус первого ответа (Success, TimedOut, etc.).
                А также (при полной неудаче):
                - error (string): Сообщение об ошибке.
                - ErrorRecord (string): Полный текст исключения.
.NOTES
    Версия: 2.3.0 (Переход на System.Net.NetworkInformation.Ping).
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,
    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},
    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,
    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация ---
$isAvailable = $false; $checkSuccess = $null; $errorMessage = $null; $finalResult = $null
$details = @{ target_ip = $TargetIP } # Базовые детали

# --- Параметры пинга ---
$TimeoutMs = 1000; if ($Parameters.ContainsKey('timeout_ms') -and $Parameters.timeout_ms -ne $null -and [int]::TryParse($Parameters.timeout_ms, [ref]$null) -and $Parameters.timeout_ms -gt 0) { $TimeoutMs = [int]$Parameters.timeout_ms }
$PingCount = 1; if ($Parameters.ContainsKey('count') -and $Parameters.count -ne $null -and [int]::TryParse($Parameters.count, [ref]$null) -and $Parameters.count -gt 0) { $PingCount = [int]$Parameters.count }
$BufferSize = 32; if ($Parameters.ContainsKey('buffer_size') -and $Parameters.buffer_size -ne $null -and [int]::TryParse($Parameters.buffer_size, [ref]$null) -and $Parameters.buffer_size -gt 0) { $BufferSize = [int]$Parameters.buffer_size }
$TtlValue = 128; if ($Parameters.ContainsKey('ttl') -and $Parameters.ttl -ne $null -and [int]::TryParse($Parameters.ttl, [ref]$null) -and $Parameters.ttl -gt 0) { $TtlValue = [int]$Parameters.ttl }

$details.packets_sent = $PingCount # Сохраняем количество запрошенных пингов

Write-Host "[$NodeName] Check-PING (v2.3.0 - .NET): Инициализация для $TargetIP (Count: $PingCount, Timeout: $TimeoutMs ms)" -ForegroundColor Magenta

# --- Основной Try/Catch ---
try { # <<< НАЧАЛО ОСНОВНОГО TRY БЛОКА >>>
    # Создаем объект Ping и опции
    $pingSender = New-Object System.Net.NetworkInformation.Ping
    $pingOptions = New-Object System.Net.NetworkInformation.PingOptions
    $pingOptions.DontFragment = $true # Устанавливаем флаг Don't Fragment
    $pingOptions.Ttl = $TtlValue

    # Создаем буфер нужного размера
    $sendBuffer = [byte[]]::new($BufferSize)
    # Заполняем буфер (не обязательно, но можно для имитации стандартного пинга)
    # For ($i = 0; $i -lt $BufferSize; $i++) { $sendBuffer[$i] = $i % 256 }

    # Массив для хранения результатов каждого пинга
    $resultsList = [System.Collections.Generic.List[System.Net.NetworkInformation.PingReply]]::new()
    $successCount = 0
    $totalRtt = 0
    $firstReplyStatus = $null # Статус самого первого ответа
    $firstSuccessReply = $null # Первый успешный ответ

    Write-Verbose "[$NodeName] Check-PING: Отправка $PingCount ICMP запросов..."
    # Отправляем запросы в цикле
    for ($i = 1; $i -le $PingCount; $i++) {
        $reply = $null
        try {
            # Отправляем синхронный пинг
            $reply = $pingSender.Send($TargetIP, $TimeoutMs, $sendBuffer, $pingOptions)
            $resultsList.Add($reply) # Добавляем результат в список

            # Сохраняем статус первого ответа
            if ($i -eq 1) { $firstReplyStatus = $reply.Status }

            # Если ответ успешный
            if ($reply.Status -eq [System.Net.NetworkInformation.IPStatus]::Success) {
                $successCount++
                $totalRtt += $reply.RoundtripTime
                # Сохраняем первый успешный ответ
                if ($null -eq $firstSuccessReply) { $firstSuccessReply = $reply }
            }
             Write-Verbose "[$NodeName] Check-PING: Попытка $i - Статус: $($reply.Status), RTT: $($reply.RoundtripTime)ms"
        } catch [System.Net.NetworkInformation.PingException] {
             # Ошибка на уровне отправки (например, не удалось разрешить имя хоста)
             $errorMessage = "Ошибка PingException для '$TargetIP': $($_.Exception.Message)"
             Write-Warning "[$NodeName] Check-PING: $errorMessage"
             # Записываем ошибку в details и прерываем цикл, т.к. пинг невозможен
             $details.error = $errorMessage
             $details.ErrorRecord = $_.ToString()
             $isAvailable = $false # Явно указываем, что проверка не удалась
             break # Выходим из цикла for
        } catch {
             # Другая непредвиденная ошибка при отправке
             $errorMessage = "Неожиданная ошибка при отправке пинга ($i/$PingCount) для '$TargetIP': $($_.Exception.Message)"
             Write-Warning "[$NodeName] Check-PING: $errorMessage"
             # Продолжаем цикл (возможно, следующие попытки пройдут) или прерываем?
             # Пока продолжим, но запишем ошибку в details
             if (-not $details.ContainsKey('ping_errors')) { $details.ping_errors = [System.Collections.Generic.List[string]]::new() }
             $details.ping_errors.Add($errorMessage)
        }
        # Небольшая пауза между пингами, если их несколько
        if ($PingCount -gt 1 -and $i -lt $PingCount) { Start-Sleep -Milliseconds 100 }
    } # Конец цикла for

    # --- Анализ результатов цикла ---
    # Проверяем, не было ли критической ошибки PingException
    if ($details.ContainsKey('error')) {
         # Ошибка уже установлена, IsAvailable = false
         $isAvailable = $false
    } else {
        # Ошибки PingException не было, анализируем результаты
        $details.packets_received = $successCount
        $details.packet_loss_percent = if ($PingCount -gt 0) { [math]::Round((($PingCount - $successCount) / $PingCount) * 100) } else { 0 }

        # Считаем проверку успешной (IsAvailable), если ХОТЯ БЫ ОДИН ответ был Success
        if ($successCount -gt 0) {
            $isAvailable = $true
            $errorMessage = $null # Сбрасываем сообщение об ошибке, т.к. пинг прошел
            $details.status_string = 'Success' # Общий статус - успех
            # Рассчитываем среднее RTT по успешным ответам
            $details.rtt_ms = if ($successCount -gt 0) { [int][math]::Round($totalRtt / $successCount) } else { $null }
            # Берем IP из первого успешного ответа
            $details.ip_address = $firstSuccessReply.Address.ToString()
             Write-Verbose "[$NodeName] Check-PING: Пинг успешен (IsAvailable=True). Успешных: $successCount/$PingCount. Средний RTT: $($details.rtt_ms)ms. IP: $($details.ip_address)."
        } else {
            # Ни одного успешного ответа
            $isAvailable = $false
            # Формируем сообщение об ошибке на основе статуса первого ответа
            $statusText = if ($firstReplyStatus -ne $null) { $firstReplyStatus.ToString() } else { "[Нет ответа]" }
            $errorMessage = "Ошибка PING для '$TargetIP': Нет успешных ответов ($successCount/$PingCount). Статус первого: $statusText"
            $details.error = $errorMessage
            $details.status_string = $statusText
            Write-Warning "[$NodeName] Check-PING: $errorMessage"
        }
    }

    # --- Вызов проверки критериев ---
    $failReason = $null
    if ($isAvailable -eq $true) { # Явное сравнение
        # Проверяем, что SuccessCriteria существует и содержит ключи
        if (($SuccessCriteria -ne $null) -and ($SuccessCriteria.PSObject.Properties.Name.Count -gt 0)) {
            Write-Verbose "[$NodeName] Check-PING: Вызов Test-SuccessCriteria..."
            try { # Перехватываем ошибку, если функция не найдена или не работает
                # <<< РАСКОММЕНТИРОВАНО >>>
                $criteriaResult = StatusMonitorAgentUtils\Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
                $checkSuccess = $criteriaResult.Passed
                $failReason = $criteriaResult.FailReason
                Write-Verbose "[$NodeName] Check-PING: Test-SuccessCriteria вернул Passed=$checkSuccess, Reason='$failReason'"
                if ($checkSuccess -eq $null) { $errorMessage = "Ошибка обработки SuccessCriteria: $failReason"; $details.error_criteria = $errorMessage; Write-Warning "[$NodeName] $errorMessage" }
                elseif ($checkSuccess -eq $false) { $errorMessage = $failReason; Write-Verbose "[$NodeName] Check-PING: SuccessCriteria НЕ пройдены: $failReason" }
                else { $errorMessage = $null; Write-Verbose "[$NodeName] Check-PING: SuccessCriteria пройдены." }
                # <<< КОНЕЦ РАСКОММЕНТИРОВАННОГО БЛОКА >>>
            } catch {
                # <<< ИЗМЕНЕНО: Выводим ТОЛЬКО Exception.Message >>>
                $exceptionMessageOnly = "Нет сообщения"
                if ($_.Exception) { $exceptionMessageOnly = $_.Exception.Message }
                $errorMessage = "Критическая ошибка при вызове Test-SuccessCriteria: $exceptionMessageOnly"
                # Обрежем, если ОЧЕНЬ длинное
                if ($errorMessage.Length -gt 1000) { $errorMessage = $errorMessage.Substring(0, 1000) + "..." }
                $checkSuccess = $null # Считаем проверку критериев неуспешной/невозможной
                # Добавляем ТОЛЬКО сообщение об ошибке в детали
                if ($details -isnot [hashtable]) { $details = @{} } # Убедимся, что details это hashtable
                $details.error_criteria = $errorMessage
                Write-Warning "[$NodeName] $errorMessage" # Выводим ошибку
            }
        } else { $checkSuccess = $true; $errorMessage = $null; Write-Verbose "[$NodeName] Check-PING: SuccessCriteria не заданы, CheckSuccess=true."}
    } else { $checkSuccess = $null; if ([string]::IsNullOrEmpty($errorMessage)) { $errorMessage = "Ошибка PING (IsAvailable=false)." } }

    # --- Формирование результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch {
    # --- Критическая ошибка ---
    Write-Host "[$NodeName] Check-PING: Перехвачена критическая ошибка!" -ForegroundColor Red
    $isAvailable = $false; $checkSuccess = $null
    $critErrorMessage = "Критическая ошибка PING для '$TargetIP': Ошибка в основном блоке try - $($_.Exception.Message)"
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString(); target_ip = $TargetIP; packets_sent = $PingCount }
    $finalResult = @{ IsAvailable=$isAvailable; CheckSuccess=$checkSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$detailsError; ErrorMessage=$critErrorMessage }
    Write-Error "[$NodeName] Check-PING: Критическая ошибка (упрощенный catch): $critErrorMessage"
}

# --- Возврат ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Host "[$NodeName] Check-PING (v2.3.0 - .NET): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr" -ForegroundColor Magenta
return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PING.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1
# --- Версия 2.0 ---
# Изменения:
# - Логика проверки SuccessCriteria вынесена в универсальную функцию Test-SuccessCriteria.
# - Стандартизирован формат $Details.
# - Добавлен вызов Test-SuccessCriteria.

<#
.SYNOPSIS
    Получает список запущенных процессов на локальной машине. (v2.0)
.DESCRIPTION
    Использует Get-Process для получения информации о процессах.
    Позволяет фильтровать, сортировать, ограничивать вывод и включать
    дополнительные данные (Username, Path).
    Формирует стандартизированный объект $Details со списком найденных процессов.
    Для определения итогового CheckSuccess использует универсальную функцию
    Test-SuccessCriteria, сравнивающую $Details с переданным $SuccessCriteria.
    Ожидаемый формат SuccessCriteria для проверки наличия/количества:
    @{ processes = @{ _condition_ = 'any'; _where_ = @{ name = 'notepad.exe'}; _count_ = @{ '>=' = 1 } } }
    (Пример: хотя бы 1 процесс notepad.exe должен быть найден).
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста. Используется для логирования,
             скрипт выполняется локально.
.PARAMETER Parameters
    [hashtable] Необязательный. Параметры настройки вывода:
    - process_names ([string[]]): Фильтр имен процессов (с wildcard *?).
    - include_username ([bool]): Включать имя пользователя (default: $false).
    - include_path ([bool]): Включать путь к файлу (default: $false).
    - sort_by ([string]): Поле для сортировки ('Name', 'Id', 'CPU', 'Memory', 'StartTime', default: 'Name').
    - sort_descending ([bool]): Сортировать по убыванию (default: $false).
    - top_n ([int]): Отобразить только N верхних процессов.
.PARAMETER SuccessCriteria
    [hashtable] Необязательный. Критерии успеха для сравнения с массивом 'processes' в $Details.
                Пример: @{ processes = @{ _condition_='none'; _where_=@{name='malware.exe'} } }
                (Процесс malware.exe не должен быть найден).
                Обрабатывается функцией Test-SuccessCriteria.
.PARAMETER NodeName
    [string] Необязательный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
                Поле Details (hashtable) содержит:
                - processes (List<object>): Массив объектов [PSCustomObject] с данными процессов
                  (id, name, cpu_seconds, memory_ws_mb, username, path, start_time).
                - message (string): Опциональное сообщение (напр., если процессы не найдены).
                - error (string): Опциональное сообщение об ошибке выполнения.
                - ErrorRecord (string): Опционально, полный текст исключения.
.NOTES
    Версия: 2.0.1 (Добавлены комментарии, форматирование, корректная обработка ошибок Get-CimInstance).
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria.
    Получение Username и Path может требовать повышенных прав.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,

    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},

    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,

    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация переменных ---
$isAvailable = $false
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null
$details = @{
    processes = [System.Collections.Generic.List[object]]::new() # Инициализируем пустой список
}

Write-Verbose "[$NodeName] Check-PROCESS_LIST (v2.0.1): Начало получения списка процессов для $TargetIP (локально на $env:COMPUTERNAME)"

# --- Основной блок Try/Catch ---
try {
    # --- 1. Обработка входных параметров ($Parameters) ---
    Write-Verbose "[$NodeName] Check-PROCESS_LIST: Обработка параметров..."
    # Фильтр по именам
    $processNamesFilter = $null
    $filteringByName = $false
    if ($Parameters.ContainsKey('process_names') -and $Parameters.process_names -is [array] -and $Parameters.process_names.Count -gt 0) {
        $processNamesFilter = $Parameters.process_names
        $filteringByName = $true
        Write-Verbose "[$NodeName] Check-PROCESS_LIST: Фильтр по именам: $($processNamesFilter -join ', ')"
    } else { Write-Verbose "[$NodeName] Check-PROCESS_LIST: Получение всех процессов." }
    # Включение Username/Path
    $includeUsername = ($Parameters.ContainsKey('include_username') -and ([bool]$Parameters.include_username))
    $includePath = ($Parameters.ContainsKey('include_path') -and ([bool]$Parameters.include_path))
    if ($includeUsername) { Write-Verbose "[$NodeName] Check-PROCESS_LIST: Включая Username." }
    if ($includePath) { Write-Verbose "[$NodeName] Check-PROCESS_LIST: Включая Path." }
    # Сортировка
    $sortByInput = if ($Parameters.ContainsKey('sort_by') -and -not [string]::IsNullOrWhiteSpace($Parameters.sort_by)) { $Parameters.sort_by } else { 'Name' }
    $validSortFields = @('id', 'name', 'cpu_seconds', 'memory_ws_mb', 'start_time')
    $sortByActual = switch ($sortByInput.ToLower()) { 'memory' {$s='memory_ws_mb'}; 'mem' {$s='memory_ws_mb'}; 'ws' {$s='memory_ws_mb'}; 'cpu' {$s='cpu_seconds'}; default {if($sortByInput -in $validSortFields){$sortByInput}else{'name'}}}; if($sortByActual -notin $validSortFields){$sortByActual = 'name'}
    $sortDesc = ($Parameters.ContainsKey('sort_descending') -and ([bool]$Parameters.sort_descending))
    $sortDirectionText = if ($sortDesc) { 'Desc' } else { 'Asc' }; Write-Verbose "[$NodeName] Check-PROCESS_LIST: Сортировка по '$sortByActual' ($sortDirectionText)"
    # Top N
    $topN = $null
    if ($Parameters.ContainsKey('top_n') -and $Parameters.top_n -ne $null) {
        $parsedTopN = 0
        if ([int]::TryParse($Parameters.top_n, [ref]$parsedTopN) -and $parsedTopN -gt 0) {
            $topN = $parsedTopN; Write-Verbose "[$NodeName] Check-PROCESS_LIST: Выбор топ $topN процессов."
        } else { Write-Warning "[$NodeName] Check-PROCESS_LIST: Некорректное 'top_n', лимит не применяется." }
    }

    # --- 2. Выполнение Get-Process ---
    $getProcessParams = @{ ErrorAction = 'Stop' } # По умолчанию - падаем при любой ошибке Get-Process
    if ($filteringByName) {
        $getProcessParams.Name = $processNamesFilter
        $getProcessParams.ErrorAction = 'SilentlyContinue' # Подавляем ТОЛЬКО ошибку "не найдено"
    }
    Write-Verbose "[$NodeName] Check-PROCESS_LIST: Вызов Get-Process @($getProcessParams | Out-String -Width 200)..."
    $processesRaw = Get-Process @getProcessParams
    # Проверяем, была ли ошибка "не найдено" (которая была подавлена)
    $processNotFoundError = $null
    if ($filteringByName -and $Error.Count -gt 0 -and $Error[0].CategoryInfo.Reason -eq 'ProcessNotFoundException') {
        $processNotFoundError = $Error[0].Exception.Message
        $Error.Clear() # Очищаем ошибку "не найдено"
        Write-Verbose "[$NodeName] Check-PROCESS_LIST: Процесс(ы) по фильтру не найдены ($processNotFoundError)"
    }
    # Если Get-Process не выбросил исключение (или ошибка была "не найдено"), считаем проверку доступной
    $isAvailable = $true
    $processCount = if ($processesRaw) { @($processesRaw).Count } else { 0 }
    Write-Verbose "[$NodeName] Check-PROCESS_LIST: Get-Process выполнен. Найдено процессов: $processCount"

    # --- 3. Обработка и форматирование результата для $Details ---
    if ($processCount -gt 0) {
        # Преобразуем объекты процессов в стандартизированный формат для $Details
        $processedList = foreach ($proc in $processesRaw) {
            $procInfo = [ordered]@{
                id           = $proc.Id
                name         = $proc.ProcessName
                cpu_seconds  = $null; memory_ws_mb = $null; username = $null; path = $null; start_time = $null
            }
            # Безопасное получение дополнительных полей
            try { $procInfo.cpu_seconds = [math]::Round($proc.CPU, 2) } catch { }
            try { $procInfo.memory_ws_mb = [math]::Round($proc.WS / 1MB, 1) } catch { }
            try { $procInfo.start_time = $proc.StartTime.ToUniversalTime().ToString("o") } catch { }
            # Username через WMI/CIM
            if ($includeUsername) {
                try {
                    # Используем CIM, ErrorAction SilentlyContinue на случай ошибок доступа к конкретному процессу
                    $ownerInfo = Get-CimInstance -ClassName Win32_Process -Filter "ProcessId = $($proc.Id)" | Select-Object -ExpandProperty Owner -ErrorAction SilentlyContinue
                    $procInfo.username = if ($ownerInfo -and $ownerInfo.User) { if ($ownerInfo.Domain) { "$($ownerInfo.Domain)\$($ownerInfo.User)" } else { $ownerInfo.User } } else { '[N/A]' }
                } catch { $procInfo.username = '[Access Error]' }
            }
            # Path
            if ($includePath) {
                try {
                    # Пытаемся получить Path, потом MainModule.FileName
                    $procPath = $proc.Path
                    if (-not $procPath -and $proc.MainModule) { try { $procPath = $proc.MainModule.FileName } catch {} }
                    $procInfo.path = $procPath
                } catch { $procInfo.path = '[Access Error]' }
            }
            [PSCustomObject]$procInfo # Возвращаем стандартизированный объект
        } # Конец foreach

        # Сортировка
        Write-Verbose "[$NodeName] Check-PROCESS_LIST: Сортировка по '$sortByActual' ($sortDirectionText)"
        try { $processedList = $processedList | Sort-Object -Property $sortByActual -Descending:$sortDesc }
        catch { Write-Warning "[$NodeName] Check-PROCESS_LIST: Ошибка сортировки по '$sortByActual'. Используется сортировка по 'name'." ; try { $processedList = $processedList | Sort-Object -Property 'name' } catch {} }

        # Top N
        if ($topN -gt 0) {
            Write-Verbose "[$NodeName] Check-PROCESS_LIST: Выбор топ $topN процессов."
            $processedList = $processedList | Select-Object -First $topN
        }

        # Запись результата в $Details
        $details.processes.AddRange($processedList)
        Write-Verbose "[$NodeName] Check-PROCESS_LIST: Добавлено в $Details.processes: $($details.processes.Count) записей."

    } elseif ($filteringByName) {
        # Если фильтровали по имени и НИЧЕГО не найдено
        $details.message = "Процессы, соответствующие фильтру '$($processNamesFilter -join ', ')', не найдены."
        Write-Verbose "[$NodeName] Check-PROCESS_LIST: $($details.message)"
        # В этом случае CheckSuccess будет $true, если нет критериев, требующих наличия
    } else {
        # Если не фильтровали, но список пуст (очень маловероятно)
         $details.message = "Список процессов пуст."
         Write-Verbose "[$NodeName] Check-PROCESS_LIST: $($details.message)"
    }

    # --- 4. Вызов универсальной функции проверки критериев ---
    $failReason = $null

    if ($isAvailable) { # Проверяем критерии только если Get-Process выполнился
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-PROCESS_LIST: Вызов Test-SuccessCriteria..."
            # Передаем $Details (который содержит массив 'processes') и $SuccessCriteria
            # Функция Test-SuccessCriteria должна будет уметь обрабатывать критерии для массивов
            # (например, _condition_, _where_, _count_)
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason

            if ($checkSuccess -eq $null) {
                $errorMessage = "Ошибка при обработке SuccessCriteria: $failReason"
                Write-Warning "[$NodeName] $errorMessage"
            } elseif ($checkSuccess -eq $false) {
                $errorMessage = $failReason
                Write-Verbose "[$NodeName] Check-PROCESS_LIST: SuccessCriteria НЕ пройдены: $failReason"
            } else {
                $errorMessage = $null
                Write-Verbose "[$NodeName] Check-PROCESS_LIST: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-PROCESS_LIST: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        # Если IsAvailable = $false
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) {
            $errorMessage = "Ошибка выполнения проверки списка процессов (IsAvailable=false)."
        }
    }

    # --- 5. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

# <<< Закрываем основной try >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ОШИБОК ---
    # Например, ошибка Get-Process (если ErrorAction=Stop) или другая ошибка PowerShell
    $isAvailable = $false
    $checkSuccess = $null
    $exceptionMessage = $_.Exception.Message
    if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
    $critErrorMessage = "Критическая ошибка при получении списка процессов: {0}" -f $exceptionMessage

    # Формируем Details с ошибкой
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }

    # Создаем финальный результат ВРУЧНУЮ
    $finalResult = @{
        IsAvailable  = $isAvailable
        CheckSuccess = $checkSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $detailsError
        ErrorMessage = $critErrorMessage
    }
    Write-Error "[$NodeName] Check-PROCESS_LIST: Критическая ошибка: $critErrorMessage"
} # <<< Закрываем основной catch >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-PROCESS_LIST (v2.0.1): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-PROCESS_LIST.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1
# --- Версия 2.0 ---
# Изменения:
# - Логика проверки SuccessCriteria вынесена в универсальную функцию Test-SuccessCriteria.
# - Стандартизирован формат $Details.
# - Убран прямой расчет CheckSuccess на основе сравнения статуса.
# - Добавлен вызов Test-SuccessCriteria.

<#
.SYNOPSIS
    Проверяет статус указанной системной службы. (v2.0)
.DESCRIPTION
    Обращается к службе локально с помощью Get-Service для получения
    текущего статуса и другой информации.
    Формирует стандартизированный объект $Details с данными службы.
    Для определения итогового CheckSuccess использует универсальную функцию
    Test-SuccessCriteria, сравнивающую $Details с переданным $SuccessCriteria.
    Ожидаемый формат SuccessCriteria для проверки статуса:
    @{ status = 'Running' } или @{ status = @{ '!=' = 'Stopped' } }
.PARAMETER TargetIP
    [string] Обязательный. IP или имя хоста. Используется для логирования,
             скрипт выполняется локально.
.PARAMETER Parameters
    [hashtable] Обязательный. Должен содержать ключ 'service_name'.
    Пример: @{ service_name = "Spooler" }
.PARAMETER SuccessCriteria
    [hashtable] Необязательный. Критерии успеха для сравнения с полями в $Details.
                Пример: @{ status = "Running"; start_type = "Automatic" }
                Обрабатывается функцией Test-SuccessCriteria.
.PARAMETER NodeName
    [string] Необязательный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
                Поле Details (hashtable) содержит (при успехе):
                - service_name (string): Имя службы.
                - status (string): Текущий статус ('Running', 'Stopped', ...).
                - display_name (string): Отображаемое имя.
                - start_type (string): Тип запуска ('Automatic', 'Manual', ...).
                - can_stop (bool): Может ли быть остановлена.
                А также (при ошибке):
                - error (string): Сообщение об ошибке.
                - ErrorRecord (string): Полный текст исключения.
.NOTES
    Версия: 2.0.1 (Добавлены комментарии, форматирование, улучшена обработка ошибок).
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP, # Используется для логирования

    [Parameter(Mandatory = $true)]
    [hashtable]$Parameters,

    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,

    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация переменных ---
$isAvailable = $false
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null
# Details инициализируем базовыми данными, которые точно известны
$details = @{
    service_name = $null # Будет установлен из параметров
    # Остальные поля (status, display_name и т.д.) добавим после Get-Service
}

Write-Verbose "[$NodeName] Check-SERVICE_STATUS (v2.0.1): Начало проверки для $TargetIP (локально)"

# --- Основной блок Try/Catch ---
try {
    # --- 1. Валидация обязательных параметров ---
    $serviceName = $Parameters.service_name
    if (-not $serviceName -or $serviceName -isnot [string] -or $serviceName.Trim() -eq '') {
        throw "Параметр 'service_name' отсутствует или пуст в Parameters."
    }
    $serviceName = $serviceName.Trim()
    $details.service_name = $serviceName # Записываем имя службы в Details
    Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Проверяемая служба '$serviceName'"

    # --- 2. Выполнение Get-Service ---
    # Выполняем всегда локально в контексте агента
    $service = $null
    # Используем внутренний try/catch для отлова ошибки "служба не найдена"
    try {
        Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Вызов Get-Service -Name '$serviceName'..."
        # ErrorAction Stop, чтобы ошибка попала в catch
        $service = Get-Service -Name $serviceName -ErrorAction Stop

        # --- УСПЕШНО ПОЛУЧИЛИ СЛУЖБУ ---
        $isAvailable = $true # Сама проверка удалась
        $currentStatus = $service.Status.ToString()
        Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Служба '$serviceName' найдена. Статус: $currentStatus"

        # Заполняем $Details информацией о службе
        $details.status = $currentStatus
        $details.display_name = $service.DisplayName
        $details.start_type = $service.StartType.ToString()
        $details.can_stop = $service.CanStop
        # Добавьте другие нужные свойства $service в $Details, если требуется

        # <<< ЛОГИКА ПРОВЕРКИ КРИТЕРИЕВ УБРАНА ОТСЮДА >>>

    # Ловим конкретную ошибку "служба не найдена"
    } catch [Microsoft.PowerShell.Commands.ServiceCommandException] {
        # --- ОШИБКА: Служба не найдена ---
        $isAvailable = $false # Не смогли выполнить проверку
        $errorMessage = "Служба '$serviceName' не найдена на '$($env:COMPUTERNAME)'."
        # Добавляем ошибку в Details
        $details.error = $errorMessage
        Write-Warning "[$NodeName] Check-SERVICE_STATUS: $errorMessage"
        # CheckSuccess остается $null

    # Ловим другие ошибки Get-Service (маловероятно при локальном вызове, но возможно)
    } catch {
        # --- ОШИБКА: Другая ошибка Get-Service ---
        $isAvailable = $false # Не смогли выполнить проверку
        $exceptionMessage = $_.Exception.Message
        if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
        $errorMessage = "Ошибка Get-Service для '$serviceName': $exceptionMessage"
        $details.error = $errorMessage
        $details.ErrorRecord = $_.ToString()
        Write-Warning "[$NodeName] Check-SERVICE_STATUS: $errorMessage"
        # CheckSuccess остается $null
    }

    # --- 3. Вызов универсальной функции проверки критериев ---
    $failReason = $null

    # Проверяем критерии только если сама проверка удалась ($isAvailable = true)
    if ($isAvailable) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SERVICE_STATUS: Вызов Test-SuccessCriteria..."
            # Передаем $Details (со status, start_type и т.д.) и $SuccessCriteria
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason

            if ($checkSuccess -eq $null) {
                # Ошибка в самих критериях
                $errorMessage = "Ошибка при обработке SuccessCriteria: $failReason"
                Write-Warning "[$NodeName] $errorMessage"
            } elseif ($checkSuccess -eq $false) {
                # Критерии не пройдены
                $errorMessage = $failReason # Используем причину как сообщение
                Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria НЕ пройдены: $failReason"
            } else {
                # Критерии пройдены
                $errorMessage = $null # Ошибки нет
                Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-SERVICE_STATUS: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        # Если IsAvailable = $false
        $checkSuccess = $null
        # $errorMessage уже был установлен в блоках catch выше
        if ([string]::IsNullOrEmpty($errorMessage)) {
            $errorMessage = "Ошибка выполнения проверки статуса службы (IsAvailable=false)."
        }
    }

    # --- 4. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

# <<< Закрываем основной try блок >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ошибок скрипта ---
    # Например, ошибка валидации параметра service_name
    $isAvailable = $false
    $checkSuccess = $null
    $exceptionMessage = $_.Exception.Message
    if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
    $critErrorMessage = "Критическая ошибка скрипта Check-SERVICE_STATUS: {0}" -f $exceptionMessage

    # Формируем Details с ошибкой
    $detailsError = @{ error = $critErrorMessage; ErrorRecord = $_.ToString() }
    # Добавляем имя службы, если успели его получить
    if ($details.service_name) { $detailsError.service_name = $details.service_name }

    # Создаем финальный результат ВРУЧНУЮ
    $finalResult = @{
        IsAvailable  = $isAvailable
        CheckSuccess = $checkSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $detailsError
        ErrorMessage = $critErrorMessage
    }
    Write-Error "[$NodeName] Check-SERVICE_STATUS: Критическая ошибка: $critErrorMessage"
} # <<< Закрываем основной catch блок >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-SERVICE_STATUS (v2.0.1): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SERVICE_STATUS.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1
# --- Версия 2.0 ---
# Изменения:
# - Логика проверки SuccessCriteria вынесена в универсальную функцию Test-SuccessCriteria.
# - Стандартизирован формат $Details для каждого return_format.
# - Убран прямой расчет CheckSuccess на основе скалярных сравнений.
# - Добавлен вызов Test-SuccessCriteria.

<#
.SYNOPSIS
    Выполняет SQL-запрос к MS SQL Server и возвращает результат. (v2.0)
.DESCRIPTION
    Подключается к SQL Server, выполняет запрос и обрабатывает результат
    в соответствии с параметром 'return_format'.
    Формирует стандартизированный объект $Details с результатом запроса.
    Для определения итогового CheckSuccess использует универсальную функцию
    Test-SuccessCriteria, сравнивающую $Details с переданным $SuccessCriteria.
.PARAMETER TargetIP
    [string] Обязательный. Имя или IP-адрес экземпляра SQL Server.
.PARAMETER Parameters
    [hashtable] Обязательный. Параметры подключения и запроса:
    - sql_database (string): Имя БД. Обязательно.
    - sql_query (string): Текст SQL-запроса. Обязательно.
    - return_format (string): Формат возврата ('first_row', 'all_rows', 'row_count', 'scalar', 'non_query', default: 'first_row').
    - sql_username (string): Имя пользователя SQL (опционально).
    - sql_password (string): Пароль SQL (опционально, небезопасно).
    - query_timeout_sec (int): Таймаут запроса (default: 30).
.PARAMETER SuccessCriteria
    [hashtable] Необязательный. Критерии успеха для сравнения с полями в $Details.
                Формат зависит от return_format. Примеры:
                - scalar: @{ scalar_value = @{ '>=' = 10 } }
                - row_count: @{ row_count = @{ '==' = 0 } }
                - non_query: @{ non_query_success = $true } # Проверка успешности выполнения
                - first_row/all_rows: Критерии для полей внутри строки/массива (требует доработки Test-SuccessCriteria).
                Обрабатывается функцией Test-SuccessCriteria.
.PARAMETER NodeName
    [string] Необязательный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
                Поле Details (hashtable) содержит:
                - server_instance, database_name, query_executed, return_format_used
                - И ОДНО из следующих полей в зависимости от return_format:
                  - query_result (hashtable или List<object>) и rows_returned (int)
                  - row_count (int)
                  - scalar_value (any)
                  - non_query_success (bool)
                А также (при ошибке):
                - error (string)
                - ErrorRecord (string)
.NOTES
    Версия: 2.0.1 (Добавлены комментарии, форматирование, проверка модуля).
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria.
    Требует наличия модуля PowerShell 'SqlServer'.
    Требует прав доступа к SQL Server.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP, # ServerInstance

    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},

    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,

    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация переменных ---
$isAvailable = $false
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null

# Инициализируем $Details базовой информацией
$details = @{
    server_instance    = $TargetIP
    database_name      = $null
    query_executed     = $null
    return_format_used = 'first_row' # Значение по умолчанию
    # Поле с результатом будет добавлено позже
}

Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE (v2.0.1): Начало выполнения SQL на $TargetIP"

# --- Основной блок Try/Catch ---
try {
    # --- 1. Валидация и извлечение параметров ---
    Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Обработка параметров..."
    $SqlServerInstance = $TargetIP
    $DatabaseName = $Parameters.sql_database
    $SqlQuery = $Parameters.sql_query
    $SqlUsername = $Parameters.sql_username
    $SqlPassword = $Parameters.sql_password

    # Проверка обязательных параметров
    if (-not $DatabaseName) { throw "Отсутствует обязательный параметр 'sql_database'." }
    if (-not $SqlQuery) { throw "Отсутствует обязательный параметр 'sql_query'." }
    if ($SqlUsername -and (-not $SqlPassword)) { throw "Параметр 'sql_password' обязателен при указании 'sql_username'." }

    # Обновляем детали
    $details.database_name = $DatabaseName
    $details.query_executed = $SqlQuery

    # Формат возврата результата
    $ReturnFormat = 'first_row' # По умолчанию
    if ($Parameters.ContainsKey('return_format') -and -not [string]::IsNullOrWhiteSpace($Parameters.return_format)) {
        $tempFormat = $Parameters.return_format.ToLower()
        $validFormats = @('first_row', 'all_rows', 'row_count', 'scalar', 'non_query')
        if ($tempFormat -in $validFormats) { $ReturnFormat = $tempFormat }
        else { throw "Недопустимое значение 'return_format': '$($Parameters.return_format)'." }
    }
    $details.return_format_used = $ReturnFormat
    Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Используется return_format: $ReturnFormat"

    # Таймаут запроса
    $QueryTimeoutSec = 30
    if ($Parameters.ContainsKey('query_timeout_sec') -and $Parameters.query_timeout_sec -ne $null) {
        $parsedTimeout = 0
        if ([int]::TryParse($Parameters.query_timeout_sec, [ref]$parsedTimeout) -and $parsedTimeout -gt 0) {
            $QueryTimeoutSec = $parsedTimeout
        } else {
            Write-Warning "[$NodeName] Check-SQL_QUERY_EXECUTE: Некорректное 'query_timeout_sec', используется $QueryTimeoutSec сек."
        }
    }
    Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Используется query_timeout_sec: $QueryTimeoutSec сек."

    # --- 2. Формирование параметров для Invoke-Sqlcmd ---
    $invokeSqlParams = @{
        ServerInstance          = $SqlServerInstance
        Database                = $DatabaseName
        Query                   = $SqlQuery
        QueryTimeout            = $QueryTimeoutSec
        ErrorAction             = 'Stop' # Перехватываем ошибки SQL
        TrustServerCertificate  = $true
    }
    if ($SqlUsername) {
        Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Используется SQL Server аутентификация для '$SqlUsername'."
        $securePassword = ConvertTo-SecureString -String $SqlPassword -AsPlainText -Force
        $invokeSqlParams.Credential = New-Object System.Management.Automation.PSCredential($SqlUsername, $securePassword)
    } else {
        Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Используется Windows аутентификация."
    }

    # --- 3. Проверка и загрузка модуля SqlServer ---
    if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
        if (-not (Get-Module -ListAvailable -Name SqlServer)) {
            throw "Модуль PowerShell 'SqlServer' не найден. Установите его: Install-Module SqlServer"
        }
        try {
            Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Загрузка модуля SqlServer..."
            Import-Module SqlServer -ErrorAction Stop
        } catch {
            throw "Не удалось загрузить модуль 'SqlServer'. Ошибка: $($_.Exception.Message)"
        }
    }

    # --- 4. Выполнение SQL-запроса ---
    Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Выполнение запроса к '$SqlServerInstance/$DatabaseName'..."
    $queryResultData = $null # Результат выполнения команды

    # Для non_query нужно перехватывать ошибку, чтобы понять, был ли успех
    if ($ReturnFormat -eq 'non_query') {
        try {
            Invoke-Sqlcmd @invokeSqlParams | Out-Null # Игнорируем вывод, если он есть
            $isAvailable = $true
            $details.non_query_success = $true # Запрос выполнен без ошибок
            Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Non-query запрос выполнен успешно."
        } catch {
            # Ошибка при выполнении non-query
            $isAvailable = $false # Считаем проверку неуспешной
            $exceptionMessage = $_.Exception.Message
            if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
            $errorMessage = "Ошибка выполнения non-query SQL: $exceptionMessage"
            $details.error = $errorMessage
            $details.ErrorRecord = $_.ToString()
            $details.non_query_success = $false
            Write-Warning "[$NodeName] Check-SQL_QUERY_EXECUTE: $errorMessage"
        }
    } else {
        # Для запросов, возвращающих данные
        $queryResultData = Invoke-Sqlcmd @invokeSqlParams
        $isAvailable = $true # Если нет исключения, запрос выполнен
        Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Запрос, возвращающий данные, выполнен."
    }

    # --- 5. Обработка результата (если это не non_query и запрос был успешен) ---
    if ($isAvailable -and $ReturnFormat -ne 'non_query') {
        Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Обработка результата (формат: $ReturnFormat)..."

        # --- СОЗДАЕМ ДЕТАЛИ ЗАПРОСА ЗАНОВО ВНУТРИ БЛОКА ---
        $details = @{
            server_instance    = $SqlServerInstance
            database_name      = $DatabaseName
            query_executed     = $SqlQuery
            return_format_used = $ReturnFormat
            # Добавляем сюда поля, специфичные для формата
        }

        switch ($ReturnFormat) {
            'first_row' {
                $resultHashTable = $null
                $rowCount = 0
                if ($queryResultData -ne $null) {
                    $resultArray = @($queryResultData)
                    if ($resultArray.Length -gt 0) {
                        $firstRow = $resultArray[0]
                        $resultHashTable = @{}
                        $firstRow.PSObject.Properties | ForEach-Object { $resultHashTable[$_.Name] = $_.Value }
                        $rowCount = $resultArray.Length
                    }
                }
                $details.Add('query_result', $resultHashTable) # Добавляем поле
                $details.Add('rows_returned', $rowCount)     # Добавляем поле
                Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: first_row результат обработан. Строк: $rowCount."
            }
            'all_rows' {
                $allRowsList = [System.Collections.Generic.List[object]]::new()
                $rowCount = 0
                if ($queryResultData -ne $null) {
                    foreach ($row in @($queryResultData)) {
                        $rowHashTable = @{}
                        $row.PSObject.Properties | ForEach-Object { $rowHashTable[$_.Name] = $_.Value }
                        $allRowsList.Add($rowHashTable)
                    }
                    $rowCount = $allRowsList.Count
                }
                $details.Add('query_result', $allRowsList) # Добавляем поле
                $details.Add('rows_returned', $rowCount)  # Добавляем поле
                Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: all_rows результат обработан. Строк: $rowCount."
            }
            'row_count' {
                $rowCount = 0
                if ($queryResultData -ne $null) { $rowCount = @($queryResultData).Length }
                $details.Add('row_count', $rowCount) # Добавляем поле
                Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: row_count результат обработан. Строк: $rowCount."
            }
            'scalar' {
                $scalarValue = $null
                if ($queryResultData -ne $null) {
                    $firstRow = @($queryResultData)[0]
                    if ($firstRow) {
                        $firstColumnName = ($firstRow.PSObject.Properties | Select-Object -First 1).Name
                        if ($firstColumnName) { $scalarValue = $firstRow.$firstColumnName }
                    }
                }
                $details.Add('scalar_value', $scalarValue) # Добавляем поле
                Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: scalar результат обработан. Значение: '$scalarValue'."
            }
        } # Конец switch

        # --- 6. Вызов универсальной функции проверки критериев (ИСПОЛЬЗУЕМ ЗАПОЛНЕННЫЙ $details) ---
        $failReason = $null
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Вызов Test-SuccessCriteria..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason
            if ($checkSuccess -eq $null) {
                $errorMessage = "Ошибка при обработке SuccessCriteria: $failReason"
                Write-Warning "[$NodeName] $errorMessage"
            } elseif ($checkSuccess -eq $false) {
                $errorMessage = $failReason
                Write-Verbose "[$NodeName] ... SuccessCriteria НЕ пройдены: $failReason"
            } else {
                $errorMessage = $null
                Write-Verbose "[$NodeName] ... SuccessCriteria пройдены."
            }
        } else {
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] ... SuccessCriteria не заданы, CheckSuccess=true."
        }

    } elseif ($ReturnFormat -eq 'non_query' -and $isAvailable) {
        # Для non_query, который прошел без SQL ошибки
        $checkSuccess = $true # Считаем успешным, если нет критериев
        $errorMessage = $null
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE: Вызов Test-SuccessCriteria для non_query..."
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            if ($checkSuccess -ne $true) { $errorMessage = $criteriaResult.FailReason }
        }
    } else {
        # Если IsAvailable = $false (ошибка SQL или подключения)
        $checkSuccess = $null
        if ([string]::IsNullOrEmpty($errorMessage)) {
            $errorMessage = "Ошибка выполнения SQL запроса (IsAvailable=false)."
        }
    }

    # --- 7. Формирование итогового результата (используем $details, сформированный выше) ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

} catch {
    # --- Обработка КРИТИЧЕСКИХ ОШИБОК ---
    $isAvailable = $false
    $checkSuccess = $null
    $exceptionMessage = $_.Exception.Message
    if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
    $critErrorMessage = "Критическая ошибка при выполнении SQL-запроса: {0}" -f $exceptionMessage
    $detailsError = @{
        error           = $critErrorMessage
        ErrorRecord     = $_.ToString()
        server_instance = $TargetIP
        database_name   = $Parameters?.sql_database
        query_executed  = $Parameters?.sql_query
    }
    $finalResult = @{
        IsAvailable  = $isAvailable
        CheckSuccess = $checkSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $detailsError
        ErrorMessage = $critErrorMessage
    }
    Write-Error "[$NodeName] Check-SQL_QUERY_EXECUTE: Критическая ошибка: $critErrorMessage"
}

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-SQL_QUERY_EXECUTE (v2.0.1): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_QUERY_EXECUTE.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1
# --- Версия 2.0 ---
# Изменения:
# - Логика проверки SuccessCriteria вынесена в универсальную функцию Test-SuccessCriteria.
# - Стандартизирован формат $Details (основные данные в extracted_data).
# - Добавлен вызов Test-SuccessCriteria.

<#
.SYNOPSIS
    Выполняет SQL-запрос, извлекает XML, парсит и извлекает значения ключей. (v2.0)
.DESCRIPTION
    Подключается к MS SQL Server, выполняет SQL-запрос, ожидает XML
    в указанном столбце первой строки результата, парсит XML и извлекает
    текстовые значения элементов по заданному списку ключей.
    Формирует стандартизированный $Details с результатом в поле 'extracted_data'.
    Для определения итогового CheckSuccess использует универсальную функцию
    Test-SuccessCriteria, сравнивающую $Details с переданным $SuccessCriteria.
.PARAMETER TargetIP
    [string] Обязательный. Имя или IP-адрес экземпляра SQL Server.
.PARAMETER Parameters
    [hashtable] Обязательный. Содержит параметры:
    - sql_database (string): Имя БД. Обязательно.
    - sql_query (string): SQL-запрос (возвращающий XML). Обязательно.
    - xml_column_name (string): Имя столбца с XML. Обязательно.
    - keys_to_extract (string[]): Массив имен XML-элементов (ключей) для извлечения. Обязательно.
    - sql_username (string): Имя пользователя SQL (опционально).
    - sql_password (string): Пароль SQL (опционально, небезопасно).
    - query_timeout_sec (int): Таймаут запроса (default: 30).
.PARAMETER SuccessCriteria
    [hashtable] Необязательный. Критерии успеха для сравнения с полем 'extracted_data' в $Details.
                Пример: @{ extracted_data = @{ VersionStat = '20231201'; ErrorCode = @{ '<' = 1 } } }
                Обрабатывается функцией Test-SuccessCriteria.
.PARAMETER NodeName
    [string] Необязательный. Имя узла для логирования.
.OUTPUTS
    Hashtable - Стандартизированный объект результата проверки.
                Поле Details (hashtable) содержит:
                - server_instance (string)
                - database_name (string)
                - query_executed (string)
                - xml_source_column (string)
                - rows_returned (int)
                - extracted_data (hashtable): Хэш-таблица с извлеченными ключ-значение.
                - message (string): Опциональное сообщение.
                - error (string): Сообщение об ошибке SQL или парсинга XML.
                - ErrorRecord (string): Полный текст исключения.
                - xml_content_sample (string): Фрагмент XML при ошибке парсинга.
.NOTES
    Версия: 2.0.1 (Добавлены комментарии, форматирование, проверка модуля).
    Зависит от функций New-CheckResultObject и Test-SuccessCriteria.
    Требует наличия модуля PowerShell 'SqlServer'.
    Требует прав доступа к SQL Server.
#>
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP, # Используется как ServerInstance

    [Parameter(Mandatory = $false)]
    [hashtable]$Parameters = @{},

    [Parameter(Mandatory = $false)]
    [hashtable]$SuccessCriteria = $null,

    [Parameter(Mandatory = $false)]
    [string]$NodeName = "Unknown Node"
)

# --- Инициализация переменных ---
$isAvailable = $false
$checkSuccess = $null
$errorMessage = $null
$finalResult = $null
# Инициализируем $Details базовой информацией и пустым extracted_data
$details = @{
    server_instance   = $TargetIP
    database_name     = $null
    query_executed    = $null
    xml_source_column = $null
    rows_returned     = 0
    extracted_data    = @{} # Здесь будут извлеченные ключ-значение
    # Поле message или error будет добавлено при необходимости
}

Write-Verbose "[$NodeName] Check-SQL_XML_QUERY (v2.0.1): Начало выполнения SQL XML запроса на $TargetIP"

# --- Основной блок Try/Catch ---
try {
    # --- 1. Валидация и извлечение параметров ---
    Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Обработка параметров..."
    $SqlServerInstance = $TargetIP
    $DatabaseName = $Parameters.sql_database
    $SqlQuery = $Parameters.sql_query
    $XmlColumnName = $Parameters.xml_column_name
    $KeysToExtract = $Parameters.keys_to_extract
    $SqlUsername = $Parameters.sql_username
    $SqlPassword = $Parameters.sql_password

    # Заполняем детали известными параметрами
    $details.database_name = $DatabaseName
    $details.query_executed = $SqlQuery
    $details.xml_source_column = $XmlColumnName

    # Проверка обязательных параметров
    if (-not $DatabaseName) { throw "Отсутствует обязательный параметр 'sql_database'." }
    if (-not $SqlQuery) { throw "Отсутствует обязательный параметр 'sql_query'." }
    if (-not $XmlColumnName) { throw "Отсутствует обязательный параметр 'xml_column_name'." }
    if (-not ($KeysToExtract -is [array]) -or $KeysToExtract.Count -eq 0) {
        throw "Параметр 'keys_to_extract' должен быть непустым массивом строк."
    }
    if ($SqlUsername -and (-not $SqlPassword)) { throw "Параметр 'sql_password' обязателен при указании 'sql_username'." }

    # Таймаут запроса
    $QueryTimeoutSec = 30
    if ($Parameters.ContainsKey('query_timeout_sec') -and $Parameters.query_timeout_sec -ne $null) {
        $parsedTimeout = 0
        if ([int]::TryParse($Parameters.query_timeout_sec, [ref]$parsedTimeout) -and $parsedTimeout -gt 0) {
            $QueryTimeoutSec = $parsedTimeout
        } else { Write-Warning "[$NodeName] Check-SQL_XML_QUERY: Некорректное 'query_timeout_sec', используется $QueryTimeoutSec сек." }
    }
    Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Используется query_timeout_sec: $QueryTimeoutSec сек."

    # --- 2. Формирование параметров для Invoke-Sqlcmd ---
    $invokeSqlParams = @{
        ServerInstance = $SqlServerInstance
        Database       = $DatabaseName
        Query          = $SqlQuery
        QueryTimeout   = $QueryTimeoutSec
        ErrorAction    = 'Stop' # Перехватываем ошибки SQL        
        TrustServerCertificate = $true
    }
    if ($SqlUsername) {
        Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Используется SQL аутентификация для '$SqlUsername'."
        $securePassword = ConvertTo-SecureString -String $SqlPassword -AsPlainText -Force
        $invokeSqlParams.Credential = New-Object System.Management.Automation.PSCredential($SqlUsername, $securePassword)
    } else {
        Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Используется Windows аутентификация."
    }

    # --- 3. Проверка и загрузка модуля SqlServer ---
    if (-not (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue)) {
         if (-not (Get-Module -ListAvailable -Name SqlServer)) { throw "Модуль PowerShell 'SqlServer' не найден. Установите его." }
         try { Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Загрузка модуля SqlServer..."; Import-Module SqlServer -ErrorAction Stop }
         catch { throw "Не удалось загрузить модуль 'SqlServer'. Ошибка: $($_.Exception.Message)" }
    }

    # --- 4. Выполнение SQL-запроса ---
    Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Выполнение запроса к '$SqlServerInstance/$DatabaseName'..."
    $queryResult = Invoke-Sqlcmd @invokeSqlParams
    # Если нет исключения - считаем, что SQL-часть выполнена успешно
    $isAvailable = $true # Установим в $false, если парсинг XML или поиск столбца не удастся

    # --- 5. Обработка результата SQL и извлечение XML ---
    $xmlString = $null
    $parseXml = $false
    $errorMessageFromSqlOrXml = $null # Внутренняя ошибка этого шага

    if ($queryResult -ne $null) {
        if ($queryResult -isnot [array]) { $queryResult = @($queryResult) }
        $details.rows_returned = $queryResult.Count

        if ($queryResult.Count -gt 0) {
            $firstRow = $queryResult[0]
            Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Запрос вернул $($queryResult.Count) строк. Обработка первой."
            # Проверка наличия столбца
            if ($firstRow.PSObject.Properties.Name -contains $XmlColumnName) {
                $xmlValue = $firstRow.$XmlColumnName
                if ($xmlValue -ne $null -and $xmlValue -ne [System.DBNull]::Value) {
                    $xmlString = $xmlValue.ToString()
                    if (-not [string]::IsNullOrWhiteSpace($xmlString)) {
                         $parseXml = $true # Есть что парсить
                         Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Получен непустой XML из '$XmlColumnName'."
                    } else { $errorMessageFromSqlOrXml = "Столбец '$XmlColumnName' пуст (строка)." }
                } else { $errorMessageFromSqlOrXml = "Столбец '$XmlColumnName' пуст (NULL)." }
            } else { $errorMessageFromSqlOrXml = "Столбец '$XmlColumnName' не найден в результате запроса." }
        } else { $details.message = "SQL-запрос не вернул строк."; Write-Verbose "[$NodeName] $($details.message)" }
    } else { $details.message = "SQL-запрос не вернул данных."; Write-Verbose "[$NodeName] $($details.message)" }

    # Если на этапе извлечения XML возникла ошибка, считаем проверку неуспешной
    if ($errorMessageFromSqlOrXml) {
        $isAvailable = $false # Не смогли получить/найти XML
        $errorMessage = $errorMessageFromSqlOrXml
        $details.error = $errorMessage
        Write-Warning "[$NodeName] Check-SQL_XML_QUERY: $errorMessage"
    }

    # --- 6. Парсинг XML и извлечение ключей (только если есть что парсить и не было ошибок) ---
    if ($isAvailable -and $parseXml) {
        Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Попытка парсинга XML..."
        $xmlContentSample = $null
        $xmlDoc = $null
        try {
            # --- Шаг 1: Получаем значение из объекта DataRow ---
            # Invoke-Sqlcmd возвращает массив объектов PSCustomObject или одиночный объект
            # Доступ к свойству может вернуть разные типы, включая System.DBNull
            $xmlRawValue = $firstRow.$XmlColumnName # Получаем значение столбца

            # --- Шаг 2: Преобразуем в строку и очищаем ---
            $xmlStringForParsing = "" # Инициализируем пустой строкой
            if ($xmlRawValue -ne $null -and $xmlRawValue -ne [System.DBNull]::Value) {
                # Явно преобразуем в строку
                $xmlStringForParsing = [string]$xmlRawValue
                Write-Debug "[$NodeName] Check-SQL_XML_QUERY: Исходное значение столбца '$XmlColumnName' (тип $($xmlRawValue.GetType().Name)):`n$xmlStringForParsing"

                # Удаляем BOM и пробелы
                $xmlStringForParsing = $xmlStringForParsing.Trim()
                if ($xmlStringForParsing.StartsWith([char]0xFEFF) -or $xmlStringForParsing.StartsWith([char]0xFFFE)) {
                    $xmlStringForParsing = $xmlStringForParsing.Substring(1)
                    Write-Debug "[$NodeName] Check-SQL_XML_QUERY: Убран BOM из XML."
                }
            } else {
                Write-Warning "[$NodeName] Check-SQL_XML_QUERY: Значение в столбце '$XmlColumnName' пусто (NULL или DBNull)."
                # Оставляем $xmlStringForParsing пустым
            }

            Write-Debug "[$NodeName] Check-SQL_XML_QUERY: Очищенная строка XML для парсинга:`n$xmlStringForParsing"

            # --- Шаг 3: Проверка и парсинг ---
            if ([string]::IsNullOrWhiteSpace($xmlStringForParsing)) {
                throw "После очистки строка XML оказалась пустой."
            }
            if (-not $xmlStringForParsing.StartsWith('<')) {
                throw "Строка из столбца '$XmlColumnName' не начинается с '<' после очистки."
            }

            # Сохраняем образец для логов
            if ($xmlStringForParsing.Length > 500) { $xmlContentSample = $xmlStringForParsing.Substring(0, 500) + "..." }
            else { $xmlContentSample = $xmlStringForParsing }

            # Парсинг через .NET
            $xmlDoc = New-Object System.Xml.XmlDocument
            $xmlDoc.LoadXml($xmlStringForParsing)
            Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: XML успешно распарсен через .NET XmlDocument."

            if ($null -eq $xmlDoc.DocumentElement) { throw "Корневой элемент в XML не найден после парсинга." }

            # --- Шаг 4: Извлечение данных (код без изменений) ---
            $extractedData = @{}
            foreach ($key in $KeysToExtract) {
                $value = $null
                $xmlElement = $xmlDoc.DocumentElement.SelectSingleNode("./*[local-name()='$key']")
                if ($xmlElement -ne $null) { $value = $xmlElement.InnerText }
                $extractedData[$key] = $value
                Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Ключ '$key' = '$value'"
            }
            $details.extracted_data = $extractedData

        } catch {
            # Обработка ошибок парсинга / извлечения
            $isAvailable = $false
            $errorMessage = "Ошибка парсинга/обработки XML из '$XmlColumnName': $($_.Exception.Message)"
            if ($errorMessage.Length > 500) { $errorMessage = $errorMessage.Substring(0, 500) + "..." }
            $details.error = $errorMessage
            $details.ErrorRecord = $_.ToString()
            if ($xmlContentSample) { $details.xml_content_sample = $xmlContentSample }
            Write-Warning "[$NodeName] Check-SQL_XML_QUERY: $errorMessage"
        }
    }

    # --- 7. Вызов универсальной функции проверки критериев ---
    $failReason = $null

    # Проверяем критерии только если проверка прошла успешно
    # (т.е. SQL выполнен, столбец найден, XML распарсен, данные извлечены)
    if ($isAvailable) {
        if ($SuccessCriteria -ne $null -and $SuccessCriteria.Keys.Count -gt 0) {
            Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: Вызов Test-SuccessCriteria..."
            # Передаем $Details (где есть extracted_data) и $SuccessCriteria
            # Функция Test-SuccessCriteria должна уметь работать с вложенной структурой,
            # например, если критерий @{ extracted_data = @{ VersionStat = '2023' } }
            $criteriaResult = Test-SuccessCriteria -DetailsObject $details -CriteriaObject $SuccessCriteria
            $checkSuccess = $criteriaResult.Passed
            $failReason = $criteriaResult.FailReason

            if ($checkSuccess -eq $null) {
                $errorMessage = "Ошибка при обработке SuccessCriteria: $failReason"
                Write-Warning "[$NodeName] $errorMessage"
            } elseif ($checkSuccess -eq $false) {
                $errorMessage = $failReason # Причина провала
                Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: SuccessCriteria НЕ пройдены: $failReason"
            } else {
                $errorMessage = $null # Критерии пройдены
                Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: SuccessCriteria пройдены."
            }
        } else {
            # Критерии не заданы
            $checkSuccess = $true
            $errorMessage = $null
            Write-Verbose "[$NodeName] Check-SQL_XML_QUERY: SuccessCriteria не заданы, CheckSuccess=true."
        }
    } else {
        # Если IsAvailable = $false
        $checkSuccess = $null
        # $errorMessage уже должен быть установлен при ошибке SQL или парсинга XML
        if ([string]::IsNullOrEmpty($errorMessage)) {
            $errorMessage = "Ошибка выполнения SQL XML запроса (IsAvailable=false)."
        }
    }

    # --- 8. Формирование итогового результата ---
    $finalResult = New-CheckResultObject -IsAvailable $isAvailable `
                                         -CheckSuccess $checkSuccess `
                                         -Details $details `
                                         -ErrorMessage $errorMessage

# <<< Закрываем основной try >>>
} catch {
    # --- Обработка КРИТИЧЕСКИХ ОШИБОК ---
    # Ошибки валидации параметров, загрузки модуля, Invoke-Sqlcmd
    $isAvailable = $false
    $checkSuccess = $null
    $exceptionMessage = $_.Exception.Message
    if ($exceptionMessage.Length -gt 500) { $exceptionMessage = $exceptionMessage.Substring(0, 500) + "..." }
    $critErrorMessage = "Критическая ошибка при выполнении SQL XML запроса: {0}" -f $exceptionMessage

    # Формируем Details с ошибкой, сохраняя исходные параметры
    $detailsError = @{
        error             = $critErrorMessage
        ErrorRecord       = $_.ToString()
        server_instance   = $TargetIP
        database_name     = $Parameters.sql_database # Используем из параметров
        query_executed    = $Parameters.sql_query
        xml_source_column = $Parameters.xml_column_name
    }

    # Создаем финальный результат ВРУЧНУЮ
    $finalResult = @{
        IsAvailable  = $isAvailable
        CheckSuccess = $checkSuccess
        Timestamp    = (Get-Date).ToUniversalTime().ToString("o")
        Details      = $detailsError
        ErrorMessage = $critErrorMessage
    }
    Write-Error "[$NodeName] Check-SQL_XML_QUERY: Критическая ошибка: $critErrorMessage"
} # <<< Закрываем основной catch >>>

# --- Возврат результата ---
$isAvailableStr = if ($finalResult) { $finalResult.IsAvailable } else { '[result is null]' }
$checkSuccessStr = if ($finalResult) { $finalResult.CheckSuccess } else { '[result is null]' }
Write-Verbose "[$NodeName] Check-SQL_XML_QUERY (v2.0.1): Завершение. IsAvailable=$isAvailableStr, CheckSuccess=$checkSuccessStr"

return $finalResult
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\Check-SQL_XML_QUERY.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md ====

---

**5. `powershell/StatusMonitorAgentUtils/Checks/README-Check-CERT_EXPIRY.md`**

```markdown
# Check-CERT_EXPIRY.ps1

**Назначение:**

Этот скрипт проверяет сроки действия локально установленных сертификатов Windows.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется только для логирования, так как скрипт выполняется локально на целевой машине.
2.  Определяет список стандартных хранилищ для поиска: `Cert:\LocalMachine\My`, `Cert:\LocalMachine\WebHosting`, `Cert:\CurrentUser\My`.
3.  Извлекает параметры **фильтрации** из `$Parameters`: `subject_like`, `issuer_like`, `thumbprint`, `require_private_key`, `eku_oid`.
4.  Извлекает **обязательный** критерий успеха `min_days_left` из `$SuccessCriteria`.
5.  Извлекает опциональный параметр `min_days_warning` из `$Parameters`.
6.  Итерирует по списку хранилищ:
    *   Выполняет `Get-ChildItem` для текущего хранилища (`ErrorAction = SilentlyContinue`).
    *   Добавляет найденные сертификаты в общий список `$allFoundCertificates`.
    *   Если при доступе к хранилищу возникла ошибка, записывает ее в `$storeAccessErrors`.
7.  Если были ошибки доступа к хранилищам, устанавливает `IsAvailable = $true` (т.к. часть работы могла быть выполнена), но запоминает ошибки для `ErrorMessage`.
8.  Применяет фильтры к общему списку `$allFoundCertificates`:
    *   Приоритет отдается фильтру по `thumbprint`.
    *   Если отпечаток не указан, применяются фильтры `subject_like` и `issuer_like`.
    *   Применяются фильтры `require_private_key` и `eku_oid`, если они заданы.
9.  Если после фильтрации сертификатов не осталось, проверка считается успешной (`CheckSuccess = $true`).
10. Для каждого отфильтрованного сертификата:
    *   Рассчитывает количество дней до истечения (`days_left`).
    *   Определяет статус сертификата: `OK`, `Expired` (истек), `Expiring (Fail)` (осталось <= `min_days_left`), `Expiring (Warn)` (осталось <= `min_days_warning`), `Error` (ошибка расчета).
    *   Если статус `Expired` или `Expiring (Fail)`, устанавливает общий флаг `$overallCheckSuccess = $false` и добавляет сообщение в `$errorMessages`.
    *   Собирает информацию о сертификате (включая статус) в хэш-таблицу и добавляет ее в `$resultData.Details.certificates`.
11. Устанавливает итоговый `CheckSuccess` равным `$overallCheckSuccess`.
12. Если были ошибки (по критериям или ошибки доступа к хранилищам), формирует `ErrorMessage`.
13. Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста (используется диспетчером).
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами фильтрации.
*   `$SuccessCriteria` ([hashtable], Обязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `subject_like` ([string], Необязательный): Фильтр по имени субъекта (Common Name, CN). Можно использовать wildcard `*`. Пример: `"*.example.com"`.
*   `issuer_like` ([string], Необязательный): Фильтр по имени издателя сертификата. Можно использовать wildcard `*`. Пример: `"*My Internal CA*"`.
*   `thumbprint` ([string], Необязательный): Точный отпечаток (Thumbprint) сертификата для поиска. Если указан, фильтры `subject_like` и `issuer_like` игнорируются.
*   `require_private_key` ([bool], Необязательный, по умолч. `$false`): Искать только сертификаты, у которых есть соответствующий закрытый ключ в хранилище.
*   `eku_oid` ([string[]], Необязательный): Массив строк с идентификаторами объектов (OID) расширенного использования ключа (Extended Key Usage). Сертификат будет отобран, если он содержит *хотя бы один* из указанных OID. Примеры:
    *   `'1.3.6.1.5.5.7.3.1'` - Проверка подлинности сервера (Server Authentication - для SSL/TLS)
    *   `'1.3.6.1.5.5.7.3.2'` - Проверка подлинности клиента (Client Authentication)
    *   `'1.3.6.1.5.5.7.3.8'` - Временная метка (Time Stamping)
*   `min_days_warning` ([int], Необязательный, по умолч. 30): Количество дней до истечения, при котором статус сертификата в `$Details` будет помечен как "Expiring (Warn)". Не влияет на `CheckSuccess`.

**Критерии успеха (`$SuccessCriteria`)**:

*   `min_days_left` ([int], **Обязательный**): Минимальное количество полных дней, которое должно оставаться до истечения срока действия *каждого* найденного по фильтрам сертификата. Если хотя бы у одного сертификата осталось дней меньше или равно этому значению (или он уже истек), `CheckSuccess` будет `$false`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `certificates` (List<object>): Массив хэш-таблиц для каждого найденного и отфильтрованного сертификата. Каждая содержит:
        *   `thumbprint` (string): Отпечаток.
        *   `subject` (string): Имя субъекта.
        *   `issuer` (string): Имя издателя.
        *   `not_before` (string): Дата начала действия (UTC ISO 8601).
        *   `not_after` (string): Дата окончания действия (UTC ISO 8601).
        *   `days_left` (int): Количество полных оставшихся дней.
        *   `has_private_key` (bool): Наличие закрытого ключа.
        *   `status` (string): Рассчитанный статус (`OK`, `Expired`, `Expiring (Fail)`, `Expiring (Warn)`, `Error`).
        *   `status_details` (string): Пояснение к статусу.
        *   `store_path` (string): Путь к хранилищу, где найден сертификат.
    *   `stores_checked` (string[]): Список путей к хранилищам, в которых производился поиск.
    *   `message` (string): (Опционально) Сообщение, если сертификаты не найдены.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Проверить все SSL-сертификаты сервера (>30 дней)
{
  "node_id": 50,
  "method_id": 7, // ID для CERT_EXPIRY
  "is_enabled": true,
  "parameters": {
    "eku_oid": ["1.3.6.1.5.5.7.3.1"], // Server Auth
    "require_private_key": true,
    "min_days_warning": 60 // Предупреждать за 60 дней
  },
  "success_criteria": {
    "min_days_left": 30 // Должно оставаться больше 30 дней
  },
  "description": "Проверка SSL сертификатов сервера (>30 дней)"
}

// Пример 2: Проверить конкретный сертификат по отпечатку (>90 дней)
{
  "node_id": 51,
  "method_id": 7,
  "is_enabled": true,
  "parameters": {
    "thumbprint": "ВАШ_ОТПЕЧАТОК_СЕРТИФИКАТА_ЗДЕСЬ"
  },
  "success_criteria": {
    "min_days_left": 90
  },
  "description": "Проверка конкретного сертификата по отпечатку (>90 дней)"
}

Возможные ошибки и замечания:

    Права доступа: Для доступа к хранилищу LocalMachine требуются права администратора. Доступ к CurrentUser обычно есть у пользователя, от имени которого запущен агент.

    Доступность хранилищ: Если какое-то из стандартных хранилищ отсутствует или недоступно, скрипт запишет ошибку, но продолжит проверку остальных.

    Фильтрация: Убедитесь, что параметры фильтрации (subject_like, thumbprint и т.д.) заданы корректно для поиска нужных сертификатов. Если фильтры не заданы, будут проверяться все сертификаты в стандартных хранилищах.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-CERT_EXPIRY.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md ====

---

**3. `powershell/StatusMonitorAgentUtils/Checks/README-Check-DISK_USAGE.md`**

```markdown
# Check-DISK_USAGE.ps1

**Назначение:**

Этот скрипт проверяет использование дискового пространства на локальных дисках, используя командлет `Get-Volume`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` напрямую не используется, так как скрипт выполняется локально на целевой машине (через `Invoke-Command`, если нужно).
2.  Вызывает `Get-Volume` для получения информации обо всех томах. Если команда не выполняется, устанавливает `IsAvailable = $false`.
3.  Фильтрует полученные тома:
    *   Оставляет только диски с `DriveType = 'Fixed'`.
    *   Оставляет только диски, имеющие букву (`DriveLetter`).
    *   Если в `$Parameters.drives` передан массив букв, оставляет только диски из этого списка (регистр не важен).
4.  Если после фильтрации дисков не осталось, проверка считается успешной (`CheckSuccess = $true`), в `$Details` добавляется соответствующее сообщение.
5.  Для каждого отфильтрованного диска:
    *   Рассчитывает общий размер, свободное/занятое место в байтах и ГБ, процент свободного/занятого места.
    *   Ищет применимый критерий успеха в `$SuccessCriteria`: сначала по букве диска (в верхнем регистре), затем по ключу `_default_`.
    *   Если найден критерий `min_percent_free`:
        *   Сравнивает рассчитанный процент свободного места с критерием.
        *   Устанавливает `criteria_passed = $true/$false` и `criteria_failed_reason`.
        *   Если критерий не пройден, устанавливает общий флаг `$overallCheckSuccess = $false` и добавляет сообщение в `$errorMessages`.
        *   Если значение `min_percent_free` некорректно, также считает критерий не пройденным.
    *   Добавляет собранную информацию о диске (включая результаты проверки критерия) в массив `$resultData.Details.disks`.
6.  Устанавливает итоговый `CheckSuccess` равным `$overallCheckSuccess`.
7.  Если были ошибки по критериям, объединяет сообщения из `$errorMessages` и записывает в `ErrorMessage`.
8.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста (используется диспетчером).
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `drives` ([string[]], Необязательный): Массив строк с буквами дисков, которые нужно проверить (например, `@('C', 'D')`). Регистр не важен. Если не указан или пуст, проверяются все локальные диски типа 'Fixed'.

**Критерии успеха (`$SuccessCriteria`)**:

*   Ожидается хэш-таблица, где ключи - **большие** буквы дисков ('C', 'D', ...) или специальный ключ `_default_`.
*   Значения - хэш-таблицы, содержащие критерии.
*   Поддерживаемый критерий:
    *   `min_percent_free` ([int], Необязательный): Минимально допустимый процент свободного места на диске. Если фактический процент меньше этого значения, `CheckSuccess` будет `$false`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `disks` (List<object>): Массив хэш-таблиц, по одной для каждого проверенного диска. Каждая хэш-таблица содержит:
        *   `drive_letter` (string)
        *   `label` (string)
        *   `filesystem` (string)
        *   `size_bytes` (long), `free_bytes` (long), `used_bytes` (long)
        *   `size_gb` (double), `free_gb` (double), `used_gb` (double)
        *   `percent_free` (double), `percent_used` (double)
        *   `criteria_applied` (hashtable/null): Примененный критерий.
        *   `criteria_passed` (bool/null): Результат проверки критерия.
        *   `criteria_failed_reason` (string/null): Причина провала критерия.
    *   `message` (string): (Опционально) Сообщение, если диски не найдены.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Проверить все локальные Fixed диски, нужно > 10% свободно на каждом
{
  "node_id": 10,
  "method_id": 5, // ID для DISK_USAGE
  "is_enabled": true,
  "parameters": null, // Проверяем все диски
  "success_criteria": {
    "_default_": { "min_percent_free": 10 }
  },
  "description": "Проверка свободного места (>10%) на всех дисках"
}

// Пример 2: Проверить диск C (>15%) и диск D (>20%)
{
  "node_id": 10,
  "method_id": 5, // ID для DISK_USAGE
  "is_enabled": true,
  "parameters": {
    "drives": ["C", "D"] // Проверяем только C и D
  },
  "success_criteria": {
    "C": { "min_percent_free": 15 },
    "D": { "min_percent_free": 20 }
  },
  "description": "Проверка места: C>15%, D>20%"
}

GNORE_WHEN_COPYING_END

Возможные ошибки и замечания:

    Версия ОС: Командлет Get-Volume доступен начиная с Windows 8 / Windows Server 2012. На более старых системах проверка не сработает.

    Права доступа: Обычно не требует повышенных прав для локального выполнения.

    Сетевые/Съемные диски: Скрипт по умолчанию проверяет только диски с DriveType = 'Fixed'. Другие типы (Network, Removable, CD-ROM) игнорируются.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.

    ОС Windows 8 / Server 2012 или новее.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-DISK_USAGE.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md ====
# Check-PING.ps1

**Назначение:**

Этот скрипт выполняет проверку доступности сетевого узла с помощью ICMP эхо-запросов (пинг), используя стандартный командлет `Test-Connection`.

**Принцип работы:**

1.  Получает целевой IP-адрес или имя хоста (`TargetIP`) и опциональные параметры (`Parameters`) от диспетчера.
2.  Извлекает параметры для `Test-Connection` из `$Parameters`:
    *   `count` (количество запросов, по умолчанию 1).
    *   `buffer_size` (размер буфера, по умолчанию 32).
    *   `timeout_ms` (используется для расчета TTL в PowerShell 5.1, по умолчанию 1000).
3.  Выполняет `Test-Connection` к `$TargetIP`.
4.  **Если пинг успешен:**
    *   Устанавливает `IsAvailable = $true`.
    *   Извлекает время ответа (RTT) и фактический IP-адрес ответившего хоста.
    *   Заполняет `$Details` значениями `response_time_ms`, `ip_address` (ответивший), `target_ip` (запрошенный), `ping_count`.
    *   Проверяет `SuccessCriteria`: если задан `max_rtt_ms` и RTT превышает его, устанавливает `CheckSuccess = $false` и добавляет `ErrorMessage`. Иначе `CheckSuccess = $true`.
5.  **Если пинг не прошел (ошибка `Test-Connection`):**
    *   Устанавливает `IsAvailable = $false`.
    *   Записывает сообщение об ошибке в `ErrorMessage` и `Details`.
    *   `CheckSuccess` остается `$null`.
6.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста для пинга.
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами для `Test-Connection`.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `count` ([int], Необязательный, по умолч. 1): Количество ICMP-запросов.
*   `buffer_size` ([int], Необязательный, по умолч. 32): Размер буфера ICMP в байтах.
*   `timeout_ms` ([int], Необязательный, по умолч. 1000): Используется для расчета TTL в PS 5.1. Не является прямым таймаутом `Test-Connection`.

**Критерии успеха (`$SuccessCriteria`)**:

*   `max_rtt_ms` ([int], Необязательный): Максимально допустимое среднее время ответа (RTT) в миллисекундах. Если фактическое RTT больше этого значения, `CheckSuccess` будет `$false`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `response_time_ms` (int): Время ответа в мс (если пинг успешен).
    *   `ip_address` (string): Фактический IP-адрес, ответивший на пинг.
    *   `target_ip` (string): IP-адрес или имя хоста, которое пинговали.
    *   `ping_count` (int): Количество отправленных пакетов.
    *   `success_criteria_failed` (string): (Опционально) Причина неудачи по критерию `max_rtt_ms`.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Простой пинг
{
  "node_id": 15,
  "method_id": 1, // ID для PING
  "is_enabled": true,
  "parameters": {
    "count": 3 // Отправить 3 пакета
  },
  "success_criteria": null, // Критериев нет
  "description": "Пинг сервера SRV-DB (3 пакета)"
}

// Пример 2: Пинг с проверкой RTT
{
  "node_id": 22,
  "method_id": 1, // ID для PING
  "is_enabled": true,
  "parameters": null, // Параметры по умолчанию
  "success_criteria": {
    "max_rtt_ms": 100 // RTT должен быть не более 100 мс
  },
  "description": "Пинг удаленного офиса (RTT < 100ms)"
}


Возможные ошибки и замечания:

    Брандмауэр: Проверьте настройки брандмауэра на целевой машине и промежуточных устройствах (ICMP Echo Request/Reply должны быть разрешены).

    Разрешение имен: Если в качестве TargetIP используется имя хоста, машина, где выполняется скрипт, должна уметь его разрешать в IP-адрес.

    PowerShell Core vs 5.1: Командлет Test-Connection имеет разные параметры в разных версиях. Скрипт пытается это учесть, но поведение может немного отличаться. Параметры BufferSize и TimeToLive используются только в PS 5.1.

    Таймаут: Стандартный таймаут Test-Connection может быть не очень гибким. Для более точного контроля таймаута может потребоваться использование .NET классов (System.Net.NetworkInformation.Ping).

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PING.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md ====

---

**4. `powershell/StatusMonitorAgentUtils/Checks/README-Check-PROCESS_LIST.md`**

```markdown
# Check-PROCESS_LIST.ps1

**Назначение:**

Этот скрипт получает список запущенных процессов на локальной машине (или удаленной, если вызван через `Invoke-Command` диспетчером), используя командлет `Get-Process`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется только для логирования, так как `Get-Process` выполняется в контексте машины, где запущен скрипт.
2.  Формирует параметры для `Get-Process` на основе `$Parameters`:
    *   Если задан `process_names`, использует его для фильтрации по имени (с `ErrorAction = SilentlyContinue`, чтобы не падать, если процесс не найден).
    *   Если `process_names` не задан, получает все процессы (с `ErrorAction = Stop`).
3.  Вызывает `Get-Process`. Если произошла критическая ошибка (например, сам командлет не доступен), устанавливает `IsAvailable = $false`.
4.  Если `Get-Process` вернул пустой результат *при фильтрации по имени*, устанавливает `IsAvailable = $true`, `CheckSuccess = $true` и добавляет сообщение в `Details.message`.
5.  Если `Get-Process` вернул процессы:
    *   Устанавливает `IsAvailable = $true`.
    *   Итерирует по каждому объекту процесса:
        *   Извлекает базовые данные: `id`, `name`, `cpu_seconds`, `memory_ws_mb`.
        *   Опционально (если запрошено `include_username`): Пытается получить имя пользователя через `Get-CimInstance Win32_Process` (более надежный способ). Обрабатывает ошибки доступа.
        *   Опционально (если запрошено `include_path`): Пытается получить путь к исполняемому файлу из свойства `Path` или `MainModule.FileName`. Обрабатывает ошибки доступа.
        *   Опционально: Пытается получить время запуска `start_time`.
        *   Собирает данные в объект `[PSCustomObject]`.
    *   Сортирует полученный список процессов согласно параметрам `sort_by` и `sort_descending` (с поддержкой псевдонимов 'memory', 'cpu'). Обрабатывает некорректные поля сортировки.
    *   Ограничивает список первыми `top_n` элементами, если указано.
    *   Добавляет итоговый список в `$resultData.Details.processes`.
    *   Устанавливает `CheckSuccess = $true` (критерии пока не реализованы).
6.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста (используется диспетчером).
*   `$Parameters` ([hashtable], Необязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха (пока не используется).
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `process_names` ([string[]], Необязательный): Массив имен процессов для фильтрации (можно использовать `*`, например, `"sql*"`). Если не указан, выводятся все процессы.
*   `include_username` ([bool], Необязательный, по умолч. `$false`): Включать ли имя пользователя, запустившего процесс. Может требовать повышенных прав.
*   `include_path` ([bool], Необязательный, по умолч. `$false`): Включать ли путь к исполняемому файлу процесса. Может быть медленным и требовать повышенных прав.
*   `sort_by` ([string], Необязательный, по умолч. `'Name'`): Поле для сортировки. Допустимые значения (регистр не важен): `'Name'`, `'Id'`, `'CPU'` (или `'cpu_seconds'`), `'Memory'` (или `'memory_ws_mb'`, `'mem'`, `'ws'`), `'start_time'`.
*   `sort_descending` ([bool], Необязательный, по умолч. `$false`): Сортировать по убыванию?
*   `top_n` ([int], Необязательный): Отобразить только указанное количество процессов после сортировки.

**Критерии успеха (`$SuccessCriteria`)**:

*   **Пока не реализованы.** В текущей версии `CheckSuccess` всегда `$true`, если `IsAvailable = $true`.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `processes` (List<object>): Массив хэш-таблиц, по одной для каждого процесса (или пустой). Каждая хэш-таблица содержит:
        *   `id` (int)
        *   `name` (string)
        *   `cpu_seconds` (double/null): Общее время процессора в секундах.
        *   `memory_ws_mb` (double/null): Рабочий набор памяти в МБ.
        *   `username` (string/null): Имя пользователя (если запрошено и доступно).
        *   `path` (string/null): Путь к файлу (если запрошено и доступно).
        *   `start_time` (string/null): Время запуска в UTC ISO 8601 (если доступно).
    *   `message` (string): (Опционально) Сообщение, если процессы по фильтру не найдены.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Топ 3 процесса по использованию памяти
{
  "node_id": 40,
  "method_id": 2, // ID для PROCESS_LIST
  "is_enabled": true,
  "parameters": {
    "sort_by": "Memory",
    "sort_descending": true,
    "top_n": 3,
    "include_username": false,
    "include_path": true // Получим путь
  },
  "success_criteria": null,
  "description": "Топ 3 процесса по памяти (с путем)"
}

// Пример 2: Проверить наличие процесса explorer.exe
{
  "node_id": 41,
  "method_id": 2, // ID для PROCESS_LIST
  "is_enabled": true,
  "parameters": {
    "process_names": ["explorer.exe"], // Ищем конкретный процесс
    "include_username": true // Получим пользователя
  },
  "success_criteria": null, // Пока не можем проверить, найден ли он
  "description": "Проверка наличия explorer.exe"
}


Возможные ошибки и замечания:

    Права доступа: Для получения username и path для всех процессов (особенно системных или запущенных другими пользователями) могут потребоваться права администратора. При недостатке прав соответствующие поля будут содержать [Ошибка доступа] или [Недоступен].

    Производительность: Получение path и username (особенно через WMI) может быть ресурсоемким, особенно при проверке большого количества процессов или на слабых машинах. Используйте include_username = $true и include_path = $true с осторожностью.

    Сортировка: Используются базовые свойства для сортировки. Сортировка по CPU может быть не всегда точной из-за того, как Get-Process его измеряет.

    Критерии: Реализация критериев успеха (например, проверка существования/отсутствия процесса, пороговые значения CPU/памяти) потребует доработки скрипта.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-PROCESS_LIST.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md ====

---

**2. `powershell/StatusMonitorAgentUtils/Checks/README-Check-SERVICE_STATUS.md`**

```markdown
# Check-SERVICE_STATUS.ps1

**Назначение:**

Этот скрипт проверяет статус указанной системной службы Windows с помощью командлета `Get-Service`.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера.
2.  Извлекает обязательное имя службы из `$Parameters.service_name`.
3.  Определяет, является ли `$TargetIP` удаленным хостом. Если да, будет использовать параметр `-ComputerName` для `Get-Service` (при вызове через `Invoke-Command`).
4.  Вызывает `Get-Service` с указанным именем и (если нужно) `-ComputerName`.
5.  **Если `Get-Service` вернул объект службы:**
    *   Устанавливает `IsAvailable = $true`.
    *   Извлекает текущий статус (`Running`, `Stopped`, `Paused`, etc.), отображаемое имя, тип запуска.
    *   Заполняет `$Details` этой информацией.
    *   Проверяет `$SuccessCriteria`: если задан ключ `status`, сравнивает текущий статус с требуемым. Если `SuccessCriteria.status` не задан, по умолчанию ожидает статус `'Running'`. Устанавливает `CheckSuccess` в `$true` или `$false` и `ErrorMessage`, если статус не соответствует.
6.  **Если `Get-Service` выдал ошибку `ServiceCommandException` (служба не найдена):**
    *   Устанавливает `IsAvailable = $false`.
    *   `CheckSuccess` остается `$null`.
    *   Записывает сообщение "Служба не найдена" в `ErrorMessage` и `Details`.
7.  **Если `Get-Service` выдал другую ошибку (нет доступа, RPC недоступен и т.д.):**
    *   Устанавливает `IsAvailable = $false`.
    *   `CheckSuccess` остается `$null`.
    *   Записывает сообщение об ошибке в `ErrorMessage` и `Details`.
8.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): IP-адрес или имя хоста. Используется диспетчером для `Invoke-Command`.
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха.
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `service_name` ([string], **Обязательный**): Имя службы Windows (короткое, например, 'Spooler', 'wuauserv').

**Критерии успеха (`$SuccessCriteria`)**:

*   `status` ([string], Необязательный, по умолч. `'Running'`): Ожидаемый статус службы. `CheckSuccess` будет `$true`, только если текущий статус службы равен этому значению. Допустимые значения зависят от `Get-Service` (обычно 'Running', 'Stopped', 'Paused').

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `service_name` (string): Имя проверенной службы.
    *   `status` (string): Текущий статус службы (если удалось получить).
    *   `display_name` (string): Отображаемое имя службы.
    *   `start_type` (string): Тип запуска службы.
    *   `can_stop` (bool): Может ли служба быть остановлена.
    *   `success_criteria_failed` (string): (Опционально) Причина несоответствия критерию `status`.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Проверить, что служба 'wuauserv' запущена
{
  "node_id": 55,
  "method_id": 4, // ID для SERVICE_STATUS
  "is_enabled": true,
  "parameters": {
    "service_name": "wuauserv"
  },
  "success_criteria": null, // Используется критерий по умолчанию (status = 'Running')
  "description": "Проверка службы Windows Update"
}

// Пример 2: Проверить, что служба 'BITS' остановлена
{
  "node_id": 55,
  "method_id": 4, // ID для SERVICE_STATUS
  "is_enabled": true,
  "parameters": {
    "service_name": "BITS"
  },
  "success_criteria": {
    "status": "Stopped" // Явно указываем ожидаемый статус
  },
  "description": "Проверка, что служба BITS остановлена"
}

Возможные ошибки и замечания:

    Права доступа: Для проверки служб на удаленной машине с помощью Get-Service -ComputerName (через Invoke-Command) требуются соответствующие права (обычно административные) и настроенный WinRM.

    Имя службы: Убедитесь, что service_name указано правильно (короткое имя, а не отображаемое).

    WinRM: При удаленных проверках необходима корректная настройка WinRM на целевой машине и, возможно, на машине агента (TrustedHosts или Kerberos/HTTPS).

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SERVICE_STATUS.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md ====

---

**7. `powershell/StatusMonitorAgentUtils/Checks/README-Check-SQL_QUERY_EXECUTE.md`**

```markdown
# Check-SQL_QUERY_EXECUTE.ps1

**Назначение:**

Этот скрипт выполняет произвольный SQL-запрос к Microsoft SQL Server и возвращает результат в заданном формате.

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется как имя SQL Server instance.
2.  Извлекает и валидирует обязательные параметры из `$Parameters`: `sql_database`, `sql_query`.
3.  Извлекает опциональный параметр `return_format` (по умолчанию `'first_row'`) и валидирует его значение.
4.  Извлекает опциональные параметры для SQL-аутентификации (`sql_username`, `sql_password`) и таймаут запроса (`query_timeout_sec`).
5.  Проверяет наличие модуля `SqlServer`. Если отсутствует, генерирует ошибку (`IsAvailable = $false`).
6.  Формирует параметры для `Invoke-Sqlcmd`, включая учетные данные.
7.  Выполняет SQL-запрос с помощью `Invoke-Sqlcmd`. Если произошла ошибка, устанавливает `IsAvailable = $false` и записывает ошибку.
8.  Если запрос выполнен успешно:
    *   Устанавливает `IsAvailable = $true` и `CheckSuccess = $true` (критерии пока не реализованы).
    *   Обрабатывает результат `$queryResultData` в соответствии с указанным `return_format`:
        *   `first_row`: Преобразует первую строку `DataRow` в хэш-таблицу и записывает в `Details.query_result`.
        *   `all_rows`: Преобразует все строки `DataRow` в массив хэш-таблиц и записывает в `Details.query_result`.
        *   `row_count`: Записывает количество строк в `Details.row_count`.
        *   `scalar`: Извлекает значение из первого столбца первой строки и записывает в `Details.scalar_value`.
        *   `non_query`: Записывает `$true` в `Details.non_query_success`.
    *   Записывает количество возвращенных строк (если применимо) в `Details.rows_returned`.
9.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): Имя или IP-адрес SQL Server instance.
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха (пока не используется).
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `sql_database` ([string], **Обязательный**): Имя базы данных.
*   `sql_query` ([string], **Обязательный**): SQL-запрос для выполнения.
*   `return_format` ([string], Необязательный, по умолч. `'first_row'`): Как интерпретировать и вернуть результат запроса. Допустимые значения:
    *   `'first_row'`: Вернуть первую строку как хэш-таблицу (`Details.query_result`).
    *   `'all_rows'`: Вернуть все строки как массив хэш-таблиц (`Details.query_result`). **Осторожно с большими результатами!**
    *   `'row_count'`: Вернуть только количество строк (`Details.row_count`).
    *   `'scalar'`: Вернуть значение первого столбца первой строки (`Details.scalar_value`).
    *   `'non_query'`: Для запросов, не возвращающих данные (INSERT, UPDATE, DELETE, DDL). Возвращает `Details.non_query_success = $true` при успехе.
*   `sql_username` ([string], Необязательный): Имя пользователя для SQL Server аутентификации.
*   `sql_password` ([string], Необязательный): Пароль для SQL Server аутентификации. **(Небезопасно)**.
*   `query_timeout_sec` ([int], Необязательный, по умолч. 30): Таймаут выполнения SQL-запроса.

**Критерии успеха (`$SuccessCriteria`)**:

*   **Пока не реализованы.** Можно будет добавить проверку возвращенных данных, например:
    *   Для `row_count`: `{ "expected_count": 5 }`, `{ "min_count": 1 }`, `{ "max_count": 10 }`
    *   Для `scalar`: `{ "expected_value": "OK" }`, `{ "value_less_than": 100 }`
    *   Для `first_row`/`all_rows`: Проверка значений в конкретных столбцах.

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `server_instance` (string)
    *   `database_name` (string)
    *   `query_executed` (string)
    *   `return_format_used` (string)
    *   В зависимости от `return_format`:
        *   `query_result` (hashtable или List<object>): Результат для `first_row` или `all_rows`.
        *   `rows_returned` (int): Количество строк (для `first_row`, `all_rows`).
        *   `row_count` (int): Количество строк (для `row_count`).
        *   `scalar_value` (any): Скалярное значение (для `scalar`).
        *   `non_query_success` (bool): Результат выполнения (для `non_query`).
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false`.

**Пример конфигурации Задания (Assignment):**

```json
// Пример 1: Получить количество активных сессий
{
  "node_id": 61,
  "method_id": 9, // ID для SQL_QUERY_EXECUTE
  "is_enabled": true,
  "parameters": {
    "sql_database": "master",
    "sql_query": "SELECT COUNT(*) FROM sys.dm_exec_sessions WHERE is_user_process = 1;",
    "return_format": "scalar" // Вернуть одно значение
  },
  "success_criteria": null, // Можно добавить { "value_less_than": 50 }
  "description": "Количество активных SQL сессий"
}

// Пример 2: Проверить статус задачи в таблице
{
  "node_id": 61,
  "method_id": 9,
  "is_enabled": true,
  "parameters": {
    "sql_database": "ApplicationDB",
    "sql_query": "SELECT Status, LastRunTime FROM dbo.BackgroundTasks WHERE TaskName = 'DailyCleanup'",
    "return_format": "first_row" // Вернуть первую (и единственную?) строку
  },
  "success_criteria": null, // Можно добавить { "expected_Status": "Completed" }
  "description": "Статус задачи DailyCleanup"
}

// Пример 3: Выполнить процедуру очистки (non-query)
{
  "node_id": 61,
  "method_id": 9,
  "is_enabled": true,
  "parameters": {
    "sql_database": "ApplicationDB",
    "sql_query": "EXEC dbo.sp_CleanupOldLogs;",
    "return_format": "non_query" // Ожидаем просто успешное выполнение
  },
  "success_criteria": null,
  "description": "Запуск процедуры очистки логов"
}

Возможные ошибки и замечания:

    Модуль SqlServer: Требуется установка Install-Module SqlServer.

    Права доступа к SQL: Права на подключение, доступ к БД, выполнение запроса.

    Безопасность пароля: Избегайте хранения паролей в параметрах.

    all_rows: Используйте с осторожностью, если запрос может вернуть очень много строк, так как это может потребить много памяти и времени.

    non_query: CheckSuccess=true означает только, что запрос выполнен без синтаксических ошибок или ошибок доступа. Он не гарантирует, что запрос сделал то, что ожидалось (например, UPDATE мог не затронуть ни одной строки). Для этого нужны SuccessCriteria.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.

    Модуль PowerShell SqlServer.

    Доступ к MS SQL Server.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_QUERY_EXECUTE.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md ====

---

**6. `powershell/StatusMonitorAgentUtils/Checks/README-Check-SQL_XML_QUERY.md`**

```markdown
# Check-SQL_XML_QUERY.ps1

**Назначение:**

Этот скрипт выполняет SQL-запрос к Microsoft SQL Server, извлекает XML-данные из указанного столбца первой строки результата, парсит этот XML и извлекает значения по заданному списку ключей (имен элементов).

**Принцип работы:**

1.  Получает параметры (`TargetIP`, `Parameters`, `SuccessCriteria`, `NodeName`) от диспетчера. `$TargetIP` используется как имя SQL Server instance.
2.  Извлекает и валидирует обязательные параметры из `$Parameters`: `sql_database`, `sql_query`, `xml_column_name`, `keys_to_extract`.
3.  Извлекает опциональные параметры для SQL-аутентификации (`sql_username`, `sql_password`) и таймаут запроса (`query_timeout_sec`).
4.  Проверяет наличие модуля `SqlServer` на машине выполнения. Если модуль отсутствует, генерирует ошибку (`IsAvailable = $false`).
5.  Формирует параметры для `Invoke-Sqlcmd`, включая учетные данные (Windows Auth по умолчанию или SQL Auth, если переданы `sql_username`/`sql_password`).
6.  Выполняет SQL-запрос с помощью `Invoke-Sqlcmd`. Если произошла ошибка подключения или выполнения запроса, устанавливает `IsAvailable = $false` и записывает ошибку.
7.  Если запрос выполнен успешно:
    *   Устанавливает `IsAvailable = $true`.
    *   Проверяет результат:
        *   Если результат пустой (0 строк), устанавливает `CheckSuccess = $true` и добавляет сообщение в `Details.message`.
        *   Если строки есть, берет первую строку.
        *   Проверяет наличие столбца `$xml_column_name` в первой строке. Если столбца нет или он `NULL`, устанавливает `CheckSuccess = $false` и записывает `ErrorMessage`.
        *   Если столбец найден и содержит данные, пытается преобразовать его содержимое в XML (`[xml]$xmlString`).
        *   Если парсинг XML неудачен, устанавливает `CheckSuccess = $false` и записывает `ErrorMessage` с деталями ошибки и примером XML.
        *   Если XML распарсен успешно:
            *   Итерирует по списку `$keys_to_extract`.
            *   Для каждого ключа пытается найти соответствующий дочерний элемент у корневого элемента XML.
            *   Извлекает текстовое содержимое найденного элемента (или `$null`, если элемент не найден).
            *   Записывает найденные пары ключ-значение в `$resultData.Details.extracted_data`.
            *   Устанавливает `CheckSuccess = $true` (пока нет реализованных критериев для данных).
8.  Возвращает стандартизированный объект результата с помощью `New-CheckResultObject`.

**Параметры скрипта:**

*   `$TargetIP` ([string], Обязательный): Имя или IP-адрес SQL Server instance (например, `SERVER\SQLEXPRESS` или `192.168.1.100`).
*   `$Parameters` ([hashtable], Обязательный): Хэш-таблица с параметрами.
*   `$SuccessCriteria` ([hashtable], Необязательный): Хэш-таблица с критериями успеха (пока не используется).
*   `$NodeName` ([string], Необязательный): Имя узла для логирования.

**Параметры задания (`$Parameters`)**:

*   `sql_database` ([string], **Обязательный**): Имя базы данных для подключения.
*   `sql_query` ([string], **Обязательный**): SQL-запрос, который необходимо выполнить. Запрос должен возвращать как минимум одну строку со столбцом, указанным в `xml_column_name`.
*   `xml_column_name` ([string], **Обязательный**): Имя столбца в результате запроса, который содержит XML-данные для парсинга.
*   `keys_to_extract` ([string[]], **Обязательный**): Массив строк, содержащий имена XML-элементов (ключей), значения которых нужно извлечь. Предполагается, что эти элементы являются прямыми потомками корневого элемента XML.
*   `sql_username` ([string], Необязательный): Имя пользователя для SQL Server аутентификации. Если не указано, используется Windows-аутентификация учетной записи, от имени которой запущен скрипт.
*   `sql_password` ([string], Необязательный): Пароль для SQL Server аутентификации. **Использовать с большой осторожностью! Хранение паролей в параметрах небезопасно.** Рекомендуется использовать Windows-аутентификацию.
*   `query_timeout_sec` ([int], Необязательный, по умолч. 30): Таймаут ожидания выполнения SQL-запроса в секундах.

**Критерии успеха (`$SuccessCriteria`)**:

*   **Пока не реализованы.** Можно будет добавить проверку значений извлеченных ключей (например, `$SuccessCriteria = @{ expected_VersionStat = '20230101' }`).

**Возвращаемый результат:**

*   Стандартный объект (`IsAvailable`, `CheckSuccess`, `Timestamp`, `Details`, `ErrorMessage`).
*   `$Details` содержит:
    *   `server_instance` (string): Имя SQL Server instance.
    *   `database_name` (string): Имя базы данных.
    *   `query_executed` (string): Выполненный SQL-запрос.
    *   `xml_source_column` (string): Имя столбца, из которого брался XML.
    *   `rows_returned` (int): Количество строк, возвращенных запросом.
    *   `extracted_data` (hashtable): Хэш-таблица с извлеченными данными (ключ - имя элемента, значение - его текстовое содержимое или `$null`, если не найден).
    *   `message` (string): (Опционально) Сообщение, если запрос не вернул строк.
    *   `error` (string): (Опционально) Сообщение об ошибке, если `IsAvailable = $false` или `CheckSuccess = $false`.
    *   `xml_content_sample` (string): (Опционально) Начало XML-строки, если произошла ошибка парсинга.

**Пример конфигурации Задания (Assignment):**

```json
// Пример: Получить VersionStat и TS_Version из столбца Revise
{
  "node_id": 60, // ID узла, представляющего SQL сервер или приложение
  "method_id": 8, // ID для SQL_XML_QUERY
  "is_enabled": true,
  "parameters": {
    "sql_database": "ApplicationDB",
    "sql_query": "SELECT TOP 1 Revise FROM Reports ORDER BY CreationDate DESC",
    "xml_column_name": "Revise",
    "keys_to_extract": ["VersionStat", "TS_Version"],
    "query_timeout_sec": 15
    // Используется Windows аутентификация
  },
  "success_criteria": null, // Критериев пока нет
  "description": "Получение версии ТС и статуса из последнего отчета SQL"
}

Возможные ошибки и замечания:

    Модуль SqlServer: Необходимо установить модуль SqlServer на машине, где выполняется скрипт (Install-Module SqlServer).

    Права доступа к SQL: Учетная запись, от имени которой запускается скрипт (или указанный SQL-пользователь), должна иметь права на подключение к SQL Server, доступ к указанной базе данных и права на выполнение переданного sql_query.

    Безопасность пароля: КАТЕГОРИЧЕСКИ НЕ РЕКОМЕНДУЕТСЯ хранить пароли SQL в параметрах задания. Используйте Windows-аутентификацию или другие безопасные методы управления учетными данными.

    Структура XML: Скрипт предполагает, что искомые ключи (keys_to_extract) являются прямыми дочерними элементами корневого элемента XML. Для более сложных XML-структур потребуется доработка логики извлечения.

    Производительность: Сложные SQL-запросы или запросы, возвращающие большие XML, могут выполняться долго. Настройте query_timeout_sec соответственно.

    Обработка результата: Скрипт обрабатывает только первую строку результата SQL-запроса.

Зависимости:

    Функция New-CheckResultObject из StatusMonitorAgentUtils.psm1.
    Модуль PowerShell SqlServer.
    Доступ к MS SQL Server.
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\Checks\README-Check-SQL_XML_QUERY.md ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 ====
# F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1
# --- Версия 2.0 ---
# Тесты для Check-PING.ps1 v2.0 с мокированием Test-SuccessCriteria

# Requires -Modules @{ ModuleName = 'Pester'; RequiredVersion = '5.0' }

# --- Определяем New-CheckResultObject Inline (можно вынести в общий файл) ---
# Версия 1.3 (без авто-сообщения для CheckSuccess=false)
function New-CheckResultObject {
    [CmdletBinding()] param([Parameter(Mandatory=$true)][bool]$IsAvailable, [Parameter(Mandatory=$false)][nullable[bool]]$CheckSuccess=$null, [Parameter(Mandatory=$false)][hashtable]$Details=$null, [Parameter(Mandatory=$false)][string]$ErrorMessage=$null)
    $result = [ordered]@{ IsAvailable=$IsAvailable; CheckSuccess=$CheckSuccess; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=$Details; ErrorMessage=$ErrorMessage }
    if ($result.IsAvailable) { if ($result.CheckSuccess -eq $null) { $result.CheckSuccess = $true } }
    else { $result.CheckSuccess = $null }
    if ([string]::IsNullOrEmpty($result.ErrorMessage)) { if (-not $result.IsAvailable) { $result.ErrorMessage = "Ошибка выполнения проверки (IsAvailable=false)." } }
    return $result
}
Write-Host "INFO: Inline New-CheckResultObject v1.3 defined..." -ForegroundColor Yellow

# --- Настройка перед тестами ---
Describe 'Check-PING.ps1 (v2.0)' {

    $script:scriptPath = $null
    BeforeAll {
        # Получаем путь к скрипту проверки
        try {
            $script:scriptPath = Resolve-Path (Join-Path -Path $PSScriptRoot -ChildPath '..\Checks\Check-PING.ps1') -EA Stop
            Write-Host "INFO: Script path: $($script:scriptPath)" -FC Cyan
        } catch {
            Write-Error "FATAL: Cannot resolve script path. Error: $($_.Exception.Message)"; throw "..."
        }
        # Убедимся, что сам модуль Utils загружен (для доступа к Test-SuccessCriteria, которую будем мокать)
        try {
            Import-Module (Join-Path -Path $PSScriptRoot -ChildPath '..\StatusMonitorAgentUtils.psd1') -Force -EA Stop
        } catch {
            Write-Error "FATAL: Failed to import StatusMonitorAgentUtils module for mocking its functions."; throw "..."
        }
    }

    # --- Базовый объект задания ---
    $baseAssignment = @{
        assignment_id = 200 # Базовый ID
        method_name = 'PING'
        node_name = 'TestNode-PING'
        ip_address = '192.168.1.1' # Используется в моках
        parameters = @{}
        success_criteria = $null
    }

    # --- Общие моки ---
    BeforeEach {
        # Мокируем New-CheckResultObject, чтобы проверять параметры вызова
        # ВАЖНО: Мок должен быть определен для модуля, где находится тестируемая функция!
        # Но так как Check-PING.ps1 НЕ входит в модуль, мы мокируем её ГЛОБАЛЬНО
        # или предполагаем, что Check-PING будет её вызывать из импортированного модуля.
        # Правильнее мокать для модуля Utils.
        Mock New-CheckResultObject {
            param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
            # Возвращаем объект с маркером, чтобы тесты видели, что мок сработал
            return @{ MockedNewCheckResult = $true; IsAvailable = $IsAvailable; CheckSuccess = $CheckSuccess; Details = $Details; ErrorMessage = $ErrorMessage }
        } -ModuleName StatusMonitorAgentUtils # Мокируем функцию из модуля

        # Мокируем Test-SuccessCriteria, по умолчанию возвращает успех
        Mock Test-SuccessCriteria {
            param($DetailsObject, $CriteriaObject)
            Write-Verbose "Mock Test-SuccessCriteria: CriteriaObject received: $($CriteriaObject | ConvertTo-Json -Depth 1 -Compress)"
            # По умолчанию считаем, что критерии пройдены
            return @{ Passed = $true; FailReason = $null }
        } -ModuleName StatusMonitorAgentUtils # Мокируем функцию из модуля
    }

    # --- Контексты и тесты ---

    Context 'Успешный Пинг (StatusCode=0)' {
        BeforeEach {
            # Мок Test-Connection для успешного пинга
            $mockSuccessResultObject = [PSCustomObject]@{
                ResponseTime = 15; Latency = 15 # RTT
                IPV4Address  = [System.Net.IPAddress]::Parse('192.168.1.1')
                Address      = '192.168.1.1'
                StatusCode   = 0
            }
            Mock Test-Connection { return ,$using:mockSuccessResultObject } -ModuleName Microsoft.PowerShell.Management
        }

        It 'Должен вернуть IsAvailable=true, CheckSuccess=true без критериев' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # $assignment.success_criteria = $null # Уже null по умолчанию

            # --- Act ---
            $result = & $script:scriptPath -TargetIP $assignment.ip_address `
                                          -Parameters $assignment.parameters `
                                          -SuccessCriteria $assignment.success_criteria `
                                          -NodeName $assignment.node_name

            # --- Assert ---
            # 1. Проверяем вызов New-CheckResultObject
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils -ParameterFilter {
                $IsAvailable -eq $true -and
                $CheckSuccess -eq $true -and # Ожидаем $true, т.к. IsAvailable и нет критериев
                ($Details -is [hashtable] -and $Details.ContainsKey('rtt_ms') -and $Details.rtt_ms -eq 15) -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
            # 2. Проверяем, что Test-SuccessCriteria НЕ вызывался
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName StatusMonitorAgentUtils
        }

        It 'Должен вернуть CheckSuccess=true, если критерии пройдены (Test-SuccessCriteria mock = true)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = 100 } } # Задаем критерий

            # Мокируем Test-SuccessCriteria, чтобы он вернул УСПЕХ
            Mock Test-SuccessCriteria { return @{ Passed = $true; FailReason = $null } } -ModuleName StatusMonitorAgentUtils -Scope It

            # --- Act ---
            $result = & $script:scriptPath -TargetIP $assignment.ip_address `
                                          -Parameters $assignment.parameters `
                                          -SuccessCriteria $assignment.success_criteria `
                                          -NodeName $assignment.node_name

            # --- Assert ---
            # 1. Проверяем вызов Test-SuccessCriteria (должен был быть вызван)
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils -ParameterFilter {
                 ($DetailsObject -is [hashtable] -and $DetailsObject.rtt_ms -eq 15) -and
                 ($CriteriaObject -is [hashtable] -and $CriteriaObject.rtt_ms -is [hashtable] -and $CriteriaObject.rtt_ms.'<=' -eq 100)
            }
            # 2. Проверяем вызов New-CheckResultObject
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils -ParameterFilter {
                $IsAvailable -eq $true -and
                $CheckSuccess -eq $true -and # Ожидаем $true, т.к. Test-SuccessCriteria вернул $true
                ($Details.rtt_ms -eq 15) -and
                [string]::IsNullOrEmpty($ErrorMessage)
            }
        }

        It 'Должен вернуть CheckSuccess=false, если критерии НЕ пройдены (Test-SuccessCriteria mock = false)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = 10 } } # Критерий, который не пройдет
            $failReasonMock = "RTT 15ms больше чем порог 10ms"

            # Мокируем Test-SuccessCriteria, чтобы он вернул НЕУСПЕХ
            Mock Test-SuccessCriteria { return @{ Passed = $false; FailReason = $using:failReasonMock } } -ModuleName StatusMonitorAgentUtils -Scope It

            # --- Act ---
            $result = & $script:scriptPath -TargetIP $assignment.ip_address `
                                          -Parameters $assignment.parameters `
                                          -SuccessCriteria $assignment.success_criteria `
                                          -NodeName $assignment.node_name

            # --- Assert ---
            # 1. Проверяем вызов Test-SuccessCriteria
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils # Проверка параметров не обязательна, т.к. выше проверяли

            # 2. Проверяем вызов New-CheckResultObject
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils -ParameterFilter {
                $IsAvailable -eq $true -and
                $CheckSuccess -eq $false -and # Ожидаем $false, т.к. Test-SuccessCriteria вернул $false
                ($Details.rtt_ms -eq 15) -and
                $ErrorMessage -eq $using:failReasonMock # Ожидаем причину провала
            }
        }

         It 'Должен вернуть CheckSuccess=$null и ErrorMessage, если Test-SuccessCriteria вернул ошибку (Passed=$null)' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = "not a number" } } # Некорректный критерий
            $failReasonMock = "Ошибка сравнения: не число"

            # Мокируем Test-SuccessCriteria, чтобы он вернул ОШИБКУ КРИТЕРИЯ
            Mock Test-SuccessCriteria { return @{ Passed = $null; FailReason = $using:failReasonMock } } -ModuleName StatusMonitorAgentUtils -Scope It

            # --- Act ---
            $result = & $script:scriptPath -TargetIP $assignment.ip_address `
                                          -Parameters $assignment.parameters `
                                          -SuccessCriteria $assignment.success_criteria `
                                          -NodeName $assignment.node_name

            # --- Assert ---
            # 1. Проверяем вызов Test-SuccessCriteria
            Should -Invoke Test-SuccessCriteria -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils

            # 2. Проверяем вызов New-CheckResultObject
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils -ParameterFilter {
                $IsAvailable -eq $true -and
                $CheckSuccess -eq $null -and # Ожидаем $null, т.к. Test-SuccessCriteria вернул $null
                ($Details.rtt_ms -eq 15) -and
                $ErrorMessage -eq $using:failReasonMock # Ожидаем причину ошибки критерия
            }
        }

    } # Конец Context 'Успешный Пинг'

    Context 'Неуспешный Пинг (ошибка StatusCode или нет ответа)' {
        BeforeEach {
            # Мок Test-Connection для ошибки "TimedOut"
             $mockFailureResultObject = [PSCustomObject]@{ StatusCode = 11010; Status = 'TimedOut' }
             Mock Test-Connection { return ,$using:mockFailureResultObject } -ModuleName Microsoft.PowerShell.Management
        }

        It 'Должен вернуть IsAvailable=false, CheckSuccess=$null и не вызывать Test-SuccessCriteria' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            $assignment.success_criteria = @{ rtt_ms = @{ '<=' = 100 } } # Критерии есть, но не должны проверяться

            # --- Act ---
            $result = & $script:scriptPath -TargetIP $assignment.ip_address `
                                          -Parameters $assignment.parameters `
                                          -SuccessCriteria $assignment.success_criteria `
                                          -NodeName $assignment.node_name

            # --- Assert ---
            # 1. Проверяем, что Test-SuccessCriteria НЕ вызывался
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName StatusMonitorAgentUtils

            # 2. Проверяем вызов New-CheckResultObject
            Should -Invoke New-CheckResultObject -Times 1 -Exactly -ModuleName StatusMonitorAgentUtils -ParameterFilter {
                $IsAvailable -eq $false -and
                $CheckSuccess -eq $null -and # CheckSuccess должен быть $null при IsAvailable=false
                ($Details -is [hashtable] -and $Details.ContainsKey('error')) -and
                $ErrorMessage -match 'StatusCode=11010' # Сообщение об ошибке пинга
            }
        }
    } # Конец Context 'Неуспешный Пинг'

    Context 'Критическая ошибка выполнения Test-Connection' {
         BeforeEach {
             # Мок Test-Connection, который выбрасывает исключение
             Mock Test-Connection { throw "Сбой RPC сервера (Mock Critical Error)." } -ModuleName Microsoft.PowerShell.Management
         }

         It 'Должен вернуть IsAvailable=false, CheckSuccess=$null и не вызывать Test-SuccessCriteria' {
            $assignment = $script:baseAssignment.PSObject.Copy()
            # Критерии не важны

            # --- Act ---
            $result = & $script:scriptPath -TargetIP $assignment.ip_address `
                                          -Parameters $assignment.parameters `
                                          -SuccessCriteria $assignment.success_criteria `
                                          -NodeName $assignment.node_name

            # --- Assert ---
            # 1. Проверяем, что Test-SuccessCriteria НЕ вызывался
            Should -Invoke Test-SuccessCriteria -Times 0 -ModuleName StatusMonitorAgentUtils

            # 2. Проверяем вызов New-CheckResultObject (он не должен вызываться, т.к. ошибка в catch)
            #    Вместо этого проверяем итоговый $result, сформированный в catch блоке
            # Should -Invoke New-CheckResultObject -Times 0 # НЕПРАВИЛЬНО, он будет вызван в конце

            # Проверяем сам результат
            $result | Should -Not -BeNull
            $result.MockedNewCheckResult | Should -BeNullOr ($result.ContainsKey('MockedNewCheckResult') -eq $false) # Убедимся, что это НЕ мок New-CheckResultObject
            $result.IsAvailable | Should -BeFalse
            $result.CheckSuccess | Should -BeNull
            $result.ErrorMessage | Should -Match 'Критическая ошибка'
            $result.ErrorMessage | Should -Match 'Сбой RPC сервера'
            $result.Details | Should -Not -BeNull
            $result.Details.error | Should -Match 'Критическая ошибка'
            $result.Details.ErrorRecord | Should -Not -BeNullOrEmpty
        }
    } # Конец Context 'Критическая ошибка'

} # Конец Describe
# --- Конец тестов ---
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Check-PING.Tests.ps1 ====

==== BEGIN FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 ====
# Invoke-StatusMonitorCheck.Tests.ps1 (v8 - ���������� $PSScriptRoot � BeforeAll)

# --- ���� ���������� ---
# BeforeAll ����������� ���� ��� ����� ����� ������� � ���� Describe �����.
BeforeAll {
    # ���������� $PSScriptRoot, ������� ��������� �� ���������� �������� ����� ����� (.Tests.ps1)
    Write-Host "INFO: PSScriptRoot ��������� ���: $PSScriptRoot" # ��� ��� �������
    if (-not $PSScriptRoot) {
        throw "�� ������� ���������� ���������� ����� (\$PSScriptRoot). ���������� ����� ������."
    }

    # ������ ���� � ��������� ������������ ����� tests
    $moduleManifestRelativePath = '..\StatusMonitorAgentUtils.psd1'
    $moduleManifestPath = Join-Path -Path $PSScriptRoot -ChildPath $moduleManifestRelativePath

    # ���������� Resolve-Path ��� ��������� ������� ���� � �������� �������������
    try {
        $resolvedModulePath = Resolve-Path -Path $moduleManifestPath -ErrorAction Stop
        Write-Host "INFO: ������ ���� � ��������� ������: $resolvedModulePath"
    } catch {
        # ��������� ����� ��������� ��������� �� ������
        Write-Error "�� ������� �����/���������� ���� � ��������� ������ '$moduleManifestPath'. ���������, ��� ��������� ����� �����: tests/ ��������� ������ StatusMonitorAgentUtils/. ������ Resolve-Path: $($_.Exception.Message)"
        throw "�� ������� ����� ������ ��� ������������." # ��������� ����������
    }

    # ����������� ������ �� ������� ����
    Write-Host "INFO: �������� ������ �� $resolvedModulePath ��� ������..."
    Remove-Module StatusMonitorAgentUtils -Force -ErrorAction SilentlyContinue
    Import-Module $resolvedModulePath -Force
    Write-Host "INFO: ������ StatusMonitorAgentUtils ��������."
}

# --- ����� ---
Describe 'Invoke-StatusMonitorCheck (��������� ��������)' {

    # --- Mocking (��� ���������) ---
    Mock New-CheckResultObject { Param($IsAvailable, $CheckSuccess, $Details, $ErrorMessage)
        return @{ Mocked = $true; IsAvailable = $IsAvailable; CheckSuccess = $CheckSuccess; ErrorMessage = $ErrorMessage; Details = $Details }
    } -ModuleName StatusMonitorAgentUtils

    Mock Test-Path { Param($Path)
        if ($Path -like "*Checks\Check-*.ps1") { return $true }
        return Test-Path @using:PSBoundParameters
    } -ModuleName Microsoft.PowerShell.Management

    Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
        Write-Verbose "��� Invoke-CheckScript: ���������� ����� '$ScriptPath'"
        return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp = (Get-Date).ToUniversalTime().ToString("o"); Details = @{ CalledScript = $ScriptPath; ParamsPassed = $ParametersForScript }; ErrorMessage = $null }
    } -ModuleName StatusMonitorAgentUtils

    # --- �������� ������ (��� ���������) ---
    $baseAssignment = @{
        assignment_id = 101; node_id = 1; node_name = 'TestNode'; ip_address = '127.0.0.1'
        parameters = @{ timeout = 500 }; success_criteria = @{ max_rtt_ms = 100 }
    }

    # --- ����� (��� ���������) ---

    It '������ �������� Invoke-CheckScript ��� ������ PING � ����������� �����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'PING'
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            $ScriptPath | Should -EndWith '\Checks\Check-PING.ps1'
            $ParametersForScript | Should -Not -BeNull
            $ParametersForScript.TargetIP | Should -Be $using:assignment.ip_address
            $ParametersForScript.Parameters | Should -Be $using:assignment.parameters
            $ParametersForScript.SuccessCriteria | Should -Be $using:assignment.success_criteria
            $ParametersForScript.NodeName | Should -Be $using:assignment.node_name
            return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=@{mocked_call_for='PING'}; ErrorMessage=$null }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        $result.IsAvailable | Should -BeTrue
        $result.Details.mocked_call_for | Should -Be 'PING'
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
    }

    It '������ �������� Invoke-CheckScript ��� SERVICE_STATUS � ����������� �����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'SERVICE_STATUS'
        $assignment.parameters = @{ service_name = 'Spooler' }
        $assignment.success_criteria = @{ status = 'Running' }
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            $ScriptPath | Should -EndWith '\Checks\Check-SERVICE_STATUS.ps1'
            $ParametersForScript.TargetIP | Should -Be $using:assignment.ip_address
            $ParametersForScript.Parameters.service_name | Should -Be 'Spooler'
            $ParametersForScript.SuccessCriteria.status | Should -Be 'Running'
            return @{ IsAvailable = $true; CheckSuccess = $true; Timestamp=(Get-Date).ToUniversalTime().ToString("o"); Details=@{mocked_call_for='SERVICE'}; ErrorMessage=$null }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        $result.IsAvailable | Should -BeTrue
        $result.Details.mocked_call_for | Should -Be 'SERVICE'
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
    }

    It '������ ���������� ������, ���� ������ �������� �� ������ (Test-Path ������ false)' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'NON_EXISTENT_METHOD'
        Mock Test-Path { Param($Path)
            if ($Path -like "*Check-NON_EXISTENT_METHOD.ps1") { return $false }
            return $true
        } -ModuleName Microsoft.PowerShell.Management -Verifiable
        Mock Invoke-CheckScript { throw "Invoke-CheckScript �� ������ ��� ���������!" } -ModuleName StatusMonitorAgentUtils -Verifiable -Scope It
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Test-Path -Times 1 -ModuleName Microsoft.PowerShell.Management
        Should -Invoke Invoke-CheckScript -Times 0 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '�� ������'
        $result.ErrorMessage | Should -Contain 'Check-NON_EXISTENT_METHOD.ps1'
    }

    It '������ ���������� ������, ���� ����� �� ������ � �������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.PSObject.Properties.Remove('method_name')
        Mock Invoke-CheckScript { throw "�� ������ ���� ����� �� ������ �������" } -ModuleName StatusMonitorAgentUtils -Verifiable -Scope It
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 0 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '������������ ������ �������'
    }

     It '������ ���������� ������, ���� Invoke-CheckScript ����������� ����������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'SCRIPT_WITH_ERROR'
        $errorMessageFromInvoke = "����������� ������ ��� ������ �������"
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            if ($ScriptPath -like "*Check-SCRIPT_WITH_ERROR.ps1") {
                throw $errorMessageFromInvoke
            }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        Mock Test-Path { return $true } -ModuleName Microsoft.PowerShell.Management
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain $errorMessageFromInvoke
        $result.ErrorMessage | Should -Contain '������ ���������� ������� ��������'
    }

     It '������ ���������� ������, ���� Invoke-CheckScript ������ ������������ ������' {
        $assignment = $script:baseAssignment.PSObject.Copy()
        $assignment.method_name = 'BAD_FORMAT_SCRIPT'
        Mock Invoke-CheckScript { Param($ScriptPath, $ParametersForScript)
            if ($ScriptPath -like "*Check-BAD_FORMAT_SCRIPT.ps1") {
                return "��� ������ ������, � �� ���-�������"
            }
        } -ModuleName StatusMonitorAgentUtils -Verifiable
        Mock Test-Path { return $true } -ModuleName Microsoft.PowerShell.Management
        $result = Invoke-StatusMonitorCheck -Assignment ([PSCustomObject]$assignment)
        Should -Invoke Invoke-CheckScript -Times 1 -ModuleName StatusMonitorAgentUtils
        $result.Mocked | Should -BeTrue
        $result.IsAvailable | Should -BeFalse
        $result.ErrorMessage | Should -Contain '������ ������������ ������'
    }
}
==== END FILE: F:\status\source\powershell\StatusMonitorAgentUtils\tests\Invoke-StatusMonitorCheck.Tests.ps1 ====

